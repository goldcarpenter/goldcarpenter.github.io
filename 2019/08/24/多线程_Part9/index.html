<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="JJMJ's blog."><meta name="keywords" content="Java, Spring, MyBatis, 后端"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>多线程编程 | 掘金木匠</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">多线程编程</h1><a id="logo" href="/.">掘金木匠</a><p class="description">懂金融的软件工程师一定是一个合格的吃货</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">多线程编程</h1><div class="post-meta"><a href="/2019/08/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B_Part9/#comments" class="comment-count"><i id="changyan_count_unit" data-xid="2019/08/24/多线程_Part9/"></i>留言,<i id="changyan_parti_unit" data-xid="2019/08/24/多线程_Part9/"></i>参与</a><p><span class="date">Aug 24, 2019</span><span><a href="/categories/Java%E9%AB%98%E7%BA%A7/" class="category">Java高级</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="8-共享模型之并发工具"><a href="#8-共享模型之并发工具" class="headerlink" title="8 共享模型之并发工具"></a>8 共享模型之并发工具</h1><h2 id="8-1-线程池"><a href="#8-1-线程池" class="headerlink" title="8.1 线程池"></a>8.1 线程池</h2><h3 id="8-1-1-线程池优点"><a href="#8-1-1-线程池优点" class="headerlink" title="8.1.1 线程池优点"></a>8.1.1 线程池优点</h3><ul>
<li>减少了创建线程的时间，提高响应速度</li>
<li>重复利用线程池中的线程，避免多次创建</li>
</ul>
<ul>
<li><p>线程数量过多缺点：①每个线程都要分配内存开销②线程上下文切换系统开销</p>
<p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B4_img/1582178021215.png" alt="1582178021215"></p>
<ul>
<li>阻塞队列：平衡生产者和线程池消费者速率不同的消息队列</li>
</ul>
</li>
</ul>
<h3 id="8-1-2-自定义线程池"><a href="#8-1-2-自定义线程池" class="headerlink" title="8.1.2 自定义线程池"></a>8.1.2 自定义线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j(topic = <span class="string">"MultiThread"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 线程池中执行单元 , 执行单元超时销毁时间, 执行单元超时销毁单位, 阻塞队列长度, 执行单元不足时 策略</span></span><br><span class="line">        ThreadPool threadPool = <span class="keyword">new</span> ThreadPool(<span class="number">1</span>,</span><br><span class="line">                <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">2</span>,</span><br><span class="line">                <span class="keyword">new</span> RejectPolicy&lt;Runnable&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(BlockingQueue&lt;Runnable&gt; queue, Runnable task)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 1. 阻塞队列满后 生产者死等队列空出</span></span><br><span class="line">                        <span class="comment">//queue.put(task);</span></span><br><span class="line">                        <span class="comment">// 2) 阻塞队列满后 生产者带超时等待队列空出</span></span><br><span class="line">                        <span class="comment">//queue.offer(task, 100, TimeUnit.MILLISECONDS);</span></span><br><span class="line">                        <span class="comment">// 3) 没有设计阻塞队列 执行单元不足时让调用者放弃任务执行</span></span><br><span class="line">                        <span class="comment">//log.debug("放弃&#123;&#125;", task);</span></span><br><span class="line">                        <span class="comment">// 4) 没有设计阻塞队列 执行单元不足时让让调用者抛出异常</span></span><br><span class="line">                        <span class="comment">//throw new RuntimeException("任务执行失败 " + task);</span></span><br><span class="line">                        <span class="comment">// 5) 没有设计阻塞队列 让调用者（main)自己执行任务</span></span><br><span class="line">                        <span class="comment">//task.run();</span></span><br><span class="line">                  &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Sleeper.sleep(<span class="number">6</span>);</span><br><span class="line">                    System.out.println(j);</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行单元不足时 策略接口【设计模式:策略模式】</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RejectPolicy</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue, T task)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j(topic = <span class="string">"c.ThreadPool"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span>&#123;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line">    <span class="comment">// 运行单元集合</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> coreSize;</span><br><span class="line">    <span class="comment">// 获取任务时的超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//线程池构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">long</span> timeout, TimeUnit timeUnit,<span class="keyword">int</span> queueCapcity, RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="keyword">this</span>.taskQueue = <span class="keyword">new</span> BlockingQueue&lt;&gt;(queueCapcity);</span><br><span class="line">        <span class="keyword">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 执行线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span></span></span><br><span class="line"><span class="function">    </span>&#123;	<span class="comment">//works并非线程安全</span></span><br><span class="line">        <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">            <span class="comment">// 当任务数没有超过 coreSize 时，直接创建线程交给 worker 对象执行</span></span><br><span class="line">            <span class="comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span></span><br><span class="line">            <span class="keyword">if</span> (workers.size() &lt; coreSize)&#123;</span><br><span class="line">                Worker worker = <span class="keyword">new</span> Worker(task);</span><br><span class="line">                log.debug(<span class="string">"新增执行单元worker&#123;&#125;"</span>, worker);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rejectPolicy.reject(taskQueue,task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行单元</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//1）当task不为空 执行任务</span></span><br><span class="line">            <span class="comment">//2) 当task执行完毕 再接着获取任务队列</span></span><br><span class="line">            <span class="comment">//while (task != null ||(task = taskQueue.take()) != null)// 执行单元永不销毁,始终阻塞在任务队列中等待任务</span></span><br><span class="line">            <span class="comment">//没有任务 run执行结束 将worker从线程池移除</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> ||(task = taskQueue.poll(timeout,timeUnit)) != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    log.debug(<span class="string">"执行单元worker执行&#123;&#125;"</span>,task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (workers)</span><br><span class="line">            &#123;</span><br><span class="line">                log.debug(<span class="string">"执行单元&#123;&#125;从集合中退出"</span>,<span class="keyword">this</span>);</span><br><span class="line">                workers.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="comment">//阻塞队列 基于泛型的生产者消费者模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 任务的阻塞双向链表</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 生产者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> Condition fullWaitSet = lock.newCondition();</span><br><span class="line">    <span class="comment">// 消费者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> Condition emptyWaitSet = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capcity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockingQueue</span><span class="params">(<span class="keyword">int</span> capcity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capcity = capcity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T task)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">"task&#123;&#125;加入阻塞队列"</span>,task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时时间阻塞添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(T task,<span class="keyword">long</span> timeout, TimeUnit timeUnit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">long</span> nanos = timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        log.debug(<span class="string">"task&#123;&#125;加入阻塞队列超时丢弃"</span>,task);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;nanos = fullWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">"task&#123;&#125;加入阻塞队列"</span>,task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 带超时阻塞获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将 timeout 统一转换为 纳秒</span></span><br><span class="line">            <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 返回值是剩余时间</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = emptyWaitSet.awaitNanos(nanos);		<span class="comment">// 返回值就是剩余时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B4_img/1591168757447.png" alt="1591168757447"></p>
<h3 id="8-1-3-Executor接口"><a href="#8-1-3-Executor接口" class="headerlink" title="8.1.3 Executor接口"></a>8.1.3 Executor接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executor只是接口 内部只有execute方法</span></span><br><span class="line"><span class="comment">     * 执行给定的命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义Executor接口实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">implements</span> <span class="title">Executor</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new Thread(command).start();</span></span><br><span class="line">        command.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Main().execute(()-&gt;System.out.println(<span class="string">"自定义Executor"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">15:03:14.523 [main] MyTest - 自定义Executor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">15:02:52.026 [Thread-0] MyTest - 自定义Executor</span></span><br><span class="line"><span class="comment">15:02:52.026 [main] MyTest - 自定义Executor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="8-1-4-ExecutorService接口"><a href="#8-1-4-ExecutorService接口" class="headerlink" title="8.1.4 ExecutorService接口"></a>8.1.4 ExecutorService接口</h3><ul>
<li><p><strong>ExecutorService接口：真正的线程池接口，常用子类ThreadPoolExecutors</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"running..."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        System.out.println(<span class="string">"================================================"</span>);</span><br><span class="line">        service.shutdown();</span><br><span class="line">        System.out.println(<span class="string">"service.isTerminated():"</span> + service.isTerminated());</span><br><span class="line">        System.out.println(<span class="string">"service.isShutdown():"</span> + service.isShutdown());</span><br><span class="line">        System.out.println(service);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>); <span class="comment">//保证所有线程运行完</span></span><br><span class="line">        System.out.println(<span class="string">"================================================"</span>);</span><br><span class="line">        System.out.println(<span class="string">"service.isTerminated():"</span> + service.isTerminated());</span><br><span class="line">        System.out.println(<span class="string">"service.isShutdown():"</span> + service.isShutdown());</span><br><span class="line">        System.out.println(service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pool-1-thread-1running...</span></span><br><span class="line"><span class="comment">pool-1-thread-3running...</span></span><br><span class="line"><span class="comment">pool-1-thread-2running...</span></span><br><span class="line"><span class="comment">java.util.concurrent.ThreadPoolExecutor@7ba4f24f[Running, pool size = 3, active threads = 3, queued tasks = 7, completed tasks = 0]</span></span><br><span class="line"><span class="comment">================================================</span></span><br><span class="line"><span class="comment">service.isTerminated():false</span></span><br><span class="line"><span class="comment">service.isShutdown():true</span></span><br><span class="line"><span class="comment">java.util.concurrent.ThreadPoolExecutor@7ba4f24f[Shutting down, pool size = 3, active threads = 3, queued tasks = 7, completed tasks = 0]</span></span><br><span class="line"><span class="comment">pool-1-thread-1running...</span></span><br><span class="line"><span class="comment">pool-1-thread-3running...</span></span><br><span class="line"><span class="comment">pool-1-thread-2running...</span></span><br><span class="line"><span class="comment">pool-1-thread-1running...</span></span><br><span class="line"><span class="comment">pool-1-thread-2running...</span></span><br><span class="line"><span class="comment">pool-1-thread-3running...</span></span><br><span class="line"><span class="comment">pool-1-thread-1running...</span></span><br><span class="line"><span class="comment">================================================</span></span><br><span class="line"><span class="comment">service.isTerminated():true</span></span><br><span class="line"><span class="comment">service.isShutdown():true</span></span><br><span class="line"><span class="comment">java.util.concurrent.ThreadPoolExecutor@7ba4f24f[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 10]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="8-1-5-ThreadPoolExecutor"><a href="#8-1-5-ThreadPoolExecutor" class="headerlink" title="8.1.5 ThreadPoolExecutor"></a>8.1.5 ThreadPoolExecutor</h3><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><ul>
<li><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p>
<table>
<thead>
<tr>
<th align="center">状态名</th>
<th align="center">高3位</th>
<th align="center">接收新任务</th>
<th align="center">处理阻塞队列任务</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RUNNING</td>
<td align="center">111</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td></td>
</tr>
<tr>
<td align="center">SHUTDOWN</td>
<td align="center">000</td>
<td align="center">N</td>
<td align="center">Y</td>
<td>不会接收新任务，但会处理阻塞队列剩余任务</td>
</tr>
<tr>
<td align="center">STOP</td>
<td align="center">001</td>
<td align="center">N</td>
<td align="center">N</td>
<td>会中断正在执行的任务，并抛弃阻塞队列任务</td>
</tr>
<tr>
<td align="center">TIDYING</td>
<td align="center">010</td>
<td align="center">-</td>
<td align="center">-</td>
<td>任务全执行完毕，活动线程为 0 即将进入终结</td>
</tr>
<tr>
<td align="center">TERMINATED</td>
<td align="center">011</td>
<td align="center">-</td>
<td align="center">-</td>
<td>终结状态</td>
</tr>
</tbody></table>
</li>
<li><p>从数字上比较，TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING</p>
</li>
<li><p>这些<strong>信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作进行赋值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c 为旧值， ctlOf 返回结果为新值</span></span><br><span class="line">ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));</span><br><span class="line"><span class="comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li>根据这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> maximumPoolSize, </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">long</span> keepAliveTime, </span></span></span><br><span class="line"><span class="function"><span class="params">	TimeUnit unit, </span></span></span><br><span class="line"><span class="function"><span class="params">	BlockingQueue&lt;Runnable&gt; workQueue, </span></span></span><br><span class="line"><span class="function"><span class="params">	ThreadFactory threadFactory, </span></span></span><br><span class="line"><span class="function"><span class="params">	RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>corePoolSize</code>核心线程数目 (最多保留的线程数)</li>
<li><code>maximumPoolSize</code>最大线程数目</li>
<li><code>keepAliveTime</code>救急线程生存时间</li>
<li><code>unit</code>救急线程时间单位</li>
<li><code>workQueue</code>阻塞队列</li>
<li><code>threadFactory</code>线程工厂 - 可以为线程创建时起个好名字 </li>
<li><code>handler</code>拒绝策略</li>
</ul>
<p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B4_img/1582211601375.png" alt="1582211601375"></p>
<ul>
<li><p>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。 </p>
</li>
<li><p>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程。</p>
</li>
<li><p>如果<strong>队列选择了有界队列</strong>，那么任务<strong>超过了队列大小</strong>时，会<strong>创建</strong> maximumPoolSize - corePoolSize 数目的<strong>线程来救急</strong>。 </p>
</li>
<li><p>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。</p>
</li>
<li><p>jdk 提供了 4 种拒绝策略实现，其它著名框架也提供了拒绝策略实现 </p>
<p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B4_img/1582212135088.png" alt="1582212135088"></p>
<ul>
<li><p>AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略</p>
</li>
<li><p>CallerRunsPolicy 让调用者运行任务 </p>
</li>
<li><p>DiscardPolicy 放弃本次任务 </p>
</li>
<li><p>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之 </p>
</li>
<li><p>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题 </p>
</li>
<li><p>Netty 的实现，是创建一个新线程来执行任务 </p>
</li>
<li><p>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略 </p>
</li>
<li><p>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</p>
</li>
</ul>
</li>
</ul>
<h4 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">// 泛型代表了执行任务返回值类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取消任务的执行。参数指定是否立即中断任务执行，或者等等任务结束</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务是否已经取消，任务正常完成前将其取消，则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务是否已经完成。需要注意的是如果任务正常终止、异常或取消，都将返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞直到任务返回结果 InterruptedException 线程被中断异常， ExecutionException任务执行异常，如果任务被取消，还会抛出CancellationException</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多了设置超时时间</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        Future&lt;Integer&gt; task = service.submit(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(task.isDone());</span><br><span class="line">        System.out.println(task.get());</span><br><span class="line">        System.out.println(task.isDone());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">1000</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h4><ul>
<li>Future接口的一个唯一实现类</li>
<li>既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     <span class="keyword">this</span>.callable = callable;</span><br><span class="line">     <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">     <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        FutureTask&lt;Boolean&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"running"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"end"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        System.out.print(task.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">running</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





<h3 id="8-1-6-Executors工具类"><a href="#8-1-6-Executors工具类" class="headerlink" title="8.1.6 Executors工具类"></a>8.1.6 Executors工具类</h3><ul>
<li><p><strong>Executors类：线程池的工具类，用于创建不同的线程池，大多都是静态方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池对象</span></span><br><span class="line">ExecutorService ser = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 执行任务 有返回值 参数一般为Callable接口</span></span><br><span class="line">ser.submit(<span class="comment">/*Callable接口*/</span>);</span><br><span class="line"><span class="comment">// 执行任务 无返回值 参数一般为Runnable接口</span></span><br><span class="line">ser.execute(<span class="comment">/*Runnable接口*/</span>);</span><br><span class="line"><span class="comment">// 关闭连接池</span></span><br><span class="line">ser.shutdown();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>executor &amp; submit区别<ul>
<li>executor <ul>
<li>Executor接口中的方法</li>
<li>接受runnable接口</li>
<li>无返回值</li>
</ul>
</li>
<li>submit<ul>
<li>ExecutorService接口【Executor接口子接口】中的方法</li>
<li>runnable &amp; callable接口</li>
<li>有返回值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-定长线程池newFixedThreadPool"><a href="#1-定长线程池newFixedThreadPool" class="headerlink" title="1 定长线程池newFixedThreadPool"></a>1 定长线程池newFixedThreadPool</h4><ul>
<li><p>可控制线程最大并发数，超出的线程会在队列中等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads,</span><br><span class="line">    	nThreads, </span><br><span class="line">    	<span class="number">0L</span>, TimeUnit.MILLISECONDS, </span><br><span class="line">    	<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>核心线程数 == 最大线程数（没有救急线程被创建）</strong>，因此也无需超时时间 </li>
<li><strong>阻塞队列是无界的，可以放任意数量的任务</strong></li>
</ul>
</li>
<li><p>适用于任务量已知，相对耗时的任务</p>
</li>
</ul>
<h4 id="2-可缓存线程池newCachedThreadPool"><a href="#2-可缓存线程池newCachedThreadPool" class="headerlink" title="2 可缓存线程池newCachedThreadPool"></a>2 可缓存线程池newCachedThreadPool</h4><ul>
<li><p>如果线程池长度超过处理需要，若无空闲线程，则新建线程。超过60秒线程未使用则回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">    	<span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着</p>
<ul>
<li><strong>全部都是救急线程（60s 后可以回收）</strong></li>
<li><strong>救急线程可以无限创建</strong></li>
<li><strong>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; integers = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"putting &#123;&#125; "</span>, <span class="number">1</span>);</span><br><span class="line">                integers.put(<span class="number">1</span>);        <span class="comment">// 要执行完take才会向下运行</span></span><br><span class="line">                log.debug(<span class="string">"&#123;&#125; putted..."</span>, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">5</span>);</span><br><span class="line">        log.debug(<span class="string">"taking &#123;&#125;"</span>, <span class="number">1</span>);</span><br><span class="line">        integers.take();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 </p>
</li>
<li><p>适合任务数比较密集，但每个任务执行时间较短的情况</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">            MyTask mytask = <span class="keyword">new</span> MyTask();</span><br><span class="line">            Future task1 = service.submit(mytask);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            System.out.println(service);</span><br><span class="line">            Future task2 = service.submit(mytask);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            System.out.println(service);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            Future task3 = service.submit(mytask);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            System.out.println(service);</span><br><span class="line">            Future task4 = service.submit(mytask);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            System.out.println(service);</span><br><span class="line">            task1.get();</span><br><span class="line">            task2.get();</span><br><span class="line">            task3.get();</span><br><span class="line">            task4.get();</span><br><span class="line"></span><br><span class="line">            System.out.println(service);</span><br><span class="line">            Thread.sleep(<span class="number">80000</span>);</span><br><span class="line">            System.out.println(service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.concurrent.ThreadPoolExecutor@6d6f6e28[Running, pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 0]</span></span><br><span class="line"><span class="comment">java.util.concurrent.ThreadPoolExecutor@6d6f6e28[Running, pool size = 2, active threads = 2, queued tasks = 0, completed tasks = 0]</span></span><br><span class="line"><span class="comment">java.util.concurrent.ThreadPoolExecutor@6d6f6e28[Running, pool size = 2, active threads = 1, queued tasks = 0, completed tasks = 2]</span></span><br><span class="line"><span class="comment">java.util.concurrent.ThreadPoolExecutor@6d6f6e28[Running, pool size = 2, active threads = 2, queued tasks = 0, completed tasks = 2]</span></span><br><span class="line"><span class="comment">java.util.concurrent.ThreadPoolExecutor@6d6f6e28[Running, pool size = 2, active threads = 0, queued tasks = 0, completed tasks = 4]</span></span><br><span class="line"><span class="comment">java.util.concurrent.ThreadPoolExecutor@6d6f6e28[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 4]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="3-单例线程池newSingleThreadExecutor"><a href="#3-单例线程池newSingleThreadExecutor" class="headerlink" title="3 单例线程池newSingleThreadExecutor"></a>3 单例线程池newSingleThreadExecutor</h4><ul>
<li><p>保证了线程的顺序，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
</li>
<li><p><strong>希望多个任务排队执行</strong>。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p>
</li>
<li><p><strong>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">  executorService.execute(()-&gt;&#123;</span><br><span class="line">      log.debug(<span class="string">"run 1"</span>);</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  executorService.execute(()-&gt;&#123;</span><br><span class="line">      log.debug(<span class="string">"run 2"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  executorService.execute(()-&gt;&#123;</span><br><span class="line">      log.debug(<span class="string">"run 3"</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Executors-newFixedThreadPool-1-与此区别"><a href="#Executors-newFixedThreadPool-1-与此区别" class="headerlink" title="Executors.newFixedThreadPool(1)与此区别"></a><code>Executors.newFixedThreadPool(1)</code>与此区别</h4><ul>
<li>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改<ul>
<li>FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法</li>
</ul>
</li>
<li>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改<ul>
<li>对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 装饰器模式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>,</span><br><span class="line">                                    TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h4 id="4-任务调度线程池ScheduledExecutorService"><a href="#4-任务调度线程池ScheduledExecutorService" class="headerlink" title="4 任务调度线程池ScheduledExecutorService"></a>4 任务调度线程池ScheduledExecutorService</h4><ul>
<li><p>在『任务调度线程池』功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，</p>
<ul>
<li><p>缺点：同一时间只能有一个任务在执行，前一个任务的<strong>延迟或异常</strong>都将会影响到之后的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        TimerTask task1 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.debug(<span class="string">"task 1"</span>);</span><br><span class="line">                Sleeper.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        TimerTask task2 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.debug(<span class="string">"task 2"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">"start..."</span>);</span><br><span class="line">        timer.schedule(task1, <span class="number">1000</span>);</span><br><span class="line">        timer.schedule(task2, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行 </span></span><br><span class="line"><span class="comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行</span></span><br><span class="line"><span class="number">11</span>:<span class="number">33</span>:<span class="number">03.832</span> [main] MultiThread - start...</span><br><span class="line"><span class="number">11</span>:<span class="number">33</span>:<span class="number">04.840</span> [Timer-<span class="number">0</span>] MultiThread - task <span class="number">1</span></span><br><span class="line"><span class="number">11</span>:<span class="number">33</span>:<span class="number">06.844</span> [Timer-<span class="number">0</span>] MultiThread - task <span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>任务调度线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*public class ScheduledThreadPoolExecutor</span></span><br><span class="line"><span class="comment">    extends ThreadPoolExecutor</span></span><br><span class="line"><span class="comment">    implements ScheduledExecutorService*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>延迟执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">log.debug(<span class="string">"now"</span>);</span><br><span class="line">service.schedule(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">"run"</span>);</span><br><span class="line">&#125;, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    17:15:00.239 [main] MyTest - now</span></span><br><span class="line"><span class="comment">	17:15:02.384 [pool-1-thread-1] MyTest - run【隔了2秒】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>延时循环执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService service1 = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">service1.scheduleAtFixedRate(()-&gt;&#123;		<span class="comment">//⭐scheduleAtFixedRate</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">"scheduleAtFixedRate run"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);			<span class="comment">//任务运行时间大于间隔时间 导致间隔时间被包含 任务不重叠</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">0</span>,<span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">Sleeper.sleep(<span class="number">10</span>);</span><br><span class="line">service1.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">17:27:04.370 [pool-1-thread-1] MyTest - scheduleAtFixedRate run</span></span><br><span class="line"><span class="comment">17:27:05.381 [pool-1-thread-1] MyTest - scheduleAtFixedRate run</span></span><br><span class="line"><span class="comment">17:27:06.382 [pool-1-thread-2] MyTest - scheduleAtFixedRate run</span></span><br><span class="line"><span class="comment">17:27:07.382 [pool-1-thread-2] MyTest - scheduleAtFixedRate run</span></span><br><span class="line"><span class="comment">17:27:08.383 [pool-1-thread-2] MyTest - scheduleAtFixedRate run</span></span><br><span class="line"><span class="comment">17:27:09.384 [pool-1-thread-2] MyTest - scheduleAtFixedRate run</span></span><br><span class="line"><span class="comment">【上一个开始执行计时 开始计时总计隔了1秒】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService service2 = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">service2.scheduleWithFixedDelay(()-&gt;&#123;		<span class="comment">//⭐scheduleWithFixedDelay</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">"scheduleWithFixedDelay run"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">0</span>,<span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">16:00:52.942 [pool-3-thread-1] MultiThread - scheduleWithFixedDelay run</span></span><br><span class="line"><span class="comment">16:00:55.943 [pool-3-thread-1] MultiThread - scheduleWithFixedDelay run【要等上一个执行完 存在延时 开始计时总计隔了3秒】</span></span><br><span class="line"><span class="comment">16:00:58.945 [pool-3-thread-2] MultiThread - scheduleWithFixedDelay run*/</span></span><br></pre></td></tr></table></figure>

<h5 id="如何让每周四-18-00-00-定时执行任务？"><a href="#如何让每周四-18-00-00-定时执行任务？" class="headerlink" title="如何让每周四 18:00:00 定时执行任务？"></a>如何让每周四 18:00:00 定时执行任务？</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  获取当前时间</span></span><br><span class="line">        LocalDateTime now = LocalDateTime.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line">        <span class="comment">// 获取周四时间</span></span><br><span class="line">        LocalDateTime time = now.withHour(<span class="number">18</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>).with(DayOfWeek.THURSDAY);</span><br><span class="line">        <span class="comment">// 如果 当前时间 &gt; 本周周四，必须找到下周周四</span></span><br><span class="line">        <span class="keyword">if</span>(now.compareTo(time) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            time = time.plusWeeks(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(time);</span><br><span class="line">        <span class="comment">// initailDelay 代表当前时间和周四的时间差</span></span><br><span class="line">        <span class="comment">// period 一周的间隔时间</span></span><br><span class="line">        <span class="keyword">long</span> initailDelay = Duration.between(now, time).toMillis();</span><br><span class="line">        <span class="keyword">long</span> period = <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>;</span><br><span class="line">        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"running..."</span>);</span><br><span class="line">        &#125;, initailDelay, period, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="5-提交任务"><a href="#5-提交任务" class="headerlink" title="5 提交任务"></a>5 提交任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务 task，用返回值 Future 获得任务执行结果 </span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;<span class="comment">//【Future使用了保护性暂停模式 线程间通信获取结果】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务 </span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间 </span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line"><span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消 </span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">       ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">       method1(pool);</span><br><span class="line">       Sleeper.sleep(<span class="number">10</span>);</span><br><span class="line">       method2(pool);</span><br><span class="line">       Sleeper.sleep(<span class="number">10</span>);</span><br><span class="line">       method3(pool);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(ExecutorService pool)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">       Future&lt;String&gt; future = pool.submit(() -&gt; &#123;</span><br><span class="line">           log.debug(<span class="string">"running"</span>);</span><br><span class="line">           Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       log.debug(<span class="string">"&#123;&#125;"</span>, future.get());</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">           00:42:15.410 [pool-1-thread-1] MultiThread - running</span></span><br><span class="line"><span class="comment">           00:42:16.416 [main] MultiThread - ok</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ExecutorService pool)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       List&lt;Future&lt;String&gt;&gt; futures = pool.invokeAll(Arrays.asList(</span><br><span class="line">               () -&gt; &#123;</span><br><span class="line">                   log.debug(<span class="string">"begin"</span>);</span><br><span class="line">                   Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="string">"2"</span>;</span><br><span class="line">               &#125;,</span><br><span class="line">               () -&gt; &#123;</span><br><span class="line">                   log.debug(<span class="string">"begin"</span>);</span><br><span class="line">                   Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="string">"3"</span>;</span><br><span class="line">               &#125;</span><br><span class="line">       ));</span><br><span class="line"></span><br><span class="line">       futures.forEach( f -&gt;  &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               log.debug(<span class="string">"&#123;&#125;"</span>, f.get());</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       00:42:26.425 [pool-1-thread-1] MultiThread - begin</span></span><br><span class="line"><span class="comment">       00:42:26.425 [pool-1-thread-2] MultiThread - begin</span></span><br><span class="line"><span class="comment">       00:42:28.426 [main] MultiThread - 2【要等时间最长的结果返回】</span></span><br><span class="line"><span class="comment">       00:42:28.426 [main] MultiThread - 3</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ExecutorService pool)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">       String result = pool.invokeAny(Arrays.asList(</span><br><span class="line">               () -&gt; &#123;</span><br><span class="line">                   log.debug(<span class="string">"begin 1"</span>);</span><br><span class="line">                   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                   log.debug(<span class="string">"end 1"</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">               &#125;,</span><br><span class="line">               () -&gt; &#123;</span><br><span class="line">                   log.debug(<span class="string">"begin 2"</span>);</span><br><span class="line">                   Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                   log.debug(<span class="string">"end 2"</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="string">"2"</span>;</span><br><span class="line">               &#125;</span><br><span class="line">       ));</span><br><span class="line">       log.debug(<span class="string">"&#123;&#125;"</span>, result);</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">           00:42:38.428 [pool-1-thread-1] MultiThread - begin 2</span></span><br><span class="line"><span class="comment">           00:42:38.428 [pool-1-thread-2] MultiThread - begin 1</span></span><br><span class="line"><span class="comment">           00:42:38.928 [pool-1-thread-1] MultiThread - end 2</span></span><br><span class="line"><span class="comment">           00:42:38.928 [main] MultiThread - 2</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-关闭线程池"><a href="#6-关闭线程池" class="headerlink" title="6 关闭线程池"></a>6 关闭线程池</h4><h5 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h5><ul>
<li><p>线程池状态变为 SHUTDOWN</p>
</li>
<li><p><strong>不会接收新任务，但已提交任务会执行完</strong></p>
</li>
<li><p>此方法<strong>不会阻塞</strong>调用线程的执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock(); </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess(); </span><br><span class="line">        advanceRunState(SHUTDOWN); <span class="comment">// 修改线程池状态 </span></span><br><span class="line">        interruptIdleWorkers(); <span class="comment">// 仅会打断空闲线程 </span></span><br><span class="line">        onShutdown(); <span class="comment">//扩展点ScheduledThreadPoolExecutor</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        	mainLock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会阻塞) </span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h5 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h5><ul>
<li><p>线程池状态变为 STOP，不会接收新任务</p>
</li>
<li><p>会将队列中的任务返回</p>
</li>
<li><p><strong>用 interrupt 的方式中断正在执行的任务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Runnable&gt; tasks;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            advanceRunState(STOP);<span class="comment">// 修改线程池状态</span></span><br><span class="line">            interruptWorkers();<span class="comment">// 打断所有线程</span></span><br><span class="line">            tasks = drainQueue();<span class="comment">// 获取队列中剩余任务</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();<span class="comment">// 尝试终结 所有已经都打断了 肯定被终结</span></span><br><span class="line">        <span class="keyword">return</span> tasks;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="7-其它方法"><a href="#7-其它方法" class="headerlink" title="7 其它方法"></a>7 其它方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不在 RUNNING 状态的线程池，此方法就返回 true </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 线程池状态是否是 TERMINATED</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待 等所有已提交的任务（包括正在跑的和队列中等待的）执行完或者等超时时间到【不好用 不确定等多久 可以用get返回结果阻塞】</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>



<h3 id="8-1-7-正确处理执行任务异常"><a href="#8-1-7-正确处理执行任务异常" class="headerlink" title="8.1.7 正确处理执行任务异常"></a>8.1.7 正确处理执行任务异常</h3><h4 id="方法1：主动捉异常"><a href="#方法1：主动捉异常" class="headerlink" title="方法1：主动捉异常"></a>方法1：主动捉异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">1</span>); </span><br><span class="line">pool.submit(() -&gt; &#123; </span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		log.debug(<span class="string">"task1"</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        	log.error(<span class="string">"error:"</span>, e);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="方法2：使用-Future"><a href="#方法2：使用-Future" class="headerlink" title="方法2：使用 Future"></a>方法2：使用 Future</h4><ul>
<li>没有异常的就获取结果，有异常就获取异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">1</span>); </span><br><span class="line">Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123; </span><br><span class="line">    log.debug(<span class="string">"task1"</span>); </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line">log.debug(<span class="string">"result:&#123;&#125;"</span>, f.get());</span><br></pre></td></tr></table></figure>



<h3 id="8-1-8-Tomcat线程池"><a href="#8-1-8-Tomcat线程池" class="headerlink" title="8.1.8 Tomcat线程池"></a>8.1.8 Tomcat线程池</h3><p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B4_img/1582274348565.png" alt="1582274348565"></p>
<ul>
<li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲 </li>
<li>Acceptor 只负责【接收新的 socket 连接】 </li>
<li>Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】 </li>
<li>一旦可读，封装一个任务对象（socketProcessor），</li>
<li>提交给 Executor 线程池处理 Executor 线程池中的工作线程最终负责【处理请求】</li>
</ul>
<p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同</p>
<ul>
<li><p>如果总线程数达到 maximumPoolSize</p>
<ul>
<li>这时不会立刻抛 RejectedExecutionException 异常 </li>
<li>而是再次尝试将任务放入队列，如果还失败，才抛出RejectedExecutionException 异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">       submittedCount.incrementAndGet();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">super</span>.execute(command);</span><br><span class="line">       <span class="comment">//捕获异常</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (RejectedExecutionException rx) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">super</span>.getQueue() <span class="keyword">instanceof</span> TaskQueue) &#123;</span><br><span class="line">               <span class="keyword">final</span> TaskQueue queue = (TaskQueue)<span class="keyword">super</span>.getQueue();</span><br><span class="line">               <span class="keyword">try</span> &#123;<span class="comment">//再试一次 </span></span><br><span class="line">                  <span class="keyword">if</span> (!queue.force(command, timeout, unit)) &#123;</span><br><span class="line">                      submittedCount.decrementAndGet();</span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Queue capacity is full."</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                   submittedCount.decrementAndGet();</span><br><span class="line">                   Thread.interrupted();</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(x);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               submittedCount.decrementAndGet();</span><br><span class="line">               <span class="keyword">throw</span> rx;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">TaskQueue.java</span><br><span class="line">  </span><br><span class="line">  ~~~java</span><br><span class="line">  public boolean force(Runnable o, long timeout, TimeUnit unit) throws InterruptedException &#123; </span><br><span class="line">  	if ( parent.isShutdown() ) throw new RejectedExecutionException(</span><br><span class="line">  		&quot;Executor not running, can&#39;t force a command into the queue&quot; ); </span><br><span class="line">  		return super.offer(o,timeout,unit); </span><br><span class="line">  		&#x2F;&#x2F;forces the item onto the queue, to be used if the task is rejected &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>Connector 配置</p>
<p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B4_img/1582275738120.png" alt="1582275738120"></p>
<p>Executor 线程配置</p>
<p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B4_img/1582275776646.png" alt="1582275776646"></p>
<p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B4_img/1582275543451.png" alt="1582275543451"></p>
<h3 id="8-1-9异步模式之工作线程"><a href="#8-1-9异步模式之工作线程" class="headerlink" title="8.1.9异步模式之工作线程"></a>8.1.9异步模式之工作线程</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h4><p>让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。也可以将其归类为分工模式，它的典型实现 就是线程池，也体现了经典设计模式中的享元模式</p>
<h4 id="2-饥饿现象"><a href="#2-饥饿现象" class="headerlink" title="2 饥饿现象"></a>2 饥饿现象</h4><ul>
<li>固定大小线程池会有饥饿现象</li>
<li><strong>同一类别任务可以使用同一个线程池，多个任务可以采用多个线程池</strong><ul>
<li>两个工人是同一个线程池中的两个线程</li>
<li>他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作</li>
<li>客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待<ul>
<li>后厨做菜：没啥说的，做就是了</li>
<li>比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好 </li>
<li>但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; MENU = Arrays.asList(<span class="string">"地三鲜"</span>, <span class="string">"宫保鸡丁"</span>, <span class="string">"辣子鸡丁"</span>, <span class="string">"烤鸡翅"</span>);</span><br><span class="line"><span class="keyword">static</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">cooking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MENU.get(RANDOM.nextInt(MENU.size()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ExecutorService waiterPool = Executors.newFixedThreadPool(1);</span></span><br><span class="line">    ExecutorService cookPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        cookPool.execute(() -&gt; &#123;			<span class="comment">//使用线程池的一个线程⭐</span></span><br><span class="line">            log.debug(<span class="string">"处理点餐..."</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;	<span class="comment">//使用线程池的一个线程⭐</span></span><br><span class="line">                log.debug(<span class="string">"做菜"</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"上菜: &#123;&#125;"</span>, f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    17:08:41.339 c.TestDeadLock [pool-1-thread-2] - 处理点餐... </span></span><br><span class="line"><span class="comment">    17:08:41.339 c.TestDeadLock [pool-1-thread-1] - 处理点餐...</span></span><br><span class="line"><span class="comment">    【饥饿死等】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService waiterPool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    ExecutorService cookPool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        waiterPool.execute(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"处理点餐..."</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">"做菜"</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"上菜: &#123;&#125;"</span>, f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-创建多少线程池合适"><a href="#3-创建多少线程池合适" class="headerlink" title="3 创建多少线程池合适"></a>3 创建多少线程池合适</h4><ul>
<li>过小会导致程序不能充分地利用系统资源、容易导致饥饿 </li>
<li>过大会导致更多的线程上下文切换，占用更多内存</li>
</ul>
<h5 id="CPU-密集型运算"><a href="#CPU-密集型运算" class="headerlink" title="CPU 密集型运算"></a>CPU 密集型运算</h5><ul>
<li><strong>通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率</strong><ul>
<li>+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</li>
</ul>
</li>
</ul>
<h5 id="I-O-密集型运算"><a href="#I-O-密集型运算" class="headerlink" title="I/O 密集型运算"></a>I/O 密集型运算</h5><ul>
<li><strong>CPU 不总是处于繁忙状态</strong><ul>
<li>当你执行业务计算时，这时候会使用 CPU 资源</li>
<li>当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你<strong>可以利用多线程提高它的利用率。</strong> </li>
</ul>
</li>
<li>经验公式如下 ：<code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code> <ul>
<li>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式 4 * 100% * 100% / 50% = 8 </li>
<li>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式 4 * 100% * 100% / 10% = 40</li>
</ul>
</li>
</ul>
<h3 id="8-1-10-ForkJoinPool"><a href="#8-1-10-ForkJoinPool" class="headerlink" title="8.1.10 ForkJoinPool"></a>8.1.10 ForkJoinPool</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h4><p>Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型 运算<br>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计 算，如归并排序、斐波那契数列、都可以用分治思想进行求解<br>Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运 算效率<br>Fork/Join 默认会创建与 cpu 核心数大小相同的线程池</p>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h4><p>提交给 Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值），例如下 面定义了一个对 1~n 之间的整数求和的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_NUM = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">10000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = r.nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        out.println(Arrays.stream(nums).sum());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有返回值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTaskWithReturn</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AddTaskWithReturn</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(end - start &lt; MAX_NUM)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">long</span> sum  = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i&lt; end ;i++) &#123;</span><br><span class="line">                    sum += nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> middle = (start+end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            AddTaskWithReturn subTask1 = <span class="keyword">new</span> AddTaskWithReturn(start, middle);</span><br><span class="line">            AddTaskWithReturn subTask2 = <span class="keyword">new</span> AddTaskWithReturn(middle, end);</span><br><span class="line">            subTask1.fork();</span><br><span class="line">            subTask2.fork();</span><br><span class="line">            <span class="keyword">return</span> subTask1.join() + subTask2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//无返回值</span></span><br><span class="line"><span class="comment">//    static class AddTaskWithoutReturn extends RecursiveAction&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int start, end;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        AddTaskWithoutReturn(int start, int end) &#123;</span></span><br><span class="line"><span class="comment">//            this.start = start;</span></span><br><span class="line"><span class="comment">//            this.end = end;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        @Override</span></span><br><span class="line"><span class="comment">//        protected void compute() &#123;</span></span><br><span class="line"><span class="comment">//            if(end - start &lt; MAX_NUM)</span></span><br><span class="line"><span class="comment">//            &#123;</span></span><br><span class="line"><span class="comment">//                long sum  = 0;</span></span><br><span class="line"><span class="comment">//                for(int i = start; i&lt; end ;i++) &#123;</span></span><br><span class="line"><span class="comment">//                    sum = sum + nums[i];</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            else &#123;</span></span><br><span class="line"><span class="comment">//                int middle = (start+end) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">//                AddTaskWithoutReturn subTask1 = new AddTaskWithoutReturn(start, middle);</span></span><br><span class="line"><span class="comment">//                AddTaskWithoutReturn subTask2 = new AddTaskWithoutReturn(middle, end);</span></span><br><span class="line"><span class="comment">//                subTask1.fork();</span></span><br><span class="line"><span class="comment">//                subTask2.fork();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//无返回值</span></span><br><span class="line"><span class="comment">//        ForkJoinPool pool = new ForkJoinPool();</span></span><br><span class="line"><span class="comment">//        AddTaskWithoutReturn task = new AddTaskWithoutReturn(0, nums.length);</span></span><br><span class="line"><span class="comment">//        pool.execute(task);</span></span><br><span class="line"><span class="comment">//        task.join();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//有返回值</span></span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        AddTaskWithReturn task = <span class="keyword">new</span> AddTaskWithReturn(<span class="number">0</span>, nums.length);</span><br><span class="line">        pool.execute(task);</span><br><span class="line">        Long result = task.join();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><blockquote><p>原文作者: 掘金木匠</p><p>原文链接: <a href="http://goldcarpenter.github.io/2019/08/24/多线程_Part9/">http://goldcarpenter.github.io/2019/08/24/多线程_Part9/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/08/31/%E5%A4%9A%E7%BA%BF%E7%A8%8B_Part10/" class="pre">多线程编程</a><a href="/2019/08/18/MyBatis_Part3/" class="next">MyBatis</a></div><div id="comments"><div id="SOHUCS" sid="2019/08/24/多线程_Part9/"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#8-共享模型之并发工具"><span class="toc-text">8 共享模型之并发工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-线程池"><span class="toc-text">8.1 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-线程池优点"><span class="toc-text">8.1.1 线程池优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-自定义线程池"><span class="toc-text">8.1.2 自定义线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-3-Executor接口"><span class="toc-text">8.1.3 Executor接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-4-ExecutorService接口"><span class="toc-text">8.1.4 ExecutorService接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-5-ThreadPoolExecutor"><span class="toc-text">8.1.5 ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程池状态"><span class="toc-text">线程池状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造方法"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Future接口"><span class="toc-text">Future接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FutureTask类"><span class="toc-text">FutureTask类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-6-Executors工具类"><span class="toc-text">8.1.6 Executors工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-定长线程池newFixedThreadPool"><span class="toc-text">1 定长线程池newFixedThreadPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-可缓存线程池newCachedThreadPool"><span class="toc-text">2 可缓存线程池newCachedThreadPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-单例线程池newSingleThreadExecutor"><span class="toc-text">3 单例线程池newSingleThreadExecutor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Executors-newFixedThreadPool-1-与此区别"><span class="toc-text">Executors.newFixedThreadPool(1)与此区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-任务调度线程池ScheduledExecutorService"><span class="toc-text">4 任务调度线程池ScheduledExecutorService</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#如何让每周四-18-00-00-定时执行任务？"><span class="toc-text">如何让每周四 18:00:00 定时执行任务？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-提交任务"><span class="toc-text">5 提交任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-关闭线程池"><span class="toc-text">6 关闭线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#shutdown"><span class="toc-text">shutdown</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#shutdownNow"><span class="toc-text">shutdownNow</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-其它方法"><span class="toc-text">7 其它方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-7-正确处理执行任务异常"><span class="toc-text">8.1.7 正确处理执行任务异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方法1：主动捉异常"><span class="toc-text">方法1：主动捉异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法2：使用-Future"><span class="toc-text">方法2：使用 Future</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-8-Tomcat线程池"><span class="toc-text">8.1.8 Tomcat线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-9异步模式之工作线程"><span class="toc-text">8.1.9异步模式之工作线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-定义"><span class="toc-text">1 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-饥饿现象"><span class="toc-text">2 饥饿现象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-创建多少线程池合适"><span class="toc-text">3 创建多少线程池合适</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CPU-密集型运算"><span class="toc-text">CPU 密集型运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#I-O-密集型运算"><span class="toc-text">I&#x2F;O 密集型运算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-10-ForkJoinPool"><span class="toc-text">8.1.10 ForkJoinPool</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-概念"><span class="toc-text">1 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-使用"><span class="toc-text">2 使用</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/17/Redis_Part3/">Redis</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/04/Redis_Part2/">Redis</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/Nginx%E5%9F%BA%E7%A1%80/">Nginx</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/Redis_Part1/">Redis</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part3/">JDK8新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part2/">JDK8新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/25/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part1/">JDK8新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/02/javaIO/">JavaIO</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/21/ThreadLocal/">ThreadLocal总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/19/SpringMVC_Part3/">SpringMVC</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Debug%E8%AE%B0%E5%BD%95/">Debug记录</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E9%AB%98%E7%BA%A7/">Java高级</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL%E5%9F%BA%E7%A1%80/">MySQL基础</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E5%BC%80%E5%8F%91/">Web开发</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">博客搭建</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/IEDA/" style="font-size: 15px;">IEDA</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/MyBatis/" style="font-size: 15px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/SpringMVC/" style="font-size: 15px;">SpringMVC</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/ThreadLocal/" style="font-size: 15px;">ThreadLocal</a> <a href="/tags/String/" style="font-size: 15px;">String</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 15px;">内部类</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 15px;">多线程</a> <a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 15px;">注解</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">34</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.scu.edu.cn/" title="四川大学首页" target="_blank">四川大学首页</a><ul></ul><a href="http://www.scu.edu.cn/" title="风雨云知道——待部署" target="_blank">风雨云知道——待部署</a><ul></ul><a href="http://www.scu.edu.cn/" title="在线聊天室——待部署" target="_blank">在线聊天室——待部署</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">掘金木匠.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script><script>window._config = { showScore: true };
(function(){ 
  var appid = 'cyuBR2wWE'; 
  var conf = 'cbd82aee65d05c481319a299102b4811'; 
  var width = window.innerWidth || document.documentElement.clientWidth; 
  var nodes =document.getElementsByTagName("head")[0]||document.head||document.documentElement;
  if (/(Android|iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) && width < 750) {  
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
  }
  else { 
    var loadJs=function(d,a){
      var b=document.createElement("script");b.setAttribute("type","text/javascript");
      b.setAttribute("charset","UTF-8");
      b.setAttribute("src",d);
      if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}
      nodes.appendChild(b)
    };
    loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); 
  } 
  var loadCss = function(cssString){  
    var style=document.createElement("style");  
    style.setAttribute("type", "text/css");  
    if(style.styleSheet){// IE  
        style.styleSheet.cssText = cssString;  
    } else {// w3c  
        var cssText = document.createTextNode(cssString);  
        style.appendChild(cssText);  
    }
    nodes.appendChild(style);
  }
  //- window.onload=function(){
  //-   if(window.outerWidth<=775){
  //-     loadCss('.module-hot-topic,.module-cmt-float-bar{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .cbox-prompt-w span.prompt-empty-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w .form-text-w span.text-null,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w a.comment-link-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w span.comment-text-w,#SOHUCS #SOHU_MAIN .module-cmt-footer .section-service-w div.service-wrap-w a:hover,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w span.wrap-name-w,#SOHUCS #SOHU_MAIN .module-cmt-list .action-click-gw span.click-disable-eg a em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li div.title-name-gw,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number .comment-number span.cy-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number span.comment-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active,#SOHUCS #SOHU_MAIN .module-cmt-list .msg-wrap-gw .wrap-action-gw .action-click-gw span a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .picture-box-gw div.box-action-gw a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-action-gw .action-click-gw span a:hover em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-user-gw span.user-name-gw a{color:#40759b!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-r,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-l,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-r{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-l{background:#FFF!important;top:-2px!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-function-w .uploading-wrapper-dw div.wrapper-image-dw,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-main,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w div.form-text-w,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-list .module-cmt-box .post-wrap-w div.post-wrap-main{border:1px solid #e6e6e6!important;border-radius:20px 20px 20px 20px;margin:0!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw{width:130px!important;height:34px!important;line-height:33px!important;font-size:17px!important;background:#5483b1!important;border-radius:20px!important;color:#FFF!important;-webkit-box-shadow:0 -1px 4px #5483b1 inset;box-shadow:0 -1px 10px #5483b1 inset}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw:before{content:"发表评论"}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a:hover .btn-fw{color:#40759b!important;background:#FFF!important}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li{background:none!important;border-bottom:1px solid #e6e6e6}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active{border:1px solid #e6e6e6;border-radius:10px 10px 0 0;border-bottom:none}#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li .title-name-gw div.title-name-gw-tag{background:#5483b1!important;border-radius:3px}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type div.cmt-list-border{background-color:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item{border:1px solid #e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo{text-align:center;line-height:40px;border-radius:50%!important;background:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo:before{content:"畅";font-size:22px;color:#FFF}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text,#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text i{color:#5483b1!important}#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w{background:#FFF!important}@media screen and (min-width:900px){#SOHUCS #SOHU_MAIN .module-mobile-cmt-list .list-wrapper-wap .list-container-wap .list-item-wap .list-content-wrapper-wap .cmt-list-image-container .cmt-list-image{max-width: 100%;}}');
  //-   }
  //- };
})();
function removeElement(_element){
     var _parentElement = _element.parentNode;
     if(_parentElement){
            _parentElement.removeChild(_element);
     }
}
var removeAD = document.createElement("div");
removeAD.id = 'removeAD';
var adInterval1 = setInterval(function() {
  if(document.querySelector("#feedAv")){
    document.querySelector("[node-type=cmt-list]").appendChild(removeAD);
    document.querySelector("#removeAD").appendChild(document.querySelector("#feedAv"));
    //- removeElement(document.querySelectorAll("#feedAv")[0]);
    var feedAv = document.querySelector("#feedAv").children;
    for( item of feedAv){
      item.style.display = 'none'
    }
    document.querySelector("#removeAD").style.display="none"
    clearInterval(adInterval1);
  }
},1000);
var adInterval2 = setInterval(function() {
  if(document.querySelector("#pop_ad")){
    removeElement(document.querySelector("#pop_ad"));
    clearInterval(adInterval2);
  }
}, 1000);</script><script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script></body></html>