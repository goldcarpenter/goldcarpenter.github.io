<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="JJMJ's blog."><meta name="keywords" content="Java, Spring, MyBatis, 后端"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>String底层总结 | 掘金木匠</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">String底层总结</h1><a id="logo" href="/.">掘金木匠</a><p class="description">懂金融的软件工程师一定是一个合格的吃货</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">String底层总结</h1><div class="post-meta"><a href="/2019/11/01/String%E6%80%BB%E7%BB%93/#comments" class="comment-count"><i id="changyan_count_unit" data-xid="2019/11/01/String总结/"></i>留言,<i id="changyan_parti_unit" data-xid="2019/11/01/String总结/"></i>参与</a><p><span class="date">Nov 01, 2019</span><span><a href="/categories/Java%E9%AB%98%E7%BA%A7/" class="category">Java高级</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="String底层总结"><a href="#String底层总结" class="headerlink" title="String底层总结"></a>String底层总结</h1><h2 id="1-字符串创建方式"><a href="#1-字符串创建方式" class="headerlink" title="1.字符串创建方式"></a>1.字符串创建方式</h2><ul>
<li>字符串有六种基本的创建方式<ul>
<li>使用<code>char[]</code>数组配合<code>new</code>来创建</li>
<li>使用<code>byte[]</code>数组配合<code>new</code>来创建</li>
<li>使用<code>int[]</code>数组配合<code>new</code>来创建</li>
<li>使用 已有字符串 配合<code>new</code>来创建</li>
<li>使用字面量创建（不使用<code>new</code>）</li>
<li>合二为一，使用<code>+</code>运算符来拼接创建</li>
</ul>
</li>
</ul>
<p>可以看到，至少从表面上讲，后两种都没有用到 new 关键字</p>
<h3 id="1-1-char-数组创建"><a href="#1-1-char-数组创建" class="headerlink" title="1.1 char[] 数组创建"></a>1.1 char[] 数组创建</h3><ul>
<li>这种是最基本的，因为字符串本身就是将字符串起来</li>
<li>String底层结构就是多个字符的 char[] 数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>它的内部结构如下（1.8）</p>
<p><img src="st01-1589963576703.png" alt=""></p>
<p>其中 97 其实就是 ‘a’ ，98 其实就是 ‘b’ ，99 其实就是 ‘c’ </p>
<h3 id="1-2-byte-数组创建"><a href="#1-2-byte-数组创建" class="headerlink" title="1.2 byte[] 数组创建"></a>1.2 byte[] 数组创建</h3><ul>
<li><p>什么时候会根据 byte[] 数组来创建字符串呢【从 byte[] 转为字符串的需求】</p>
<ul>
<li>从网络（例如一个浏览器的 http 请求）传递过来的字节数据</li>
<li>从 I/O（例如从一个文本文件）读取到的数据</li>
</ul>
</li>
<li><p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;); <span class="comment">// abc</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>new byte[]{97, 98, 99}</code> 就可以是</p>
<ul>
<li>从网络（例如一个浏览器的 http 请求）传递过来的字节数据</li>
<li>从 I/O（例如从一个文本文件）读取到的数据</li>
</ul>
</li>
<li><p>它的内部结构其实也是</p>
</li>
</ul>
<p><img src="st01.png" alt=""></p>
<p>这时 byte[] 会在构造时被转换为 char[]，其中 byte[] 和 char [] 的结构如下</p>
<p><img src="st02.png" alt=""></p>
<p>看到上幅图有同学会说，对于 byte[] 转换为 char[]，97 还是对应 97，98 还是对应 98，99 还是对应 99 啊，看不出 byte[] 和 char[] 的任何区别啊？你要知道，首先他们的大小不一样，其次上面的 char[] 中的 97（a），98（b），99（c） 都属于拉丁字符集，如果用到其它字符集，那么结果就不一样了，看下面的例子</p>
<ul>
<li><p>按 gbk 字符集转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = &#123;(<span class="keyword">byte</span>) <span class="number">0xD5</span>, (<span class="keyword">byte</span>) <span class="number">0xC5</span>&#125;;</span><br><span class="line">String str = <span class="keyword">new</span> String(bytes, Charset.forName(<span class="string">"gbk"</span>));</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>

<p>这时</p>
</li>
</ul>
<p><img src="st04.png" alt=""></p>
<ul>
<li><p>其中两个<code>byte 0xD5</code>和 <code>0xC5</code>被转换成了一个 char 0x5F20（汉字【张】）</p>
</li>
<li><p>按<code>utf-8</code>字符集转换</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">byte</span>[] bytes = &#123;(<span class="keyword">byte</span>) <span class="number">0xE5</span>, (<span class="keyword">byte</span>) <span class="number">0xBC</span>, (<span class="keyword">byte</span>) <span class="number">0xA0</span>&#125;;</span><br><span class="line">      String str = <span class="keyword">new</span> String(bytes, Charset.forName(<span class="string">"utf-8"</span>));</span><br><span class="line"><span class="comment">//String str = new String(bytes);		等价</span></span><br><span class="line">      System.out.println(str);</span><br></pre></td></tr></table></figure>

<p><img src="st03.png" alt=""></p>
<p>其中三个<code>byte 0xE5</code>，<code>0xBC</code> 和<code>0xA0</code> 被转换成了一个<code>char 0x5F20</code>（汉字【张】）</p>
<p><strong>其实 java 中的 char 字符都是以 unicode 编码的，从外界不同的编码（如 gbk，utf-8）传过来的 byte[] 最终到 java 中的 char 都统一了</strong></p>
<h3 id="1-3-int-数组创建"><a href="#1-3-int-数组创建" class="headerlink" title="1.3 int[] 数组创建"></a>1.3 int[] 数组创建</h3><p>有时候我们还需要用两个 char 表示一个字符，比如 😂 这个笑哭的字符，它用 unicode 编码表示为 0x1F602，存储范围已经超过了 char 能表示的最大值 0xFFFF，因此需要使用 int[] 来构造这样的字符串，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0x1F602</span>&#125;, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>转换过程如图所示</p>
<p><img src="st05.png" alt=""></p>
<blockquote>
<p>参考</p>
<p><a href="http://unicode.org/versions/Unicode9.0.0/" target="_blank" rel="noopener">unicode 9.0 说明</a></p>
<p><a href="http://www.unicode.org/emoji/charts/emoji-versions.html#v9.0_2016" target="_blank" rel="noopener">unicode 中的 emoji 表情</a></p>
</blockquote>
<h3 id="1-4-从已有字符串创建"><a href="#1-4-从已有字符串创建" class="headerlink" title="1.4 从已有字符串创建"></a>1.4 从已有字符串创建</h3><p>直接看源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种最为简单，但要注意是两个字符串对象<strong>引用同一个 char[] 对象</strong>，但是引用值不相等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(s1);</span><br></pre></td></tr></table></figure>

<p>内存结构如下</p>
<p><img src="st09.png" alt=""></p>
<h3 id="1-5-字面量创建"><a href="#1-5-字面量创建" class="headerlink" title="1.5 字面量创建"></a>1.5 字面量创建</h3><p>以上四种创建方式，大家用的实际上相对少一点，最熟悉的是这种字面量的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"abc"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>&quot;abc&quot;</code>  被叫做字符串字面量</strong>（英文 Literal），但恰恰是这种方式其实奥妙最多<ul>
<li><strong>非对象</strong></li>
<li><strong>懒加载</strong></li>
<li><strong>不重复</strong></li>
</ul>
</li>
</ul>
<h4 id="1-5-1非对象"><a href="#1-5-1非对象" class="headerlink" title="1.5.1非对象"></a>1.5.1非对象</h4><p>严格地说，<strong>字面量在代码运行到它所在语句之前，它还不是字符串对象</strong></p>
<p>要理解从字面量变成字符串对象的过程，需要从字节码的角度来分析</p>
<p>在上面的 java 代码被编译为 class 文件后，<code>&quot;abc&quot;</code>  存储于【类文件常量池】中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constant pool: &#x2F;&#x2F; 常量池</span><br><span class="line">   #1 &#x3D; Methodref          #19.#41        &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; String             #42            &#x2F;&#x2F; abc</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>当 class 完成类加载之后，<code>&quot;abc&quot;</code>  这个字面量被存储于【运行时常量池】（归属于方法区）中，其中 #1 #2 都会被翻译为运行时真正的内存地址</p>
<p>再看一下 class 中 main 方法的字节码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]); &#x2F;&#x2F; 字节码指令</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;2, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String abc</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: return</span><br><span class="line">         ...</span><br></pre></td></tr></table></figure>

<p>将来 main 方法被调用时，就会执行里面的字节码指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: ldc           #2                  &#x2F;&#x2F; String abc</span><br><span class="line">2: astore_1</span><br><span class="line">3: return</span><br></pre></td></tr></table></figure>

<p><strong><code>ldc #2</code> 就是到运行时常量池中找到 #2 的内存地址，找到 <code>&quot;abc&quot;</code>  这个字面量，再根据它创建一个 String 对象。</strong></p>
<p><img src="st11.png" alt=""></p>
<h4 id="1-5-2懒加载"><a href="#1-5-2懒加载" class="headerlink" title="1.5.2懒加载"></a>1.5.2懒加载</h4><ul>
<li><p><strong>当第一次用到 <code>&quot;abc&quot;</code>  字面量时（就是执行到 <code>ldc #2</code> 时） ，才会创建对应的字符串对象</strong></p>
</li>
<li><p>如何验证呢？</p>
</li>
</ul>
<p>例如有如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"1"</span>); <span class="comment">// 断点1 2411</span></span><br><span class="line">System.out.println(<span class="string">"2"</span>); <span class="comment">// 断点2 2412</span></span><br><span class="line">System.out.println(<span class="string">"3"</span>); <span class="comment">// 断点3</span></span><br></pre></td></tr></table></figure>

<p>可以给每行语句加上断点，然后用 idea 的 debug 界面中的 memory 工具来查看字符串对象的数量</p>
<p>刚开始在断点1 处，其它类中创建的字符串对象有 2411 个</p>
<p><img src="st06.png" alt=""></p>
<p>执行到断点2 处，这时新创建了 <code>&quot;1&quot;</code> 对应的字符串对象，个数为 2412</p>
<p><img src="st07.png" alt=""></p>
<p>执行到断点3 处，这时新创建了 <code>&quot;2&quot;</code> 对应的字符串对象，个数为 2413</p>
<p><img src="st08.png" alt=""></p>
<h4 id="1-5-3不重复"><a href="#1-5-3不重复" class="headerlink" title="1.5.3不重复"></a>1.5.3不重复</h4><p><strong>同一个类中的值相同字面量，其实只有一份</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量池为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #25.#48        &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; String             #49            &#x2F;&#x2F; abc</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>对应的字节码为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String abc</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: ldc           #2                  &#x2F;&#x2F; String abc</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: return</span><br><span class="line">         ...</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>&quot;abc&quot;</code> 这个字面量虽然出现了 2 次，但实际上都是对应着常量池中 #2 这个地址</p>
<p>如果是不同类中的 <code>&quot;abc&quot;</code> 呢？【类文件常量池】包括【运行时常量池】都是以类为单位的</p>
<p>例如，另一个类中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"a"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的常量池</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #5.#22         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = String             #23            // a</span><br><span class="line">   #3 = String             #24            // abc</span><br></pre></td></tr></table></figure>

<p>可以看到在这个类中，<code>&quot;abc&quot;</code> 对应的常量池的编号是 #3，与 TestString1 中的已经不同</p>
<p>这时候【字面量】是两份，而【字符串对象】会有几个呢？</p>
<p>我们来做个实验，把刚才的代码做个改写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>; <span class="comment">// 字符串对象 "abc"</span></span><br><span class="line">        String s2 = <span class="string">"abc"</span>; <span class="comment">// 字符串对象 "abc"</span></span><br><span class="line">        TestString2.main(<span class="keyword">new</span> String[]&#123;s1, s2&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// args[0] "abc", args[1] "abc"</span></span><br><span class="line">        String s1 = <span class="string">"a"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(args[<span class="number">0</span>] == s2);</span><br><span class="line">        System.out.println(args[<span class="number">1</span>] == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>具体原理我们下一个章节再讲</p>
<h3 id="1-5-拼接创建"><a href="#1-5-拼接创建" class="headerlink" title="1.5 拼接创建"></a>1.5 拼接创建</h3><p>最后还可以通过 <code>+</code> 运算符将两个字符串（其中一个也可以是其它类型）拼接为一个新字符串，例如</p>
<p>例1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span> + <span class="string">"b"</span>;</span><br></pre></td></tr></table></figure>

<p>例2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="string">"a"</span> + x;</span><br></pre></td></tr></table></figure>

<p>例3</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="string">"a"</span> + x;</span><br></pre></td></tr></table></figure>

<p>例4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>有同学会问，例1与例2与例3 不同吗？还别说，真就不同，其中例1 与例2 原理是一样的，例3 与例4 原理是一样的，反编译一下</p>
<p>例1 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span> + <span class="string">"b"</span>;</span><br></pre></td></tr></table></figure>

<p>常量池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #4.#20         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; String             #21            &#x2F;&#x2F; ab</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>主方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;2, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String ab</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: return</span><br><span class="line">         ...</span><br></pre></td></tr></table></figure>

<p>可以看到，其实并没有真正的【拼接】操作发生，从源码编译为字节码时，javac 就已经把 “a” 和 “b” 串在一起了，这是一种编译期的优化处理</p>
<p>例2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="string">"a"</span> + x;</span><br></pre></td></tr></table></figure>

<p>常量池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #5.#22         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; String             #23            &#x2F;&#x2F; b</span><br><span class="line">   #3 &#x3D; String             #24            &#x2F;&#x2F; ab</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>主方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String b   final b</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: ldc           #3                  &#x2F;&#x2F; String ab</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: return</span><br><span class="line">         ...</span><br></pre></td></tr></table></figure>

<p>可以看到，还是没有真正的【拼接】操作发生，final 意味着 x 的值不可改变，因此其它引用 x 的地方都可以安全地被替换为 “b”，而不用担心 x 被改变，从源码编译为字节码时，javac 就也进行了优化，把所有出现 x 的地方都替换成为了 “b”</p>
<p>那么，什么是真正的【拼接】操作呢？看一下例3 反编译后的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="string">"a"</span> + x;</span><br></pre></td></tr></table></figure>

<p>常量池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #9.#26         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; String             #27            &#x2F;&#x2F; b</span><br><span class="line">   #3 &#x3D; Class              #28            &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">   #4 &#x3D; Methodref          #3.#26         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #5 &#x3D; String             #29            &#x2F;&#x2F; a</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>可以看到常量池中并没有 ab 字面量</p>
<p>主方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String b</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: new           #3                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">         6: dup</span><br><span class="line">         7: invokespecial #4                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        10: ldc           #5                  &#x2F;&#x2F; String a</span><br><span class="line">        12: invokevirtual #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        15: aload_1</span><br><span class="line">        16: invokevirtual #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        19: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">        22: astore_2</span><br><span class="line">        23: return</span><br></pre></td></tr></table></figure>

<p>翻译成人能读懂的就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="string">"a"</span> + x;</span><br><span class="line"></span><br><span class="line">String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="keyword">new</span> StringBuilder().append(<span class="string">"a"</span>).append(x).toString();</span><br></pre></td></tr></table></figure>

<p>StringBuilder 的 toString() 方法又是怎么实现的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从 AbstractStringBuilder 继承的属性，方便阅读加在此处</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create a copy, don't share the array</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，本质上就是根据 StringBuilder 维护的 char[] 创建了新的 String 对象</p>
<h3 id="1-6-JDK-9-之后的改变"><a href="#1-6-JDK-9-之后的改变" class="headerlink" title="1.6 JDK 9 之后的改变"></a>1.6 JDK 9 之后的改变</h3><p>前面我们讲的是 JDK 8 中的字符串，但从 JDK 9 开始，String 的内部存储方式、以及拼接方式又发生了较大的改变</p>
<ul>
<li>不再用 char[] 存储字符，改为了 byte[]，目的是更节约内存</li>
<li>使用 invokedynamic 指令扩展了字符串的拼接的实现方式</li>
</ul>
<h4 id="1-6-1内存结构改变"><a href="#1-6-1内存结构改变" class="headerlink" title="1.6.1内存结构改变"></a>1.6.1内存结构改变</h4><p>例如，字符串中仅有拉丁字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="st12.png" alt=""></p>
<p>例如，字符串中有中文字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(</span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;(<span class="keyword">byte</span>) <span class="number">0xd5</span>, (<span class="keyword">byte</span>) <span class="number">0xc5</span>&#125;, </span><br><span class="line">    Charset.forName(<span class="string">"gbk"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="st13.png" alt=""></p>
<p>例如，既有中文字符也有拉丁字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(</span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;(<span class="keyword">byte</span>) <span class="number">0xd5</span>, (<span class="keyword">byte</span>) <span class="number">0xc5</span>, <span class="number">97</span>&#125;, </span><br><span class="line">    Charset.forName(<span class="string">"gbk"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p><img src="st14.png" alt=""></p>
<h4 id="1-6-2拼接方式改变"><a href="#1-6-2拼接方式改变" class="headerlink" title="1.6.2拼接方式改变"></a>1.6.2拼接方式改变</h4><p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String x = <span class="string">"b"</span>;</span><br><span class="line">    String s = <span class="string">"a"</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #5.#22         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; String             #23            &#x2F;&#x2F; b</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>主方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String b</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: aload_1</span><br><span class="line">         4: invokedynamic #3,  0              &#x2F;&#x2F; InvokeDynamic #0:makeConcatWithConstants:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">         9: astore_2</span><br><span class="line">        10: return</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>直接跟 <code>invokedynamic</code> 对应的字节码比较难，我直接翻译成人能看懂的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    String x = <span class="string">"b"</span>;</span><br><span class="line">    <span class="comment">// String s = "a" + x; </span></span><br><span class="line">    <span class="comment">// 会生成如下等价的字节码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器会提供 lookup，用来查找 MethodHandle</span></span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    CallSite callSite = StringConcatFactory.makeConcatWithConstants(</span><br><span class="line">        lookup,</span><br><span class="line">        <span class="comment">// 方法名，不重要，编译器会自动生成</span></span><br><span class="line">        <span class="string">"arbitrary"</span>,</span><br><span class="line">        <span class="comment">// 方法的签名，第一个 String 为返回值类型，之后是入参类型</span></span><br><span class="line">        MethodType.methodType(String<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class">        // 具体处方格式，其中 \1 意思是变量的占位符，将来被 <span class="title">x</span> 代替</span></span><br><span class="line">        "a\1"</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// callSite.getTarget() 返回的是 MethodHandle 对象，用来反射执行拼接方法</span></span><br><span class="line">    String s = (String) callSite.getTarget().invoke(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么搞这么麻烦！！！</strong>主要是为了对字符串的拼接做各种扩展优化，多了扩展途径。其中最为重要的是 <code>MethodHandle</code> ，它使用了<strong>策略模式</strong>生成，JDK 提供的所有的策略可以在 <code>StringConcatFactory.Strategy</code> 中找到：</p>
<table>
<thead>
<tr>
<th>策略名</th>
<th>内部调用</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>BC_SB</td>
<td>字节码拼接生成 StringBuilder 代码</td>
<td>等价于 new StringBuilder()</td>
</tr>
<tr>
<td>BC_SB_SIZED</td>
<td>字节码拼接生成 StringBuilder 代码</td>
<td>等价于 new StringBuilder(n) n为预估大小</td>
</tr>
<tr>
<td>BC_SB_SIZED_EXACT</td>
<td>字节码拼接生成 StringBuilder 代码</td>
<td>等价于 new StringBuilder(n) n为准确大小</td>
</tr>
<tr>
<td>MH_SB_SIZED</td>
<td>MethodHandle 生成 StringBuilder 代码</td>
<td>等价于 new StringBuilder(n) n为预估大小</td>
</tr>
<tr>
<td>MH_SB_SIZED_EXACT</td>
<td>MethodHandle 生成 StringBuilder 代码</td>
<td>等价于 new StringBuilder(n) n为准确大小</td>
</tr>
<tr>
<td>MH_INLINE_SIZED_EXACT</td>
<td>MethodHandle 内部使用字节数组直接构造出 String</td>
<td>默认策略</td>
</tr>
</tbody></table>
<p>如果想改变策略，可以在运行时添加 JVM 参数，例如将策略改为 BC_SB</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Djava.lang.invoke.stringConcat&#x3D;BC_SB</span><br><span class="line">-Djava.lang.invoke.stringConcat.debug&#x3D;true</span><br><span class="line">-Djava.lang.invoke.stringConcat.dumpClasses&#x3D;匿名类导出路径</span><br></pre></td></tr></table></figure>

<p>还有一种选择，是在 <code>javac</code> 编译时仍使用JDK1.5<code>StringBuilder</code>的办法拼接字符串，而不是采用 <code>invokedynamic</code>，就是在 <code>javac</code> 时加上参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XDstringConcat&#x3D;inline</span><br></pre></td></tr></table></figure>





<h4 id="1-6-3默认拼接策略"><a href="#1-6-3默认拼接策略" class="headerlink" title="1.6.3默认拼接策略"></a>1.6.3默认拼接策略</h4><p>默认策略为 MH_INLINE_SIZED_EXACT，使用字节数组直接构造出 String</p>
<p>例如有下面的字符串拼接代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="string">"a"</span> + x + <span class="string">"c"</span> + <span class="string">"d"</span>;</span><br></pre></td></tr></table></figure>

<p>使用了 MH_INLINE_SIZED_EXACT 策略后，内部会执行如下等价调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"b"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预先分配字符串需要的字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新字符串，这时内部字节数组值为 [0,0,0,0]</span></span><br><span class="line">String s = StringConcatHelper.newString(buf, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行【拼接】，字符串内部字节数组值为 [97,0,0,0]</span></span><br><span class="line">StringConcatHelper.prepend(<span class="number">1</span>, buf, <span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行【拼接】，字符串内部字节数组值为 [97,98,0,0]</span></span><br><span class="line">StringConcatHelper.prepend(<span class="number">2</span>, buf, x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行【拼接】，字符串内部字节数组值为 [97,98,99,100]</span></span><br><span class="line">StringConcatHelper.prepend(<span class="number">4</span>, buf, <span class="string">"cd"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到此【拼接完毕】</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> </p>
<ul>
<li>StringConcatHelper 对外是不可见的，因此无法直接测试，只能反射测试</li>
<li>prepend 可以直接修改字符串中的 bytes 属性值，他们都是 java.lang 包下的</li>
</ul>
</blockquote>
<h4 id="1-6-4模仿-BC-SB-策略"><a href="#1-6-4模仿-BC-SB-策略" class="headerlink" title="1.6.4模仿 BC_SB 策略"></a>1.6.4模仿 BC_SB 策略</h4><p>接下来我模拟其中一种策略的实现过程：以字节码指令生成拼接方法为例</p>
<p>先说明一下我的目的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"hello,"</span>;</span><br><span class="line">String y = <span class="string">"world"</span>;</span><br><span class="line">String s = x + y;</span><br></pre></td></tr></table></figure>

<p>其中 + 可以被 invokedynamic 优化为多种实现策略，如果让我自己来实现，我仅会用 StringBuilder 来拼接，因此我希望 x+y 能够被翻译为对下面方法的调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concat</span><span class="params">(String x, String y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder().append(x).append(y).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="1-方法手动生成"><a href="#1-方法手动生成" class="headerlink" title="1. 方法手动生成"></a>1. 方法手动生成</h5><p>提供一个拼接方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concat</span><span class="params">(String x, String y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder().append(x).append(y).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 MethodHandle 反射调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"hello,"</span>;</span><br><span class="line">String y = <span class="string">"world"</span>;</span><br><span class="line">MethodHandle mh = MethodHandles.lookup().findStatic(</span><br><span class="line">    TestString4<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">    "concat", </span><br><span class="line">    MethodType.methodType(String<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">)</span>;</span><br><span class="line">String s = (String) mh.invoke(x,y);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello,world</span><br></pre></td></tr></table></figure>

<p>但这样需要自己提供 concat 方法，而且其参数个数都固定死了，能否动态生成这么一个方法呢，答案是肯定的，为了简化生成逻辑，这里我仍然以固定参数为例</p>
<h5 id="2-字节码生成方法"><a href="#2-字节码生成方法" class="headerlink" title="2. 字节码生成方法"></a>2. 字节码生成方法</h5><p>Unsafe 对象访问类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeAccessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 asm 生成匿名类字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] dump() &#123;</span><br><span class="line"></span><br><span class="line">    ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">    FieldVisitor fv;</span><br><span class="line">    MethodVisitor mv;</span><br><span class="line">    AnnotationVisitor av0;</span><br><span class="line"></span><br><span class="line">    cw.visit(<span class="number">52</span>, ACC_PUBLIC + ACC_SUPER, <span class="string">"cn/itcast/string/TestString4"</span>, <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    cw.visitSource(<span class="string">"TestString4.java"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        mv = cw.visitMethod(ACC_PUBLIC, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        mv.visitCode();</span><br><span class="line">        Label l0 = <span class="keyword">new</span> Label();</span><br><span class="line">        mv.visitLabel(l0);</span><br><span class="line">        mv.visitLineNumber(<span class="number">3</span>, l0);</span><br><span class="line">        mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">        mv.visitMethodInsn(INVOKESPECIAL, <span class="string">"java/lang/Object"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">false</span>);</span><br><span class="line">        mv.visitInsn(RETURN);</span><br><span class="line">        Label l1 = <span class="keyword">new</span> Label();</span><br><span class="line">        mv.visitLabel(l1);</span><br><span class="line">        mv.visitLocalVariable(<span class="string">"this"</span>, <span class="string">"Lcn/itcast/string/TestString4;"</span>, <span class="keyword">null</span>, l0, l1, <span class="number">0</span>);</span><br><span class="line">        mv.visitMaxs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        mv.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, <span class="string">"concat"</span>, <span class="string">"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        mv.visitCode();</span><br><span class="line">        Label l0 = <span class="keyword">new</span> Label();</span><br><span class="line">        mv.visitLabel(l0);</span><br><span class="line">        mv.visitLineNumber(<span class="number">9</span>, l0);</span><br><span class="line">        mv.visitTypeInsn(NEW, <span class="string">"java/lang/StringBuilder"</span>);</span><br><span class="line">        mv.visitInsn(DUP);</span><br><span class="line">        mv.visitMethodInsn(INVOKESPECIAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">false</span>);</span><br><span class="line">        mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">        mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line">        mv.visitVarInsn(ALOAD, <span class="number">1</span>);</span><br><span class="line">        mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line">        mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"toString"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">false</span>);</span><br><span class="line">        mv.visitInsn(ARETURN);</span><br><span class="line">        Label l1 = <span class="keyword">new</span> Label();</span><br><span class="line">        mv.visitLabel(l1);</span><br><span class="line">        mv.visitLocalVariable(<span class="string">"x"</span>, <span class="string">"Ljava/lang/String;"</span>, <span class="keyword">null</span>, l0, l1, <span class="number">0</span>);</span><br><span class="line">        mv.visitLocalVariable(<span class="string">"y"</span>, <span class="string">"Ljava/lang/String;"</span>, <span class="keyword">null</span>, l0, l1, <span class="number">1</span>);</span><br><span class="line">        mv.visitMaxs(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        mv.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    cw.visitEnd();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cw.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么多字节码主要目的仅仅是生成一个匿名类的字节码，其中包括了拼接方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concat</span><span class="params">(String x, String y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder().append(x).append(y).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就可以生成匿名类，供 MethodHandler 反射调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成匿名类所需字节码</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = dump();</span><br><span class="line"><span class="comment">// 根据字节码生成匿名类.class</span></span><br><span class="line">Class&lt;?&gt; innerClass = UnsafeAccessor.UNSAFE</span><br><span class="line">    .defineAnonymousClass(TestString4<span class="class">.<span class="keyword">class</span>, <span class="title">bytes</span>, <span class="title">null</span>)</span>;</span><br><span class="line"><span class="comment">// 确保匿名类初始化</span></span><br><span class="line">UnsafeAccessor.UNSAFE.ensureClassInitialized(innerClass);</span><br><span class="line"><span class="comment">// 找到匿名类中 String concat(String x, String y)</span></span><br><span class="line">MethodHandle mh = MethodHandles.lookup().findStatic(</span><br><span class="line">    innerClass,</span><br><span class="line">    <span class="string">"concat"</span>, </span><br><span class="line">    MethodType.methodType(String<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">)</span>;</span><br></pre></td></tr></table></figure>

<p>最终就可以使用该 MethodHandle 反射完成字符串拼接了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"hello,"</span>;</span><br><span class="line">String y = <span class="string">"world"</span>;</span><br><span class="line">String s = (String) mh.invoke(x, y);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello,world</span><br></pre></td></tr></table></figure>

<p>JDK 9 当然做的更为专业，可以适配生成不同的参数个数、类型的 MethodHandle，但原理就是这样。</p>
<h2 id="2-字符串之家-StringTable"><a href="#2-字符串之家-StringTable" class="headerlink" title="2.字符串之家 - StringTable"></a>2.字符串之家 - StringTable</h2><h3 id="2-1-家养与野生"><a href="#2-1-家养与野生" class="headerlink" title="2.1 家养与野生"></a>2.1 家养与野生</h3><p>其实字符串分为家养的和野生的。</p>
<p>前面我们讲解了 String 的六种创建方式，<strong>除了字面量方式创建的字符串是家养的以外，其它方法创建的字符串都是野生的。</strong>什么意思呢？</p>
<ul>
<li><p>字面量方式创建的字符串，会放入 StringTable 中，StringTable 管理的字符串，才具有不重复的特性，这种就像是家养的</p>
</li>
<li><p>而 char[]，byte[]，int[]，String，以及 + 方式本质上都是使用 new 来创建，它们都是在堆中创建新的字符串对象，<strong>不会考虑字符串重不重复</strong>，这种就像是野生的，野生字符串的缺点就是如果存在大量值相同的字符串，对内存占用非常严重</p>
</li>
</ul>
<p>如何保证家养的字符串对象不重复呢？JDK 使用了 <strong>StringTable 来解决，StringTable 是采用 c++ 代码编写的，数据结构上就是一个 hash 表</strong>，字符串对象就充当 hash 表中的 key，key 的不重复性，是 hash 表的基本特性</p>
<p><img src="st10.png" alt=""></p>
<p>当代码运行到一个字面量 “abc” 时，会首先检查 StringTable 中有没有相同的 key，如果没有，创建新字符串对象加入；否则直接返回已有的字符串对象</p>
<h3 id="2-2-收留野生字符串"><a href="#2-2-收留野生字符串" class="headerlink" title="2.2 收留野生字符串"></a>2.2 收留野生字符串</h3><p>野生的字符串也有机会得到教育</p>
<p>字符串提供了 intern 方法来实现去重，让字符串对象有机会受到 StringTable 的管理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>它会尝试将调用者放入 StringTable</p>
<h4 id="2-2-1如果-StringTable-中已有"><a href="#2-2-1如果-StringTable-中已有" class="headerlink" title="2.2.1如果 StringTable 中已有"></a>2.2.1如果 StringTable 中已有</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = ...;</span><br><span class="line">String s = x.intern();</span><br></pre></td></tr></table></figure>

<p>总会返回家养的 String 对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant x as x</span><br><span class="line">participant s as s</span><br><span class="line">participant st as StringTable</span><br><span class="line"></span><br><span class="line">x -&gt;&gt; st : intern()</span><br><span class="line">st -&gt;&gt; st : 如果已有</span><br><span class="line">st --&gt;&gt; s : 返回 StringTable 对象</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;); <span class="comment">// 野生的</span></span><br><span class="line">String y = <span class="string">"abc"</span>; <span class="comment">// 将 "abc"字符串对象 加入 StringTable</span></span><br><span class="line">String z = x.intern(); <span class="comment">// 已有，返回 StringTable 中 "abc"，即 y</span></span><br><span class="line">System.out.println(z == y);</span><br><span class="line">System.out.println(z == x);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>



<h4 id="2-2-2如果-StringTable-中没有（1-7-以上-JDK-的做法）"><a href="#2-2-2如果-StringTable-中没有（1-7-以上-JDK-的做法）" class="headerlink" title="2.2.2如果 StringTable 中没有（1.7 以上 JDK 的做法）"></a>2.2.2如果 StringTable 中没有（1.7 以上 JDK 的做法）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = ...;</span><br><span class="line">String s = x.intern();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant x as x</span><br><span class="line">participant s as s</span><br><span class="line">participant st as StringTable</span><br><span class="line"></span><br><span class="line">x -&gt;&gt; st : intern()</span><br><span class="line">st -&gt;&gt; st : 如果没有</span><br><span class="line">st -&gt;&gt; st : 将x引用的对象加入</span><br><span class="line">st --&gt;&gt; s : 返回 StringTable 对象</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;); <span class="comment">// 野生的</span></span><br><span class="line">String z = x.intern(); <span class="comment">// 野生的 x 加入 StringTable，StringTable 中有了 "abc"</span></span><br><span class="line">String y = <span class="string">"abc"</span>; <span class="comment">// 已有，不会产生新的对象，用的是 StringTable 中 "abc"</span></span><br><span class="line">System.out.println(z == x);</span><br><span class="line">System.out.println(z == y);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>



<h4 id="2-2-3如果-StringTable-中没有（1-6-JDK-的做法）"><a href="#2-2-3如果-StringTable-中没有（1-6-JDK-的做法）" class="headerlink" title="2.2.3如果 StringTable 中没有（1.6 JDK 的做法）"></a>2.2.3如果 StringTable 中没有（1.6 JDK 的做法）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = ...;</span><br><span class="line">String s = x.intern();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant x as x</span><br><span class="line">participant s as s</span><br><span class="line">participant st as StringTable</span><br><span class="line"></span><br><span class="line">x -&gt;&gt; st : intern()</span><br><span class="line">st -&gt;&gt; st : 如果没有</span><br><span class="line">st -&gt;&gt; st : 将x引用的对象复制</span><br><span class="line">st -&gt;&gt; st : 将复制后的对象加入</span><br><span class="line">st --&gt;&gt; s : 返回 StringTable 对象</span><br></pre></td></tr></table></figure>

<p>例子，代码同上面 1.7 相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;); <span class="comment">// 野生的</span></span><br><span class="line">String z = x.intern(); <span class="comment">// 野生的 x 被复制后加入 StringTable，StringTable 中有了 "abc"</span></span><br><span class="line">String y = <span class="string">"abc"</span>; <span class="comment">// 已有，不会产生新的对象，用的是 StringTable 中 "abc"</span></span><br><span class="line">System.out.println(z == x);</span><br><span class="line">System.out.println(z == y);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>



<h3 id="2-3-去重的好处"><a href="#2-3-去重的好处" class="headerlink" title="2.3 去重的好处"></a>2.3 去重的好处</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 intern 减少内存占用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        List&lt;String&gt; address = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"linux.words"</span>), <span class="string">"utf-8"</span>))) &#123;</span><br><span class="line">                String line = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    line = reader.readLine();</span><br><span class="line">                    <span class="keyword">if</span>(line == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    address.add(line.intern());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"cost:"</span> +(System.nanoTime()-start)/<span class="number">1000000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-家的位置"><a href="#2-4-家的位置" class="headerlink" title="2.4 家的位置"></a>2.4 家的位置</h3><p><strong>StringTable 的位置（1.6）</strong></p>
<p><img src="8.png" alt=""></p>
<p><strong>StringTable 的位置（1.8）</strong></p>
<p>![](</p>
<p>9.png)</p>
<p>如何证明</p>
<ul>
<li>1.6 不断将字符串用 intern 加入 StringTable，最后撑爆的是永久代内存，为了让错误快速出现，将永久代内存设置的小一些：<code>-XX:MaxPermSize=10m</code>，最终会出现 <code>java.lang.OutOfMemoryError: PermGen space</code></li>
<li>1.8 不断将字符串用 intern 加入 StringTable，最后撑爆的是堆内存，为了让错误快速出现，将堆内存设置的小一些：<code>-Xmx10m -XX:-UseGCOverheadLimit</code> 后一个虚拟机参数是避免 GC 频繁引起其他错误而不是我们期望的 <code>java.lang.OutOfMemoryError: Java heap space</code></li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 StringTable 位置</span></span><br><span class="line"><span class="comment"> * 在jdk8下设置 -Xmx10m -XX:-UseGCOverheadLimit</span></span><br><span class="line"><span class="comment"> * 在jdk6下设置 -XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">260000</span>; j++) &#123;</span><br><span class="line">                list.add(String.valueOf(j).intern());</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-5-intern-去重原理"><a href="#2-5-intern-去重原理" class="headerlink" title="2.5 intern 去重原理"></a>2.5 intern 去重原理</h3><p>查阅一下 jdk 的源码</p>
<p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/5bd0e0bcb152/src/share/vm/classfile/symbolTable.cpp" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/5bd0e0bcb152/src/share/vm/classfile/symbolTable.cpp</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string_or_null 字符串对象</span></span><br><span class="line"><span class="comment">// name 字符串原始指针</span></span><br><span class="line"><span class="comment">// len 字符串长度</span></span><br><span class="line">oop StringTable::intern(Handle string_or_null, jchar* name,</span><br><span class="line">                        <span class="keyword">int</span> len, TRAPS) &#123;</span><br><span class="line">  <span class="comment">// 获取字符串的 hash 值</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hashValue = hash_string(name, len);</span><br><span class="line">  <span class="comment">// 算出 hash table 桶下标  </span></span><br><span class="line">  <span class="keyword">int</span> index = the_table()-&gt;hash_to_index(hashValue);</span><br><span class="line">  <span class="comment">// 看字符串在 hash table 中有没有 </span></span><br><span class="line">  oop found_string = the_table()-&gt;lookup(index, name, len, hashValue);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有，直接返回（避免重复加入）</span></span><br><span class="line">  <span class="keyword">if</span> (found_string != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保该字符串对象没有被垃圾回收  </span></span><br><span class="line">    ensure_string_alive(found_string);</span><br><span class="line">    <span class="keyword">return</span> found_string;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  debug_only(StableMemoryChecker smc(name, len * <span class="keyword">sizeof</span>(name[<span class="number">0</span>])));</span><br><span class="line">  assert(!Universe::heap()-&gt;is_in_reserved(name),</span><br><span class="line">         <span class="string">"proposed name of symbol must be stable"</span>);</span><br><span class="line"></span><br><span class="line">  Handle <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// try to reuse the string if possible</span></span><br><span class="line">  <span class="keyword">if</span> (!string_or_null.is_null()) &#123;</span><br><span class="line">    <span class="built_in">string</span> = string_or_null;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 根据 unicode 创建【字符串对象 string】 </span></span><br><span class="line">    <span class="built_in">string</span> = java_lang_String::create_from_unicode(name, len, CHECK_NULL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> INCLUDE_ALL_GCS</span></span><br><span class="line">  <span class="keyword">if</span> (G1StringDedup::is_enabled()) &#123;</span><br><span class="line">    <span class="comment">// Deduplicate the string before it is interned. Note that we should never</span></span><br><span class="line">    <span class="comment">// deduplicate a string after it has been interned. Doing so will counteract</span></span><br><span class="line">    <span class="comment">// compiler optimizations done on e.g. interned string literals.</span></span><br><span class="line">    G1StringDedup::deduplicate(<span class="built_in">string</span>());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Grab the StringTable_lock before getting the_table() because it could</span></span><br><span class="line">  <span class="comment">// change at safepoint.</span></span><br><span class="line">  oop added_or_found;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLocker <span class="title">ml</span><span class="params">(StringTable_lock, THREAD)</span></span>;</span><br><span class="line">    <span class="comment">// 将【字符串对象 string】加入 hash table</span></span><br><span class="line">    added_or_found = the_table()-&gt;basic_add(index, <span class="built_in">string</span>, name, len,</span><br><span class="line">                                  hashValue, CHECK_NULL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ensure_string_alive(added_or_found);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> added_or_found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中 lookup 的定义为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index 桶下标</span></span><br><span class="line"><span class="comment">// name 字符串原始指针</span></span><br><span class="line"><span class="comment">// len 字符串长度</span></span><br><span class="line"><span class="comment">// hash 哈希码</span></span><br><span class="line">oop StringTable::lookup(<span class="keyword">int</span> index, jchar* name,</span><br><span class="line">                        <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash) &#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (HashtableEntry&lt;oop, mtSymbol&gt;* l = bucket(index); l != <span class="literal">NULL</span>; l = l-&gt;next()) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (l-&gt;hash() == hash) &#123;</span><br><span class="line">      <span class="keyword">if</span> (java_lang_String::equals(l-&gt;literal(), name, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> l-&gt;literal();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果链表过长，需要 rehash</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt;= rehash_count &amp;&amp; !needs_rehashing()) &#123;</span><br><span class="line">    _needs_rehashing = check_rehash_table(count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中 basic_add 的定义为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index_arg 桶下标</span></span><br><span class="line"><span class="comment">// string 字符串对象</span></span><br><span class="line"><span class="comment">// name 字符串原始指针</span></span><br><span class="line"><span class="comment">// len 字符串长度</span></span><br><span class="line">oop StringTable::basic_add(<span class="keyword">int</span> index_arg, Handle <span class="built_in">string</span>, jchar* name,</span><br><span class="line">                           <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> hashValue_arg, TRAPS) &#123;</span><br><span class="line"></span><br><span class="line">  assert(java_lang_String::equals(<span class="built_in">string</span>(), name, len),</span><br><span class="line">         <span class="string">"string must be properly initialized"</span>);</span><br><span class="line">  <span class="comment">// Cannot hit a safepoint in this function because the "this" pointer can move.</span></span><br><span class="line">  No_Safepoint_Verifier nsv;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if the symbol table has been rehashed, if so, need to recalculate</span></span><br><span class="line">  <span class="comment">// the hash value and index before second lookup.</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hashValue;</span><br><span class="line">  <span class="keyword">int</span> index;</span><br><span class="line">  <span class="keyword">if</span> (use_alternate_hashcode()) &#123;</span><br><span class="line">    hashValue = hash_string(name, len);</span><br><span class="line">    index = hash_to_index(hashValue);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    hashValue = hashValue_arg;</span><br><span class="line">    index = index_arg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Since look-up was done lock-free, we need to check if another</span></span><br><span class="line">  <span class="comment">// thread beat us in the race to insert the symbol.</span></span><br><span class="line"></span><br><span class="line">  oop test = lookup(index, name, len, hashValue); <span class="comment">// calls lookup(u1*, int)</span></span><br><span class="line">  <span class="keyword">if</span> (test != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// Entry already added</span></span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 构造新的 HashtableEntry 节点</span></span><br><span class="line">  HashtableEntry&lt;oop, mtSymbol&gt;* entry = new_entry(hashValue, <span class="built_in">string</span>());</span><br><span class="line">  <span class="comment">// 加入链表  </span></span><br><span class="line">  add_entry(index, entry);</span><br><span class="line">  <span class="comment">// 返回字符串对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-6-G1-去重"><a href="#2-6-G1-去重" class="headerlink" title="2.6 G1 去重"></a>2.6 G1 去重</h3><p>懒惰是程序员的一大美德，不追求懒惰的程序员不是好程序员</p>
<p>如果你使用的 JDK 8u20，那么可以使用下面的 JVM 参数开启 G1 垃圾回收器，并开启字符串去重功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC -XX:+UseStringDeduplication</span><br></pre></td></tr></table></figure>

<p>原理是让多个字符串对象引用同一个 char[] 来达到节省内存的目的</p>
<p><img src="st09.png" alt=""></p>
<p>特点</p>
<ul>
<li>由 G1 垃圾回收器在 minor gc 阶段自动分析优化，不需要程序员自己干预</li>
<li>只有针对那些多次回收还不死的字符串对象，才会进行去重优化，可以通过 <code>-XX:StringDeduplicationAgeThreshold=n</code> 来调整</li>
<li>可以通过 <code>-XX:+PrintStringDeduplicationStatistics</code> 查看 G1 去重的统计信息</li>
<li>与调用 intern 去重相比，G1 去重好处在于自动，但缺点是即使 char[] 不重复，但字符串对象本身还要占用一定内存（对象头、value引用、hash），intern 去重是字符串对象只存一份，更省内存</li>
</ul>
<h3 id="2-7-家的大小"><a href="#2-7-家的大小" class="headerlink" title="2.7 家的大小"></a>2.7 家的大小</h3><p>StringTable 足够大，才能发挥性能优势，大意味着 String 在 hash 表中冲突减少，链表短，性能高。</p>
<p>可以通过 <code>-XX:+PrintStringTableStatistics</code> 来查看 StringTable 的大小，<strong>JDK 8 中它的默认大小为 60013</strong></p>
<p><strong>要注意 StringTable 底层的 hash 表在 JVM 启动后大小就固定不变了</strong></p>
<p>这个 hash 表可以在链表长度太长时进行 rehash，但不是利用扩容实现的 rehash，而是通过重新计算字符串的 hash 值来让它们分布均匀</p>
<p>如果想在启动前调整 StringTable 的大小，可以通过 <code>-XX:StringTableSize=n</code> 来指定</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示串池大小对性能的影响</span></span><br><span class="line"><span class="comment"> * -XX:+PrintStringTableStatistics -XX:StringTableSize=1009</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"linux.words"</span>), <span class="string">"utf-8"</span>))) &#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                line = reader.readLine();</span><br><span class="line">                <span class="keyword">if</span> (line == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                line.intern();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"cost:"</span> + (System.nanoTime() - start) / <span class="number">1000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-8-字符串之死"><a href="#2-8-字符串之死" class="headerlink" title="2.8 字符串之死"></a>2.8 字符串之死</h3><p>字符串也是一个对象，只要是对象，终究逃不过死亡的命运。字符串对象与其它 Java 对象一样，只要失去了利用价值，就会被垃圾回收，无论是野生字符串，还是家养字符串</p>
<p>怎么证明家养的字符串也能被垃圾回收呢，可以用以下 JVM 参数来查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 StringTable 垃圾回收</span></span><br><span class="line"><span class="comment"> * -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123; <span class="comment">// j=100, j=10000</span></span><br><span class="line">                String.valueOf(j).intern();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、面试题讲解"><a href="#三、面试题讲解" class="headerlink" title="三、面试题讲解"></a>三、面试题讲解</h2><p><strong>1. 判断输出</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"string"</span>; <span class="comment">// 家</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"string"</span>); <span class="comment">// 野生</span></span><br><span class="line">String str3 = str2.intern(); <span class="comment">// 家</span></span><br><span class="line"></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//#1  false</span></span><br><span class="line">System.out.println(str1==str3);<span class="comment">//#2  true</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 判断输出</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String baseStr = <span class="string">"baseStr"</span>;</span><br><span class="line"><span class="keyword">final</span> String baseFinalStr = <span class="string">"baseStr"</span>;</span><br><span class="line"></span><br><span class="line">String str1 = <span class="string">"baseStr01"</span>; <span class="comment">// 家</span></span><br><span class="line">String str2 = <span class="string">"baseStr"</span>+<span class="string">"01"</span>; <span class="comment">// 家</span></span><br><span class="line">String str3 = baseStr + <span class="string">"01"</span>; <span class="comment">// 野生</span></span><br><span class="line">String str4 = baseFinalStr+<span class="string">"01"</span>;<span class="comment">// 家</span></span><br><span class="line">String str5 = <span class="keyword">new</span> String(<span class="string">"baseStr01"</span>).intern(); <span class="comment">// 家</span></span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//#3 true</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//#4 false </span></span><br><span class="line">System.out.println(str1 == str4);<span class="comment">//#5 true</span></span><br><span class="line">System.out.println(str1 == str5);<span class="comment">//#6 true</span></span><br></pre></td></tr></table></figure>
<p><strong>3. 判断输出（注意版本）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"str"</span>)+<span class="keyword">new</span> String(<span class="string">"01"</span>);</span><br><span class="line">str2.intern(); <span class="comment">//1.6</span></span><br><span class="line">String str1 = <span class="string">"str01"</span>;</span><br><span class="line">System.out.println(str2==str1);<span class="comment">//#7 1.7 true, 1.6 false</span></span><br></pre></td></tr></table></figure>
<p><strong>4. 判断输出</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"str01"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"str"</span>)+<span class="keyword">new</span> String(<span class="string">"01"</span>);</span><br><span class="line">str2.intern();</span><br><span class="line">System.out.println(str2 == str1);<span class="comment">//#8 false</span></span><br></pre></td></tr></table></figure>
<p><strong>5. String s = new String(“xyz”)，创建了几个String Object?</strong></p>
<p><strong>6. 判断输出</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>7. 判断输出</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p><strong>8. 判断输出</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"a"</span>;</span><br><span class="line">String s3 = <span class="string">"bc"</span>;</span><br><span class="line">String s4 = s2 + s3;</span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p><strong>9. 判断输出</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">final</span> String s2 = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">final</span> String s3 = <span class="string">"bc"</span>;</span><br><span class="line">String s4 = s2 + s3;</span><br><span class="line">System.out.println(s1 == s4);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><strong>10. 判断输出</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">// 野生</span></span><br><span class="line">String s1 = <span class="string">"abc"</span>; <span class="comment">// 家</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">// 野生</span></span><br><span class="line">System.out.println(s == s1.intern()); <span class="comment">// false</span></span><br><span class="line">System.out.println(s == s2.intern()); <span class="comment">// false</span></span><br><span class="line">System.out.println(s1 == s2.intern()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div><div class="post-copyright"><blockquote><p>原文作者: 掘金木匠</p><p>原文链接: <a href="http://goldcarpenter.github.io/2019/11/01/String总结/">http://goldcarpenter.github.io/2019/11/01/String总结/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/JVM/">JVM</a><a href="/tags/String/">String</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/11/05/SpringMVC_Part1/" class="pre">SpringMVC</a><a href="/2019/09/22/Spring_AOP/" class="next">Spring FrameWork</a></div><div id="comments"><div id="SOHUCS" sid="2019/11/01/String总结/"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#String底层总结"><span class="toc-text">String底层总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-字符串创建方式"><span class="toc-text">1.字符串创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-char-数组创建"><span class="toc-text">1.1 char[] 数组创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-byte-数组创建"><span class="toc-text">1.2 byte[] 数组创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-int-数组创建"><span class="toc-text">1.3 int[] 数组创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-从已有字符串创建"><span class="toc-text">1.4 从已有字符串创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-字面量创建"><span class="toc-text">1.5 字面量创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1非对象"><span class="toc-text">1.5.1非对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2懒加载"><span class="toc-text">1.5.2懒加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3不重复"><span class="toc-text">1.5.3不重复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-拼接创建"><span class="toc-text">1.5 拼接创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-JDK-9-之后的改变"><span class="toc-text">1.6 JDK 9 之后的改变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-1内存结构改变"><span class="toc-text">1.6.1内存结构改变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-2拼接方式改变"><span class="toc-text">1.6.2拼接方式改变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-3默认拼接策略"><span class="toc-text">1.6.3默认拼接策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-4模仿-BC-SB-策略"><span class="toc-text">1.6.4模仿 BC_SB 策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-方法手动生成"><span class="toc-text">1. 方法手动生成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-字节码生成方法"><span class="toc-text">2. 字节码生成方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-字符串之家-StringTable"><span class="toc-text">2.字符串之家 - StringTable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-家养与野生"><span class="toc-text">2.1 家养与野生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-收留野生字符串"><span class="toc-text">2.2 收留野生字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1如果-StringTable-中已有"><span class="toc-text">2.2.1如果 StringTable 中已有</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2如果-StringTable-中没有（1-7-以上-JDK-的做法）"><span class="toc-text">2.2.2如果 StringTable 中没有（1.7 以上 JDK 的做法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3如果-StringTable-中没有（1-6-JDK-的做法）"><span class="toc-text">2.2.3如果 StringTable 中没有（1.6 JDK 的做法）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-去重的好处"><span class="toc-text">2.3 去重的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-家的位置"><span class="toc-text">2.4 家的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-intern-去重原理"><span class="toc-text">2.5 intern 去重原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-G1-去重"><span class="toc-text">2.6 G1 去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-家的大小"><span class="toc-text">2.7 家的大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-字符串之死"><span class="toc-text">2.8 字符串之死</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、面试题讲解"><span class="toc-text">三、面试题讲解</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/17/Redis_Part3/">Redis</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/04/Redis_Part2/">Redis</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/Nginx%E5%9F%BA%E7%A1%80/">Nginx</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/Redis_Part1/">Redis</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part3/">JDK8新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part2/">JDK8新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/25/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part1/">JDK8新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/02/javaIO/">JavaIO</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/21/ThreadLocal/">ThreadLocal总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/19/SpringMVC_Part3/">SpringMVC</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Debug%E8%AE%B0%E5%BD%95/">Debug记录</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E9%AB%98%E7%BA%A7/">Java高级</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL%E5%9F%BA%E7%A1%80/">MySQL基础</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E5%BC%80%E5%8F%91/">Web开发</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">博客搭建</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 15px;">注解</a> <a href="/tags/String/" style="font-size: 15px;">String</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 15px;">内部类</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/ThreadLocal/" style="font-size: 15px;">ThreadLocal</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 15px;">多线程</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/IEDA/" style="font-size: 15px;">IEDA</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/SpringMVC/" style="font-size: 15px;">SpringMVC</a> <a href="/tags/MyBatis/" style="font-size: 15px;">MyBatis</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">34</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.scu.edu.cn/" title="四川大学首页" target="_blank">四川大学首页</a><ul></ul><a href="http://www.scu.edu.cn/" title="个人项目——待完善" target="_blank">个人项目——待完善</a><ul></ul><a href="http://www.scu.edu.cn/" title="个人项目——待完善" target="_blank">个人项目——待完善</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">掘金木匠.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script><script>window._config = { showScore: true };
(function(){ 
  var appid = 'cyuBR2wWE'; 
  var conf = 'cbd82aee65d05c481319a299102b4811'; 
  var width = window.innerWidth || document.documentElement.clientWidth; 
  var nodes =document.getElementsByTagName("head")[0]||document.head||document.documentElement;
  if (/(Android|iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) && width < 750) {  
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
  }
  else { 
    var loadJs=function(d,a){
      var b=document.createElement("script");b.setAttribute("type","text/javascript");
      b.setAttribute("charset","UTF-8");
      b.setAttribute("src",d);
      if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}
      nodes.appendChild(b)
    };
    loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); 
  } 
  var loadCss = function(cssString){  
    var style=document.createElement("style");  
    style.setAttribute("type", "text/css");  
    if(style.styleSheet){// IE  
        style.styleSheet.cssText = cssString;  
    } else {// w3c  
        var cssText = document.createTextNode(cssString);  
        style.appendChild(cssText);  
    }
    nodes.appendChild(style);
  }
  //- window.onload=function(){
  //-   if(window.outerWidth<=775){
  //-     loadCss('.module-hot-topic,.module-cmt-float-bar{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .cbox-prompt-w span.prompt-empty-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w .form-text-w span.text-null,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w a.comment-link-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w span.comment-text-w,#SOHUCS #SOHU_MAIN .module-cmt-footer .section-service-w div.service-wrap-w a:hover,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w span.wrap-name-w,#SOHUCS #SOHU_MAIN .module-cmt-list .action-click-gw span.click-disable-eg a em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li div.title-name-gw,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number .comment-number span.cy-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number span.comment-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active,#SOHUCS #SOHU_MAIN .module-cmt-list .msg-wrap-gw .wrap-action-gw .action-click-gw span a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .picture-box-gw div.box-action-gw a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-action-gw .action-click-gw span a:hover em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-user-gw span.user-name-gw a{color:#40759b!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-r,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-l,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-r{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-l{background:#FFF!important;top:-2px!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-function-w .uploading-wrapper-dw div.wrapper-image-dw,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-main,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w div.form-text-w,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-list .module-cmt-box .post-wrap-w div.post-wrap-main{border:1px solid #e6e6e6!important;border-radius:20px 20px 20px 20px;margin:0!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw{width:130px!important;height:34px!important;line-height:33px!important;font-size:17px!important;background:#5483b1!important;border-radius:20px!important;color:#FFF!important;-webkit-box-shadow:0 -1px 4px #5483b1 inset;box-shadow:0 -1px 10px #5483b1 inset}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw:before{content:"发表评论"}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a:hover .btn-fw{color:#40759b!important;background:#FFF!important}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li{background:none!important;border-bottom:1px solid #e6e6e6}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active{border:1px solid #e6e6e6;border-radius:10px 10px 0 0;border-bottom:none}#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li .title-name-gw div.title-name-gw-tag{background:#5483b1!important;border-radius:3px}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type div.cmt-list-border{background-color:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item{border:1px solid #e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo{text-align:center;line-height:40px;border-radius:50%!important;background:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo:before{content:"畅";font-size:22px;color:#FFF}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text,#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text i{color:#5483b1!important}#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w{background:#FFF!important}@media screen and (min-width:900px){#SOHUCS #SOHU_MAIN .module-mobile-cmt-list .list-wrapper-wap .list-container-wap .list-item-wap .list-content-wrapper-wap .cmt-list-image-container .cmt-list-image{max-width: 100%;}}');
  //-   }
  //- };
})();
function removeElement(_element){
     var _parentElement = _element.parentNode;
     if(_parentElement){
            _parentElement.removeChild(_element);
     }
}
var removeAD = document.createElement("div");
removeAD.id = 'removeAD';
var adInterval1 = setInterval(function() {
  if(document.querySelector("#feedAv")){
    document.querySelector("[node-type=cmt-list]").appendChild(removeAD);
    document.querySelector("#removeAD").appendChild(document.querySelector("#feedAv"));
    //- removeElement(document.querySelectorAll("#feedAv")[0]);
    var feedAv = document.querySelector("#feedAv").children;
    for( item of feedAv){
      item.style.display = 'none'
    }
    document.querySelector("#removeAD").style.display="none"
    clearInterval(adInterval1);
  }
},1000);
var adInterval2 = setInterval(function() {
  if(document.querySelector("#pop_ad")){
    removeElement(document.querySelector("#pop_ad"));
    clearInterval(adInterval2);
  }
}, 1000);</script><script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script></body></html>