<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="JJMJ's blog."><meta name="keywords" content="Java, Spring, MyBatis, 后端"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>ThreadLocal总结 | 掘金木匠</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ThreadLocal总结</h1><a id="logo" href="/.">掘金木匠</a><p class="description">懂金融的软件工程师一定是一个合格的吃货</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">ThreadLocal总结</h1><div class="post-meta"><a href="/2019/12/21/ThreadLocal/#comments" class="comment-count"><i id="changyan_count_unit" data-xid="2019/12/21/ThreadLocal/"></i>留言,<i id="changyan_parti_unit" data-xid="2019/12/21/ThreadLocal/"></i>参与</a><p><span class="date">Dec 21, 2019</span><span><a href="/categories/Java%E5%9F%BA%E7%A1%80/" class="category">Java基础</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><ul>
<li><code>ThreadLocal</code>可以为当前线程关联一个数据【普通变量，对象，数组，集合】</li>
<li>可以像 Map一样存取数据，key 为当前线程，<strong>保证各个线程的变量相对独立于其他线程内的变量，解决多线程的数据安全问题</strong>。</li>
<li>每一个<code>ThreadLocal</code>对象，只能为当前线程关联一个数据，如果要为当前线程关联多个数据，就需要使用多个<code>ThreadLocal</code>对象</li>
<li>每个<code>ThreadLocal</code>对象实例定义的时候，<strong>一般都是static类型</strong></li>
<li><code>ThreadLocal</code>中保存数据，在线程销毁后。会由JVM虚拟自动释放</li>
</ul>
<h2 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2.常用方法"></a>2.常用方法</h2><table>
<thead>
<tr>
<th align="center">方法声明</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ThreadLocal()</td>
<td align="center">创建ThreadLocal对象</td>
</tr>
<tr>
<td align="center">public T get()</td>
<td align="center">设置当前线程绑定的局部变量</td>
</tr>
<tr>
<td align="center">public void set(T value)</td>
<td align="center">获取当前线程绑定的局部变量</td>
</tr>
<tr>
<td align="center">public void remove()</td>
<td align="center">移除当前线程绑定的局部变量</td>
</tr>
</tbody></table>
<h2 id="3-案例"><a href="#3-案例" class="headerlink" title="3.案例"></a>3.案例</h2><ul>
<li>线程隔离，在多线程并发的场景下，每个线程中的变量都是相互独立<br>线程1——设置(变量1)——获取(变量1)<br>线程2——设置(变量2)——获取(变量2)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;       </span><br><span class="line">    String content;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main main = <span class="keyword">new</span> Main();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                main.setContent(Thread.currentThread().getName() + <span class="string">"的数据"</span>);</span><br><span class="line">                System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"---&gt;"</span> + main.getContent());</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">"线程"</span>+i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--------------------</span><br><span class="line">线程2---&gt;线程2的数据</span><br><span class="line">--------------------</span><br><span class="line">线程3---&gt;线程3的数据</span><br><span class="line">--------------------</span><br><span class="line">线程0---&gt;线程4的数据</span><br><span class="line">--------------------</span><br><span class="line">线程4---&gt;线程1的数据</span><br><span class="line">--------------------</span><br><span class="line">线程1---&gt;线程1的数据</span><br></pre></td></tr></table></figure>

<ul>
<li><p>尝试使用Synchronized解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main main = <span class="keyword">new</span> Main();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Load10<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    main.setContent(Thread.currentThread().getName() + <span class="string">"的数据"</span>);</span><br><span class="line">                	System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">                	System.out.println(Thread.currentThread().getName() + <span class="string">"---&gt;"</span> + main.getContent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">"线程"</span>+i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>从结果可以发现，加锁确实可以解决这个问题，但是在<strong>这里我们强调的是线程数据隔离的问题</strong>，并<strong>不是多线程共享数据的问题</strong>，在这个案例中使用synchronized关键字是不合适的。</li>
</ul>
</blockquote>
</li>
<li><p>ThreadLocal与synchronized的区别</p>
<ul>
<li><p>虽然ThreadLocal模式与synchronized关键字都用于处理多线程并发访问变量的问题,不过两者处理问题的角度和思路不同。</p>
<table>
<thead>
<tr>
<th></th>
<th align="center">synchronized</th>
<th align="center">ThreadLocal</th>
</tr>
</thead>
<tbody><tr>
<td>原理</td>
<td align="center">同步机制采用以时间换空间的方式，只提供了一份变量，让不同的线程排队访问</td>
<td align="center">ThreadLocal采用以空间换时间的方式，为<strong>每一个线程原都提供了一份变量的副本</strong>，从而实现同时访问而相不干扰</td>
</tr>
<tr>
<td>侧重点</td>
<td align="center">多个线程之间<strong>访问资源同步</strong></td>
<td align="center">多线程中让每个线程之间的<strong>数据相互隔离</strong></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>ThreadLocal</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String content = threadLocal.get();</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.threadLocal.set(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="4-ThreadLocal方案的好处"><a href="#4-ThreadLocal方案的好处" class="headerlink" title="4.ThreadLocal方案的好处"></a>4.ThreadLocal方案的好处</h2><ul>
<li>线程隔离：各线程之间的数据相互隔离却又具备并发性，<strong>避免同步方式带来的性能损失</strong>【案例1】</li>
<li>传递数据：保存每个线程绑定的数据，在需要的地方可以直接获取，<strong>避免参数直接传递带来的代码耦合问题</strong>【Service层和Dao层传递Connection对象】</li>
</ul>
<h2 id="4-内部结构"><a href="#4-内部结构" class="headerlink" title="4.内部结构"></a>4.内部结构</h2><ul>
<li><p>早期</p>
<ul>
<li>每个ThreadLocal都创建一个Map，然后用线程作为Map的key，要存储的局部变量作为Map的value ，这样就能达到各个线程的局部变量隔离的效果。</li>
</ul>
<p><img src="ThreadLocal_img/1589278568621.png" alt="1589278568621"></p>
</li>
<li><p>JDK8</p>
<ul>
<li><p>每个Thread维护一个ThreadLocalMap，这个Map的key是ThreadLocal实例本身，value 才是真正要存储的值Object。</p>
</li>
<li><p>具体的过程是这样的:</p>
<ul>
<li>每个Thread线程内部都有一个Map【ThreadLocalMap】</li>
<li>Map【ThreadLocalMap】<code>key</code>存储<strong>ThreadLocal对象</strong>和 <code>value</code>存储<strong>线程的变量副本</strong></li>
<li>Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。</li>
<li>对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，<br>互不干扰。</li>
</ul>
<p><img src="ThreadLocal_img/1589278729316.png" alt="1589278729316"></p>
</li>
</ul>
</li>
<li><p>JDK8 VS 早期的优点</p>
<ul>
<li>每个Map存储的Entry数量变少</li>
<li>当Thread销毁的时候, ThreadLocalMap也会随之销毁,减少内存的使用</li>
</ul>
</li>
</ul>
<h2 id="5-ThreadLocal源码分析"><a href="#5-ThreadLocal源码分析" class="headerlink" title="5.ThreadLocal源码分析"></a>5.ThreadLocal源码分析</h2><h3 id="5-1-set方法"><a href="#5-1-set方法" class="headerlink" title="5.1.set方法"></a>5.1.set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 设置当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value 将要保存在当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">pub1ic <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程对象</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">//判断map是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (map != nu11)&#123;</span><br><span class="line">            <span class="comment">//存在则调用map.set设置此实体entry</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 1)当前线程Thread不存在ThreadLocalMap对象</span></span><br><span class="line">            <span class="comment">// 2)则调用createMap进行ThreaduocalMap对象的初始化</span></span><br><span class="line">            <span class="comment">// 3)并将t(当前线程)和value(t对应的值)作为第一 个entry存放至ThreadLocalMap中</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *	获取当前线程Thr ead对应维护的ThreadLocalMap</span></span><br><span class="line"><span class="comment">  *	<span class="doctag">@param</span> t the current thread 当前线程</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the map 对应维护的ThreadLocalMap</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadlocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建当前线程Thread对应维护的ThreadLocalMap</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> t 当前线程</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> firstValue存放到map中第一个entry的值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t,T firstValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里的this 是调用此方法的threadLocal</span></span><br><span class="line">        t.threadlocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码执行流程<ul>
<li>首先获取当前线程,并根据当前线程获取一个Map</li>
<li>如果获取的Map不为空,则将参数设置到Map中(当前ThreadLocal的引用作为key )</li>
<li>如果Map为空,则给该线程创建Map，并设置初始值</li>
</ul>
</li>
</ul>
<h3 id="5-2-get方法"><a href="#5-2-get方法" class="headerlink" title="5.2.get方法"></a>5.2.get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程中保存ThreadLocal的值</span></span><br><span class="line"><span class="comment"> * 如果当前线程没有此ThreadLocal变量</span></span><br><span class="line"><span class="comment"> * 则它会通过调用&#123;<span class="doctag">@link</span> #initialvalue&#125; 方法进行初始化值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回当前线程对应此ThreadLocal的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程对象</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t) ;</span><br><span class="line">        <span class="comment">//如果此map存在</span></span><br><span class="line">        <span class="keyword">if</span> (map != nu11) &#123;</span><br><span class="line">        <span class="comment">//以当前的ThreadLocal为key,调用getEntry获取对应的存储实体e</span></span><br><span class="line">        	ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//对e进行判空</span></span><br><span class="line">            <span class="keyword">if</span> (e != nu11) &#123;</span><br><span class="line">            	<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                <span class="comment">//获取存储实体e对应的value值</span></span><br><span class="line">                <span class="comment">//即为我们想要的当前线程对应此ThreadLocal的值</span></span><br><span class="line">            	T result = (T)e.value;</span><br><span class="line">            	<span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            初始化:有两种情况有执行当前代码</span></span><br><span class="line"><span class="comment">            第一种情况: map不存在，表示此线程没有维护的ThreadLocalMap对象</span></span><br><span class="line"><span class="comment">            第二种情况: map存在， 但是没有与当前ThreadLocal关联的entry</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">return</span> setInitialvalue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value初始化后的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用initialvalue获取初始化的值</span></span><br><span class="line">        <span class="comment">//此方法可以被子类重写，如果不重写默认返回null</span></span><br><span class="line">        T value = initialValue();</span><br><span class="line">        <span class="comment">//获取当前线程对象</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">//判断map是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (map != nu11)&#123;</span><br><span class="line">            <span class="comment">//存在则调用map.set设置此实体entry</span></span><br><span class="line">            map.set(<span class="keyword">this</span>,value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 1)当前线程Thread 不存在ThreadL oca 1Map对象</span></span><br><span class="line">        <span class="comment">// 2)则调用cr eat eMap进行ThreadLoca 1Map对象的初始化</span></span><br><span class="line">        <span class="comment">// 3)并将t(当前线程)和value(t对应的值)作为第一个entry存放至Thr eadL ocalMap中</span></span><br><span class="line">        	createMap(t,value);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//返回设置的值value</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码执行流程<ol>
<li>首先获取当前线程，根据当前线程获取一个Map</li>
<li>如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的<code>Entry e</code>，否则转到4</li>
<li>如果e不为null，则返回<code>e.value</code>，否则转到4</li>
<li><code>Map</code>为空或者<code>e</code>为空,则通过<code>initialValue</code>函数获取初始值<code>value</code> ,然后用<code>Threadlocal</code>的引用和<code>value</code>作为<code>firstKey</code>和<code>firstValue</code>创建一个新的<code>Map</code></li>
</ol>
</li>
<li>总结：先获取当前线程的ThreadLocalMap变量，如果存在则返回值，不存在则创建并返回初始值。</li>
</ul>
<h3 id="5-3-remove方法"><a href="#5-3-remove方法" class="headerlink" title="5.3.remove方法"></a>5.3.remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除当前线程中保存的Thr eadLoca 1对应的实体entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">        <span class="comment">//如果此map存在</span></span><br><span class="line">        <span class="keyword">if</span> (m != nu11)&#123;</span><br><span class="line">            <span class="comment">//存在则调用map.remove</span></span><br><span class="line">            <span class="comment">//以当前ThreadLocal为key删除对应的实体entry</span></span><br><span class="line">            m.remove(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码执行流程<ul>
<li>首先获取当前线程，并根据当前线程获取一个Map</li>
<li>如果获取的Map不为空，则移除当前ThreadLocal对象对应的entry</li>
</ul>
</li>
</ul>
<h3 id="5-4-initialValue方法"><a href="#5-4-initialValue方法" class="headerlink" title="5.4.initialValue方法"></a>5.4.initialValue方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方返回当前线程对应的Threadlocal的初始值</span></span><br><span class="line"><span class="comment"> * 此方法的第一次调用发生在，当线程通过get方法访问此线程的ThreadLocal值时</span></span><br><span class="line"><span class="comment"> * 除非线程先调用了set方法，在这种情况下，initialvalue才不会被这个线程调用。</span></span><br><span class="line"><span class="comment"> * 通常情况下，每个线程最多调用一次这个方法。</span></span><br><span class="line"><span class="comment"> * 这个方法仅仅简单的返回null &#123;<span class="doctag">@code</span> nu11&#125;;</span></span><br><span class="line"><span class="comment"> * 如果程序员想ThreadLoca1线程局部变量有一个除null以外的初始值，</span></span><br><span class="line"><span class="comment"> * 必须通过子类继承&#123;<span class="doctag">@code</span> ThreadLocal&#125; 的方式去重写此方法</span></span><br><span class="line"><span class="comment"> * 通常，可以通过匿名内部类的方式实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前ThreadLocal的初始值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> nu11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>此方法的作用是返回该线程局部变量的初始值。<ul>
<li>这个方法是一个延迟调用方法，从上面的代码我们得知，在set方法还未调用而先调用了get方法时才执行，并且仅执行一次</li>
<li>这个方法缺省实现直接返回<code>null</code></li>
<li>如果想要一个除<code>null</code>之外的初始值,可以重写此方法。( 备注:该访法是一个protected的方法，显然是<br>为了让子类覆盖而设计的)</li>
</ul>
</li>
</ul>
<h2 id="6-ThreadLocalMap源码分析"><a href="#6-ThreadLocalMap源码分析" class="headerlink" title="6.ThreadLocalMap源码分析"></a>6.ThreadLocalMap源码分析</h2><ul>
<li>分析ThreadLocal方法了解到ThreadLocal的操作实际上是围绕ThreadLocalMap展开的。</li>
<li>ThreadLocalMap的源码相对比较复杂，以下三个方面进行讨论。</li>
</ul>
<h3 id="6-1基本结构"><a href="#6-1基本结构" class="headerlink" title="6.1基本结构"></a>6.1基本结构</h3><ul>
<li><p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的<strong>内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也是独立实现。</strong></p>
<p><img src="ThreadLocal_img/1589289298701.png" alt="1589289298701"></p>
</li>
<li><p>成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	初始容量--必须是2的整次幂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> InItIAl_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  存放数据的table，Entry类的定义在下面分析</span></span><br><span class="line"><span class="comment"> *  同样，数组长度必须是2的整次幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组里面entrys的个数，可以用于判断table当前使用量是否超过阈值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 进行扩容的阈值，表使用量大于它的时候进行扩容。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>跟HashMap类似，<code>INITIAL_CAPACITY</code>代表这个Map的初始容量，table是一个<code>Entry</code>类型的数组，用于存储数据，size代表表中的存储数目， threshold代表需要扩容时对应size的阈值。</li>
</ul>
</li>
<li><p>存储结构Entry</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Entry继承WeakReference，并且用ThreadLocal作为key</span></span><br><span class="line"><span class="comment"> * 如果key为null(entry.get() == nu11) 意味着key不再被引用</span></span><br><span class="line"><span class="comment"> * 因此这时候entry也可以从tab1e中清除。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this Threadocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。不过Entry中的key只能是ThreadLocal对象 ,这点在构造方法中已经限定死了。</li>
<li>另外, Entry继承WeakReference，也就是key ( ThreadLocal )是弱引用，其目的是将ThreadLocal对象的生命周期和线程生命周期解绑。</li>
</ul>
</li>
</ul>
<h3 id="6-2弱引用和内存泄漏"><a href="#6-2弱引用和内存泄漏" class="headerlink" title="6.2弱引用和内存泄漏"></a>6.2弱引用和内存泄漏</h3><ul>
<li><p>内存泄漏相关概念</p>
<ul>
<li>Memory overflow：内存溢出,没有足够的内存提供申请者使用</li>
<li>Memory leak：内存泄漏是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。内存泄漏的堆积终将导致内存溢出。</li>
</ul>
</li>
<li><p>弱引用相关概念</p>
<ul>
<li>Java中的引用有4种类型：强、软、弱、虚。</li>
<li>强引用：最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾回收器就不会回收这种对象。</li>
<li>弱引用：垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</li>
</ul>
</li>
<li><p><strong>在使用ThreadLocal的过程中有内存泄漏的情况发生</strong></p>
</li>
</ul>
<h4 id="6-2-1与否与ThreadLocalMap中的key使用弱引用有关"><a href="#6-2-1与否与ThreadLocalMap中的key使用弱引用有关" class="headerlink" title="6.2.1与否与ThreadLocalMap中的key使用弱引用有关"></a>6.2.1与否与ThreadLocalMap中的key使用弱引用有关</h4><p><img src="ThreadLocal_img/1589292275492.png" alt="1589292275492"></p>
<ul>
<li>假设在业务代码中使用完<code>ThreadLocal</code> ，<code>threadLocalRef</code>被回收了</li>
<li>由于<code>ThreadLocalMap</code>只持有<code>ThreadLocal</code>的弱引用，没有任何强引用指向<code>threadlocal</code>实例,所以<code>threadlocal</code>就可以顺利被GC回收，此时<code>Entry</code>中的<code>key=null</code></li>
<li>【在没有手动删除这个<code>Entry</code>以及<code>CurrentThread</code>依然运行的前提下】，存在有强引用链<code>threadRef-&gt; currentThread-&gt; threadLocalMap-&gt;entry-&gt;value</code>，<code>value</code>不会被回收，而这块<code>value</code>永远不会被访问到了，导致<code>value</code>内存泄漏</li>
<li><strong>ThreadLocalMap中的key使用了弱引用，有可能内存泄漏。</strong></li>
</ul>
<h4 id="6-2-2假设ThreadLocalMap中的key使用强引用"><a href="#6-2-2假设ThreadLocalMap中的key使用强引用" class="headerlink" title="6.2.2假设ThreadLocalMap中的key使用强引用"></a>6.2.2假设ThreadLocalMap中的key使用强引用</h4><ul>
<li><p>假设<code>ThreadLocalMap</code>中的<code>key</code>使用了强引用，那么会出现内存泄漏吗?</p>
</li>
<li><p>此时<code>ThreadLocal</code>的内存图如下:</p>
<p><img src="ThreadLocal_img/1589291319111.png" alt="1589291319111"></p>
<ul>
<li>在业务代码中使用完<code>ThreadLocal</code>，<code>threadLocalRef</code>被回收了</li>
<li>因为<code>threadLocalMap</code>的<code>Entry</code>强引用了<code>threadLocal</code>，造成<code>threadLocal</code>无法被回收</li>
<li>【在没有手动删除这个<code>Entry</code>以及<code>CurrentThread</code>依然运行的前提下】，始终有强引用链<code>threadRef-&gt; currentThread-&gt; threadLocalMap-&gt; entry</code>，<code>Entry</code>就不会被回收（包括了<code>ThreadLocal</code>实例和<code>value</code>)，导致Entry内存泄漏</li>
<li><strong>ThreadLocalMap中的key使用了强引用，是无法完全避免内存泄漏的。</strong></li>
</ul>
</li>
</ul>
<h4 id="6-2-3为什么使用弱引用"><a href="#6-2-3为什么使用弱引用" class="headerlink" title="6.2.3为什么使用弱引用"></a>6.2.3为什么使用弱引用</h4><ul>
<li><strong>在<code>ThreadLocalMap</code>中的<code>set/getEntry</code>方法中，会对<code>key</code>为<code>null</code> (也即是<code>ThreadLocal</code>为<code>null</code> )进行判</strong><br><strong>断，如果为<code>null</code>的话，那么是会对<code>value</code>置为<code>null</code>的</strong></li>
<li>意味着使用完<code>ThreadLocal</code> ，<code>CurrentThread</code>依然运行的前提下，就算忘记调用<code>remove</code>方法，<strong>弱引比</strong><br><strong>强引用可以多一层保障</strong>，弱引用的ThreadLocal会被回收，<strong>对应的value在下一次<code>ThreadLocalMap</code>调用<code>set get remove</code>中的任一方法的时候会被清除，从而避免内存泄漏。</strong></li>
</ul>
<h4 id="6-2-4出现内存泄漏的真实原因"><a href="#6-2-4出现内存泄漏的真实原因" class="headerlink" title="6.2.4出现内存泄漏的真实原因"></a>6.2.4出现内存泄漏的真实原因</h4><ul>
<li><strong>内存泄漏的发生跟<code>ThreadLocalMap</code>中的<code>key</code>使用哪种类型引用是没有关系的</strong></li>
<li>在以上两种内存泄漏的情况中，都有两个前提:<ul>
<li>没有手动删除这个<code>Entry</code><ul>
<li><strong>只要在使用完<code>ThreadLocal</code>，调用其<code>remove</code>方法删除对应的<code>Entry</code>，就能避免内存泄漏</strong></li>
</ul>
</li>
<li><code>CurrentThread</code>依然运行<ul>
<li><code>ThreadLocalMap</code>是<code>Thread</code>的一个属性，被当前线程所引用，所以它的生命周期跟<code>Thread</code>样长。</li>
<li><strong>那么在使用完<code>ThreadLocal</code>的使用，如果当前<code>Thread</code>也随之执行结束，</strong><code>ThreadLocalMap</code>自然也会被GC回收，<strong>从根源上避免了内存泄漏。</strong>【不好控制，使用线程池的时候，线程结束是不会销毁的】</li>
</ul>
</li>
</ul>
</li>
<li>综上，<code>ThreadLocal</code>内存泄漏的根源是：ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏。</li>
</ul>
<h3 id="6-3-hash冲突的解决"><a href="#6-3-hash冲突的解决" class="headerlink" title="6.3 hash冲突的解决"></a>6.3 hash冲突的解决</h3><ul>
<li><p>hash冲突的解决是Map中的一个重要内容。我们以hash冲突的解决为线索,来研究一下ThreadLocalMap的<br>核心源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 设置当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value 将要保存在当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">pub1ic <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != nu11)&#123;</span><br><span class="line">            <span class="comment">//threadLocalMap的set方法</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            createMap(t, value);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadlocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t,T firstValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//threadLocalMap构造方法</span></span><br><span class="line">        t.threadlocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="6-3-1构造方法"><a href="#6-3-1构造方法" class="headerlink" title="6.3.1构造方法"></a>6.3.1构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * firstKey : 本ThreadLocal实例(this)</span></span><br><span class="line"><span class="comment"> * firstValue :要保存的线程本地变量</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line">	ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        <span class="comment">//初始化table</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="comment">//计算索引(重点代码)</span></span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//设置值</span></span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//设置阈值</span></span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的索引，然后存储到table中，并设置size和threshold</p>
</li>
<li><p>重点分析: <code>int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</code></p>
<ul>
<li><p><code>firstKey.threadLocalHashCode</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//AtomicInteger是一个提供原子操作的Integer类，通过线程安全的方式操作加减, 适合高并发情况下的使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">   <span class="comment">//特殊的hash值    </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br></pre></td></tr></table></figure>

<p>这里定义了一个AtomicInteger类型，每次获取当前值并加上HASH_INCREMENT，这个值跟斐波那契数列(黄金分割数)有关，其主要目的就是为了让哈希码能均匀的分布在2的n次方的数组里,也就是Entry[] table中，这样做可以尽星避免hash冲突。</p>
</li>
<li><p><code>(INITIAL_CAPACITY - 1)</code></p>
<ul>
<li>计算hash的时候里面采用了<code>hashCode &amp; (size - 1)</code>的算法，这相当于取模运算<code>hashCode % size</code>的一个更高效的实现。正是因为这种算法，我们要求size必须是2的整次幂，这也能保证在索引不越界的前提下,使得hash发生冲突的次数减小。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-3-2set方法"><a href="#6-3-2set方法" class="headerlink" title="6.3.2set方法"></a>6.3.2set方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">     Entry[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line">     <span class="comment">//计算索引(重点代码，刚才分析过了)</span></span><br><span class="line">     <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">     <span class="comment">//使用线性探测法查找元素(重点代码)</span></span><br><span class="line">     <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">          e != <span class="keyword">null</span>;</span><br><span class="line">          e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">         ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">		</span><br><span class="line">         <span class="comment">//Threadlocal对应的key存在，直接覆盖之前的值</span></span><br><span class="line">         <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">             e.value = value;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">// key为null 但是值不为null 说明之前的ThreadLocal对象已经被回收了，</span></span><br><span class="line">        <span class="comment">// 当前数组中的Entry是一个陈旧(stale)的元素</span></span><br><span class="line">         <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">             replaceStaleEntry(key, value, i);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">	 <span class="comment">//Threadlocal对应的key不存在并且没有找到陈旧的元素，则在空元素的位置创建一个新的Entry</span></span><br><span class="line">     tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">     <span class="keyword">int</span> sz = ++size;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * cleanSomeSlots用于清除那些e.get()==null的元素，</span></span><br><span class="line"><span class="comment">       * 这种数据key关联的对象已经被回收，所以这个Entry(table[index])可以被置null</span></span><br><span class="line"><span class="comment">       * 如果没有清除任何entry ,并且当前使用量达到了负载因子所定义(长度的2/3)。那么进行rehash(执行一次全表的扫描清理工作)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">     <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">         rehash();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *获取环形数组的下一个索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span>&lt; len)?i+<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>代码执行流程</p>
<ul>
<li>首先还是根据key计算出索引i，然后查找i位置上的Entry</li>
<li>若是Entry已经存在并且key等于传入的key，那么这时候直接给这个Entry赋新的value值</li>
<li>若是Entry存在，但是key为null，则调用<code>replaceStaleEntry</code>来更换这个key为空的Entry</li>
<li>不断循环检测，直到遇到为null的地方，这时候要是还没在循环过程中return，则在空元素的位置创建一个新的Entry，并且插入同时size增加1。</li>
<li>最后调用cleanSomeSlots，清理key为null的Entry，最后返回是否清理了Entry，接下来再判断sz是否&gt;=<br>threshold达到了rehash的条件，达到的话就会调用rehash函数执行一次全表的扫描清理。</li>
</ul>
</li>
<li><p>重点分析: <strong>ThreadLocalMap使用线性探测法来解决哈希冲突的</strong></p>
<ul>
<li>该方法一次探测下一个地址，直到有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。</li>
<li>举个例子<ul>
<li>假设当前table长度为16 ,也就是说如果计算出来key的hash值为14，如果table[14]上已经有值，并且其key与当前key不一致，那么就发生了hash冲突，这个时候将14加1得到15 ,取table[15]进行判断，这个时候如果还是冲突会回到0，取table[0]，以此类推,直到可以插入。</li>
<li>可以把Entry[] table看成一个环形数组</li>
</ul>
</li>
</ul>
</li>
</ul>
</div><div class="post-copyright"><blockquote><p>原文作者: 掘金木匠</p><p>原文链接: <a href="http://goldcarpenter.github.io/2019/12/21/ThreadLocal/">http://goldcarpenter.github.io/2019/12/21/ThreadLocal/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/ThreadLocal/">ThreadLocal</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/02/02/javaIO/" class="pre">JavaIO</a><a href="/2019/11/19/SpringMVC_Part3/" class="next">SpringMVC</a></div><div id="comments"><div id="SOHUCS" sid="2019/12/21/ThreadLocal/"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ThreadLocal"><span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-简介"><span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-常用方法"><span class="toc-text">2.常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-案例"><span class="toc-text">3.案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-ThreadLocal方案的好处"><span class="toc-text">4.ThreadLocal方案的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-内部结构"><span class="toc-text">4.内部结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-ThreadLocal源码分析"><span class="toc-text">5.ThreadLocal源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-set方法"><span class="toc-text">5.1.set方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-get方法"><span class="toc-text">5.2.get方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-remove方法"><span class="toc-text">5.3.remove方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-initialValue方法"><span class="toc-text">5.4.initialValue方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-ThreadLocalMap源码分析"><span class="toc-text">6.ThreadLocalMap源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1基本结构"><span class="toc-text">6.1基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2弱引用和内存泄漏"><span class="toc-text">6.2弱引用和内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1与否与ThreadLocalMap中的key使用弱引用有关"><span class="toc-text">6.2.1与否与ThreadLocalMap中的key使用弱引用有关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2假设ThreadLocalMap中的key使用强引用"><span class="toc-text">6.2.2假设ThreadLocalMap中的key使用强引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3为什么使用弱引用"><span class="toc-text">6.2.3为什么使用弱引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-4出现内存泄漏的真实原因"><span class="toc-text">6.2.4出现内存泄漏的真实原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-hash冲突的解决"><span class="toc-text">6.3 hash冲突的解决</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1构造方法"><span class="toc-text">6.3.1构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2set方法"><span class="toc-text">6.3.2set方法</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/17/Redis_Part3/">Redis</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/04/Redis_Part2/">Redis</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/Nginx%E5%9F%BA%E7%A1%80/">Nginx</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/Redis_Part1/">Redis</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part3/">JDK8新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part2/">JDK8新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/25/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part1/">JDK8新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/02/javaIO/">JavaIO</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/21/ThreadLocal/">ThreadLocal总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/19/SpringMVC_Part3/">SpringMVC</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Debug%E8%AE%B0%E5%BD%95/">Debug记录</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E9%AB%98%E7%BA%A7/">Java高级</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL%E5%9F%BA%E7%A1%80/">MySQL基础</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E5%BC%80%E5%8F%91/">Web开发</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">博客搭建</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/IEDA/" style="font-size: 15px;">IEDA</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/MyBatis/" style="font-size: 15px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/SpringMVC/" style="font-size: 15px;">SpringMVC</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/String/" style="font-size: 15px;">String</a> <a href="/tags/ThreadLocal/" style="font-size: 15px;">ThreadLocal</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 15px;">内部类</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 15px;">多线程</a> <a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 15px;">注解</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">34</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.scu.edu.cn/" title="四川大学首页" target="_blank">四川大学首页</a><ul></ul><a href="http://www.scu.edu.cn/" title="风雨云知道——待部署" target="_blank">风雨云知道——待部署</a><ul></ul><a href="http://www.scu.edu.cn/" title="在线聊天室——待部署" target="_blank">在线聊天室——待部署</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">掘金木匠.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script><script>window._config = { showScore: true };
(function(){ 
  var appid = 'cyuBR2wWE'; 
  var conf = 'cbd82aee65d05c481319a299102b4811'; 
  var width = window.innerWidth || document.documentElement.clientWidth; 
  var nodes =document.getElementsByTagName("head")[0]||document.head||document.documentElement;
  if (/(Android|iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) && width < 750) {  
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
  }
  else { 
    var loadJs=function(d,a){
      var b=document.createElement("script");b.setAttribute("type","text/javascript");
      b.setAttribute("charset","UTF-8");
      b.setAttribute("src",d);
      if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}
      nodes.appendChild(b)
    };
    loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); 
  } 
  var loadCss = function(cssString){  
    var style=document.createElement("style");  
    style.setAttribute("type", "text/css");  
    if(style.styleSheet){// IE  
        style.styleSheet.cssText = cssString;  
    } else {// w3c  
        var cssText = document.createTextNode(cssString);  
        style.appendChild(cssText);  
    }
    nodes.appendChild(style);
  }
  //- window.onload=function(){
  //-   if(window.outerWidth<=775){
  //-     loadCss('.module-hot-topic,.module-cmt-float-bar{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .cbox-prompt-w span.prompt-empty-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w .form-text-w span.text-null,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w a.comment-link-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w span.comment-text-w,#SOHUCS #SOHU_MAIN .module-cmt-footer .section-service-w div.service-wrap-w a:hover,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w span.wrap-name-w,#SOHUCS #SOHU_MAIN .module-cmt-list .action-click-gw span.click-disable-eg a em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li div.title-name-gw,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number .comment-number span.cy-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number span.comment-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active,#SOHUCS #SOHU_MAIN .module-cmt-list .msg-wrap-gw .wrap-action-gw .action-click-gw span a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .picture-box-gw div.box-action-gw a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-action-gw .action-click-gw span a:hover em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-user-gw span.user-name-gw a{color:#40759b!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-r,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-l,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-r{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-l{background:#FFF!important;top:-2px!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-function-w .uploading-wrapper-dw div.wrapper-image-dw,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-main,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w div.form-text-w,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-list .module-cmt-box .post-wrap-w div.post-wrap-main{border:1px solid #e6e6e6!important;border-radius:20px 20px 20px 20px;margin:0!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw{width:130px!important;height:34px!important;line-height:33px!important;font-size:17px!important;background:#5483b1!important;border-radius:20px!important;color:#FFF!important;-webkit-box-shadow:0 -1px 4px #5483b1 inset;box-shadow:0 -1px 10px #5483b1 inset}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw:before{content:"发表评论"}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a:hover .btn-fw{color:#40759b!important;background:#FFF!important}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li{background:none!important;border-bottom:1px solid #e6e6e6}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active{border:1px solid #e6e6e6;border-radius:10px 10px 0 0;border-bottom:none}#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li .title-name-gw div.title-name-gw-tag{background:#5483b1!important;border-radius:3px}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type div.cmt-list-border{background-color:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item{border:1px solid #e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo{text-align:center;line-height:40px;border-radius:50%!important;background:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo:before{content:"畅";font-size:22px;color:#FFF}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text,#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text i{color:#5483b1!important}#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w{background:#FFF!important}@media screen and (min-width:900px){#SOHUCS #SOHU_MAIN .module-mobile-cmt-list .list-wrapper-wap .list-container-wap .list-item-wap .list-content-wrapper-wap .cmt-list-image-container .cmt-list-image{max-width: 100%;}}');
  //-   }
  //- };
})();
function removeElement(_element){
     var _parentElement = _element.parentNode;
     if(_parentElement){
            _parentElement.removeChild(_element);
     }
}
var removeAD = document.createElement("div");
removeAD.id = 'removeAD';
var adInterval1 = setInterval(function() {
  if(document.querySelector("#feedAv")){
    document.querySelector("[node-type=cmt-list]").appendChild(removeAD);
    document.querySelector("#removeAD").appendChild(document.querySelector("#feedAv"));
    //- removeElement(document.querySelectorAll("#feedAv")[0]);
    var feedAv = document.querySelector("#feedAv").children;
    for( item of feedAv){
      item.style.display = 'none'
    }
    document.querySelector("#removeAD").style.display="none"
    clearInterval(adInterval1);
  }
},1000);
var adInterval2 = setInterval(function() {
  if(document.querySelector("#pop_ad")){
    removeElement(document.querySelector("#pop_ad"));
    clearInterval(adInterval2);
  }
}, 1000);</script><script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script></body></html>