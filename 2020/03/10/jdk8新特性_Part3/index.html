<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="JJMJ's blog."><meta name="keywords" content="Java, Spring, MyBatis, 后端"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>JDK8新特性 | 掘金木匠</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JDK8新特性</h1><a id="logo" href="/.">掘金木匠</a><p class="description">懂金融的软件工程师一定是一个合格的吃货</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">JDK8新特性</h1><div class="post-meta"><a href="/2020/03/10/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part3/#comments" class="comment-count"><i id="changyan_count_unit" data-xid="2020/03/10/jdk8新特性_Part3/"></i>留言,<i id="changyan_parti_unit" data-xid="2020/03/10/jdk8新特性_Part3/"></i>参与</a><p><span class="date">Mar 10, 2020</span><span><a href="/categories/Java%E9%AB%98%E7%BA%A7/" class="category">Java高级</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><ul>
<li>在Java 8中，得益于Lambda所带来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。</li>
</ul>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><h4 id="传统集合循环遍历的弊端"><a href="#传统集合循环遍历的弊端" class="headerlink" title="传统集合循环遍历的弊端"></a>传统集合循环遍历的弊端</h4><ul>
<li><p>几乎所有的集合（如 Collection 接口或 Map 接口等）都支持直接或间接的遍历操作</p>
</li>
<li><p><code>Java 8</code>循环遍历的弊端的<code>Lambda</code>让我们可以更加专注于<strong>做什么</strong>（What），而不是<strong>怎么做</strong>（How）</p>
<ul>
<li>for循环的语法就是<strong>“怎么做”</strong> </li>
<li>for循环的循环体才是<strong>“做什么”</strong></li>
</ul>
</li>
<li><p>为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，<strong>而并不是从第一个到最后一个顺次处理的循环</strong>。前者是目的，后者是方式。</p>
</li>
</ul>
<p>在Java 8之前的做法可能为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"张无忌"</span>);</span><br><span class="line">list.add(<span class="string">"周芷若"</span>);</span><br><span class="line">List&lt;String&gt; zhangList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line"><span class="keyword">for</span> (String name : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.startsWith(<span class="string">"张"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        zhangList.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; shortList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line"><span class="keyword">for</span> (String name : zhangList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.length() == <span class="number">3</span>) &#123;</span><br><span class="line">        shortList.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line"><span class="keyword">for</span> (String name : shortList) &#123; </span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。循环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使用另一个循环从头开始。</p>
<h4 id="Stream的更优写法"><a href="#Stream的更优写法" class="headerlink" title="Stream的更优写法"></a>Stream的更优写法</h4><p>下面来看一下借助Java 8的Stream API，什么才叫优雅：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> list.add(<span class="string">"张无忌"</span>);</span><br><span class="line"> list.add(<span class="string">"周芷若"</span>);</span><br><span class="line"><span class="comment">//       list.stream().filter(new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//           @Override</span></span><br><span class="line"><span class="comment">//           public boolean test(String s) &#123;</span></span><br><span class="line"><span class="comment">//               return s.startsWith("张");</span></span><br><span class="line"><span class="comment">//           &#125;</span></span><br><span class="line"><span class="comment">//       &#125;)</span></span><br><span class="line"> list.stream().filter(name-&gt;name.startsWith(<span class="string">"张"</span>))</span><br><span class="line">               .filter(name-&gt;name.length()==<span class="number">3</span>)</span><br><span class="line">               .forEach(System.out::println);       <span class="comment">//方法引用</span></span><br></pre></td></tr></table></figure>

<p>直接阅读代码的字面意思即可<strong>完美展示</strong>无关逻辑方式的<strong>语义</strong>：<strong>获取流、过滤姓张、过滤长度为3、逐一打印</strong>。</p>
<p>代码中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。</p>
<h3 id="1-2-流式思想概述"><a href="#1-2-流式思想概述" class="headerlink" title="1.2 流式思想概述"></a>1.2 流式思想概述</h3><ul>
<li><p>注意：<strong>暂时忘记对传统IO流的固有印象</strong>！ 整体来看，流式思想类似于工厂车间的“生产流水线”。</p>
</li>
<li><p>当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先<strong>拼好一个“模型”步骤方案</strong>，然后再按照方案去执行它。</p>
<p><img src="1580898920476.png" alt="1580898920476"></p>
<p>这张图中展示了过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种“函数模型”。图中的<strong>每一个方框都是一个“流”</strong>，调用指定的方法，可以<strong>从一个流模型转换为另一个流模型</strong>。而最右侧的数字 3是最终结果。</p>
</li>
<li><p>这里的<code>filter</code>、<code>map</code> 、<code>skip</code>都是在对函数模型进行操作，集合元素并没有真正被处理。<strong>只有当终结方法 count 执行</strong>的时候，<strong>整个模型才会按照指定策略执行操作</strong>。而这得<strong>益于Lambda的延迟执行特性。</strong></p>
</li>
</ul>
<blockquote>
<p>备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。</p>
</blockquote>
<p>Stream（流）是一个来自数据源的元素队列</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>
<li><strong>数据源</strong>/流的来源。 可以是<strong>集合，数组</strong>等。</li>
</ul>
<p>和以前的<code>Collection</code>操作不同， Stream操作还有两个基础的特征：</p>
<ul>
<li><code>Pipelining</code>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路(short-circuiting)。 </li>
<li>内部迭代： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。</li>
</ul>
<p>当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结果</p>
<h3 id="1-3-获取流"><a href="#1-3-获取流" class="headerlink" title="1.3 获取流"></a>1.3 获取流</h3><ul>
<li><p><code>java.util.stream.Stream&lt;T&gt;</code>是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。）</p>
</li>
<li><p>获取一个流非常简单，有以下几种常用的方式：</p>
<ul>
<li><p><strong>所有的<code>Collection</code>集合都可以通过<code>stream</code>默认方法获取流；</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default Stream&lt;E&gt; stream()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>Stream</code>接口的静态方法<code>of</code>可以获取数组对应的流。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; Stream&lt;T&gt; of(T... values) 参数是一个可变参数,那么我们就可以传递一个数组</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h4 id="根据Collection获取流"><a href="#根据Collection获取流" class="headerlink" title="根据Collection获取流"></a>根据Collection获取流</h4><ul>
<li>首先，<code>java.util.Collection</code>接口中加入了<code>default</code>方法 stream 用来获取流，所以其所有实现类均可获取流。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;把集合转换为Stream流</span><br><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream1 &#x3D; list.stream();</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream2 &#x3D; set.stream();</span><br></pre></td></tr></table></figure>



<h4 id="根据Map获取流"><a href="#根据Map获取流" class="headerlink" title="根据Map获取流"></a>根据Map获取流</h4><p>java.util.Map 接口不是 Collection 的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F;获取键,存储到一个Set集合中</span><br><span class="line">Set&lt;String&gt; keySet &#x3D; map.keySet();</span><br><span class="line">Stream&lt;String&gt; stream3 &#x3D; keySet.stream();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取值,存储到一个Collection集合中</span><br><span class="line">Collection&lt;String&gt; values &#x3D; map.values();</span><br><span class="line">Stream&lt;String&gt; stream4 &#x3D; values.stream();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取键值对(键与值的映射关系 entrySet)</span><br><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entries &#x3D; map.entrySet();</span><br><span class="line">Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream5 &#x3D; entries.stream();</span><br></pre></td></tr></table></figure>



<h4 id="根据数组获取流"><a href="#根据数组获取流" class="headerlink" title="根据数组获取流"></a>根据数组获取流</h4><ul>
<li>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法 of ，使用很简单：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;把数组转换为Stream流</span><br><span class="line">Stream&lt;Integer&gt; stream6 &#x3D; Stream.of(1, 2, 3, 4, 5);</span><br><span class="line">&#x2F;&#x2F;可变参数可以传递数组</span><br><span class="line">Integer[] arr &#x3D; &#123;1,2,3,4,5&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream7 &#x3D; Stream.of(arr);</span><br><span class="line">String[] arr2 &#x3D; &#123;&quot;a&quot;,&quot;bb&quot;,&quot;ccc&quot;&#125;;</span><br><span class="line">Stream&lt;String&gt; stream8 &#x3D; Stream.of(arr2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注： of 方法的参数其实是一个可变参数，所以支持数组。</p>
</blockquote>
<h3 id="1-4-常用方法"><a href="#1-4-常用方法" class="headerlink" title="1.4 常用方法"></a>1.4 常用方法</h3><p><img src="1580899952784.png" alt="1580899952784"></p>
<ul>
<li><p>流模型的操作很丰富，这里介绍一些常用的API。</p>
</li>
<li><p>这些方法可以被分成两种： </p>
<ul>
<li>延迟方法：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方 法均为延迟方法。） </li>
<li>终结方法：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调 用。本小节中，终结方法包括 count 和 forEach 方法。</li>
</ul>
</li>
</ul>
<h4 id="逐一处理：forEach"><a href="#逐一处理：forEach" class="headerlink" title="逐一处理：forEach"></a>逐一处理：forEach</h4><p>虽然方法名字叫 forEach ，但是与for循环中的“for-each”昵称不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void forEach(Consumer&lt;? super T&gt; action);</span><br></pre></td></tr></table></figure>

<p>该方法接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理。 </p>
<h4 id="复习Consumer接口"><a href="#复习Consumer接口" class="headerlink" title="复习Consumer接口"></a>复习Consumer接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.function.Consumer&lt;T&gt;接口是一个消费型接口。</span><br><span class="line">Consumer接口中包含抽象方法void accept(T t)，意为消费一个指定泛型的数据。</span><br></pre></td></tr></table></figure>

<h4 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); </span><br><span class="line">	stream.forEach(name‐&gt; System.out.println(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过滤：filter"><a href="#过滤：filter" class="headerlink" title="过滤：filter"></a>过滤：filter</h4><p>可以通过 filter 方法将一个流转换成另一个子集流。方法签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</span><br></pre></td></tr></table></figure>

<p>该接口接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</p>
<p><img src="1580899980697.png" alt="1580899980697"></p>
<h4 id="复习Predicate接口"><a href="#复习Predicate接口" class="headerlink" title="复习Predicate接口"></a>复习Predicate接口</h4><p>此前我们已经学习过 java.util.stream.Predicate 函数式接口，其中唯一的抽象方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean test(T t);</span><br></pre></td></tr></table></figure>

<p>该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的 filter 方法 将会留用元素；如果结果为false，那么 filter 方法将会舍弃元素。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p> Stream流中的 filter 方法基本使用的代码如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); </span><br><span class="line">	Stream&lt;String&gt; result &#x3D; original.filter(s ‐&gt; s.startsWith(&quot;张&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里通过Lambda表达式来指定了筛选的条件：必须姓张。</p>
<h4 id="映射：map"><a href="#映射：map" class="headerlink" title="映射：map"></a>映射：map</h4><p>如果需要将流中的元素映射到另一个流中，可以使用 map 方法。方法签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</span><br></pre></td></tr></table></figure>

<p>该接口需要一个 Function 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p>
<p><img src="1580899926624.png" alt="1580899926624"></p>
<h4 id="复习Function接口"><a href="#复习Function接口" class="headerlink" title="复习Function接口"></a>复习Function接口</h4><p>此前我们已经学习过 java.util.stream.Function 函数式接口，其中唯一的抽象方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R apply(T t);</span><br></pre></td></tr></table></figure>

<p>这可以将一种T类型转换成为R类型，而这种转换的动作，就称为“映射”。 </p>
<h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p> Stream流中的 map 方法基本使用的代码如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	Stream&lt;String&gt; original &#x3D; Stream.of(&quot;10&quot;, &quot;12&quot;, &quot;18&quot;); 		Stream&lt;Integer&gt; result &#x3D; original.map(str‐&gt;Integer.parseInt(str));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="统计个数：count"><a href="#统计个数：count" class="headerlink" title="统计个数：count"></a>统计个数：count</h4><p>正如旧集合 Collection 当中的 size 方法一样，流提供 count 方法来数一数其中的元素个数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long count();</span><br></pre></td></tr></table></figure>

<p>该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">	Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); </span><br><span class="line">	Stream&lt;String&gt; result &#x3D; original.filter(s ‐&gt; s.startsWith(&quot;张&quot;)); </span><br><span class="line">	System.out.println(result.count()); &#x2F;&#x2F; 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="取用前几个：limit"><a href="#取用前几个：limit" class="headerlink" title="取用前几个：limit"></a>取用前几个：limit</h4><p>limit 方法可以对流进行截取，只取用前n个。方法签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; limit(long maxSize);</span><br></pre></td></tr></table></figure>

<p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用</p>
<p><img src="1580900011097.png" alt="1580900011097"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); </span><br><span class="line">	Stream&lt;String&gt; result &#x3D; original.limit(2); </span><br><span class="line">	System.out.println(result.count()); &#x2F;&#x2F; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="跳过前几个：skip"><a href="#跳过前几个：skip" class="headerlink" title="跳过前几个：skip"></a>跳过前几个：skip</h4><p>如果希望跳过前几个元素，可以使用 skip 方法获取一个截取之后的新流：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; skip(long n);</span><br></pre></td></tr></table></figure>

<p>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用：</p>
<p><img src="1580900027816.png" alt="1580900027816"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">	Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);</span><br><span class="line">    Stream&lt;String&gt; result &#x3D; original.skip(2); </span><br><span class="line">    System.out.println(result.count()); &#x2F;&#x2F; 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="组合：concat"><a href="#组合：concat" class="headerlink" title="组合：concat"></a>组合：concat</h4><p>如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。 </p>
</blockquote>
<p>该方法的基本使用代码如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       Stream&lt;String&gt; stream1 &#x3D; Stream.of(&quot;张三丰&quot;, &quot;张翠山&quot;);</span><br><span class="line">       String[] arr &#x3D; &#123;&quot;美羊羊&quot;,&quot;喜洋洋&quot;&#125;;</span><br><span class="line">       Stream&lt;String&gt; stream2 &#x3D; Stream.of(arr);</span><br><span class="line">       Stream&lt;String&gt; concat &#x3D; Stream.concat(stream1, stream2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h1 id="JDK5新特性"><a href="#JDK5新特性" class="headerlink" title="JDK5新特性"></a>JDK5新特性</h1><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><ul>
<li>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：<ul>
<li><strong>…</strong> 用在参数上，称之为可变参数。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其实这个书写完全等价与</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可【简单之处】。</strong></p>
<p>如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，<strong>可变参数一定要写在参数列表的末尾位置。</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">62</span>, <span class="number">431</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = getSum(arr);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="comment">//  6  7  2 12 2121</span></span><br><span class="line">        <span class="comment">// 求 这几个元素和 6  7  2 12 2121</span></span><br><span class="line">        <span class="keyword">int</span> sum2 = getSum(<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">2121</span>);</span><br><span class="line">        System.out.println(sum2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可变参数写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="JDK9新特性"><a href="#JDK9新特性" class="headerlink" title="JDK9新特性"></a>JDK9新特性</h1><h2 id="对集合添加的优化"><a href="#对集合添加的优化" class="headerlink" title="对集合添加的优化"></a>对集合添加的优化</h2><p>通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用，使得代码重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"abc"</span>);</span><br><span class="line">        list.add(<span class="string">"def"</span>);</span><br><span class="line">        list.add(<span class="string">"ghi"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJDK9</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Set&lt;String&gt; str1=Set.of(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);  </span><br><span class="line">        <span class="comment">//str1.add("c");这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合  </span></span><br><span class="line">        System.out.println(str1);  </span><br><span class="line">        Map&lt;String,Integer&gt; str2=Map.of(<span class="string">"a"</span>,<span class="number">1</span>,<span class="string">"b"</span>,<span class="number">2</span>);  </span><br><span class="line">        System.out.println(str2);  </span><br><span class="line">        List&lt;String&gt; str3=List.of(<span class="string">"a"</span>,<span class="string">"b"</span>);  </span><br><span class="line">        System.out.println(str3);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意以下两点：</p>
<blockquote>
<ol>
<li><p>of方法只适用于List接口,Set接口,Map接口,不适用于接接口的实现类</p>
</li>
<li><p>of方法的返回值是一个不能改变的集合,集合不能再使用add,put方法添加元素,会抛出异常</p>
</li>
<li><p>Set接口和Map接口在调用of方法的时候,不能有重复的元素,否则会抛出异常</p>
</li>
</ol>
</blockquote>
</div><div class="post-copyright"><blockquote><p>原文作者: 掘金木匠</p><p>原文链接: <a href="http://goldcarpenter.github.io/2020/03/10/jdk8新特性_Part3/">http://goldcarpenter.github.io/2020/03/10/jdk8新特性_Part3/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/03/26/Redis_Part1/" class="pre">Redis</a><a href="/2020/02/29/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part2/" class="next">JDK8新特性</a></div><div id="comments"><div id="SOHUCS" sid="2020/03/10/jdk8新特性_Part3/"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Stream流"><span class="toc-text">Stream流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#引言"><span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#传统集合循环遍历的弊端"><span class="toc-text">传统集合循环遍历的弊端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Stream的更优写法"><span class="toc-text">Stream的更优写法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-流式思想概述"><span class="toc-text">1.2 流式思想概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-获取流"><span class="toc-text">1.3 获取流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#根据Collection获取流"><span class="toc-text">根据Collection获取流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#根据Map获取流"><span class="toc-text">根据Map获取流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#根据数组获取流"><span class="toc-text">根据数组获取流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-常用方法"><span class="toc-text">1.4 常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#逐一处理：forEach"><span class="toc-text">逐一处理：forEach</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#复习Consumer接口"><span class="toc-text">复习Consumer接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基本使用："><span class="toc-text">基本使用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#过滤：filter"><span class="toc-text">过滤：filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#复习Predicate接口"><span class="toc-text">复习Predicate接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基本使用"><span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#映射：map"><span class="toc-text">映射：map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#复习Function接口"><span class="toc-text">复习Function接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基本使用-1"><span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#统计个数：count"><span class="toc-text">统计个数：count</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#取用前几个：limit"><span class="toc-text">取用前几个：limit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#跳过前几个：skip"><span class="toc-text">跳过前几个：skip</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组合：concat"><span class="toc-text">组合：concat</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK5新特性"><span class="toc-text">JDK5新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#可变参数"><span class="toc-text">可变参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK9新特性"><span class="toc-text">JDK9新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#对集合添加的优化"><span class="toc-text">对集合添加的优化</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/17/Redis_Part3/">Redis</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/04/Redis_Part2/">Redis</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/Nginx%E5%9F%BA%E7%A1%80/">Nginx</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/Redis_Part1/">Redis</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part3/">JDK8新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part2/">JDK8新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/25/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part1/">JDK8新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/02/javaIO/">JavaIO</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/21/ThreadLocal/">ThreadLocal总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/19/SpringMVC_Part3/">SpringMVC</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Debug%E8%AE%B0%E5%BD%95/">Debug记录</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E9%AB%98%E7%BA%A7/">Java高级</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL%E5%9F%BA%E7%A1%80/">MySQL基础</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E5%BC%80%E5%8F%91/">Web开发</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">博客搭建</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/IEDA/" style="font-size: 15px;">IEDA</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/MyBatis/" style="font-size: 15px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/SpringMVC/" style="font-size: 15px;">SpringMVC</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/String/" style="font-size: 15px;">String</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/ThreadLocal/" style="font-size: 15px;">ThreadLocal</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 15px;">多线程</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 15px;">内部类</a> <a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 15px;">注解</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">34</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.scu.edu.cn/" title="四川大学首页" target="_blank">四川大学首页</a><ul></ul><a href="http://www.scu.edu.cn/" title="风雨云知道——待部署" target="_blank">风雨云知道——待部署</a><ul></ul><a href="http://www.scu.edu.cn/" title="在线聊天室——待部署" target="_blank">在线聊天室——待部署</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">掘金木匠.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script><script>window._config = { showScore: true };
(function(){ 
  var appid = 'cyuBR2wWE'; 
  var conf = 'cbd82aee65d05c481319a299102b4811'; 
  var width = window.innerWidth || document.documentElement.clientWidth; 
  var nodes =document.getElementsByTagName("head")[0]||document.head||document.documentElement;
  if (/(Android|iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) && width < 750) {  
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
  }
  else { 
    var loadJs=function(d,a){
      var b=document.createElement("script");b.setAttribute("type","text/javascript");
      b.setAttribute("charset","UTF-8");
      b.setAttribute("src",d);
      if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}
      nodes.appendChild(b)
    };
    loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); 
  } 
  var loadCss = function(cssString){  
    var style=document.createElement("style");  
    style.setAttribute("type", "text/css");  
    if(style.styleSheet){// IE  
        style.styleSheet.cssText = cssString;  
    } else {// w3c  
        var cssText = document.createTextNode(cssString);  
        style.appendChild(cssText);  
    }
    nodes.appendChild(style);
  }
  //- window.onload=function(){
  //-   if(window.outerWidth<=775){
  //-     loadCss('.module-hot-topic,.module-cmt-float-bar{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .cbox-prompt-w span.prompt-empty-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w .form-text-w span.text-null,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w a.comment-link-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w span.comment-text-w,#SOHUCS #SOHU_MAIN .module-cmt-footer .section-service-w div.service-wrap-w a:hover,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w span.wrap-name-w,#SOHUCS #SOHU_MAIN .module-cmt-list .action-click-gw span.click-disable-eg a em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li div.title-name-gw,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number .comment-number span.cy-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number span.comment-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active,#SOHUCS #SOHU_MAIN .module-cmt-list .msg-wrap-gw .wrap-action-gw .action-click-gw span a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .picture-box-gw div.box-action-gw a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-action-gw .action-click-gw span a:hover em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-user-gw span.user-name-gw a{color:#40759b!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-r,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-l,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-r{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-l{background:#FFF!important;top:-2px!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-function-w .uploading-wrapper-dw div.wrapper-image-dw,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-main,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w div.form-text-w,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-list .module-cmt-box .post-wrap-w div.post-wrap-main{border:1px solid #e6e6e6!important;border-radius:20px 20px 20px 20px;margin:0!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw{width:130px!important;height:34px!important;line-height:33px!important;font-size:17px!important;background:#5483b1!important;border-radius:20px!important;color:#FFF!important;-webkit-box-shadow:0 -1px 4px #5483b1 inset;box-shadow:0 -1px 10px #5483b1 inset}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw:before{content:"发表评论"}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a:hover .btn-fw{color:#40759b!important;background:#FFF!important}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li{background:none!important;border-bottom:1px solid #e6e6e6}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active{border:1px solid #e6e6e6;border-radius:10px 10px 0 0;border-bottom:none}#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li .title-name-gw div.title-name-gw-tag{background:#5483b1!important;border-radius:3px}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type div.cmt-list-border{background-color:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item{border:1px solid #e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo{text-align:center;line-height:40px;border-radius:50%!important;background:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo:before{content:"畅";font-size:22px;color:#FFF}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text,#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text i{color:#5483b1!important}#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w{background:#FFF!important}@media screen and (min-width:900px){#SOHUCS #SOHU_MAIN .module-mobile-cmt-list .list-wrapper-wap .list-container-wap .list-item-wap .list-content-wrapper-wap .cmt-list-image-container .cmt-list-image{max-width: 100%;}}');
  //-   }
  //- };
})();
function removeElement(_element){
     var _parentElement = _element.parentNode;
     if(_parentElement){
            _parentElement.removeChild(_element);
     }
}
var removeAD = document.createElement("div");
removeAD.id = 'removeAD';
var adInterval1 = setInterval(function() {
  if(document.querySelector("#feedAv")){
    document.querySelector("[node-type=cmt-list]").appendChild(removeAD);
    document.querySelector("#removeAD").appendChild(document.querySelector("#feedAv"));
    //- removeElement(document.querySelectorAll("#feedAv")[0]);
    var feedAv = document.querySelector("#feedAv").children;
    for( item of feedAv){
      item.style.display = 'none'
    }
    document.querySelector("#removeAD").style.display="none"
    clearInterval(adInterval1);
  }
},1000);
var adInterval2 = setInterval(function() {
  if(document.querySelector("#pop_ad")){
    removeElement(document.querySelector("#pop_ad"));
    clearInterval(adInterval2);
  }
}, 1000);</script><script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script></body></html>