[{"title":"内部类","date":"2020-06-05T14:04:35.663Z","path":"2020/06/05/内部类/","text":"内部类 分类 成员内部类 局部内部类(包含匿名内部类) 1.成员内部类 定义格式： 12345修饰符 class 外部类名称&#123; 修饰符 class 内部类名称&#123; //... &#125;&#125; 案例 123456789101112131415161718public class Body &#123; //外部类 private String name; Body(String name) &#123; this.name = name; &#125; //外部类的方法——外部类用内部类，需要内部类对象 public void alive() &#123; new Heart().beat(); &#125; //成员内部类 public class Heart &#123; public void beat() &#123; //内部类用外部类，随意访问 System.out.println(name + \"心脏跳动! \"); &#125; &#125;&#125; 1.1如何使用成员内部类 间接方式：在外部类的方法当中，使用内部类。然后只是调用外部类的方法 123Body body = new Body(\"掘金木匠\");// 在外部类的方法当中，使用内部类body.alive(); 直接方式：公式：[外部类名称.内部类名称对象名= new外部类名称().new内部类名称();] 12Body.Heart heart = new Body(\"掘金木匠\").new Heart();heart.beat(); 1.2内部类同名变量 如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名 12345678910111213public class Outer &#123; int num = 10; //外部类的成员变量 public class Inner /*extends object*/ &#123; int num = 20; //内部类的成员变量 public void methodInner() &#123; int num = 30; //内部类方法的局部变量 System.out.println(num); //局部变量，就近原则 System.out.println(this.num); //内部类的成员变量 System.out.println(Outer.this.num); //外部类的成员变量 &#125; &#125;&#125; 2.局部内部类 如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。 局部：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。 定义格式: 1234567修饰符 class 外部类名称&#123; 修饰符 返回值类型 外部类方法名称(参数列表) &#123; class 局部内部类名称&#123; // &#125; &#125;&#125; 案例 123456789101112public class Outer &#123; public void method0uter()&#123; class Inner &#123; //局部内部类 int num = 10; public void methodInner() &#123; System.out.println(num); // 10 &#125; &#125; Inner inner = new Inner(); inner.methodInner(); &#125;&#125; 2.1 局部内部类final问题 局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是有效final的 原因 new出来的对象在堆内存当中。 局部变量是跟着方法走的，在栈内存当中。 方法运行结束之后，立刻出栈，局部变量就会立刻消失。 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。 局部变量与局部内部类的对象的生命周期不同； 为解决这一问题，Java把局部内部类要访问的局部变量重新拷贝了一份，并把备份放在内部类的常量池中，这样不论方法有没有执行结束，拷贝都是存在的，就不会再出现访问不存在的变量的错误了。 123456789101112public class MyOuter &#123; public void method0uter() &#123; // ⭐从Java 8开始，只要局部变量事实不变，那么final关键字可以省略。 final int num = 10; //所在方法的局部变量// num = 130; × class MyInner&#123; public void methodInner() &#123; System.out.println(num); &#125; &#125; &#125;&#125; 局部内部类访问的是方法体的参数呢？ Java采取的方法是，默认为局部内部类的构造方法传入该参数作为构造方法的参数，然后用该参数来初始化内部类中拷贝的变量a。 上面通过拷贝一份局部变量来解决生命周期不同的问题，如果方法体和局部内部类都改变了a的值会怎么样呢？ Java规定局部内部类可访问的局部变量必须为final的，即内部类不能改变要访问的局部变量的值，这样就不会出现数据不同步的问题了。 3 匿名内部类【局部内部类特例】 如果接口的实现类/父类的子类只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用匿名内部类 定义格式 123接口名称 对象名 = new 接口名称() &#123; // 覆盖重写所有抽象方法&#125;; 案例 1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; ArrayList&lt;String&gt; col = new ArrayList&lt;&gt;(); Collections.addAll(col,\"a\",\"b\",\"c\"); //============================================== // 局部内部类 class ConsumerImpl implements Consumer&lt;String&gt; &#123; @Override public void accept(String s) &#123; System.out.println(s); &#125; &#125; ConsumerImpl consumer = new ConsumerImpl(); col.stream().forEach(consumer); //============================================== // 匿名内部类 col.stream().forEach(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) &#123; System.out.println(s); &#125; &#125;); //============================================== // lambda表达式 col.stream().forEach(s -&gt; System.out.println(s)); //============================================== // 方法引用 col.stream().forEach(System.out::println); &#125; 3.1 匿名对象 创建对象时，只有创建对象的语句，却没有把对象地址赋值给某个变量 虽然是创建对象的简化写法，但是应用场景非常有限。 语法格式： 1new 类名(参数列表)； 应用场景 创建匿名对象直接调用方法，没有变量名 12new Scanner(System.in).nextInt();new Scanner(System.in).nextInt(); 匿名对象可以作为方法的参数和返回值 作为参数 123456789101112class Test &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = new Scanner(System.in); input(sc); //匿名对象作为方法接收的参数 input(new Scanner(System.in)); &#125; public static void input(Scanner sc)&#123; System.out.println(sc); &#125;&#125; 作为返回值 12345678910111213class Test2 &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = getScanner(); &#125; public static Scanner getScanner()&#123; //普通方式 //Scanner sc = new Scanner(System.in); //return sc; //匿名对象作为方法返回值 return new Scanner(System.in); &#125; &#125; 3.2匿名内部类 VS 匿名对象 匿名内部类，在【创建对象】的时候，只能使用唯一一次；如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了。 匿名对象，在【调用方法】的时候，只能调用唯一一次；如果希望同一个对象，调用多次方法，那么必须给对象起个名字。 匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】 强调：匿名内部类和匿名对象不是一回事 4.类的权限修饰符 类的权限修饰符：public &gt; protected &gt; (default) &gt; private 定义一个类的时候，权限修饰符规则 外部类：public / (default) 成员内部类：public / protected / (default) / private 局部内部类：什么都不能写 5.编译后.Class文件 外部类保存为：外部类.class 内部类保存为：外部类$内部类.class 6.访问权限 内部类用外部类，随意访问 外部类用内部类，需要内部类对象 12345678910111213141516171819public class Body &#123; //外部类 private String name; Body(String name) &#123; this.name = name; &#125; //外部类的方法——外部类用内部类，需要内部类对象 public void alive() &#123; new Heart().beat(); &#125; //成员内部类 public class Heart &#123; public void beat() &#123; //内部类用外部类，随意访问 System.out.println(name + \"心脏跳动! \"); &#125; &#125;&#125;","tags":[]},{"title":"Java异常","date":"2020-06-05T13:13:46.812Z","path":"2020/06/05/Java异常/","text":"异常1.Throwable异常体系 异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception 平常所说的异常指java.lang.Exception Error错误 Error：严重错误Error，无法通过处理的错误，只能事先避免。 123456789/*Error:错误 OutOfMemoryError: Java heap space 内存溢出的错误,创建的数组太大了,超出了给JVM分配的内存*/int[] arr = new int[1024*1024*1024];//必须修改代码,创建的数组小一点int[] arr = new int[1024*1024];System.out.println(\"后续代码\"); Exception异常 Exception：表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。 Throwable中的常用方法 public void printStackTrace()：打印异常的详细信息。包含了异常的类型，异常的原因，还包括异常出现的位置，在开发和调试阶段，都得使用printStackTrace。 public String getMessage()：获取发生异常的原因。提示给用户的时候,就提示错误原因。 2.异常分类 我们平常说的异常就是指Exception 异常(Exception)的分类：根据在编译时期还是运行时期检查异常细分 编译时期异常 编译时期异常：checked异常。在编译时期就会检查，如果没有处理异常，则编译失败。(如日期格式化异常) 12345678SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");//用来格式化日期Date date = null;try &#123; date = sdf.parse(\"1999-0909\");//把字符串格式的日期,解析为Date格式的日期&#125; catch (ParseException e) &#123; e.printStackTrace();&#125;System.out.println(date); 运行时期异常 运行时期异常：runtime异常。在运行时期检查异常，在编译时期，运行异常不会编译器检测(不报错)。(如数学异常) 12345678910//RuntimeException:运行期异常,java程序运行过程中出现的问题int[] arr = &#123;1,2,3&#125;;//System.out.println(arr[0]);try &#123; //可能会出现异常的代码 System.out.println(arr[3]);&#125;catch(Exception e)&#123; //异常的处理逻辑 System.out.println(e);&#125; 3.异常的产生过程解析图解异常产生的过程 4.异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws 抛出异常throw 在编写程序时，程序出现问题的情况出现时需要使用抛出异常的方式来告诉调用者。 throw用在方法内，程序出现问题时用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 创建一个异常对象，封装一些提示信息(信息可以自己编写)。 通过关键字throw将这个异常对象传递到调用者处。 使用格式： 1throw new 异常类名(参数); 例如： 12throw new NullPointerException(\"要访问的arr数组不存在\");throw new ArrayIndexOutOfBoundsException(\"该索引在数组中不存在，已超出范围\"); 注意事项: throw关键字必须写在方法的内部 throw关键字后边new的对象必须是Exception或者Exception的子类对象 throw关键字抛出指定的异常对象，我们就必须处理这个异常对象 throw关键字后边创建的是RuntimeException或者是RuntimeException的子类对象，可以不处理，默认交给JVM处理(打印异常对象,中断程序) throw关键字后边创建的是编译异常(写代码的时候报错)，我们就必须处理这个异常，要么throws,要么try...catch 1234567891011121314151617181920212223242526272829/* 以后(工作中)我们首先必须对方法传递过来的参数进行合法性校验 如果参数不合法,那么我们就必须使用抛出异常的方式,告知方法的调用者,传递的参数有问题 注意: NullPointerException是一个运行期异常,我们不用处理,默认交给JVM处理 ArrayIndexOutOfBoundsException是一个运行期异常,我们不用处理,默认交给JVM处理 */ public static int getElement(int[] arr,int index)&#123; /* 我们可以对传递过来的参数数组,进行合法性校验 如果数组arr的值是null 那么我们就抛出空指针异常,告知方法的调用者\"传递的数组的值是null\" */ if(arr == null)&#123; throw new NullPointerException(\"传递的数组的值是null\"); &#125; /* 我们可以对传递过来的参数index进行合法性校验 如果index的范围不在数组的索引范围内 那么我们就抛出数组索引越界异常,告知方法的调用者\"传递的索引超出了数组的使用范围\" */ if(index&lt;0 || index&gt;arr.length-1)&#123; throw new ArrayIndexOutOfBoundsException(\"传递的索引超出了数组的使用范围\"); &#125; int ele = arr[index]; return ele; &#125; Objects非空判断 类Objects曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。 public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象不是null。 查看源码发现这里对为null的进行了抛出异常操作： 1234567891011//对传递过来的参数进行合法性判断,判断是否为nullpublic static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125;public static &lt;T&gt; T requireNonNull(T obj, String message) &#123; if (obj == null) throw new NullPointerException(message); return obj;&#125; 12Objects.requireNonNull(obj);Objects.requireNonNull(obj,\"传递的对象的值是null\"); 异常处理的第一种方式：声明异常throws 交给别人处理 声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理，那么必须通过throws进行声明，让调用者去处理。 关键字throws运用于方法声明之上，用于表示当前方法不处理异常，而是提醒该方法的调用者来处理异常(抛出异常). 声明异常格式： 1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125; 声明异常的代码演示： 12345678910111213public class ThrowsDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; read(\"a.txt\"); &#125; // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; 注意: throws关键字必须写在方法声明处 throws关键字后边声明的异常必须是Exception或者是Exception的子类 方法内部如果抛出了多个异常对象,那么throws后边必须也声明多个异常 如果抛出的多个异常对象有子父类关系，那么直接声明父类异常即可 调用了一个声明抛出异常的方法，我们就必须的处理声明的异常 要么继续使用throws声明抛出，交给方法的调用者处理，最终交给JVM 要么try…catch自己处理异常 异常处理的第二种方式：捕获异常try…catch 自己处理 try-catch的方式就是捕获异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。* 捕获异常语法如下： 12345678try&#123; 可能产生异常的代码&#125;catch(定义一个异常的变量,用来接收try中抛出的异常对象)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;...catch(异常类名 变量名)&#123;&#125; try：该代码块中编写可能产生异常的代码。 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 1234567891011121314151617181920public class TryCatchDemo &#123; public static void main(String[] args) &#123; try &#123;// 当产生异常时，必须有处理方式。要么捕获，要么声明。 read(\"b.txt\"); &#125; catch (FileNotFoundException e) &#123; //try中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); &#125; System.out.println(\"over\"); &#125; /* * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; finally 代码块 finally一般用于资源释放(资源回收),无论程序是否出现异常,最后都要资源释放(IO) finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 1234567891011121314151617181920212223public class TryCatchDemo4 &#123; public static void main(String[] args) &#123; try &#123; read(\"a.txt\"); &#125; catch (FileNotFoundException e) &#123; //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); &#125; finally &#123; System.out.println(\"不管程序怎样，这里都将会被执行。\"); &#125; System.out.println(\"over\"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; 当只有在try或者catch中调用退出JVM的相关方法，此时finally才不会执行，否则finally永远会执行。 异常注意事项 一般我们是使用一次捕获多次处理方式，格式如下： 123456789try&#123; 编写可能会出现异常的代码&#125;catch(异常类型A e)&#123; 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;catch(异常类型B e)&#123; 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果finally有return语句，会永远返回finally中的结果，应该避免该情况 123456789101112131415161718public static void main(String[] args) &#123; int a = getA(); System.out.println(a); //100 &#125; //定义一个方法,返回变量a的值 public static int getA()&#123; int a = 10; try&#123; return a; &#125;catch (Exception e)&#123; System.out.println(e); &#125;finally &#123; //一定会执行的代码 a = 100; return a; &#125; &#125; 子父类的异常 如果父类抛出了多个异常，子类重写父类方法时，抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出 父类异常时什么样，子类异常就什么样 1234567891011121314151617181920212223242526272829public class Fu &#123; public void show01() throws NullPointerException,ClassCastException&#123;&#125; public void show02() throws IndexOutOfBoundsException&#123;&#125; public void show03() throws IndexOutOfBoundsException&#123;&#125; public void show04() throws Exception &#123;&#125;&#125;class Zi extends Fu&#123; //子类重写父类方法时,抛出和父类相同的异常 public void show01() throws NullPointerException,ClassCastException&#123;&#125; //子类重写父类方法时,抛出父类异常的子类 public void show02() throws ArrayIndexOutOfBoundsException&#123;&#125; //子类重写父类方法时,不抛出异常 public void show03() &#123;&#125; /* 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。 */ //public void show04() throws Exception&#123;&#125; × //此时子类产生该异常，只能捕获处理，不能声明抛出 public void show04() &#123; try &#123; throw new Exception(\"编译期异常\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5.自定义异常概述 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类. 自定义一个业务逻辑异常: RegisterException。一个注册异常类。 异常类如何定义: 自定义一个编译期异常：自定义类 并继承于java.lang.Exception。 自定义一个运行时期的异常类：自定义类 并继承于java.lang.RuntimeException。 自定义异常的练习要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 首先定义一个登陆异常类RegisterException： 12345678910111213141516// 业务逻辑异常public class RegisterException extends Exception &#123; /** * 空参构造 */ public RegisterException() &#123; &#125; /** * * @param message 表示异常提示 */ public RegisterException(String message) &#123; super(message); &#125;&#125; 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。 123456789101112131415161718192021222324252627public class Demo &#123; // 模拟数据库中已存在账号 private static String[] names = &#123;\"bill\",\"hill\",\"jill\"&#125;; public static void main(String[] args) &#123; //调用方法 try&#123; // 可能出现异常的代码 checkUsername(\"nill\"); System.out.println(\"注册成功\");//如果没有异常就是注册成功 &#125;catch(RegisterException e)&#123; //处理异常 e.printStackTrace(); &#125; &#125; //判断当前注册账号是否存在 //因为是编译期异常，又想调用者去处理 所以声明该异常 public static boolean checkUsername(String uname) throws LoginException&#123; for (String name : names) &#123; if(name.equals(uname))&#123;//如果名字在这里面 就抛出登陆异常 throw new RegisterException(\"亲\"+name+\"已经被注册了！\"); &#125; &#125; return true; &#125;&#125;","tags":[]},{"title":"Github无法登陆","date":"2020-02-06T00:56:17.000Z","path":"2020/02/06/GithububNologin/","text":"问题 最初在使用git时出现报错，如下 123456$ git push -u origin masterssh: Could not resolve hostname github.com: Temporary failure in name resolutionfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 登陆github.com，报告404 ping github.com，超时 解决 需要在host文件里做些修改 1C:\\Windows\\System32\\drivers\\etc Win10操作系统，先给自己最高权限【右键-属性-安全-编辑】 在host文件追加内容 12345678192.30.253.113 github.com192.30.252.131 github.com185.31.16.185 github.global.ssl.fastly.net74.125.237.1 dl-ssl.google.com173.194.127.200 groups.google.com192.30.252.131 github.com185.31.16.185 github.global.ssl.fastly.net74.125.128.95 ajax.googleapis.com ping github.com，成功 登陆github.com，成功 将host文件权限恢复","tags":[{"name":"hexo","slug":"hexo","permalink":"http://goldcarpenter.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://goldcarpenter.github.io/tags/github/"}]},{"title":"javaIO（一）","date":"2020-02-02T09:55:36.000Z","path":"2020/02/02/javaIO/","text":"1.File类1.1 概述 java.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作 File类是一个与系统无关的类，任何的操作系统都可以使用这个类中的方法 1.2静态成员变量 static String pathSeparator：与系统有关的路径分隔符，为了方便，它被表示为一个字符串。 static char pathSeparatorChar：与系统有关的路径分隔符。 static string separator：与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。 static char separatorChar：与系统有关的默认名称分隔符。 1.3 构造方法 public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的File实例。 public File(String parent, String child) ：拼接 父路径名字符串和子路径名字符串创建新的 File实例。 public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例。 构造举例，代码如下： 无论该路径下是否存在文件或者目录，都不影响File对象的创建。 路径可以是以文件结尾，也可以是以文件夹结尾 路径可以是相对路径,也可以是绝对路径 路径可以是存在，也可以是不存在 创建File对象，只是把字符串路径封装为File对象，不考虑路径的真假情况 1.4 常用方法1.4.1获取功能的方法 public String getAbsolutePath() ：返回此File的绝对路径名字符串。 public String getPath() ：将此File转换为绝对/相对路径名字符串，toString调用此方法实现。 public String getName() ：返回由此File表示的文件或目录的名称。 public long length() ：返回由此File表示的文件的大小，字节单位。 API中说明：length()——表示文件的大小。但是File对象表示目录，则返回值0。 1.4.2绝对路径和相对路径 绝对路径：从盘符开始的路径，这是一个完整的路径。 相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。 1234567891011121314public class FilePath &#123; public static void main(String[] args) &#123; // D盘下的bbb.java文件 File f = new File(\"D:\\\\bbb.java\"); System.out.println(f.getAbsolutePath()); // 项目下的bbb.java文件 File f2 = new File(\"bbb.java\"); System.out.println(f2.getAbsolutePath()); &#125;&#125;输出结果：D:\\bbb.javaD:\\idea_project_test4\\bbb.java 1.4.3判断功能的方法 public boolean exists() ：此File表示的文件或目录是否实际存在。 public boolean isDirectory() ：此File表示的是否为目录。 public boolean isFile() ：此File表示的是否为文件。 isFile() &amp; isDirectory() 使用前提，路径必须是存在的，否则都返回false 1.4.4创建删除功能的方法 public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 只能创建文件，不能创建文件夹 创建文件的路径必须存在，否则会抛出异常 文件存在，不会创建，返回false public boolean delete() ：删除由此File表示的文件或目录。 如果此File表示目录，文件夹中有内容，不会删除返回false，目录必须为空才能删除 构造方法中路径不存在，返回false 直接在硬盘删除文件/文件夹，不走回收站，删除要谨慎 public boolean mkdir() 【不常用】：创建由此File表示的单级目录。 文件夹存在，不会创建，返回false 构造方法中给出的路径不存在，返回false public boolean mkdirs() 【常用】：创建由此File表示的目录，包括任何必需但不存在的父目录。 既可以创建单级文件夹，也可以创建多级文件夹 1.5目录的遍历 public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 12345678910111213141516public class FileFor &#123; public static void main(String[] args) &#123; File dir = new File(\"d:\\\\java_code\"); //获取当前目录下的文件以及文件夹的名称。 String[] names = dir.list(); for(String name : names)&#123; System.out.println(name); &#125; //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息 File[] files = dir.listFiles(); for (File file : files) &#123; System.out.println(file); &#125; &#125;&#125; 调用遍历方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。 可以遍历到隐藏的文件夹 1.6文件过滤器实现 java.io.FileFilter是一个接口，File过滤器。 该接口的对象可以传递给File类listFiles(FileFilter) 作为参数， 接口中只有一个方法。 boolean accept(File pathname) ：测试pathname是否应该包含在当前File目录中，符合则返回true。 分析： 接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。 accept方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则： 要么是.java文件。 要么是目录，用于继续遍历。 通过过滤器的作用，listFiles(FileFilter)返回的数组元素中，子文件对象都是符合条件的，可以直接打印。 代码实现： 123456789101112131415161718192021222324public class DiGuiDemo4 &#123; public static void main(String[] args) &#123; File dir = new File(\"D:\\\\aaa\"); printDir2(dir); &#125; public static void printDir2(File dir) &#123; // 匿名内部类方式,创建过滤器子类对象 File[] files = dir.listFiles(new FileFilter() &#123; @Override public boolean accept(File pathname) &#123; return pathname.getName().endsWith(\".java\")||pathname.isDirectory(); &#125; &#125;); // 循环打印 for (File file : files) &#123; if (file.isFile()) &#123; System.out.println(\"文件名:\" + file.getAbsolutePath()); &#125; else &#123; printDir2(file); &#125; &#125; &#125;&#125; 1.7文件过滤器实现Lambda优化分析：FileFilter是只有一个方法的接口，因此可以用lambda表达式简写。 lambda格式： 1()-&gt;&#123; &#125; 代码实现： 123456789101112131415public static void printDir3(File dir) &#123; // lambda的改写 File[] files = dir.listFiles(f -&gt;&#123; return f.getName().endsWith(\".java\") || f.isDirectory(); &#125;); // 循环打印 for (File file : files) &#123; if (file.isFile()) &#123; System.out.println(\"文件名:\" + file.getAbsolutePath()); &#125; else &#123; printDir3(file); &#125; &#125;&#125; 2.IO流2.1IO的分类根据数据的流向分为：输入流和输出流。 输入流 ：把数据从其他设备上读取到内存中的流。 输出流 ：把数据从内存 中写出到其他设备上的流。 格局数据的类型分为：字节流和字符流。 字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 2.2顶级父类 输入流 输出流 字节流 字节输入流InputStream 字节输出流OutputStream 字符流 字符输入流Reader 字符输出流Writer","tags":[{"name":"java","slug":"java","permalink":"http://goldcarpenter.github.io/tags/java/"},{"name":"IO","slug":"IO","permalink":"http://goldcarpenter.github.io/tags/IO/"}]},{"title":"hexo博客绑定自定义域名","date":"2019-02-18T11:40:20.000Z","path":"2019/02/18/hexo博客绑定域名/","text":"1.准备 一个已经备案的阿里云域名（国内备案可太麻烦了） 一般域名实名认证通过后2-3天，才会恢复解析 2.前置知识 修改阿里云域名解析 主机记录 &amp; 记录值 &amp; 记录类型 主机记录【设置子域名】：指创建子域名时所添加域名前缀 主机记录 说明 www 解析后的域名为www.aliyun.com @ 直接解析主域名 aliyun.com ***** 泛解析，匹配其他所有域名 *.aliyun.com mail 将域名解析为mail.aliyun.com，通常用于解析邮箱服务器 二级域名 如：abc.aliyun.com，填写abc 三级域名 a.www.example.com，填写a.www 手机网站 如：m.aliyun.com，填写m 记录值是指需要将子域名指向哪个解析地址 可以输入服务器IP地址，也可以输入域名 记录类型 A记录：最普通常见的域名解析，是把某一主机名解析到服务器IP 主机记录 类型 记录值 www A 192.168.0.1 CNAME记录：是主机名到主机名的映射 主机记录 类型 记录值 @ CNAME othername.com AAAA：用来指定主机名（或域名）对应的IPv6地址。A记录对应的是IPV4地址 url转发：可以转发到某一个目录下，甚至某一个文件上。 url转发和cname的主要区别：CNAME记录是不可以转发到某一个目录下，甚至某一个文件上 3.配置阿里云域名解析 无论是A记录、CNAME、URL转发在实际使用时是全部可以设置多条记录的 为了之后项目域名保留，博客使用二级域名scu.yangyuxin.top 使用在线域名解析发现原域名对应多个IP，可能做了负载均衡，故记录类型没有使用A类型 记录类型 主机记录 记录值 CNAME scu 博客原域名 获取博客IP地址方法 cmd窗口中ping 博客原goldcarpenter.github.io 网页在线域名解析服务获取 在本地博客..\\source中新建CNAME文件，注意无拓展名，内容输入scu.yangyuxin.top【新域名】 使用git shell 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 如此 在github的博客仓库中就会设置自定义域名，已经修改，无需再次修改 大功告成","tags":[{"name":"hexo","slug":"hexo","permalink":"http://goldcarpenter.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://goldcarpenter.github.io/tags/github/"}]},{"title":"【博客搭建】使用hexo与github搭建个人博客系统（一）","date":"2018-10-27T14:19:02.000Z","path":"2018/10/27/配置hexo与github/","text":"1.软件准备 软件准备 注册Github账户(略) 安装node.js软件(略) 安装Git软件(略) 建议安装Typora(编辑博文使用，略) 创建github page仓库 在Github中创建goldcarpenter.github.io(goldcarpenter为github用户名)的仓库 未来博客网站访问地址就是https://goldcarpenter.github.io 了 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟 配置SSH key 使用SSH key（公钥私钥）验证登录可以简化我们的登录过程，避免输入账户密码 12ssh-keygen -t rsa -C &quot;youremail@qq.com&quot;提示信息——连续3次回车 在C盘的用户当前用户目录下找到.ssh\\id_rsa.pub，将公钥内容使用软件打开拷贝至setting -&gt; SSH and GPG keys -&gt; New SSH key 将刚复制的内容粘贴到key那里，title填你的计算机名称，保存。 测试SSH key 1ssh -T git@github.com # 注意邮箱地址不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： 1Hi goldcarpenter! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 如果你是首次使用git，git shell中配置 12345你的github用户名$ git config --global user.name &quot;goldcarpenter&quot;填写你的github注册邮箱$ git config --global user.email &quot;xxx@qq.com&quot; 2.搭建hexo博客系统2.1.前言 hexo简介 Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 hexo原理 由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容 hexo将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github 注意事项 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，为避免不必要的问题，使用的命令建议全部使用git bash来执行 hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2类_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下管理各个主题的_config.yml； 2.2.本地hexo使用 安装hexo 1$ npm install -g hexo 创建博客本地存放文件夹 在电脑的某个地方新建一个文件夹，作为存放代码的地方。我的是F:\\Project\\Hexo_Repo 12$ cd [目标目录]$ hexo init 12345678910├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json #npm 依赖等 12$ hexo g # 生成相关页面$ hexo s # 启动本地hexo预览服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github的 hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到hexo写了一篇名为 Hello World 的文章内容 修改主题 官方主题中有很多优秀的主题，本文使用主题为BlueLake 12$ cd [目标目录]$ git clone https:&#x2F;&#x2F;github.com&#x2F;chaooo&#x2F;hexo-theme-BlueLake.git themes&#x2F;BlueLake 下载后的主题放在themes目录中 BlueLake是基于jade和stylus写的，所以需要安装hexo-renderer-jade和hexo-renderer-stylus来渲染 12$ npm install hexo-renderer-jade@0.3.0 --save$ npm install hexo-renderer-stylus --save 修改_config.yml中的theme: landscape改为theme: BlueLake 12$ hexo clean$ hexo g 更新主题 今后若主题添加了新功能正是需要的，可以直接git pull来更新主题 12cd themes&#x2F;BlueLakegit pull 2.3.hexo上传Github 上传之前 一定要记得先把你以前所有代码pull下来（虽然github有版本管理，但备份一下总是好的） 因为从hexo提交代码时会把你以前的所有代码都删掉 上传前配置准备 安装插件 1$ npm install hexo-deployer-git --save 配置_config.yml中有关deploy的部分 1234deploy: type: git repository: git@github.com:goldcarpenter&#x2F;goldcarpenter.github.io.git branch: master 上传 1hexo d 2.4.写博客 定位到我们的hexo根目录 1hexo new &#39;配置hexo与github&#39; hexo会帮我们在_posts下生成相关配置hexo与github.md文件 需要打开这个文件就可以开始写博客了 12345title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面 如何让博文列表不显示全部内容 默认情况下，生成的博文目录会显示全部的文章内容，在合适的位置加上&lt;!--more--&gt;即可设置文章摘要的长度 2.5.博客系统优化 根_config.yml配置 _config.yml详细说明 参数 描述 title 网站标题 显示在网站头部 subtitle 网站副标题 显示在网站头部 description 网站描述 加入网站源码的meta标签中 主要用于SEO keywords 网站的关键词。使用半角逗号 , 分隔多个关键词。 author 您的名字 网站底部的Copyright处有所显示 language 简体中文（zh-CN）繁体中文（zh-TW）英语（en） 1234567title: 掘金木匠subtitle: 不玩金融的软件工程师不是好的吃货description: JJMJ&#39;s blog.keywords: Java, Spring, MyBatis, 后端author: 掘金木匠language: zh-CNtimezone: &#39;&#39; 主题_config.yml设置 主题默认是展示四个菜单，即主页home，归档archive，关于about，订阅RSS；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。 12345678910111213menu: - page: home directory: . icon: fa-home - page: archive directory: archives&#x2F; icon: fa-archive - page: about directory: about&#x2F; icon: fa-user #- page: rss # directory: atom.xml # icon: fa-rss 每个页面底部的footer中联系博主的三个图标分别是邮箱，微博主页链接地址，GitHUb个人页链接地址，直接使用主题_config.yml中about页面的配置，若不需要about页面，只需要如下配置就好： 1234about: email: ## 个人邮箱 weibo_url: ## 微博主页链接地址 github_url: ## github主页链接地址 添加about页 此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面 1$ hexo new page &#39;about&#39; 1234567about: photo_url: ## 头像的链接地址 email: ## 个人邮箱 weibo_url: ## 微博主页链接地址 weibo_name: ## 微博用户名 github_url: ## github主页链接地址 github_name: ## github用户名 当然也可以自定义重新布局about页面，只需要修改layout/page.jade模板就好 安装 RSS(订阅) 和 sitemap(网站地图) 插件 123$ npm install hexo-generator-feed --save$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 添加主题_config.yml配置 1234567891011121314Plugins: hexo-generator-feed hexo-generator-sitemap hexo-generator-baidu-sitemapfeed: type: atom path: atom.xml limit: 20sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 添加本地搜索 默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件hexo-generator-json-content来创建JSON数据文件 1$ npm install hexo-generator-json-content@2.2.0 --save 然后在根_config.yml添加配置： 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 最后在主题_config.yml添加配置： 1local_search: true 修改站点图标 站点图标存放在主题的Source目录下，已经默认准备了两张图片。您也可以自己设计站点LOGO。 需要准备一张ico格式并命名为favicon.ico 将其放入hexo目录的source文件夹，建议大小：32px X 32px。 首页添加文章置顶 在根目录下打开命令行窗口安装： 12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 然后在需要置顶的文章的Front-matter中加上top: true即可。 123456---title: BlueLake博客主题的详细配置tags: [hexo,BlueLake]categories: hexo博客折腾top: true--- 其他配置 show_category_count——是否显示分类下的文章数。 widgets_on_small_screens——是否在小屏显示侧边栏，若true,则侧边栏挂件将显示在底部。 12show_category_count: true widgets_on_small_screens: true 保留CNAME、README.md等文件 一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的： 由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。 3.Q&amp;A 博客中的图片无法显示问题 Hexo下的_config.yml里的post_asset_folder，把这个选项从false改成true Hexo目录下打开Git Brsh，执行一个下载上传图片插件的命令npm install hexo-asset-image --save 图片所在文件夹为文件同名的文件夹 .md中的图片仅仅保留图片名 4.常用hexo命令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate &#x3D;&#x3D; hexo g #生成静态页面至public目录hexo server &#x3D;&#x3D; hexo s #开启预览访问端口（默认端口4000）hexo deploy &#x3D;&#x3D; hexo d #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 5.鸣谢12原文作者: 郑超(Charles·Zheng)原文链接: http:&#x2F;&#x2F;chaoo.oschina.io&#x2F;2016&#x2F;12&#x2F;29&#x2F;BlueLake博客主题的详细配置.html","tags":[{"name":"hexo","slug":"hexo","permalink":"http://goldcarpenter.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://goldcarpenter.github.io/tags/github/"}]}]