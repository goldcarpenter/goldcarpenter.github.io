[{"title":"Redis","date":"2020-04-16T16:00:00.000Z","path":"2020/04/17/Redis_Part3/","text":"7高级数据类型7.1Bitmaps 获取指定key对应偏移量上的bit值 1getbit key offset 设置指定key对应偏移量上的bit值，value只能是1或0 1setbit key offset value 对指定key按位进行交、并、非、异或操作，并将结果保存到destKey中 1bitop op destKey key1 [key2...] and：交 or：并 not：非 xor：异或 统计指定key中1的数量 1bitcount key [start end] 应用场景13 统计每天某一部电影是否被点播 统计每天有多少部电影被点播 统计每周/月/年有多少部电影被点播 统计年度哪部电影没有被点播 答：redis 应用于信息状态统计 7.2HyperLogLog HyperLogLog 是用来做基数统计的，运用了LogLog的算法 基数是数据集去重后元素个数 添加数据 1pfadd key element [element ...] 统计数据 1pfcount key [key ...] 合并数据 1pfmerge destkey sourcekey [sourcekey...] 相关说明 用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据 核心是基数估算算法，最终数值存在一定误差 误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值 耗空间极小，每个hyperloglog key占用了12K的内存用于标记基数 pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存逐渐增大 Pfmerge命令合并后占用的存储空间为12K，无论合并之前数据量多少 应用场景15 统计独立UV 答：redis 应用于独立信息统计 7.3GEO 添加坐标点 1geoadd key longitude latitude member [longitude latitude member ...] 获取坐标点 1geopos key member [member ...] 计算坐标点距离 1geodist key member1 member2 [unit] 根据坐标求范围内的数据 1georadius key longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count] 根据点求范围内数据. 1georadiusbymember key member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count] 获取指定点对应的坐标hash值 1geohash key member [member ...] 应用场景15 统计独立UV 答：redis 应用于地理位置计算 8主从复制8.1主从复制简介 单机redis的风险与问题 机器故障【硬盘故障、系统崩溃】，数据丢失，很可能对业务造成灾难性打击 容量瓶颈【内存不足】，硬件条件跟不上 为了避免单点Redis服务器故障，准备多台服务器，互相连通。 将数据复制多个副本保存在不同的服务器上，连接在一起，并保证数据是同步的。即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时实现数据冗余备份。 提供数据方：master 主服务器，主节点，主库，主客户端 接收数据方：slave 从服务器，从节点，从库，从客户端 需要解决的问题： 数据同步 核心工作： master的数据复制到slave中 主从复制 主从复制即将master中的数据即时、有效的复制到slave中 特征：一个master可以拥有多个slave，一个slave只对应一个master 职责： master:①写数据 ②执行写操作时，将出现变化的数据自动同步到slave ③读数据（可忽略） slave:①读数据 ②写数据（禁止） 作用 读写分离：master写、slave读，提高服务器的读写负载能力 负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量 故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复 数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式 高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案 8.2主从复制工作流程 主从复制过程大体可以分为3个阶段 建立连接阶段（即准备阶段） 数据同步阶段 命令传播阶段 8.2.1阶段一：建立连接阶段 建立slave到master的连接，使master能够识别slave，并保存slave端口号 主从连接（slave连接master） 方式一：客户端发送命令 1slaveof &lt;masterip&gt; &lt;masterport&gt; 方式二：启动服务器参数 1redis-server -slaveof &lt;masterip&gt; &lt;masterport&gt; 方式三：服务器配置 1slaveof &lt;masterip&gt; &lt;masterport&gt; 主从断开连接 客户端发送命令 1slaveof no one 说明： slave断开连接后，不会删除已有数据，只是不再接受master发送的数据 slave启动服务器设置密码 1redis-server –a &lt;password&gt; slave配置文件设置密码 1masterauth &lt;password&gt; 查看 1info 8.2.2阶段二：数据同步阶段工作流程 在slave初次连接master后，复制master中的所有数据到slave 将slave的数据库状态更新成master当前的数据库状态 步骤1：请求同步数据 步骤2：创建RDB同步数据 步骤3：恢复RDB同步数据 步骤4：请求部分同步数据 步骤5：恢复部分同步数据 至此，数据同步工作完成！ 状态： slave： 具有master端全部数据，包含RDB过程接收的数据 master： 保存slave当前数据同步的位置 总体： 之间完成了数据克隆 8.2.2.1部分复制的三个核心要素——服务器的运行 id（run id） 概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id 组成：运行id由40位字符组成，是一个随机的十六进制字符 例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce 作用：运行id被用于在服务器间进行传输，识别身份 如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别 实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发 送给slave，slave保存此ID，通过info Server命令，可以查看节点的runid 8.2.2.2部分复制的三个核心要素——主服务器的复制积压缓冲区 概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命 令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区 复制缓冲区默认数据存储空间大小是1M，由于存储空间大小是固定的，当入队元素的数量大于队 列长度时，最先入队的元素会被弹出，而新元素会被放入队列 由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区 作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select） 数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中 8.2.2.3部分复制的三个核心要素——主从服务器的复制偏移量 概念：一个数字，描述复制缓冲区中的指令字节位置 分类： master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个） slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个） 数据来源： master端：发送一次记录一次 slave端：接收一次记录一次 作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用 8.2.2.4数据同步阶段master 如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行 复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。 1repl-backlog-size 1mb master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执行bgsave命令和创建复制缓冲区 8.2.2.5数据同步阶段slave 为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的写数据功能 1slave-serve-stale-data yes|no 数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令 多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果 master带宽不足，因此数据同步需要根据业务需求，适量错峰 slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟 较大，数据一致性变差，应谨慎选择 8.2.3阶段三：命令传播阶段 当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的 状态，同步的动作称为命令传播 master将接收到的数据变更命令发送给slave，slave接收命令后执行命令 命令传播阶段出现了断网现象 网络闪断闪连——忽略 短时间网络中断——部分复制 长时间网络中断——全量复制 8.2.3.1心跳机制 进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线 master心跳： 指令：PING 周期：由repl-ping-slave-period决定，默认10秒 作用：判断slave是否在线 查询：INFO replication 获取slave最后一次连接时间间隔，lag项维持在0或1视为正常 slave心跳任务 指令：REPLCONF ACK {offset} 周期：1秒 作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令 作用2：判断master是否在线 8.2.3.2心跳阶段注意事项 当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作 12min-slaves-to-write [2] min-slaves-max-lag [8] slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步 slave数量由slave发送REPLCONF ACK命令做确认 slave延迟由slave发送REPLCONF ACK命令做确认 9主从复制常见问题9.1频繁的全量复制一 伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的 全量复制操作 内部优化调整方案： master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave 在master关闭时执行命令 shutdown save，进行RDB持久化,将runid与offset保存到RDB文件中 repl-id repl-offset 通过redis-check-rdb命令可以查看该信息 master重启后加载RDB文件，恢复数据重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中 1master_repl_id &#x3D; repl master_repl_offset &#x3D; repl-offset 通过info命令可以查看该信息 *作用： 本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master * 9.2频繁的全量复制二 问题现象：网络环境不佳，出现网络中断，slave不提供服务 问题原因：复制缓冲区过小，断网后slave的offset越界，触发全量复制 最终结果：slave反复进行全量复制 解决方案：修改复制缓冲区大小 1repl-backlog-size 建议设置如下： 测算从master到slave的重连平均时长second 获取master平均每秒产生写命令数据总量write_size_per_second 最优复制缓冲区空间 = 2 * second * write_size_per_second 9.3频繁的网络中断一 问题现象：master的CPU占用过高 或 slave频繁断开连接 问题原因： slave每1秒发送REPLCONF ACK命令到master，当slave接到了慢查询时（keys * ，hgetall等），会大量占用CPU性能，master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应 最终结果：master各种资源（输出缓冲区、带宽、连接等）被严重占用 解决方案：通过设置合理的超时时间，确认是否释放slave 1repl-timeout 该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave 9.4频繁的网络中断二 问题现象：slave与master连接断开 问题原因 master发送ping指令频度较低 master设定超时时间较短 ping指令在网络中存在丢包 解决方案：提高ping指令发送的频度 1repl-ping-slave-period 超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时 9.5数据不一致 问题现象：多个slave获取相同数据不同步 问题原因：网络信息不同步，数据发送有延迟 解决方案 优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象  监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问 10哨兵模式10.1哨兵简介 引入——主机“宕机” 关闭master和所有slave 找一个slave作为master 修改其他slave的配置，连接新的主 启动新的master与slave 哨兵(sentinel) 是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的 master并将所有slave连接到新的master。 哨兵的作用 监控：不断的检查master和slave是否正常运行。 master存活检测、master与slave运行情况检测 通知（提醒）：当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。 自动故障转移：断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服 务器地址 注意： 哨兵也是一台redis服务器，只是不提供数据服务 通常哨兵配置数量为单数 10.2启用哨兵模式 配置一拖二的主从结构 配置三个哨兵（配置相同，端口不同） sentinel.conf文件 启动哨兵 1redis-sentinel [sentinel-端口号.conf] 10.3哨兵工作原理 监控阶段 通知阶段 故障转移阶段 发现问题 竞选负责人，优选新master 新master上任，其他slave切换master，原master作为slave故障恢复后连接 11集群11.1集群简介 集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果 作用 分散单台服务器的访问压力，实现负载均衡 分散单台服务器的存储压力，实现可扩展性 降低单台服务器宕机带来的业务灾难 11.2Redis集群结构设计 增减节点就是改变槽的位置 11.3cluster集群结构搭建11.3.1Cluster配置 添加节点 1cluster-enabled yes|no cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容 1cluster-config-file &lt;filename&gt; 节点服务响应超时时间，用于判定该节点是否下线或切换为从节点 1cluster-node-timeout &lt;milliseconds&gt; master连接的slave最小数量 1cluster-migration-barrier &lt;count&gt; 11.3.2Cluster节点操作命令 查看集群节点信息 1cluster nodes 进入一个从节点 redis，切换其主节点 1cluster replicate &lt;master-id&gt; 发现一个新节点，新增主节点 1cluster meet ip:port 忽略一个没有solt的节点 1cluster forget &lt;id&gt; 手动故障转移 1cluster failover 12企业级解决方案12.1缓存预热 缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓 存的问题！用户直接查询事先被预热的缓存数据！ 现象：服务器启动后迅速宕机 问题排查： 请求数量较高 主从之间数据吞吐量较大，数据同步操作频度较高 解决方案 前置准备工作 日常例行统计数据访问记录，统计访问频度较高的热点数据 利用LRU数据删除策略，构建数据留存队列 例如：storm与kafka配合 准备工作 将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据 利用分布式多服务器同时进行数据读取，提速数据加载过程 热点数据主从同时预热 实施 使用脚本程序固定触发数据预热过程 如果条件允许，使用了CDN（内容分发网络），效果会更好 12.2缓存雪崩 缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现 （约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。 现象 系统平稳运行过程中，忽然数据库连接量激增 应用服务器无法及时处理请求 大量408，500错误页面出现 客户反复刷新页面获取数据 数据库崩溃 应用服务器崩溃 重启应用服务器无效 Redis服务器崩溃 Redis集群崩溃 重启数据库后再次被瞬间流量放倒 问题排查 在一个较短的时间内，缓存中较多的key集中过期 此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据 数据库同时接收到大量的请求无法及时处理 Redis大量请求被积压，开始出现超时现象 数据库流量激增，数据库崩溃 重启后仍然面对缓存中无数据可用 Redis服务器资源被严重占用，Redis服务器崩溃 Redis集群呈现崩塌，集群瓦解 应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃 应用服务器，redis，数据库全部重启，效果不理想 问题分析 短时间范围内 大量key集中过期 解决方案（道） 更多的页面静态化处理 构建多级缓存架构【Nginx缓存+redis缓存+ehcache缓存】 检测Mysql严重耗时业务进行优化【对数据库的瓶颈排查：例如超时查询、耗时较高事务等】 灾难预警机制 监控redis服务器性能指标 CPU占用、CPU使用率 内存容量 查询平均响应时间 线程数 限流、降级 短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问 解决方案（术） LRU与LFU切换 数据有效期策略调整 根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟 过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量 超热数据使用永久key 定期维护（自动+人工） 对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时 加锁 慎用！ 12.3缓存击穿 缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服 务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度 较高，配合雪崩处理策略即可 现象 系统平稳运行过程中 数据库连接量瞬间激增 Redis服务器无大量key过期 Redis内存平稳，无波动 Redis服务器CPU正常 数据库崩溃 问题排查 Redis中某个key过期，该key访问量巨大 多个数据请求从服务器直接压到Redis后，均未命中 Redis在短时间内发起了大量对数据库中同一数据的访问 问题分析 单个key高热数据 key过期 解决方案（术） 预先设定 以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长 注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势 现场调整 监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key 后台刷新数据 启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失 二级缓存 设置不同的失效时间，保障不会被同时淘汰就行 加锁 分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！ 12.4缓存穿透 缓存击穿访问了根本不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。 通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。 无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。 现象 系统平稳运行过程中 应用服务器流量随时间增量较大 Redis服务器命中率随时间逐步降低 Redis内存平稳，内存无压力 Redis服务器CPU占用激增 数据库服务器压力激增 数据库崩溃 问题排查 获取的数据在数据库中也不存在，数据库查询未得到对应数据 Redis获取到null数据未进行持久化，直接返回 下次此类数据到达重复上述过程 出现黑客攻击服务器 问题分析 Redis中大面积出现未命中 出现非正常URL访问 解决方案（术） 缓存null【对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟】 白名单策略 提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放 行，加载异常数据时直接拦截（效率偏低） 使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略） 实施监控【实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比】 非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象 活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象 根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营） key加密 问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验 例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问 12.5性能指标监控 性能指标：Performance Name Description latency Redis响应一个请求的时间 instantaneous_ ops_per_sec 平均每秒处理请求总数 hit rate (calculated) 缓存命中率(计算出来的) 内存指标：Memory Name Description used_memory 已使用内存 mem_fragmentation_ratio 内存碎片率 evicted_keys 由于最大内存限制被移除的key的数量 blocked_clients 由于BLPOP, BRPOP, or BRPOPLPUSH而备阻塞的客户端 基本活动指标：Basic activity Name Description connected_clients 客户端连接数 connected_slaves Slave数量 master_last_io_seconds_ago 最近一次主从交互之后的秒数 keyspace 数据库中的key值总数 持久性指标：Persistence Name description rdb_last_save_time 最后一次持久化保存到磁盘的时间戳 rdb_changes_since_last_save 自最后一次持久化以来数据库的更改数 错误指标：Error Name Description rejected_ connections 由于达到maxclient限制而被拒绝的连接数 keyspace_misses Key值查找失败(没有命中)次数 master_ link_down_since_seconds 主从断开的持续时间(以秒为单位) 监控方式 工具 Cloud Insight Redis Prometheus Redis-stat Redis-faina RedisLive zabbix 命令 benchmark【指令】 monitor【redis cli指令】 showlog【redis cli指令】 179.redis 是什么？都有哪些使用场景？ redis用于控制数据库表主键id ,为数据库表主键提供生成策略,保障数据库表的主键唯一性 redis 控制数据的生命周期,通过数据是否失效控制业务行为,适用于所有具有时效性限定控制的操作——setex redis应用于各种结构型和非结构型高热度数据访问加速——String redis应用于购物车数据存储设计——hash redis应用于抢购,限购类、限量发放优惠卷、激活码等业务的数据存储设计——hash redis应用于具有操作先后顺序的数据控制——list redis应用于最新消息展示——list redis应用于随机推荐类信息检索,例如热点歌单推荐,热点新闻推荐,热卖旅游线路,应用APP推荐,大V推荐等——set redis应用于同类信息的关联搜索,二度关联搜索,深度关联搜索——set redis应用于同类型不重复数据的合并操作——set redis应用于计数器组合排序功能对应的排名——sorted_set redis应用于定时任务执行顺序管理或任务过期管理 redis应用于即时任务/消息队列执行管理 redis应用于按次结算的服务控制 redis应用于基于时间顺序的数据操作,而不关注具体时间 180.redis 有哪些功能？ 181.redis 和 memecache 有什么区别？ 182.redis 为什么是单线程的？ 183.什么是缓存穿透？怎么解决？ 184.redis 支持的数据类 型有哪些？ 185.redis 支持的 java 客户端都有哪些？ 186.jedis 和 redisson 有哪些区别？ 187.怎么保证缓存和数据库数据的一致性？ 188.redis 持久化有几种方式？ 189.redis 怎么实现分布式锁？ 190.redis 分布式锁有什么缺陷？ 191.redis 如何做内存优化？ 192.redis 淘汰策略有哪些？ 193.redis 常见的性能问题有哪些？该如何解决？","tags":[{"name":"Redis","slug":"Redis","permalink":"http://goldcarpenter.github.io/tags/Redis/"}]},{"title":"Redis","date":"2020-04-03T16:00:00.000Z","path":"2020/04/04/Redis_Part2/","text":"2.Jedis Java程序操作Redis的工具 Jedis SpringData Redis Lettuce 2.1Jedis入门程序 pom.xml 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; JedisTest 1234567891011121314151617package top.carpenter;import org.junit.Test;import redis.clients.jedis.Jedis;public class JedisTest &#123; @Test public static void main(String[] args) &#123; &#x2F;&#x2F; 1.连接Redis Jedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;, 6379); &#x2F;&#x2F; 2.操作Redis——与终端操作方法一致 jedis.set(&quot;name&quot;,&quot;carpenter&quot;); System.out.println(jedis.get(&quot;name&quot;)); &#x2F;&#x2F; 3.关闭连接 jedis.close(); &#125;&#125; 2.2Jedis读写redis数据 案例：服务调用次数控制 服务免费开放给企业试用，对试用用户的使用行为进行限速，限制每个用户每分钟最多发起10次调用 案例要求①设定A、B三个用户②A用户限制10次/分调用, B用户限制30次/分调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package top.carpenter;import org.junit.Test;import redis.clients.jedis.Jedis;import redis.clients.jedis.exceptions.JedisDataException;import java.util.Random;public class JedisTest &#123; public static final Integer EXPAIRTIME = 300; @Test public static void main(String[] args) &#123; MyThread mt1 = new MyThread(\"初级用户\",new Integer(10)); MyThread mt2 = new MyThread(\"高级用户\",30); mt1.start() ; mt2.start() ; &#125;&#125;class MyThread extends Thread&#123; private Service service; public MyThread(String id,Integer num)&#123; service = new Service(id,num); &#125; public void run()&#123; while(true)&#123; service.service(); try&#123; Random r = new Random(); Thread.sleep(1000+ r.nextInt(200)); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class Service&#123; private String id; private Integer num; public Service(String id, Integer num) &#123; this.id = id; this.num = num; &#125; // 模拟服务内容 void business (String id, long num)&#123; System.out.println (\"用户\"+id+\"发起业务调用,当前第\"+num+\"次\"); &#125; void service () &#123; Jedis jedis = new Jedis(\"localhost\",6379); String value = jedis.get(\"compid:\" + id); try &#123; // 判断值是否存在 if (value == null) &#123; // 不存在 则创建该值 jedis.setex(\"compid:\" + this.id,JedisTest.EXPAIRTIME, \"\"+(Long.MAX_VALUE-this.num)); &#125;else &#123; // 存在 自增 调用业务 Long val = jedis.incr(\"compid:\" + id); business(id, this.num + val - Long.MAX_VALUE); &#125; &#125; catch (JedisDataException e) &#123; System.out.println(\"用户: \" + id + \"使用次数已达上限，请稍后再试或升级VIP会员\"); &#125; finally &#123; jedis.close(); &#125; &#125;&#125; 2.3Jedis连接池 JedisPool: Jedis提供的连接池技术 poolConfig:连接池配置对象 host:redis服务地址 port:redis服务端口号 123public JedisPool (GenericObjectPoolConfig poolConfig, String host,int port) &#123; this(poolConfig, host, port, 2000，(String)null, 0,(String) null);&#125; 实现 123456789101112131415161718192021222324252627282930package top.carpenter;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import java.util.ResourceBundle;public class JedisUtils &#123; private static JedisPool jp = null; private static String host = null; private static int port; private static int maxTotal ; private static int maxIdle; static &#123; ResourceBundle rb = ResourceBundle.getBundle(\"redis\" ); host = rb. getString(\"redis.host\"); port = Integer.parseInt(rb. getString(\"redis.port\")); maxTotal = Integer.parseInt(rb. getString( \"redis.maxTotal\")); maxIdle = Integer. parseInt(rb. getString( \"redis.maxIdle\")); JedisPoolConfig jpc = new JedisPoolConfig(); jpc.setMaxTotal (maxTotal); jpc.setMaxIdle(maxIdle); jp = new JedisPool(jpc ,host,port); &#125; public static Jedis getJedis() &#123; return jp.getResource(); &#125;&#125; 3.基于Linux的Redis3.1Redis启动 默认配置启动【企业开发不用】 12redis-serverredis-server --port 6380 [更换端口启动] 123redis-cli redis-cli -p 6380 [更换端口启动]redis-cli -h 127.0.0.1 [更换host] 使用配置文件启动 1redis-server config&#x2F;redis-6380.conf redis.conf 12345678# 以守护进程方式启动，redis将以服务的形式存在，日志不再打印到命令窗口daemonize yes # 设定当前服务启动端口号port 6380# 设定当前服务文件保存位置，包含日志文件、持久化文件(后面详细讲解)等dir \"/[自定义目录]/redis/data\"#设定日志文件名，便于查阅logfile \"***.log ” 配置文件 dbfilename dump.rdb说明：设置本地数据库文件名，默认值为 dump.rdb 经验：通常设置为dump-端口号.rdb dir说明：设置存储.rdb文件的路径 经验：通常设置成存储空间较大的目录中，目录名称data rdbcompression yes 说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩 经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大） rdbchecksum yes说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行 经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险 stop-writes-on-bgsave-error yes说明：后台存储过程中如果出现错误现象，是否停止保存操作 经验：通常默认为开启状态 appendonly yes|no说明：是否开启AOF持久化功能 默认为不开启状态 appendfsync always|everysec|no 说明：AOF写数据策略 appendfilename filename说明：AOF持久化文件名，默认文件名appendonly.aof 建议配置为appendonly-端口号.aof 4.Redis持久化 什么是持久化 利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化 为什么要进行持久化 防止数据的意外丢失，确保数据安全性 持久化过程保存什么 将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据 将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程 4.1RDB方案4.1.1RDB启动方式——save指令 手动执行一次保存操作 1save 本地生成***.rdb的文件，保存生产的快照信息 注意: save指令的执行会阻塞当前Redis服务器，直到当前RDB过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用。 4.1.2RDB启动方式 —— bgsave指令命令 手动启动后台保存操作，但不是立即执行 1bgsave 注意: bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用。 4.1.3RDB启动方式——save配置 满足限定时间范围内key的变化数量达到指定数量即进行持久化 1save second changes second：监控时间范围 changes：监控key的变化量 位置：在conf文件中进行配置 注意： save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的 save配置中对于second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系 save配置启动后执行的是bgsave操作 4.1.4对比 方式 save指令 bgsave指令 读写 同步 异步 阻塞客户端指令 是 否 额外内存消耗 否 是 启动新进程 否 是 4.1.5RDB特殊启动形式 全量复制 在主从复制中详细讲解 服务器运行过程中重启 1debug reload 关闭服务器时指定保存数据 1shutdown save 4.1.6优点 &amp; 缺点 RDB优点 RDB是一个紧凑压缩的二进制文件，存储效率较高 RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景 RDB恢复数据的速度要比AOF快很多 应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。 Rdb缺点 RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据 bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能 Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象 4.2AOF方案4.2.1引入 RDB存储的弊端 存储数据量较大，效率较低【基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低】 大数据量下的IO性能较低 基于fork创建子进程，内存产生额外消耗 宕机带来的数据丢失风险 解决思路 写全数据，仅记录部分数据 改记录数据为记录操作过程 对所有操作均进行记录，排除丢失数据的风险 4.2.2AOF概念 以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程 作用：解决了数据持久化的实时性，目前已经是Redis持久化的主流方式 AOF写数据三种策略(appendfsync) always(每次）每次写入操作均同步到AOF文件中，数据零误差，性能较低，不建议使用。 everysec（每秒）每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，性能较高，建议使用，也是默认配置 在系统突然宕机的情况下丢失1秒内的数据 no（系统控制）由操作系统控制每次同步到AOF文件的周期，整体过程不可控 4.2.3AOF重写 随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。 AOF文件重写：将Redis进程内的数据转化为写命令同步到新AOF文件的过程。【将对同一个数据的若干个条命令执行结果转化成最终结果数据对应的指令进行记录。】 作用 降低磁盘占用量，提高磁盘利用率 提高持久化效率，降低持久化写时间，提高IO性能 降低数据恢复用时，提高数据恢复效率 4.2.4AOF重写规则 进程内已超时的数据不再写入文件 忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令 如del key1、 hdel key2、srem key3、set key4 111、set key4 222等 对同一数据的多条写命令合并为一条命令 如lpush list1 a、lpush list1 b、 lpush list1 c可以转化为：lpush list1 a b c。 为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素 4.2.5AOF重写方式 手动重写 1bgrewriteaof bgrewriteaof指令工作原理 自动重写 自动重写触发条件设置 12auto-aof-rewrite-min-size [size] auto-aof-rewrite-percentage [percentage] 自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ） 12aof_current_sizeaof_base_size 自动重写触发条件 4.2.6AOF工作流程 4.3AOF &amp; RDB对比 对数据非常敏感，建议使用默认的AOF持久化方案 AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。 注意：由于AOF文件存储体积较大，且恢复速度较慢 数据呈现阶段有效性，建议使用RDB持久化方案 数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段 点数据恢复通常采用RDB方案 注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重总结： 综合比对 RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊 如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF 如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB 灾难恢复选用RDB 双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量 4.4持久化应用场景 Tips 1：redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性【从DB读取最大】 Tips 3：redis应用于各种结构型和非结构型高热度数据访问加速【从DB读取】 Tips 4：redis 应用于购物车数据存储设计【从DB读取】 Tips 5：redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计 Tips 6：redis 应用于具有操作先后顺序的数据控制【用MQ】 Tips 7：redis 应用于最新消息展示【用RQ】 Tips 9：redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索【从DB读取】 Tips 12：redis 应用于基于黑名单与白名单设定的服务控制【长期】【从DB读取】 Tips 12：redis 应用于基于黑名单设定的服务控制【短期】 Tips 13：redis 应用于计数器组合排序功能对应的排名 Tips 15：redis 应用于即时任务/消息队列执行管理【用MQ】 Tips 16：redis 应用于按次结算的服务控制 5.Redis事务概念 redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性 按照添加顺序依次执行，中间不会被打断或者干扰。 一个队列中，一次性、顺序性、排他性的执行一系列命令 事务的基本操作 开启事务 设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中 1multi 执行事务 设定事务的结束位置，同时执行事务。与multi成对出现，成对使用 1exec 取消事务 终止当前事务的定义，发生在multi之后，exec之前 1discard 注意：加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行 事务的工作流程 注意事项 定义事务的过程中，命令格式输入错误怎么办？ 语法错误：命令书写格式有误 处理结果 如果定义的事务中所包含的命令存在语法错误，整体事务中所有命令均不会执行。包括那些语法正确的命令。 定义事务的过程中，命令执行出现错误怎么办？ 运行错误：命令格式正确，但是无法正确的执行。例如对list进行incr操作 能够正确运行的命令会执行，运行错误的命令不会被执行 已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚。 基于特定条件的事务执行 多个客户端有可能同时操作同一组数据，并且该数据一旦被操作修改后，将不适用于继续操作 在操作之前锁定要操作的数据，一旦发生变化，终止当前操作 对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行 1watch key1 [key2……] watch 不能在multi命令之后 取消对所有 key 的监视 1unwatch 业务场景 redis 应用基于状态控制的批量任务执行 6.Redis 删除策略6.1过期数据 Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态 XX ：具有时效性的数据 -1 ：永久有效的数据 ：已经过期的数 -2 ：已经过期的数据 或 被删除的数据 或 未定义的数据 6.2数据删除策略6.2.1时效性数据的存储结构 6.2.2数据删除策略的目标在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露 6.2.3定时删除 创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作 优点：节约内存，到时就删除，快速释放掉不必要的内存占用 缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量 总结：用处理器性能换取存储空间 （拿时间换空间） 6.2.4惰性删除 数据到达过期时间，不做处理。等下次访问该数据时 如果未过期，返回数据 发现已过期，删除，返回不存在 优点：节约CPU性能，发现必须删除的时候才删除 缺点：内存压力很大，出现长期占用内存的数据 总结：用存储空间换取处理器性能 （拿时间换空间） 6.2.5定期删除 Redis启动服务器初始化时，读取配置server.hz的值，默认为10 每秒钟执行server.hz次serverCron() ​ —-&gt;databasesCron() ​ —-&gt;activeExpireCycle() activeExpireCycle()对每个expires[*]逐一进行检测，每次执行250/server.hzms 对某个expires[*]检测时，随机挑选W个key检测 如果key超时，删除key 如果一轮中删除的key的数量&gt;W*25%，循环该过程 如果一轮中删除的key的数量≤W*25%，检查下一个expires[\\*]，0-15循环 W=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值 参数current_db用于记录activeExpireCycle()进入哪个expires[*]执行。如果activeExpireCycle()执行时间到期，下次从current_db继续向下执行 周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度 特点1：CPU性能占用设置有峰值，检测频度可自定义设置 特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理 总结：周期性抽查存储空间（随机抽查，重点抽查） 6.3逐出算法 Redis使用内存存储数据，在执行每一个命令前，会调用freeMemoryIfNeeded()检测内存是否充足。 逐出算法：如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略即为逐出算法。 注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。 最大可使用内存，占用物理内存的比例，默认值为0，表示不限制 1maxmemory [] 生产环境中根据需求设定，通常设置在50%以上。 每次选取待删除数据的个数，选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据 1maxmemory-samples [] 删除策略，达到最大内存后的，对被挑选出来的数据进行删除的策略 1maxmemory-policy [] 检测易失数据（可能会过期的数据集server.db[i].expires ） ① volatile-lru：挑选最近最少使用的数据淘汰 ② volatile-lfu：挑选最近使用次数最少的数据淘汰 ③ volatile-ttl：挑选将要过期的数据淘汰 ④ volatile-random：任意选择数据淘汰 检测全库数据（所有数据集server.db[i].dict ） ⑤ allkeys-lru：挑选最近最少使用的数据淘汰 ⑥ allkeys-lfu：挑选最近使用次数最少的数据淘汰 ⑦ allkeys-random：任意选择数据淘汰 放弃数据驱逐 ⑧ no-enviction（驱逐）：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out Of Memory）","tags":[{"name":"Redis","slug":"Redis","permalink":"http://goldcarpenter.github.io/tags/Redis/"}]},{"title":"Nginx","date":"2020-03-28T16:00:00.000Z","path":"2020/03/29/Nginx基础/","text":"Nginx1 Nginx简介 Nginx是开源，高性能，高可靠的Http Web服务、代理服务、负载均衡 高性能：支持海量并发，有报告表明能支持高达50, 000个并发连接数 可靠：服务稳定 轻量：占用内存资源少 Nginx优点 轻量级 功能模块少（源代码仅保留http与核心模块代码,其余不够核心代码会作为插件来安装） 代码模块化（易读，便于二次开发，对于开发人员非常友好） 技术成熟，国内公司基本大规模使用 适合当前主流架构趋势，微服务、云架构、中间层 统一技术栈，降低维护成本，降低技术更新成本 Nginx采用Epoll网络模型，Apache 采用select模型 select：当用户发起一次请求，select模型就会进行一次遍历扫描， 从而导致性能低下 Epoll：当用户发起请求，epool模型会直接进行处理，效率高效，并无连接限制 常用的HTTP Web服务 Httpd——Apache基金会 IIS——微软服务器版 GWS——Google开发 Openrestry——基于Nginx+lua Tengline——淘宝基于Nginx开发 2 Nginx应用场景 正向代理 正向代理：在客户端(浏览器)配置代理服务器，通过代理服务器进行互联网访问 反向代理 我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器， 暴露的是代理服务器地址,隐藏了真实服务器IP地址 负载均衡 增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器。 动静分离 为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。 Nginx安装方式 官方源 ——官方编译好的，封装成rpm包，并提供yum源【推荐】 nginx.org 官网有详细过程[http://nginx.org/en/download.html] 配置Nginx官方yum仓库 123456[root@web01 ~]# vim /etc/yum.repos.d/nginx.repo [nginx] name=nginx repo baseurl=http://nginx.org/packages/centos/7/$basearch/ gpgcheck=0 enabled=1 安装nginx，必须安装官方源的nginx 123[root@web01 ~]# yum install -y nginx[root@web01 ~]# nginx -v # 查询是否成功 nginx version: nginx/1.14.0 访问网址 查询是否成功 EPEL源——版本低，功能少 源代码——自己下载源代码，安装复杂，费时 123如果企业之前的Nginx都是通过源码安装，这时需要我们部署新的Nginx服务器，怎么接手通过源代码方式安装通过nginx -v 获得版本通过nginx -V 查看配置选项 Nginx常用命令 查看nginx的版本号 1nginx -v 启动nginx 1nginx 关闭nginx 1nginx -s stop 重新加载nginx 1nginx -s reload 配置文件语法检测 1nginx -t ​ Nginx配置文件 Nginx主配置文件 1234&#x2F;etc&#x2F;nginx&#x2F;etc&#x2F;nginx&#x2F;nginx.conf&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf Cgi、Fastcgi、 Uwcgi配置文件 123&#x2F;etc&#x2F;nginx&#x2F;fastcgi_params&#x2F;etc&#x2F;nginx&#x2F;scgi_params&#x2F;etc&#x2F;nginx&#x2F;uwsgi_params Nginx编码转换映射文件 123&#x2F;etc&#x2F;nginx&#x2F;win-utf&#x2F;etc&#x2F;nginx&#x2F;koi-utf&#x2F;etc&#x2F;nginx&#x2F;koi-win http协议的Content-Type与扩展名 1&#x2F;etc&#x2F;nginx&#x2F;mime.types 配置系统守护进程管理器 1&#x2F;usr&#x2F;1ib&#x2F;systemd&#x2F;system&#x2F;nginx.service Nginx日志轮询，日志切割 1&#x2F;etc&#x2F;logrotate.d&#x2F;nginx Nginx终端管理命令 12&#x2F;usr&#x2F;sbin&#x2F;nginx&#x2F;usr&#x2F;sbin&#x2F;nginx-debug Nginx模块目录 123&#x2F;etc&#x2F;nginx&#x2F;modules&#x2F;usr&#x2F;1ib64&#x2F;nginx&#x2F;usr&#x2F;1ib64&#x2F;nginx&#x2F;modules Nginx默认站点目录 1234&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;50x.html&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html Nginx的帮助手册 12&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.14.0&#x2F;usr&#x2F;share&#x2F;man&#x2F;man8&#x2F;nginx.8.gz Nginx的缓存目录 1&#x2F;var&#x2F;cache&#x2F;nginx Nginx的日志目录 1&#x2F;var&#x2F;log&#x2F;nginx Nginx主配置文件 nginx.conf是一个纯文本类型的文件，整个配置文件是以区块的形式组织的。每个区块以一对大括号{}来表示开始与结束 CoreModule核心模块 从配置文件开始到events块之间的内容 主要会设置一些影响nginx服务器整体运行的配置指令，主要包括配置运行Nginx服务器的用户(组)、允许生成的worker process数，进程PID存放路径、日志存放路径和类型以及配置文件的引入等。 1234user nginx; #Nginx进程所使用的用户worker_processes 1; #Nginx运行的work进程数量(建议与CPU数量一致或auto)error_log &#x2F;1og&#x2F;nginx&#x2F;error.1og; #Nginx错误日志存放路径pid &#x2F;var&#x2F;run&#x2F;nginx.pid; #Nginx服务运行后产生的pid进程号 EventModule 事件驱动模块 影响Nginx服务器与用户的网络连接 常用的设置包括是否开启对多work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个word process可以同时支持的最大连接数等。 对Nginx的性能影响较大，在实际中应该灵活配置 1234events &#123; worker_connections 1024; #每个worker进程支持的最大连接数 use epool; #事件驱动模型，epoll默认&#125; HttpCoreModule http内核模块 Nginx服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 http内核模块 http全局块 server 块 12345678910111213141516171819202122232425http &#123; # http全局块 ... #使用server配置网站，每个Server&#123;&#125;代表一个网站(简称虛拟主机) server&#123; listen 80; #监听端口，默认80 server_name localhost; #提供服务的域名或主机名 access_log host.access.1og #访问日志 #控制网站访问路径 location / &#123; root /usr/share/nginx/html; //存放网站 代码路径 index index.php index.html index.htm; //服务器返回的默认页面文件 //指定错误代码，统一定义错误页面，错误代码重定向到新的Locaiton error_page 500 502 503 504 /50x.html; &#125; #第二个虚拟主机配置 server&#123; ... &#125; include /etc/nginx/conf.d/*.conf; #其他附加配置文件&#125; http全局块 http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。 server 块 HTTP模块层允许有多个Server块 Server主要 用于配置多个网站 Server块又允许有多个Location Location主要用于定义网站访问路径 location指令详解123location [ &#x3D; | ~ | ~* | ^~ ] uri&#123; ...&#125; 没有修饰符：必须以指定模式开始，如： 123456789101112server &#123; server_name baidu.com; location &#x2F;abc &#123; …… &#125;&#125;那么，如下是对的：http:&#x2F;&#x2F;baidu.com&#x2F;abchttp:&#x2F;&#x2F;baidu.com&#x2F;abc?p1http:&#x2F;&#x2F;baidu.com&#x2F;abc&#x2F;http:&#x2F;&#x2F;baidu.com&#x2F;abcde =：用于不含正则表达式的uri前，要求请求字符串与uri严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。 123456789101112server &#123;server_name sish location &#x3D; &#x2F;abc &#123; …… &#125;&#125;那么，如下是对的：http:&#x2F;&#x2F;baidu.com&#x2F;abchttp:&#x2F;&#x2F;baidu.com&#x2F;abc?p1如下是错的：http:&#x2F;&#x2F;baidu.com&#x2F;abc&#x2F;http:&#x2F;&#x2F;baidu.com&#x2F;abcde ~ ： 用于表示uri包含正则表达式，并且区分大小写。 12345678910111213server &#123; server_name baidu.com; location ~^ &#x2F;abc$ &#123; …… &#125;&#125;那么，如下是对的：http:&#x2F;&#x2F;baidu.com&#x2F;abchttp:&#x2F;&#x2F;baidu.com&#x2F;abc?p1&#x3D;11&amp;p2&#x3D;22如下是错的：http:&#x2F;&#x2F;baidu.com&#x2F;ABChttp:&#x2F;&#x2F;baidu.com&#x2F;abc&#x2F;http:&#x2F;&#x2F;baidu.com&#x2F;abcde ~*：用于表示uri包含正则表达式，并且不区分大小写。 12345678910111213server &#123;server_name baidu.com;location ~* ^&#x2F;abc$ &#123; …… &#125;&#125;那么，如下是对的：http:&#x2F;&#x2F;baidu.com&#x2F;abchttp:&#x2F;&#x2F;baidu..com&#x2F;ABChttp:&#x2F;&#x2F;baidu..com&#x2F;abc?p1&#x3D;11&amp;p2&#x3D;22如下是错的：http:&#x2F;&#x2F;baidu..com&#x2F;abc&#x2F;http:&#x2F;&#x2F;baidu..com&#x2F;abcde ^~：用于不含正则表达式的 uri前，无修饰符的行为，也是以指定模式开始，不同的是，如果模式匹配，那么就停止搜索其他模式了。 注意：如果uri包含正则表达式，则必须要有~或者~*标识 root &amp; alias指令区别 alias是一个目录别名的定义，root则是最上层目录的定义。 若按照上述配置的话，则访问/img/目录里面的文件时，ningx会自动去/var/www/image/目录找文件 123location &#x2F;img&#x2F; &#123; alias &#x2F;var&#x2F;www&#x2F;image&#x2F;;&#125; #若按照这种配置的话，则访问/img/目录下的文件时，nginx会去/var/www/image/img/目录下找文件 123location &#x2F;img&#x2F; &#123; root &#x2F;var&#x2F;www&#x2F;image;&#125; 还有一个重要的区别是alias后面必须要用“/”结束，否则会找不到文件，而root则可有可无 Nginx搭建Web服务器 Nginx可以作为静态页面的web服务器，同时还支持CGI协议的动态语言，比如perl、php等。但是不支持Java，Java程序只能通过与tomcat配合完成 Nginx配置Web服务器网站【功能同Apache的Tomcat】——接收客户请求端请求，并响应 功能：当我们访问game.oldboy.com的时候，访问/oldboy_code/里面的页面代码 1234567server&#123; listen 80; server_name yangyuxin.top; index index.php index.html index.htm default.php default.htm default.html; root &#x2F;www&#x2F;wwwroot&#x2F;yangyuxin.top; # 静态页面所在目录&#125; Nginx反向代理 功能：使用Nginx从80端口跳转到8080端口的Tomcat主页 12345678910server &#123; listen 80; server_name yangyuxin.top; location &#x2F; &#123; root html; proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080; &#x2F;&#x2F;⭐ index index.html index.htm; &#125; &#125; 功能：使用 nginx 反向代理，根据访问的路径跳转到不同端口的服务中 123456789101112131415server &#123; listen 80; server_name yangyuxin.top; location ~/hello/ &#123; root html; proxy_pass http://127.0.0.1:8080; index index.html index.htm; &#125; location ~/world/ &#123; root html; proxy_pass http://127.0.0.1:8081; index index.html index.htm; &#125; &#125; Nginx负载均衡 实现效果：浏览器地址栏输入地址负载均衡，按比例均衡到8080和8081端口 1234567891011121314151617upstream myservername&#123; &#x2F;&#x2F;⭐ # ip_hash &#x2F;&#x2F; 每个请求按访问ip的hash结果分配，访客固定访问一个后端服务器,可以解决session的问题。 server 47.92.38.57:8080 weight&#x3D;2; &#x2F;&#x2F;⭐ server 47.92.38.57:8081 weight&#x3D;4; &#x2F;&#x2F;⭐ # fair &#x2F;&#x2F; 按后端服务器的响应时间来分配请求，响应时间短的优先分配。&#125;server &#123; listen 80; server_name yangyuxin.top; location ~&#x2F;hello&#x2F; &#123; root html; proxy_pass http:&#x2F;&#x2F;myservername; &#x2F;&#x2F;⭐ index index.html index.htm; &#125; &#125; Nginx高可用 准备 两台nginx服务器 分别安装keepalived 虚拟ip Keepalived实现高可用 安装 1yum install keepalived -y 安装之后，在etc里面生成目录keepalived, 有文件keepalived.conf 1234567891011121314151617181920212223242526272829303132333435363738global_defs &#123; # 全局配置 notification_email &#123; acassen@firewall.loc failover@firewall.loc sysadmin@firewall.loc &#125; notification_email_from Alexandre.Cassen@firewall.loc smtp_server 192.168.200.1 smtp_connect_timeout 30 router_id LVS_DEVEL # ⭐通过这个名字可以访问主机&#x2F;服务器 &#x2F;etc&#x2F;hosts文件下配置这个名字 vrrp_skip_check_adv_addr vrrp_strict vrrp_garp_interval 0 vrrp_gna_interval 0&#125; vrrp_script chk_http_port &#123; # 脚本配置 script &quot;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_check.sh&quot; interval 2 #(检测脚本执行的间隔) weight 2 # 设置当前服务器权重&#125;vrrp_instance VI_1 &#123; # 虚拟IP配置 state MASTER # 备份服务器改为BACKUP interface eth0 # 网卡 virtual_router_id 51 # 主、备机的virtual_ router_ id必须相同 priority 100 #主、备机取不同的优先级，主机值较大，备份机值较小 advert_int 1 # 心跳时间 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.200.16 #VRRP H虚拟IP 192.168.200.17 192.168.200.18 &#125;&#125; 检测脚本 123456789#! &#x2F;bin&#x2F;bashA&#x3D; &#96;ps -C nginx -no-header| wc -l&#96;if [ $A -eq 0 ];then &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx sleep 2 if [&#96;ps -C nginx --no-header| wc -l&#96; -eq 0]; killall keepalived fifi 把两台服务器上nginx和keepalived启动。 启动nginx 1nginx 启动keepalived 1systemctl start keepalived.services Nginx目录索引模块 官方文档使用说明 1234567891011Nginx 默认是不允许列出整个目录浏览下载Syntax: autoindex on | off;Default: autoindex off;Context: http, server, location# autoindex常用参数autoindex_exact_size off; # 默认为on 显示出文件的确切大小 单位是bytes # 修改为off 显示出文件的大概大小 单位是kB或者MB或者GBautoindex_localtime on; # 默认为off 显示的文件时间为GMT时间 # 修改为on 显示的文件时间为文件的服务器时间charset utf-8,gbk; # 默认中文目录乱码 添加解决乱码 访问game.oldboy.com/download，打开目录索引列表 在配置文件中添加 Nginx状态监控模块 ngx_http_stub_status_module用于展示Nginx连接状态信息 需要–with-http_stub_status_module配置参数启用【nginx -V 查看】 12345678910Syntax: stub_status;Default: —Context: server, location注意:- 如果使用restart重置服务，会清空所有的连接数- reload重载不会清空之前的连接数- 通过状态监控，可以区分长连接和短连接 vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf #修改下面参数 keepalive_timeout 0; #将长连接变为短连接 1234Active connections # 当前活动的连接数accepts 4 # 当前的总连接数TCPhandled 4 # 成功的连接数TCPrequests 61 # 总的http请求数 Nginx访问控制 访问控制分类 基于IP的访问控制http_access_modul 只允许10.0.0.1访问nginx_status,其他都拒绝 1234567891011应用——网站后台# 从上往下依次匹配 满足则停止# 允许配置语法Syntax: allow address | CIDR | unix: | all;Default: —Context: http, server, location, limit_except# 拒绝配置语法Syntax: deny address | CIDR | unix: | all;Default: —Context: http, server, location, limit_except 基于用户登陆认证http_auth_basic_module 身份认证后才可以登录 123456789&#x2F;&#x2F;配置语法Syntax: auth_basic string | off;Default: auth_basic off;Context: http, server, location, limit_except&#x2F;&#x2F;配置语法 用户密码记录配置文件Syntax: auth_basic_user_file file;Default: -Context: http，server, location, limit_except 123&#x2F;&#x2F;需要安装依赖组件[root@web01 ~]# yum install httpd-too1s[root@web01 ~]# htpasswd -b -c &#x2F;etc&#x2F;nginx&#x2F;.auth_conf username 123456 Nginx访问限制 经常会遇到这种情况， 服务器流量异常，负载过大等等。 对于大流量恶意的攻击访问，会带来带宽的浪费， 服务器压力，影响业务，往往考虑对同一个IP的连接数，并发数进行限制 ngx_http_limit_conn_module 模块可以根据定义的key来限制每个键值的连接数，如同一个IP来源的连接数 limit_conn_module连接频率限制 同一IP同一时间只允许有一个连接 12345678910$binary_remote_addr 变量的长度是固定的4字节$remote_addr 变量的长度是7-15字节Syntax: limit_conn_zone key zone&#x3D;name:size;Default: -Context: http;Syntax: limit_conn zone number;Default: —Context: http, server, location 123&#x2F;&#x2F;压力测试yum install -y httpd-toolsab -n 50 -c 20 http:&#x2F;&#x2F;127.0.0.1&#x2F;index.html # 一次50个请求 20个并发 limit_req_module请求频率限制1234567891011Syntax: limit_req_zone key zone&#x3D;name:size rate&#x3D;rate;Default: -Context: httpSyntax: limit_req zone&#x3D;name [burst&#x3D;number] [nodelay | delay&#x3D;number];Default: —Context: http, server, location Syntax: limit_req_status code;Default: 503Context: http, server, location 123定义的区域名称为req_zone（zone&#x3D;req_zone） 分配内存大小为10m（如果限制域的存储空间耗尽了 对于后续所有请求 服务器都会返回503） 同一个ip（$binary_remote_addr）平均处理的请求频率不能超过每秒1次（rate&#x3D;1r&#x2F;s）； 如果超过每秒1次但超过的请求数量小于等于3（burst&#x3D;3）时，会延迟请求。如果超过每秒1次的请求数超过3，则立即返回503（limit_req_status 503）给客户端 请求/连接限制对比 多个请求可以建立在一次的TCP连接之上，那么我们对请求的精度限制，当然比对一个连接的限制会更加的有效，因为同- -时刻只允许一个连接请求进入。但是同一 时刻多个请求可以通过一个 连接进入。所以请求限制才是比较优的解决方案 Nginx原理 master &amp; worker master进程主要负责对外接收客户端的请求，并将活儿合理的分配给多个worker，每个worker进程主要负责处理请求。 master-workers的机制的优点 可以使用 nginx –s reload热部署，利用 nginx进行热部署操作 每个worker进程是独立的进程，不需要加锁，节省锁带来的开销。 每个worker进程互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的worker进程。 设置多少个 woker 合适 Nginx同redis类似都采用了io 多路复用机制，每个worker都是一个独立的进程， 但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求，即使是千上万个请求也不在话下。每个worker的线程可以把一个cpu的性能发挥到极致。所以worker数和服务器的cpu数相等是最为适宜的。设少了会浪费qpu，设多了会造成cgpu频繁切换上下文带来的损耗。 发送请求，占用了 woker 的几个连接数？ 从用户的角度，http 1.1协议下，由于浏览器默认使用两个并发连接,因此计算方法： nginx作为http服务器的时候 1max_clients &#x3D; worker_processes * worker_connections&#x2F;2 nginx作为反向代理服务器的时候： 1max_clients &#x3D; worker_processes * worker_connections&#x2F;4 从一般建立连接的角度：客户并发连接为1. nginx作为http服务器的时候： 1max_clients &#x3D; worker_processes * worker_connections nginx作为反向代理服务器的时候 1max_clients &#x3D; worker_processes * worker_connections&#x2F;2 nginx做反向代理时，和客户端之间保持一个连接，和后端服务器保持一个连接。","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://goldcarpenter.github.io/tags/Nginx/"}]},{"title":"Redis","date":"2020-03-26T00:56:17.000Z","path":"2020/03/26/Redis_Part1/","text":"0.架构 Redis基础 Redis 入门 数据类型 通用命令 Jedis Redis高级 持久化 redis.conf 事务 集群 Redis应用 企业级解决方案 1.Redis1.1NoSQL介绍 网站崩溃现象来源：①海量用户②高并发 罪魁祸首——关系型数据库 性能瓶颈：磁盘IO性能低下 扩展瓶颈：数据关系复杂,扩展性差,不便于大规模集群 解决思路 降低磁盘IO次数,越低越好——内存存储 去除数据间关系，越简单越好——不存储关系，仅存储数据 NoSQL：即Not-OnlySQL(泛指非关系型的数据库） 定位：作为关系型数据库的补充 作用：应对基于海量用户和海量数据前提下的数据处理问题。 特征： 可扩容，可伸缩 大数据量下高性能 灵活的数据模型 高可用 常见Nosql数据库： Redis memcache HBase MongoDB 电商场景解决方案 1.2Redis简介 Redis (Remote Dictionary Server)是一个开源的高性能键值对(key-value) 数据库 特征 数据间没有必然的关联关系 内部采用单线程机制进行工作 高性能。官方提供测试数据, 50个并发执行100000个请求读的速度是110000次/s，写的速度是81000次/s。 多数据类型支持 字符串类型——string 列表类型——list 散列类型——hash 集合类型——set 有序集合类型——sorted_set 持久化支持。可以进行数据灾难恢复（不是主要功能） 应用 为热点数据加速查询(主要场景)， 如热点商品、热点新闻、热点资讯、推广类等高访问量信息等 任务队列，如秒杀、抢购、购票排队等 即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息(聊天室、网站)、设备信号等 时效性信息控制，如验证码控制、投票控制等 分布式数据共享，如分布式集群架构中的session分离 消息队列 分布式锁 1.3Redis下载/安装 Windows：Redis-x64-3.2.100.zip 绿色版，解压即可 解压文件 核心文件 redis-server.exe——服务器启动命令 redis-cli.exe——命令行客户端 redis.windows.conf——redis核心配置文件 redis-benchmarkexe——性能测试工具 redis-check- aof.exe——AOF文件修复工具 redis-check-dump.exe——RDB文件检查工具(快照持久化文件) Redis启动 1.4Redis的基本操作1.4.1信息添加 功能:设置key，value数据 1set key value 1.4.2信息添加 功能:根据key查询对应的value,如果不存在,返回空(nil) 1get key 1.4.3清除屏幕信息 功能:清除屏幕中的信息 1clear 1.4.4帮助信息1help [CMD] 1.4.5退出客户端命令行模式 功能:退出客户端 123quitexit &lt;ESC&gt; 1.5Redis数据类型 Redis自身是一个Map，其中所有的数据都是采用key：value的形式存储 数据类型指的是value的类型【存储的数据类型】，key部分永远都是字符串 Redis数据类型(5种常用） Redis 类比Java string String hash HashMap list LinkedList set HashSet sorted_set TreeSet 1.5.1String类型 存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型 存储数据的格式：一个存储空间保存一个数据 存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用 添加/修改数据 1set key value 获取数据 1get key 删除数据 123del key# (integer) 0 删除失败# (integer) 1 删除成功 添加/修改多个数据 1mset key1 value1 key2 value2 .. 获取多个数据 1mget key1 key2 .. 获取数据字符个数（字符串长度） 12strlen key# (integer) [N长度] 追加信息到原始信息后部（如果原始信息存在则追加，否则新建） 1append key value 注意事项 数据操作不成功的反馈与数据正常操作之间的差异①表示运行结果是否成功 (integer)0 →false 失败 (integer)1 →true成功 ②表示运行结果值 (integer)3 →3 3个 (integer)1 →1 1个 数据未获取到——(nil)等同于null 数据最大存储量——512MB 应用场景1 大型企业级应用中，分表操作是基本操作，使用多张表存储同类型数据，但是对应的主键id必须保证统一性, 不能重复。MySQL数据库并不具有类似的机制，那么如何解决? 答：Redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性。此方案适用于所有数据库，且支持数据库集群 设置数值数据增加指定范围的值 123incr keyincrby key increment [increment可以为负]incrbyfloat key increment 设置数值数据减少指定范围的值 12decr keydecrby key increment String在Redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算 redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。 注意:按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis数值上限范围，将报错。【9223372036854775807（Java中Long型数据最大值，Long.MAX_VALUE）】 应用场景2 微信每4小时只能投1票/商品热门期维持3天自动取消热门/自动控制热点新闻的时效性 答：Redis控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作 设置数据具有指定的生命周期 12setex key seconds valuepsetex key milliseconds value 超时则抹去Id，存在则禁止重复投票 应用场景3 高频访问信息显示控制，例如新浪微博大V主页显示粉丝数与微博数量 在redis中为大V用户设定用户信息，以用户主键和属性值作为key，后台设定定时刷新策略即可 数据库中的热点数据命名惯例【大部分数据还是从数据库中来】 123set user:id:3506728370:fans 12210947set user:id:3506728370:blogs 6164set user:id:3506728370:focus 83 在redis中以json格式存储大V用户信息，定时刷新(也可以使用hash类型) 1set user:id:3506728370 &#123;id:3506728370, fans:12210862, blogs:6164, focus:83&#125; 答：redis应用于各种结构型和非结构型高热度数据访问加速 1.5.2Hash类型 对象类数据用String类型以json格式存储，如果具有较频繁的更新需求操作会显得笨重 新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用是存储对象信息 需要的存储结构: 一个存储空间保存多个键值对数据【感觉就像是Map套Map】 hash类型：底层使用哈希表结构实现数据存储 如果field数量较少，存储结构优化为类数组结构 如果field数量较多，存储结构使用HashMap结构 添加/修改数据 1hset key field value 获取数据 1234hget key fieldhgetall keyhkeys key [获取的到的field字段]hvals key [获取的到的value字段] 删除数据 1hdel key field1 [field2] 添加/修改多个数据 1hmset key field1 value1 field2 val 获取多个数据 1hmget key field1 field2 获取哈希表中字段的数量 1hlen key 获取哈希表中是否存在指定的字段 1hexists key field 设置指定字段的数值数据增加指定范围的值 12hincrby key field incrementhincrbyfloat key field increment 不存在则添加，否则不变 1hsetnx key field value 注意事项 hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为(nil) 每个hash可以存储23^2-1个键值对 hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，切记不可滥用，不可以将hash作为对象列表使用 hgetall操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈 应用场景4 电商网站购物车设计与实现 问题：当前仅仅是将数据存储到了redis中，并没有起到加速的作用，商品信息还需要根据商品id二次查询商品信息的数据库 方案：每条购物车中的商品记录保存成两条field 123field1专用于保存购买数量命名格式:商品id:nums保存数据:数值 123field2专用于保存购物车中显示的信息，包含文字描述，图片地址，所属商家信息等命名格式:商品id:info保存数据: json 问题：商品id:info将因为用户购买相同商品，而重复大量的商品信息 方案：将商品信息单独做成hash 问题：我们一开始不能将所有商品信息都导入Redis，但是用一个加一个则与之前没有区别 方案： 1hsetnx key field value 答：应用于购物车数据存储设计 应用场景5 双11活动日,销售手机充值卡的商家对移动、联通、电信的30元、50元、 100元商品推出抢购活动，每种商品抢购上限1000张 答：redis应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计 补充：String存储对象（Json） VS Hash存储对象 String存在对象讲究整体性，以读为主 Hash存储对象讲究分散性，以写为主 1.5.3List类型 数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分 需要的存储结构：一个存储空间保存够个数据，且通过数据可以体现进入顺序 list类型：保存多个数据，底层使用双向链表存储结构实现 添加/修改数据 12lpush key value1 [value2] ....rpush key value1 [value2] .... 获取数据 123lrange key start stoplindex key indexllen key 获取并移除数据 12lpop keyrpop key 规定时间内获取并移除数据【规定时间内阻塞 队列中有就移除 没有就算了】 12blpop key1 [key2] timeout [block]brpop key1 [key2] timeout 移除指定数据 1lrem key count value 注意事项 list中保存的数据都是string类型的，数据总容量是有限的，最多23^2- 1个元素(4294967295) list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作 获取全部数据操作结束索引设置为-1 list可以对数据进行分页操作，通常第一页的信息来自于list, 第2页及更多的信息通过数据库的形式加载 应用场景6 微信朋友圈点赞，要求按照点赞顺序显示点赞好友信息如果取消点赞，移除对应好友信息 答：redis应用于具有操作先后顺序的数据控制 应用场景7 twitter、新浪微博、腾讯微博中个人用户的关注列表需要按照用户的关注顺序进行展示,粉丝列表需要将最近关注的粉丝列在前面 新闻、资讯类网站如何将最新的新闻或资讯按照发生的时间顺序展示 企业运营过程中,系统将产生出大量的运营数据,如何保障多台服务器操作日志的统一顺序输出 答：redis应用于依赖list的数据具有顺序的特征对信息进行管理，使用队列模型解决多路信息汇总合并的问题，使用栈模型解决最新消息的问题 1.5.5Set类型 新的存储需求：存储大量的数据，在查询方面提供更高的效率 需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询 set类型：与hash存储结构完全相同，仅存储键，不存储值(nil) ，且值不允许重复的 添加数据 1sadd key member1 [member2] 获取全部数据 1smembers key 删除数据 1srem key member1 [member2] 获取集合数据总量 1scard key 判断集合中是否包含指定数据 1sismember key member 随机获取集合中指定数量的数据 1srandmember key [count] 随机获取集合中的某个数据并将该数据移出集合 1spop key 求两个集合的交、并、差集 123sinter key1 [key2]sunion key1 [key2]sdiff key1 [key2] 求两个集合的交、并、差集并存储到指定集合中 123sinterstore destination key1 [key2]sunionstore destination key1 [key2]sdiffstore destination key1 [key2] 将指定数据从原始集合中移动到目标集合中 1smove source destination member 注意事项 set类型不允许数据重复，如果添加的数据在set中已经存在，将只保留一份 set虽然与hash的存储结构相同，但是无法启用hash中存储值的空间 应用场景8 后期为了增加用户的活跃度、兴趣点，必须让用户 对其他信息类别逐渐产生兴趣，增加客户留存度，实现随机推送 答：redis应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等 应用场景9 答：redis应用于同类信息的关联搜索，二度关联搜索，深度关联搜索 显示共同关注(一度) 显示共同好友(一度) 由用户A出发，获取到好友用户B的好友信息列表(一度) 由用户A出发，获取到好友用户B的购物清单列表(二度) 由用户A出发，获取到好友用户B的游戏充值列表(二度) 应用场景10 PV:网站被访问次数，可通过刷新页面提高访问量 UV:网站被不同用户访问的次数,可通过cookie统计访问量, 相同用户切换IP地址，UV不变 IP:网站被不同IP地址访问的总次数，可通过IP地址统计访问量，相同IP不同用户访问，IP不变 建立string类型数据，利用incr统计日访问量(PV) 建立set模型，记录不同cookie数量(UV) 建立set模型，记录不同IP数量(IP) 答：redis应用于同类型数据的快速去重 1.5.6Sorted_set类型 新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式 需要的存储结构：新的存储模型，可以保存可排序的数据 sorted_set类型：在set的存储结构基础上添加可排序字段 添加数据 1zadd key score1 memberl [score2 member2 ] 获取全部数据 12zrange key start stop [WITHSCORES]zrevrange key start stop [WITHSCORES] 删除数据 1zrem key member [member ...] 按条件获取数据 12zrangebyscore key min max [WITHSCORES] [LIMIT OFFSET COUNT]zrevrangebyscore key max min [WITHSCORES] 条件删除数据 12zremrangebyrank key start stopzremrangebyscore key min max 注意: min与max用于限定搜索查询的条件 start与stop用于限定查询范围，作用于索引，表示开始和结束索引 offset与count用于限定查询范围，作用于查询结果，表示开始位置和数据总量 获取集合数据总量 12zcard keyzcount key min max 集合交、并操作【默认合并相加】 12zinterstore destination numkeys key [key ...]zunionstore destination numkeys key [key . ..] 获取数据对应的索引(排名) 12zrank key memberzrevrank key member score值获取与修改 12zscore key memberzincrby key increment member 注意事项 score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992 score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，使用时候要慎重 sorted_set底层存储还是基于set结构的，因此数据不能重复，如果重复添加相同的数据，score值将被反复覆盖，保留最后一次修改的结果 业务场景11 票选广东十大杰出青年，各类综艺选秀海选投票 各类资源网站TOP10(电影，歌曲，文档，电商，游戏等) 聊天室活跃度统计 游戏好友亲密度 答：redis应用于计数器组合排序功能对应的排名 业务场景12 网站会定期开启投票、讨论，限时进行，逾期作废。如何有效管理此类过期信息。 答：redis 应用于定时任务执行顺序管理或任务过期管理 1.6Redis通用命令1.6.1Key通用命令 key是一个字符串， 通过key获取redis中保存的数据 获取key的类型 1type key 获取key是否存在 1exists key 删除指定key 1del key 为指定key设置有效期 1234expire key secondspexpire key millisecondsexpireat key timestamp [时间戳的形式 time命令获取]pexpireat key milliseconds-timestamp 获取key的有效时间 12345ttl key# (integer) -2 过期# (integer) -1 没设置有效期# (integer) N 有效期pttl key 切换key从时效性转换为永久性 123persist key# (integer) 0 失败# (integer) 1 成功 查询key * 匹配任意数量的任意符号? 配合一个任意符号[] 匹配个指定符 1keys [pattern] 123456keys * 查询所有keys it * 查询所有以it开头keys *heima 查询所有以he ima结尾keys ??heima 查 询所有前面两个字符任意，后面以he ima结尾keys user:? 查询所有以user:开头，最后一个字符任意keys u[st]er:1 查询所有以u开头，以er:1结尾， 中间包含一个字母，s或t 为key改名 12rename key newkey [可能覆盖同名key]renamenx key newkey [不会覆盖同名key] 对所有key排序 1sort key [只排序不保存] 其他key通用操作 1help @generic 配置文件设置密码 12config set requirepass &lt;password&gt; config get requirepass 客户端发送命令设置密码 1requirepass &lt;password&gt; 启动客户端设置密码 1redis-cli –a &lt;password&gt; 1.6.2数据库通用命令 redis为每个服务提供有16个数据库，编号从0到15【默认使用select 0】 每个数据库之间的数据相互独立 没有大小 共有同一空间 测试服务器是否连通 1ping 切换数据库 1select [index] 数据移动 目标数据库必须不存在才能成功 1move key dbindex 数据清除 123dbsize [查看key数量]flushdb [删除本库] flushall [删除所有0-15库] 自动重写 自动重写触发条件设置 12auto-aof-rewrite-min-size [size] auto-aof-rewrite-percentage [percentage] 自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ） 12aof_current_sizeaof_base_size 自动重写触发条件 s的高可用，同时实现数据冗余备份。 提供数据方：master 主服务器，主节点，主库，主客户端 接收数据方：slave 从服务器，从节点，从库，从客户端 需要解决的问题： 数据同步 核心工作： master的数据复制到slave中 1588729303276 主从复制 主从复制即将master中的数据即时、有效的复制到slave中 特征：一个master可以拥有多个slave，一个slave只对应一个master 职责： master:①写数据 ②执行写操作时，将出现变化的数据自动同步到slave ③读数据（可忽略） slave:①读数据 ②写数据（禁止） 作用 读写分离：master写、slave读，提高服务器的读写负载能力 负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量 故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复 数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式 高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案","tags":[{"name":"Redis","slug":"Redis","permalink":"http://goldcarpenter.github.io/tags/Redis/"}]},{"title":"JDK8新特性","date":"2020-03-09T16:00:00.000Z","path":"2020/03/10/jdk8新特性_Part3/","text":"Stream流 在Java 8中，得益于Lambda所带来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。 引言传统集合循环遍历的弊端 几乎所有的集合（如 Collection 接口或 Map 接口等）都支持直接或间接的遍历操作 Java 8循环遍历的弊端的Lambda让我们可以更加专注于做什么（What），而不是怎么做（How） for循环的语法就是“怎么做” for循环的循环体才是“做什么” 为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，而并不是从第一个到最后一个顺次处理的循环。前者是目的，后者是方式。 在Java 8之前的做法可能为： 12345678910111213141516171819202122List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"张无忌\");list.add(\"周芷若\");List&lt;String&gt; zhangList = new ArrayList&lt;&gt;();//循环for (String name : list) &#123; if (name.startsWith(\"张\")) &#123; zhangList.add(name); &#125;&#125;List&lt;String&gt; shortList = new ArrayList&lt;&gt;();//循环for (String name : zhangList) &#123; if (name.length() == 3) &#123; shortList.add(name); &#125;&#125;//循环for (String name : shortList) &#123; System.out.println(name);&#125; 每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。循环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使用另一个循环从头开始。 Stream的更优写法下面来看一下借助Java 8的Stream API，什么才叫优雅： 123456789101112 List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"张无忌\"); list.add(\"周芷若\");// list.stream().filter(new Predicate&lt;String&gt;() &#123;// @Override// public boolean test(String s) &#123;// return s.startsWith(\"张\");// &#125;// &#125;) list.stream().filter(name-&gt;name.startsWith(\"张\")) .filter(name-&gt;name.length()==3) .forEach(System.out::println); //方法引用 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印。 代码中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。 1.2 流式思想概述 注意：暂时忘记对传统IO流的固有印象！ 整体来看，流式思想类似于工厂车间的“生产流水线”。 当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先拼好一个“模型”步骤方案，然后再按照方案去执行它。 这张图中展示了过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种“函数模型”。图中的每一个方框都是一个“流”，调用指定的方法，可以从一个流模型转换为另一个流模型。而最右侧的数字 3是最终结果。 这里的filter、map 、skip都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法 count 执行的时候，整个模型才会按照指定策略执行操作。而这得益于Lambda的延迟执行特性。 备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。 Stream（流）是一个来自数据源的元素队列 元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。 数据源/流的来源。 可以是集合，数组等。 和以前的Collection操作不同， Stream操作还有两个基础的特征： Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路(short-circuiting)。 内部迭代： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。 当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结果 1.3 获取流 java.util.stream.Stream&lt;T&gt;是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。） 获取一个流非常简单，有以下几种常用的方式： 所有的Collection集合都可以通过stream默认方法获取流； 1default Stream&lt;E&gt; stream() Stream接口的静态方法of可以获取数组对应的流。 1static &lt;T&gt; Stream&lt;T&gt; of(T... values) 参数是一个可变参数,那么我们就可以传递一个数组 根据Collection获取流 首先，java.util.Collection接口中加入了default方法 stream 用来获取流，所以其所有实现类均可获取流。 123456&#x2F;&#x2F;把集合转换为Stream流List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();Stream&lt;String&gt; stream1 &#x3D; list.stream();Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();Stream&lt;String&gt; stream2 &#x3D; set.stream(); 根据Map获取流java.util.Map 接口不是 Collection 的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况： 123456789101112Map&lt;String,String&gt; map &#x3D; new HashMap&lt;&gt;();&#x2F;&#x2F;获取键,存储到一个Set集合中Set&lt;String&gt; keySet &#x3D; map.keySet();Stream&lt;String&gt; stream3 &#x3D; keySet.stream();&#x2F;&#x2F;获取值,存储到一个Collection集合中Collection&lt;String&gt; values &#x3D; map.values();Stream&lt;String&gt; stream4 &#x3D; values.stream();&#x2F;&#x2F;获取键值对(键与值的映射关系 entrySet)Set&lt;Map.Entry&lt;String, String&gt;&gt; entries &#x3D; map.entrySet();Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream5 &#x3D; entries.stream(); 根据数组获取流 如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法 of ，使用很简单： 1234567&#x2F;&#x2F;把数组转换为Stream流Stream&lt;Integer&gt; stream6 &#x3D; Stream.of(1, 2, 3, 4, 5);&#x2F;&#x2F;可变参数可以传递数组Integer[] arr &#x3D; &#123;1,2,3,4,5&#125;;Stream&lt;Integer&gt; stream7 &#x3D; Stream.of(arr);String[] arr2 &#x3D; &#123;&quot;a&quot;,&quot;bb&quot;,&quot;ccc&quot;&#125;;Stream&lt;String&gt; stream8 &#x3D; Stream.of(arr2); 备注： of 方法的参数其实是一个可变参数，所以支持数组。 1.4 常用方法 流模型的操作很丰富，这里介绍一些常用的API。 这些方法可以被分成两种： 延迟方法：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方 法均为延迟方法。） 终结方法：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调 用。本小节中，终结方法包括 count 和 forEach 方法。 逐一处理：forEach虽然方法名字叫 forEach ，但是与for循环中的“for-each”昵称不同。 1void forEach(Consumer&lt;? super T&gt; action); 该方法接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理。 复习Consumer接口12java.util.function.Consumer&lt;T&gt;接口是一个消费型接口。Consumer接口中包含抽象方法void accept(T t)，意为消费一个指定泛型的数据。 基本使用：1234public static void main(String[] args) &#123; Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); stream.forEach(name‐&gt; System.out.println(name));&#125; 过滤：filter可以通过 filter 方法将一个流转换成另一个子集流。方法签名： 1Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); 该接口接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。 复习Predicate接口此前我们已经学习过 java.util.stream.Predicate 函数式接口，其中唯一的抽象方法为： 1boolean test(T t); 该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的 filter 方法 将会留用元素；如果结果为false，那么 filter 方法将会舍弃元素。 基本使用 Stream流中的 filter 方法基本使用的代码如： 1234public static void main(String[] args) &#123; Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); Stream&lt;String&gt; result &#x3D; original.filter(s ‐&gt; s.startsWith(&quot;张&quot;));&#125; 在这里通过Lambda表达式来指定了筛选的条件：必须姓张。 映射：map如果需要将流中的元素映射到另一个流中，可以使用 map 方法。方法签名： 1&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 该接口需要一个 Function 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。 复习Function接口此前我们已经学习过 java.util.stream.Function 函数式接口，其中唯一的抽象方法为： 1R apply(T t); 这可以将一种T类型转换成为R类型，而这种转换的动作，就称为“映射”。 基本使用 Stream流中的 map 方法基本使用的代码如： 123public static void main(String[] args) &#123; Stream&lt;String&gt; original &#x3D; Stream.of(&quot;10&quot;, &quot;12&quot;, &quot;18&quot;); Stream&lt;Integer&gt; result &#x3D; original.map(str‐&gt;Integer.parseInt(str));&#125; 统计个数：count正如旧集合 Collection 当中的 size 方法一样，流提供 count 方法来数一数其中的元素个数： 1long count(); 该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用 12345public static void main(String[] args) &#123; Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); Stream&lt;String&gt; result &#x3D; original.filter(s ‐&gt; s.startsWith(&quot;张&quot;)); System.out.println(result.count()); &#x2F;&#x2F; 2&#125; 取用前几个：limitlimit 方法可以对流进行截取，只取用前n个。方法签名： 1Stream&lt;T&gt; limit(long maxSize); 参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用 12345public static void main(String[] args) &#123; Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); Stream&lt;String&gt; result &#x3D; original.limit(2); System.out.println(result.count()); &#x2F;&#x2F; &#125; 跳过前几个：skip如果希望跳过前几个元素，可以使用 skip 方法获取一个截取之后的新流： 1Stream&lt;T&gt; skip(long n); 如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用： 12345public static void main(String[] args) &#123; Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); Stream&lt;String&gt; result &#x3D; original.skip(2); System.out.println(result.count()); &#x2F;&#x2F; 1&#125; 组合：concat如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat ： 1static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) 备注：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。 该方法的基本使用代码如： 123456public static void main(String[] args) &#123; Stream&lt;String&gt; stream1 &#x3D; Stream.of(&quot;张三丰&quot;, &quot;张翠山&quot;); String[] arr &#x3D; &#123;&quot;美羊羊&quot;,&quot;喜洋洋&quot;&#125;; Stream&lt;String&gt; stream2 &#x3D; Stream.of(arr); Stream&lt;String&gt; concat &#x3D; Stream.concat(stream1, stream2); &#125; JDK5新特性可变参数 在JDK1.5之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式： … 用在参数上，称之为可变参数。 1修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125; 其实这个书写完全等价与 1修饰符 返回值类型 方法名(参数类型[] 形参名)&#123; &#125; 只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可【简单之处】。 如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。 1234567891011121314151617181920public class ChangeArgs &#123; public static void main(String[] args) &#123; int[] arr = &#123; 1, 4, 62, 431, 2 &#125;; int sum = getSum(arr); System.out.println(sum); // 6 7 2 12 2121 // 求 这几个元素和 6 7 2 12 2121 int sum2 = getSum(6, 7, 2, 12, 2121); System.out.println(sum2); &#125; //可变参数写法 public static int getSum(int... arr) &#123; int sum = 0; for (int a : arr) &#123; sum += a; &#125; return sum; &#125;&#125; JDK9新特性对集合添加的优化通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用，使得代码重复。 123456789public class Demo01 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"abc\"); list.add(\"def\"); list.add(\"ghi\"); System.out.println(list); &#125;&#125; Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。 例子： 1234567891011public class HelloJDK9 &#123; public static void main(String[] args) &#123; Set&lt;String&gt; str1=Set.of(\"a\",\"b\",\"c\"); //str1.add(\"c\");这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合 System.out.println(str1); Map&lt;String,Integer&gt; str2=Map.of(\"a\",1,\"b\",2); System.out.println(str2); List&lt;String&gt; str3=List.of(\"a\",\"b\"); System.out.println(str3); &#125; &#125; 需要注意以下两点： of方法只适用于List接口,Set接口,Map接口,不适用于接接口的实现类 of方法的返回值是一个不能改变的集合,集合不能再使用add,put方法添加元素,会抛出异常 Set接口和Map接口在调用of方法的时候,不能有重复的元素,否则会抛出异常","tags":[{"name":"Java","slug":"Java","permalink":"http://goldcarpenter.github.io/tags/Java/"}]},{"title":"JDK8新特性","date":"2020-02-28T16:00:00.000Z","path":"2020/02/29/jdk8新特性_Part2/","text":"JDK8新特性3.函数式接口3.1概念 函数式接口在Java中是指：有且仅有一个抽象方法的接口 函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。 只有确保接口中有且仅有一个抽象方法 , Java中的Lambda才能顺利地进行推导。 3.2格式 只要确保接口中有且仅有一个抽象方法【可以同时有默认方法、静态方法】 1234修饰符 interface [接口名称] &#123; public abstract 返回值类型 方法名称(可选参数信息); //其他非抽象方法内容&#125; 3.3@FunctionalInterface注解 Java 8中专门为函数式接口引入了一个新的注解@FunctionalInterface 作用：编译阶段可以检测接口是否是一个函数式接口，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。 1234@FunctionalInterface public interface MyFunctionalInterface &#123; void myMethod();&#125; 3.4自定义函数式编程12345678910111213141516171819202122232425// 使用自定义的函数式接口作为方法参数 其实就是传入一个接口作为参数private static void doSomething(MyFunctionalInterface inter) &#123; inter.myMethod(); // 调用自定义的函数式接口方法&#125;public static void main(String[] args) &#123; //传递接口的实现类对象 show(new MyFunctionalInterfaceImpl()); //传递接口的匿名内部类 show(new MyFunctionalInterface() &#123; @Override public void method() &#123; System.out.println(\"使用匿名内部类重写接口中的抽象方法\"); &#125; &#125;); //Lambda表达式 show(()-&gt;&#123; System.out.println(\"使用Lambda表达式重写接口中的抽象方法\"); &#125;); //简化Lambda表达式【去掉&#123;&#125; ; return】 show(()-&gt; System.out.println(\"使用Lambda表达式重写接口中的抽象方法\"));&#125; 2.函数式编程2.1Lambda的延迟执行 有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以作为解决方案，提升性能。 性能浪费的日志案例 典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出： 123456789101112private static void log(int level, String msg) &#123; if (level == 1) &#123; System.out.println(msg); &#125; &#125;public static void main(String[] args) &#123; String msgA = \"Hello\"; String msgB = \"World\"; String msgC = \"Java\"; log(1, msgA + msgB + msgC); &#125; 问题：无论级别是否满足要求，作为 log 方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费。 备注：SLF4J是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行字符串的拼接，而是将字符串的若干部分作为可变参数传入方法中，仅在日志级别满足要求的情况下才会进行字符串拼接。 例如： LOGGER.debug(“变量{}的取值为{}。”, “os”, “macOS”) ，其中的大括号 {} 为占位符。如果满足日志级别要求，则会将“os”和“macOS”两个字符串依次拼接到大括号的位置；否则不会进行字符串拼接。这也是一种可行解决方案，但Lambda可以做到更好。 Lambda的更优写法 使用Lambda必然需要一个函数式接口： 12345@FunctionalInterfaceinterface MessageBuilder&#123; String buildMessage();&#125; 然后对log方法进行改造： 1234567891011121314static void log(int level, MessageBuilder messageBuilder)&#123; if (level == 1) &#123; System.out.println(messageBuilder.buildMessage()); &#125;&#125;public static void main(String[] args) &#123; String msgA = \"Hello\"; String msgB = \"World\"; String msgC = \"Java\"; log(0,()-&gt; &#123; System.out.println(\"Lambda执行！\"); return msgA+msgB+msgC; &#125;);&#125; 只有当级别满足要求的时候，才会进行三个字符串的拼接；否则三个字符串将不会进行拼接。 扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的。 2.2 使用Lambda作为参数和返回值 使用Lambda表达式作为方法参数，其实就是使用函数式接口作为方法参数。 java.lang.Runnable接口就是一个函数式接口，Thread类的构造方法参数使用该接口作为参数，那么就可以使用Lambda进行传参。 123456private static void startThread(Runnable task) &#123; new Thread(task).start();&#125;public static void main(String[] args) &#123; startThread(() ‐&gt; System.out.println(\"线程任务执行！\"));&#125; 使用Lambda表达式作为返回值类型，实就是返回一个函数式接口 当需要通过一个方法来获取一个java.util.Comparator接口类型的对象作为排序器时，就可以调该方法获取。 123456789101112131415161718192021222324252627282930//定义一个方法,方法的返回值类型使用函数式接口Comparatorpublic static Comparator&lt;String&gt; getComparator()&#123; //方法的返回值类型是一个接口,返回这个接口的匿名内部类 /*return new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; //按照字符串的降序排序 return o2.length()-o1.length(); &#125; &#125;;*/ //方法的返回值类型是一个函数式接口,返回一个Lambda表达式 /*return (String o1, String o2)-&gt;&#123; //按照字符串的降序排序 return o2.length()-o1.length(); &#125;;*/ //Lambda表达式 return (o1, o2)-&gt;o2.length()-o1.length();&#125; public static void main(String[] args) &#123; String[] arr = &#123;\"aaa\",\"b\",\"cccccc\",\"dddddddddddd\"&#125;; System.out.println(Arrays.toString(arr));//[aaa, b, cccccc, dddddddddddd] //调用Arrays中的sort方法,对字符串数组进行排序 Arrays.sort(arr,getComparator()); //输出排序后的数组 System.out.println(Arrays.toString(arr)); //[dddddddddddd, cccccc, aaa, b]&#125; 常用函数式接口JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在 java.util.function包中被提供。 下面是最简单的几个接口及使用示例。 Comparator接口 java.util.comparator能实现比较器功能，即比较两个对象谁排在前谁排在后 public int compare(String o1, String o2)：比较其两个参数的顺序。 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序：o1 - o2 &lt; 0 参数列表o1在左侧 则o1 小于o2，返回（负数），相等返回0，o1大于o2返回（正数） 123456789101112131415public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"cba\"); list.add(\"aba\"); list.add(\"sba\"); list.add(\"nba\"); //排序方法 按照第一个单词的降序 Collections.sort(list, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o2.charAt(0) - o1.charAt(0); &#125; &#125;); System.out.println(list); &#125; 对比补充：Comparable[普通接口] 采用的public static &lt;T&gt; void sort(List&lt;T&gt; list)这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下： 1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则固定写死了，那比如我想要字符串按照第一个字符降序排列[默认升序]，那么这样就要修改String的源代码，这是不可能的了，那么这个时候提出了上述的Comparator接口 实现 12345678910111213// 需要写在对比的Pojo类中public class Student implements Comparable&lt;Student&gt;&#123; .... @Override public int compareTo(Student o) &#123; return this.age-o.age;//升序 &#125;&#125;// 写在main业务代码中 ArrayList&lt;Student&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(stu1); arrayList.add(stu2); Collections.sort(arrayList); 对比 1234567// 写在main业务代码中Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o2.getAge()-o1.getAge();//以学生的年龄降序 &#125;&#125;); Comparable[普通接口]和Comparator[函数式接口]区别Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 Comparator：强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。 用 Supplier接口 获取一个泛型参数指定类型的对象数据。 java.util.function.Supplier&lt;T&gt;接口仅包含一个无参的方法：T get()。 Supplier&lt;T&gt;接口被称之为生产型接口，指定接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据 123456789101112131415//定义一个方法,方法的参数传递Supplier&lt;T&gt;接口,泛型执行String,get方法就会返回一个String public static String getString(Supplier&lt;String&gt; sup)&#123; return sup.get(); &#125; public static void main(String[] args) &#123; //调用getString方法,方法的参数Supplier是一个函数式接口,所以可以传递Lambda表达式 String s = getString(()-&gt;&#123; return \"掘金木匠\"; &#125;); System.out.println(s); //掘金木匠 //Lambda表达式 String s2 = getString(()-&gt;\"掘金木匠\"); &#125; 1234567891011121314151617181920public static int getMax(Supplier&lt;Integer&gt; sup)&#123; return sup.get(); &#125; public static void main(String[] args) &#123; int[] arr = &#123;100,0,-50,880,99,33,-30&#125;; //调用getMax方法,方法的参数Supplier是一个函数式接口,所以可以传递Lambda表达式 int maxValue = getMax(()-&gt;&#123; //获取数组的最大值,并返回 int max = arr[0]; for (int i : arr) &#123; if(i&gt;max)&#123; //如果i大于max,则替换max作为最大值 max = i; &#125; &#125; return max; &#125;); System.out.println(\"数组中元素的最大值是:\"+maxValue); &#125; Consumer接口 java.util.function.Consumer&lt;T&gt;接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型决定。 Consumer接口是一个消费型接口,泛型执行什么类型,就可以使用accept方法消费什么类型的数据，至于具体怎么消费(使用),需要自定义(输出,计算….) 抽象方法：accept Consumer接口中包含抽象方法void accept(T t) ，意为消费一个指定泛型的数据。 12345678910111213141516/* 方法的参数传递Consumer接口,泛型使用String 可以使用Consumer接口消费字符串的姓名 */ public static void method(String name, Consumer&lt;String&gt; con)&#123; con.accept(name); &#125; public static void main(String[] args) &#123; //调用method方法,传递字符串姓名,方法的另一个参数是Consumer接口,是一个函数式接口,所以可以传递Lambda表达式 method(\"赵丽颖\",(String name)-&gt;&#123; //消费方式:把字符串进行反转输出 String reName = new StringBuffer(name).reverse().toString(); System.out.println(reName); &#125;); &#125; 默认方法：andThen 如果一个方法的参数和返回值全都是Consumer类型，那么就可以实现效果：消费数据的时候，首先做一个操作， 然后再做一个操作，实现组合。而这个方法就是Consumer接口中的default方法andThen。下面是JDK的源代码： 1234default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123; Objects.requireNonNull(after); return (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125;;&#125; java.util.Objects 的 requireNonNull 静态方法将会在参数为null时主动抛出 NullPointerException 异常。这省去了重复编写if语句和抛出空指针异常的麻烦。 要想实现组合，需要两个或多个Lambda表达式即可，而 andThen 的语义正是“一步接一步”操作。例如两个步骤组 合的情况： 1234567891011121314//定义一个方法,方法的参数传递一个字符串和两个Consumer接口,Consumer接口的泛型使用字符串 public static void method(String s, Consumer&lt;String&gt; con1 ,Consumer&lt;String&gt; con2)&#123; //con1.accept(s); //con2.accept(s); //使用andThen方法,把两个Consumer接口连接到一起,在消费数据 con1.andThen(con2).accept(s);//con1连接con2,先执行con1消费数据,在执行con2消费数据 &#125; public static void main(String[] args) &#123; //调用method方法,传递一个字符串,两个Lambda表达式 method(\"Hello\", (t)-&gt; System.out.println(t.toUpperCase()), //消费方式:把字符串转换为大写 (t)-&gt; System.out.println(t.toLowerCase()));//消费方式:把字符串转换为小写 &#125; Predicate接口 有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用java.util.function.Predicate&lt;T&gt;接口。 抽象方法：test Predicate 接口中包含一个抽象方法：boolean test(T t) 。用于条件判断的场景： 结果：符合条件，返回true 结果：不符合条件，返回false 条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。 123456789101112131415/* 参数传递一个String类型的字符串 传递一个Predicate接口,泛型使用String 使用Predicate中的方法test对字符串进行判断,并把判断的结果返回 */ public static boolean checkString(String s, Predicate&lt;String&gt; pre)&#123; return pre.test(s); &#125; public static void main(String[] args) &#123; //定义一个字符串 String s = \"abcdef\"; //Lambda表达式 boolean b = checkString(s,str-&gt;str.length()&gt;5); &#125; 默认方法：and 既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个 Predicate 条件使用“与”逻辑连接起来实现“并且”的效果时，可以使用default方法 and 。其JDK源码为： 1234default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) ‐&gt; test(t) &amp;&amp; other.test(t);&#125; 判断一个字符串既要长度是否大于52，又要判断字符串中是否包含a 12345678910public static boolean checkString(String s, Predicate&lt;String&gt; pre1,Predicate&lt;String&gt; pre2)&#123; //return pre1.test(s) &amp;&amp; pre2.test(s); return pre1.and(pre2).test(s);//等价于return pre1.test(s) &amp;&amp; pre2.test(s);&#125; public static void main(String[] args) &#123; String s = \"abcdef\"; //调用checkString方法,参数传递字符串和两个Lambda表达式 boolean b = checkString(s,(str)-&gt; str.length()&gt;5,(str)-&gt; str.contains(\"a\"));&#125; 默认方法：or 与 and 的“与”类似，默认方法 or 实现逻辑关系中的“或”。JDK源码为： 1234default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) ‐&gt; test(t) || other.test(t);&#125; 判断一个字符串满足长度是否大于52，或判断字符串中是否包含a 12345678910public static boolean checkString(String s, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)&#123; //return pre1.test(s) || pre2.test(s); return pre1.or(pre2).test(s);&#125; public static void main(String[] args) &#123; String s = \"bc\"; //调用checkString方法,参数传递字符串和两个Lambda表达式 boolean b = checkString(s,(String str)-&gt; str.length()&gt;5,(String str)-&gt; str.contains(\"a\"));&#125; 默认方法：negate “与”、“或”已经了解了，剩下的“非”（取反）也会简单。默认方法 negate 的JDK源代码为： 123default Predicate&lt;T&gt; negate() &#123; return (t) ‐&gt; !test(t);&#125; 从实现中很容易看出，它是执行了test方法之后，对结果boolean值进行“!”取反而已。一定要在 test 方法调用之前调用 negate 方法，正如 and 和 or 方法一样 123456789101112//使用Predicate接口判断字符串的长度是否大于5 public static boolean checkString(String s, Predicate&lt;String&gt; pre)&#123; //return !pre.test(s); return pre.negate().test(s); &#125; public static void main(String[] args) &#123; String s = \"abc\"; //调用checkString方法,参数传递字符串和Lambda表达式 boolean b = checkString(s,(String str)-&gt; str.length()&gt;5); System.out.println(b); //true &#125; 3.7 Function接口 java.util.function.Function&lt;T,R&gt;接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。 抽象方法：apply Function接口中最主要的抽象方法为：R apply(T t)，根据类型T的参数获取类型R的结果。 使用的场景例如：将 String 类型转换为 Integer 类型。 12345678910111213141516/* 方法的参数传递一个Function接口,泛型使用&lt;String,Integer&gt; 使用Function接口中的方法apply,把字符串类型的整数,转换为Integer类型的整数 */ public static void change(String s, Function&lt;String,Integer&gt; fun)&#123; int in = fun.apply(s); System.out.println(in); &#125; public static void main(String[] args) &#123; //定义一个字符串类型的整数 String s = \"1234\"; //调用change方法,传递字符串类型的整数,方法引用 change(s, Integer::parseInt); //把字符串类型的整数,转换为Integer类型的整数返回 &#125; 默认方法：andThen Function接口中有一个默认的andThen方法，用来进行组合操作。JDK源代码如： 1234default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123; Objects.requireNonNull(after); return (T t) ‐&gt; after.apply(apply(t));&#125; 该方法同样用于“先做什么，再做什么”的场景，和 Consumer 中的 andThen 差不多： 123456789101112131415161718/* 参数串一个字符串类型的整数 参数再传递两个Function接口 一个泛型使用Function&lt;String,Integer&gt; 一个泛型使用Function&lt;Integer,String&gt; */ public static void change(String s, Function&lt;String,Integer&gt; fun1,Function&lt;Integer,String&gt; fun2)&#123; String ss = fun1.andThen(fun2).apply(s); System.out.println(ss); &#125; public static void main(String[] args) &#123; String s = \"123\"; //调用change方法,传递字符串和两个Lambda表达式 //把整数转换为字符串 change(s,str-&gt; parseInt(str)+10, String::valueOf); &#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://goldcarpenter.github.io/tags/Java/"}]},{"title":"JDK8新特性","date":"2020-02-24T16:00:00.000Z","path":"2020/02/25/jdk8新特性_Part1/","text":"JDK8新特性1.Lambda表达式函数式编程思想概述 相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——强调做什么，而不是以什么形式做。 面向对象的思想: 做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情. 函数式编程思想: 只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程 编程思想转换我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而不得不创建一个对象。我们真正希望做的事情是：将run方法体内的代码传递给Thread类知晓。 传递一段代码——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。 Java 8（JDK 1.8）中，加入了Lambda表达式的重量级新特性，为我们打开了新世界的大门。 回顾匿名内部类使用实现类要启动一个线程，需要创建一个Thread类的对象并调用start方法。而为了指定线程执行的内容，需要调用Thread类的构造方法： public Thread(Runnable target) 为了获取Runnable接口的实现对象，可以为该接口定义一个实现类RunnableImpl： 123456public class RunnableImpl implements Runnable &#123; @Override public void run() &#123; System.out.println(\"多线程任务执行！\"); &#125;&#125; 然后创建该实现类的对象作为Thread类的构造参数： 123456public class Demo03ThreadInitParam &#123; public static void main(String[] args) &#123; Runnable task = new RunnableImpl(); new Thread(task).start(); &#125;&#125; 使用匿名内部类这个RunnableImpl类只是为了实现Runnable接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类： 12345678910public class Demo04ThreadNameless &#123; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"多线程任务执行！\"); &#125; &#125;).start(); &#125;&#125; 匿名内部类的好处与弊端一方面，匿名内部类可以帮我们省去实现类的定义；另一方面，匿名内部类的语法——确实太复杂了！ 仔细分析该代码中的语义，Runnable接口只有一个run方法的定义： public abstract void run(); 即制定了一种做事情的方案（其实就是一个函数）： 无参数：不需要任何条件即可执行该方案。 无返回值：该方案不产生任何结果。 代码块（方法体）：该方案的具体执行步骤。 同样的语义体现在Lambda语法中，要更加简单： 1() -&gt; System.out.println(\"多线程任务执行！\") 前面的一对小括号即run方法的参数（无），代表不需要任何条件； 中间的一个箭头代表将前面的参数传递给后面的代码； 后面的输出语句即业务逻辑代码。 Lambda标准格式 Lambda省去面向对象的条条框框，格式由3个部分组成： 一些参数 一个箭头 一段代码 Lambda表达式的标准格式为： 1(参数类型 参数名称) -&gt; &#123; 代码语句 &#125; 格式说明： 小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。 -&gt;是新引入的语法格式，代表指向动作。 大括号内的语法与传统方法体要求基本一致。 Lambda省略格式可推导即可省略Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。 省略规则在Lambda标准格式的基础上，使用省略写法的规则为： 小括号内参数的类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。 Lambda的使用前提 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。无论是JDK内置的Runnable、Comparator接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。 使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 备注：有且仅有一个抽象方法的接口，称为“函数式接口”。 2.方法引用 在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑 一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？ 2.1 冗余的Lambda场景 来看一个简单的函数式接口以应用Lambda表达式： 123@FunctionalInterface public interface Printable &#123; void printout(String str);&#125; 在Printable接口当中唯一的抽象方法printout接收一个字符串参数，目的就是为了打印显示它。那么通过Lambda来使用它的代码很简单： 12345678910public static void printString(Printable p) &#123; p.printout(\"HelloWorld\"); &#125; public static void main(String[] args) &#123; //调用printString方法,方法的参数Printable是一个函数式接口,所以可以传递Lambda printString((s) -&gt; &#123; System.out.println(s); &#125;); &#125; 2.2 问题分析 这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是System.out对象中的println(String)方法。既然Lambda希望做的事情就是调用println(String)方法，那何必自己手动调用呢？ 2.3 用方法引用改进代码 能否省去Lambda的语法格式（尽管它已经相当简洁）呢？只要“引用”过去就好了： 1234567891011/* 分析: Lambda表达式的目的,打印参数传递的字符串 把参数s,传递给了System.out对象,调用out对象中的方法println对字符串进行了输出 注意: 1.System.out对象是已经存在的 2.println方法也是已经存在的 所以我们可以使用方法引用来优化Lambda表达式 可以使用System.out方法直接引用(调用)println方法*/printString(System.out::println); 请注意其中的双冒号::写法，这被称为“方法引用”，而双冒号是一种新的语法。 2.4 方法引用符双冒号::为引用运算符，而它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。 语义分析 例如上例中， System.out对象中有一个重载的println(String)方法恰好就是我们所需要的。那么对于printString方法的函数式接口参数，对比下面两种写法，完全等效： Lambda表达式写法：s -&gt; System.out.println(s);——拿到参数之后经Lambda之手，继而传递给 System.out.println方法去处理。 方法引用写法： System.out::println——复用了已有方案 Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常 推导与省略 如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式——它们都 将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。 函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。 通过对象名引用成员方法 最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法 123456class MethodRerObject &#123; //定义一个成员方法,传递字符串,把字符串按照大写输出 public void printUpperCaseString(String str)&#123; System.out.println(str.toUpperCase()); &#125;&#125; 12345678910111213141516171819202122232425262728293031/* 通过对象名引用成员方法 使用前提是对象名是已经存在的,成员方法也是已经存在 就可以使用对象名来引用成员方法 */public class Demo01ObjectMethodReference &#123; //定义一个方法,方法的参数传递Printable接口 public static void printString(Printable p)&#123; p.printout(\"Hello\"); &#125; public static void main(String[] args) &#123; //调用printString方法,方法的参数Printable是一个函数式接口,所以可以传递Lambda表达式 printString((s)-&gt;&#123; //创建MethodRerObject对象 MethodRerObject obj = new MethodRerObject(); //调用MethodRerObject对象中的成员方法printUpperCaseString,把字符串按照大写输出 obj.printUpperCaseString(s); &#125;); /* 使用方法引用优化Lambda 对象是已经存在的MethodRerObject 成员方法也是已经存在的printUpperCaseString 所以我们可以使用对象名引用成员方法 */ //创建MethodRerObject对象 MethodRerObject obj = new MethodRerObject(); printString(obj::printUpperCaseString); &#125;&#125; 通过类名称引用静态方法 由于在java.lang.Math类中已经存在了静态方法abs，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口： 12345@FunctionalInterfacepublic interface Calcable &#123; //定义一个抽象方法,传递一个整数,对整数进行绝对值计算并返回 int calsAbs(int number);&#125; 1234567891011121314151617181920212223242526272829/* 通过类名引用静态成员方法 类已经存在,静态成员方法也已经存在 就可以通过类名直接引用静态成员方法 */public class Demo01StaticMethodReference &#123; //定义一个方法,方法的参数传递要计算绝对值的整数,和函数式接口Calcable public static int method(int number,Calcable c)&#123; return c.calsAbs(number); &#125; public static void main(String[] args) &#123; //调用method方法,传递计算绝对值得整数,和Lambda表达式 int number = method(-10,(n)-&gt;&#123; //对参数进行绝对值得计算并返回结果 return Math.abs(n); &#125;); System.out.println(number); /* 使用方法引用优化Lambda表达式 Math类是存在的 abs计算绝对值的静态方法也是已经存在的 所以我们可以直接通过类名引用静态方法 */ int number2 = method(-10,Math::abs); System.out.println(number2); &#125;&#125; 通过super引用成员方法 如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口： 12345@FunctionalInterfacepublic interface Greetable &#123; //定义一个见面的方法 void greet();&#125; 父类Human的内容： 12345678910package com.itheima.demo07.SuperMethodReference;/* 定义父类 */public class Human &#123; //定义一个sayHello的方法 public void sayHello()&#123; System.out.println(\"Hello 我是Human!\"); &#125;&#125; 最后是子类Man的内容，其中使用了Lambda的写法 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.itheima.demo07.SuperMethodReference;/* 定义子类 */public class Man extends Human&#123; //子类重写父类sayHello的方法 @Override public void sayHello() &#123; System.out.println(\"Hello 我是Man!\"); &#125; //定义一个方法参数传递Greetable接口 public void method(Greetable g)&#123; g.greet(); &#125; public void show()&#123; //调用method方法,方法的参数Greetable是一个函数式接口,所以可以传递Lambda /*method(()-&gt;&#123; //创建父类Human对象 Human h = new Human(); //调用父类的sayHello方法 h.sayHello(); &#125;);*/ //因为有子父类关系,所以存在的一个关键字super,代表父类,所以我们可以直接使用super调用父类的成员方法 /* method(()-&gt;&#123; super.sayHello(); &#125;);*/ /* 使用super引用类的成员方法 super是已经存在的 父类的成员方法sayHello也是已经存在的 所以我们可以直接使用super引用父类的成员方法 */ method(super::sayHello); &#125; public static void main(String[] args) &#123; new Man().show(); //Hello 我是Human! &#125;&#125; 通过this引用成员方法 this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“this::成员方法”的格式来使用方 法引用。123456789101112131415161718192021222324252627282930313233/* 使用this引用本类的成员方法 */public class Human &#123; public void sayHello() &#123; System.out.println(\"Hello 我是Man!\"); &#125; //定义一个方法参数传递Greetable接口 public void method(Greetable g)&#123; g.greet(); &#125; public void show()&#123; //调用method方法,方法的参数Greetable是一个函数式接口,所以可以传递Lambda /*method(()-&gt;&#123; // 使用this.成员方法,调用父类的sayHello方法 this.sayHello(); &#125;);*/ /* 使用方法引用优化Lambda表达式 this是已经存在的 本类的成员方法sayHello也是已经存在的 所以我们可以直接使用this引用本类的成员方法buyHouse */ method(this::sayHello); &#125; public static void main(String[] args) &#123; new Human().show(); &#125;&#125; 类的构造器引用 由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 类名称::new 的格式表示。创建 Person 对象的函数式接口 12345@FunctionalInterfacepublic interface PersonBuilder &#123; //定义一个方法,根据传递的姓名,创建Person对象返回 Person builderPerson(String name);&#125; 1234567891011121314151617181920212223242526package com.itheima.demo09.ConstructorMethodReference;/* 类的构造器(构造方法)引用 */public class Demo &#123; //定义一个方法,参数传递姓名和PersonBuilder接口,方法中通过姓名创建Person对象 public static void printName(String name,PersonBuilder pb)&#123; Person person = pb.builderPerson(name); System.out.println(person.getName()); &#125; public static void main(String[] args) &#123; //调用printName方法,方法的参数PersonBuilder接口是一个函数式接口,可以传递Lambda printName(\"迪丽热巴\",(String name)-&gt;&#123; return new Person(name); &#125;); /* 使用方法引用优化Lambda表达式 构造方法new Person(String name) 已知 创建对象已知 new 就可以使用Person引用new创建对象 */ printName(\"古力娜扎\",Person::new);//使用Person类的带参构造方法,通过传递的姓名创建对象 &#125;&#125; 数组的构造器引用 数组也是 Object 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时， 需要一个函数式接口： 12345@FunctionalInterfacepublic interface ArrayBuilder &#123; //定义一个创建int类型数组的方法,参数传递数组的长度,返回创建好的int类型数组 int[] builderArray(int length);&#125; 123456789101112131415161718192021222324252627282930313233/* 数组的构造器引用 */public class Demo &#123; /* 定义一个方法 方法的参数传递创建数组的长度和ArrayBuilder接口 方法内部根据传递的长度使用ArrayBuilder中的方法创建数组并返回 */ public static int[] createArray(int length, ArrayBuilder ab)&#123; return ab.builderArray(length); &#125; public static void main(String[] args) &#123; //调用createArray方法,传递数组的长度和Lambda表达式 int[] arr1 = createArray(10,(len)-&gt;&#123; //根据数组的长度,创建数组并返回 return new int[len]; &#125;); System.out.println(arr1.length);//10 /* 使用方法引用优化Lambda表达式 已知创建的就是int[]数组 数组的长度也是已知的 就可以使用方法引用 int[]引用new,根据参数传递的长度来创建数组 */ int[] arr2 =createArray(10,int[]::new); System.out.println(Arrays.toString(arr2)); System.out.println(arr2.length);//10 &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://goldcarpenter.github.io/tags/Java/"}]},{"title":"Tomcat","date":"2020-02-13T16:00:00.000Z","path":"2020/02/14/Tomcat_Part4/","text":"Tomcat源码包安装 官方下载source 1https:&#x2F;&#x2F;tomcat.apache.org&#x2F;download-80.cgi IDEA创建新空工程 进入下载的解压目录，并创建一个目录，命名为home并将conf，webapps目录移入home 目录中 在源码目录下创建pom.xml文件,引入tomcat的依赖包 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;groupId&gt;org.apache.tomcat&lt;&#x2F;groupId&gt; &lt;artifactId&gt;Tomcat8.5&lt;&#x2F;artifactId&gt; &lt;name&gt;Tomcat8.5&lt;&#x2F;name&gt; &lt;version&gt;8.5&lt;&#x2F;version&gt; &lt;build&gt; &lt;finalName&gt;Tomcat8.5&lt;&#x2F;finalName&gt; &lt;sourceDirectory&gt;java&lt;&#x2F;sourceDirectory&gt; &lt;testSourceDirectory&gt;test&lt;&#x2F;testSourceDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;java&lt;&#x2F;directory&gt; &lt;&#x2F;resource&gt; &lt;&#x2F;resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;directory&gt;test&lt;&#x2F;directory&gt; &lt;&#x2F;testResource&gt; &lt;&#x2F;testResources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;2.3&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;&#x2F;encoding&gt; &lt;source&gt;1.8&lt;&#x2F;source&gt; &lt;target&gt;1.8&lt;&#x2F;target&gt; &lt;&#x2F;configuration&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.12&lt;&#x2F;version&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.easymock&lt;&#x2F;groupId&gt; &lt;artifactId&gt;easymock&lt;&#x2F;artifactId&gt; &lt;version&gt;3.4&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ant&lt;&#x2F;groupId&gt; &lt;artifactId&gt;ant&lt;&#x2F;artifactId&gt; &lt;version&gt;1.7.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;wsdl4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;wsdl4j&lt;&#x2F;artifactId&gt; &lt;version&gt;1.6.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jaxrpc&lt;&#x2F;artifactId&gt; &lt;version&gt;1.1&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;&#x2F;groupId&gt; &lt;artifactId&gt;ecj&lt;&#x2F;artifactId&gt; &lt;version&gt;4.5.1&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt; 确认maven 配置idea的启动类， 配置Mainclass，并配置VM参数 1org.apache.catalina.startup.Bootstrap 1234-Dcatalina.home&#x3D;E:&#x2F;Tomcat_Source&#x2F;apache-tomcat-8.5.49-src&#x2F;home-Dcatalina.base&#x3D;E:&#x2F;Tomcat_Source&#x2F;apache-tomcat-8.5.49-src&#x2F;home-Djava.util.logging.manager&#x3D;org.apache.juli.ClassLoaderLogManager-Djava.util.logging.config.file&#x3D;E:&#x2F;Tomcat_Source&#x2F;apache-tomcat-8.5.49-src&#x2F;home&#x2F;conf&#x2F;logging.properties Debug运行 原因是我们直接启动org.apache.catalina.startup.Bootstrap的时候没有加载org.apache.jasper.servlet.JasperInitializer，从而无法编译JSP 解决办法是在tomcat的源码org.apache.catalina.startup.ContextConfig中的configureStart函数中手动将JSP解析器初始化 12Ctrl+Shift+Alt+N查找 ContextConfig类 1context.addServletContainerInitializer(new JasperInitializer(), null); 成功","tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://goldcarpenter.github.io/tags/Tomcat/"}]},{"title":"Tomcat","date":"2020-02-06T16:00:00.000Z","path":"2020/02/07/Tomcat_Part3/","text":"Tomcat9.Tomcat安全9.1配置安全【运维人员】 删除webapps目录下的所有文件，禁用tomcat管理界面 注释或删除tomcat-users.xml文件内的所有用户权限 更改关闭tomcat指令或禁用 Tomcat的server.xml中定义了可以直接关闭Tomcat实例的管理端口(默认8005) 由于默认关闭Tomcat 的端口和指令都很简单。默认端口为8005 ,指令为SHUTDOWN。 可以通过telnet连接上该端口之后，输入SHUTDOWN (此为默认关闭指令)即可关闭Tomcat 实例（注意,此时虽然实例关闭了,但是进程还是存在的） 方案一：更改端口号和指令 1&lt;Server port&#x3D;&quot;8456&quot; shutdown&#x3D;&quot;server_shut&quot;&gt; 方案二：禁用8005端口 1&lt;Server port&#x3D;&quot;-1&quot; shutdown&#x3D;&quot;SHUTDOWN&quot;&gt; 定义错误页面 在webapps/ROOT目录下错误页面404.html，500.html 9.2应用安全 在大部分的web应用中，特别是一些后台应用系统，都会实现自己的安全管理模块(权限模块) , 用于控制应用系统的安全访问。 基本包含两个部分：认证(登录/单点登录)和授权(功能权限、数据权限)两个部分 对于当前的业务系统,可以自己做一套适用于自己业务系统的权限模块，也有很多的应用系统直接使用一些功能完善的安全框架 ,将其集成到我们的web应用中,如: SpringSecurity. Apache Shiro等。 9.3传输安全9.3.1 HTTPS介绍 Https的全称是超文本传输安全协议( Hypertext Transfer Protocol Secure) , 是一种网络安全传输协议。在HTTP的基础上加入SSL/TLS来进行数据加密，保护交换数据不被泄露、窃取。 SSL和TLS是用于网络通信安全的加密协议,它允许客户端和服务器之间通过安全链接通信。ssL协议的3个特性: 保密 :通过ssL链接传输的数据时加密的。 鉴别:通信双方的身份鉴别,通常是可选的,单至少有一方需要验证。 完整性:传输数据的完整性检查。 从性能角度考虑,加解密是一项计算昂贵的处理,因为尽量不要将整个web应用采用SSL链接，实际部署过程中，选择有必要进行安全加密的页面(存在敏感信息传输的页面)采用SSL通信。 HTTPs和HTTP的区别 HTTPs协议需要到证书颁发机构cA申请ssL证书，然后与域名进行绑定, HTTP不用申请证书; HTTP是超文本传输协议,属于应用层信息传输, HTTPS则是具有ss加密传安全性传输协议,对数据的传输进行加密,相当于HTTP的升级版; HTTp和HTTps使用的是完全不同的连接方式 ,用的端口也不一-样 ,前者是8080,后者是8443。 HTTP的连接很简单 。是无状态的; HTTPs协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议,比HTTp协议安全 HTTPs协议优势: 提高网站排名。有利于搜索引擎优化(SEO)。谷歌已经公开声明两个网站在搜索结果方面相同。如果一个网站启用了 ssL。它可能会获得略高于没有ssL网站的等级，而且百度也表明对安装了ssI的网站表示友好。因此,网站上的内容中启用ssI都有明显的sEo优势。 隐私信息加密,防止流量劫持。特别是涉及到隐私信息的网站,互联网大型的数据泄露的事件频发发生,网站进行信息加密势在必行。 浏览器受信任。自从各大主流浏览器大力支持Https协议之后 ,访问Http的网站都会提示”不安全”的警告信息。 9.3.2.Tomcat支持HTTPs 不向CA进行申请，构建Https 生成秘钥库文件 1keytool -genkey -alias tomcat -keyalg RSA -Keystore tomcatkey.keystose 输入对应的密钥库密码，秘钥密码等信息之后 .会在当前文件夹中出现一个秘钥库文件: tomcatkey.keystore 将秘钥库文件tomcatkey . keystore复制到tomcat/conf目录下 配置tomcat/conf/server.xml 12345&lt;Connector port&#x3D;&quot;8443&quot; protocol&#x3D;&quot;org.apache.coyote.http11. Http11NioProtocol&quot; maxThreads&#x3D;&quot;150&quot; schema&#x3D;&quot;https&quot; secure&#x3D;&quot;true&quot; SSLEnabled&#x3D;&quot;true&quot;&gt; &lt;SSLHostConfig certificateVerification&#x3D;&quot;false&quot;&gt; &lt;Certificate certificateKeystoreFile&#x3D;&quot;[...]&#x2F;conf&#x2F;tomcatkey. keystore&quot; certificateKeystorePassword&#x3D;&quot;itcast&quot; type&#x3D;&quot;RSA&quot;&#x2F;&gt;&lt;&#x2F;SSLHostConfig&gt;&lt;&#x2F;Connector&gt; 结果 10.Tomcat 性能调优10.1. Tomcat 性能测试 对于系统性能,用户最直观的感受就是系统的加载和操作时间，即用户执行某项操作的耗时。 从更为专业的角度上讲,性能测试可以从以下两个指标量化。 响应时间：为执行某个操作的耗时。大多数情况下,我们需要针对同一一个操作测试多次，以获取操作的平均响应时间 吞吐量:即在给定的时间内，系统支持的事务数量，一秒内可以处理多少请求，计算单位为TPS。 通常情况下,我们需要借助于一些自动化工具来进行性能测试，因为手动模拟大量用户的并发访问几乎是不可行的。而且现在市面上也有很多的性能测试工具可以使用,如: ApacheBench，ApacheJMeter， WCAT、 WebPolygraph、 LoadRunner 10.1.1 ApacheBench ApacheBench (ab)是一款Apacheserver基准的测试工具 ，用户测试Apache server的服务能力(每秒处理请求数) ,它不仅可以用户Apache的测试,还可以用于测试Tomcat、Nginx、 lighthttp、 IIS等服务器 安装 1yum install httpd-tools 部署Tomcat 上传War，删除原始项目 数据库环境准备 启动Tomcat 性能测试 1ab -n 1000 -c 100 -p data.json -T application&#x2F;json http:&#x2F;&#x2F; localhost:9000&#x2F;course&#x2F;search.do?page&#x3D;1spageSize&#x3D;10 参数 含义描述 -n 在测试会话中所执行的请求个数,默认只执行一次请求 -c 一次产生的请求个数， 默认一次一个 -p 包含了需要POST的数据文件 -t 测试所进行的最大秒数,默认没有时间限制 -T POST数据所需要使用的Content-Type头信息 -v 设置显示信息的详细程度 -w 以HTML表的格式输出结果,默认是白色背景的两列宽度的一张表 结果说明 指标 Server Software 服务器软件 Server Hostname 主机名 Server Port 端口号 Document Path 测试的页面 Document Length 测试的页面大小 Concurrency Level 并发数 Time taken for tests 整个测试持续的时间 Complete requests 完成的请求数量 Failed requests 失败的请求数量,这里的失败是指请求的连接服务器、发送数据、接收数据等环节发生异 Write errors 输出错误数量 Total transferred 整个场景中的网络传输量,表示所有请求的响应数据长度总和,包括每个http响应数据的头信息和正文数据的长度 THL transferred 整个场景中的HTML内容传输最，表示所有请求的响应数据中正文数据的总和 Requests per second 每秒钟平均处理的请求数(相当于LR中的每秒事务数)这便是我们重点关注的吞吐率 ==Complete requests / Time taken for tests Time per request 每个线程处理请求平均消耗时间(相当于LR中的平均事务响应时间)用户平均请求等待时间 Transfer rate 平均每秒网络上的流量 Percentage of the requeste served within a certain time (ms) 指定时间里，执行的请求百分比 参数 指标说明 Requests per second 吞吐率：服务器并发处理能力的量化描述,单位是reqs/s。指的是在某个并发用户数下单位时间内处理的请求数，某个并发用户数下单位时间内能处理的最大请求数。称之为最大吞吐率。这个数值表示当前机器的整体性能,值越大越好 Time per request 用户平均请求等待时间：从用户角度看，完成一个请求所需要的时间 Time per request 服务器平均请求等待时间服务器完成一个请求的时间 Concurrency Level 并发用户数 10.2. JVM参数调优 Tomcat是一款Java应用，那么JVM的配置便与其运行性能密切相关 JVM优化的重点集中在内存分配和GC策略的调整上 内存会直接影响服务的运行效率和吞吐量 JVM垃圾回收机制则会不同程度地导致程序运行中断，调整JVM垃圾回收策略，可以极大减少垃圾回收次数，提升垃圾回收效率，改善程序运行性能 -server 启动Server，以服务端模式运行 服务端模式建议开启 -Xms 最小堆内存 建议与-Xmx设置相同 -Xmx 最大堆内存 建议设置为可用内存(排除系统和其他服务)的80% -XX:MetaspaceSize 元空间初始值 -XX:MaxMetaspaceSize 元空间最大内存 默认无限 -XX:MaxNewSize 新生代最大内存 默认16M -XX:NewRatio 年轻代和老年代大小比值，取值为整数，默认为2 不建议修改 -XX:SurvivorRatio Eden区与Survivor区大小的比值，取值为整数，默认为8 不建议修改 修改catalina.sh 查看Tomcat内存占用情况 1jmap -heap [Tomcat pid] 10.3.JVMGC策略 JVM垃圾回收性能有以下两个主要的指标 吞吐量:工作时间(排除GC时间)占总时间的百分比，工作时间并不仅是程序运行的时间 ,还包含内存分配时间。 暂停时间:测试时间段内，由垃圾回收导致的应用程序停止响应次数/时间 查看Tomcat默认垃圾回收器 在bin/catalina.sh的配置中，加入如下配置 打开jconsole 上面新生代垃圾收集器，下面老年代垃圾收集器 修改catalina.sh 10.4.Tomcat配置调优 调整tomcat/conf/server.xml中关干链接器的配置可以提升应用服务器的性能 参数 说明 maxConnections 最大连接数，当到达该值后，服务器接收但不会处理更多的请求，额外的请求将会阻塞直到连接数低于maxConnections。可通过ulimit -a查看服务器限制。对于cpu要求更高(计算型)时,建议不要配置过大；对于CPU要求不是特别高时，建议配置在2000左右(受服务器性能影响)。当然这个需 要服务器硬件的支持 maxThreads 最大线程数，需要根据服务器的硬件情况，进行一个合理的设置 acceptCount 最大排队等待数，当服务器接收的请求数量到达maxConnections , 此时Tomcat会将后面的请求,存放在任务队列中进行排序，acceptCount指的就是任务队列中排队等待的请求数 。一台Tomcat的最大的请求处理数量是maxConnections+acceptCount 11.Tomcat附加功能11.1.WebSocket websocket是HTML5新增的协议,它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。 为什么传统的HTTP协议不能做到websocket实现的功能? 这是因为HTTp协议是一个请求-响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求,再把数据发送给浏览器。换句话说，浏览器不主动请求,服务器是没法主动发数据给浏览器的。 这样一来,要在浏览器中搞一个实时聊天,或者在线多人游戏的话就没法实现了,只能借助Flash这些插件。 HTTP协议其实也能实现啊,比如用轮询或者comet。 轮询是指浏览器通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求,询问服务器有没有新消息。这个机制的缺点一是实时性不够,二是频繁的请求会给服务器带来极大的压力。 Comet本质上也是轮询,但是在没有消息的情况下,服务器先拖一段时间,等到有消息了再回复。这个机制暂时地解决了实时性问题,但是它带来了新的问题:以多线程模式运行的服务器会让大部分线程大部分时间都处于挂起状态,极大地浪费服务器资源。另外,一个HTTP连接在长时间没有数据传输的情况下,链路上的任何一一个网关都可能关闭这个连接,而网关是我们不可控的,这就要求Comet连接必须定期发一些ping数据表示连接“正常工作”。 以上两种机制都治标不治本。所以，HTML5推出了Websocket标准,让浏览器和服务器之间可以建立无限制的全双工通信，任何一方都可以主动发消息给对方。 WebSocket并不是全新的协议,而是利用了HTTP协议来建立连接。 首先, Websocket连接必须由浏览器发起,因为请求协议是一个标准的HTTp请求 ,格式如下 WebSocket请求和普通的HTTP请求有几点不同 GET请求的地址不是类似http:// ,而是以ws://开头的地址 请求头Connection: Upgrade和请求头Upgrade: websocket表示这个连接将要被转换为Websocket连接 Sec-Websocket-Key是用于标识这个连接，是一个BASE64编码的密文，要求服务端响应一个对应加密的Sec-WebSocket-Accept头信息作为应答 Sec-WebSocket-Version 指定了Websocket的协议版本; 101状态码表明服务端已经识别并切换为websocket协议 Sec-Websocket-Accept是服务端与客户端致的秘钥计算出来的信息 11.2Tomcat的Websocket Tomcat的7.0.5版本开始支持Websocket, 并且实现了Java Websocket规范(JSR356)，而在7.0.5版本之前(7.0.2之后)则采用自义API，即webSocketServlet实现。 Java WebSocket应用由一系列的WebSocketEndpoint组成。Endpoint 是一个java对象，代表WebSocket链接的一端,对于服务端,我们可以视为处理具体Websocket消息的接口，就像servlet之与http请求一样 我们可以通过两种方式定义Endpoint 第一种是编程式，即继承类javax.websocket.Endpoint并实现其方法 第二种是注解式，即定义一-个POJO,并添加@ServerEndpoint相关注解 Endpoint实例在WebSocket握手时创建，并在客户端与服务端链接过程中有效,最后在链接关闭时结束。在Endpoint接口中明确定义了与其生命周期相关的方法，规范实现者确保生命周期的各个阶段调用实例的相关方法。生命周期方法如下: 方法 含义描述 注解 onOpen 当开启一个新的会话时调用，该访法是客户端与服务端握手成功后调用的方法 @OnOpen onClose 当会话关闭时调用 @OnClose onError 当连接过程中异常时调用 @OnError 通过为Session添加MessageHandler消息处理器来接收消息，当采用注解方式定义Endpoint时，我们还可以通过@onMessage注解指定接收消息的方法。发送消息则由RemoteEndpoint完成，其实例由Session维护，根据使用情况，我们可以通过session. getBasicRemote获取同步消息发送的实例，然后调用其sendXxx()方法就可以发送消息，可以通过session. getAsyncRemote获取异步消息发送实例。 11.3.WebSocket Demo 实现简易网络聊天室 11.3.1.实现流程 11.3.2. 数据格式 客户端–&gt;服务端 1&#123;&quot;fromName&quot;:&quot;Deng&quot;,&quot;toName&quot;:&quot;HEIMA&quot;,&quot;content&quot;:&quot;约会呀&quot;&#125; 服务端–&gt;客户端: 如果type为user， 则说明返回的是用户列表 1&#123;&quot;data&quot;:&quot;HEIMA,Deng,ITCAST&quot;,&quot;toName&quot;:&quot;&quot;,&quot;fromName&quot;:”&quot;,&quot;type&quot;: &quot;user&quot;&#125; 如果type为message ，则说明返回的是消息内容 1&#123;&quot;data&quot;:&quot;你好&quot;,&quot;toName&quot;:&quot;HEIMA&quot;,&quot;fromName&quot;:&quot;Deng&quot;,&quot;type&quot;:&quot;message&quot;&#125; Tomcat–Q&amp;ACATALINA_HOME和CATALINA_BASE区别？ CATALINA_HOME是Tomcat的安装目录 CATALINA_BASE是Tomcat的工作目录 Tomcat安装目录中 /conf，/logs，/temp，/work，/webapps是实例私有的 /lib和/bin是实例共享的 需要在一台机器上面部署多个Tomcat实例，但是又不想创建多个Tomcat软件——Tomcat副本拥有自己的工作目录但是共享Tomcat的代码","tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://goldcarpenter.github.io/tags/Tomcat/"}]},{"title":"JavaIO","date":"2020-02-02T09:55:36.000Z","path":"2020/02/02/javaIO/","text":"1.File类1.1 概述 java.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作 File类是一个与系统无关的类，任何的操作系统都可以使用这个类中的方法 1.2静态成员变量 static String pathSeparator：与系统有关的路径分隔符，为了方便，它被表示为一个字符串。 static char pathSeparatorChar：与系统有关的路径分隔符。 static string separator：与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。 static char separatorChar：与系统有关的默认名称分隔符。 1.3 构造方法 public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的File实例。 public File(String parent, String child) ：拼接 父路径名字符串和子路径名字符串创建新的 File实例。 public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例。 构造举例，代码如下： 无论该路径下是否存在文件或者目录，都不影响File对象的创建。 路径可以是以文件结尾，也可以是以文件夹结尾 路径可以是相对路径,也可以是绝对路径 路径可以是存在，也可以是不存在 创建File对象，只是把字符串路径封装为File对象，不考虑路径的真假情况 1.4 常用方法1.4.1获取功能的方法 public String getAbsolutePath() ：返回此File的绝对路径名字符串。 public String getPath() ：将此File转换为绝对/相对路径名字符串，toString调用此方法实现。 public String getName() ：返回由此File表示的文件或目录的名称。 public long length() ：返回由此File表示的文件的大小，字节单位。 API中说明：length()——表示文件的大小。但是File对象表示目录，则返回值0。 1.4.2绝对路径和相对路径 绝对路径：从盘符开始的路径，这是一个完整的路径。 相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。 1234567891011121314public class FilePath &#123; public static void main(String[] args) &#123; // D盘下的bbb.java文件 File f = new File(\"D:\\\\bbb.java\"); System.out.println(f.getAbsolutePath()); // 项目下的bbb.java文件 File f2 = new File(\"bbb.java\"); System.out.println(f2.getAbsolutePath()); &#125;&#125;输出结果：D:\\bbb.javaD:\\idea_project_test4\\bbb.java 1.4.3判断功能的方法 public boolean exists() ：此File表示的文件或目录是否实际存在。 public boolean isDirectory() ：此File表示的是否为目录。 public boolean isFile() ：此File表示的是否为文件。 isFile() &amp; isDirectory() 使用前提，路径必须是存在的，否则都返回false 1.4.4创建删除功能的方法 public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 只能创建文件，不能创建文件夹 创建文件的路径必须存在，否则会抛出异常 文件存在，不会创建，返回false public boolean delete() ：删除由此File表示的文件或目录。 如果此File表示目录，文件夹中有内容，不会删除返回false，目录必须为空才能删除 构造方法中路径不存在，返回false 直接在硬盘删除文件/文件夹，不走回收站，删除要谨慎 public boolean mkdir() 【不常用】：创建由此File表示的单级目录。 文件夹存在，不会创建，返回false 构造方法中给出的路径不存在，返回false public boolean mkdirs() 【常用】：创建由此File表示的目录，包括任何必需但不存在的父目录。 既可以创建单级文件夹，也可以创建多级文件夹 1.5目录的遍历 public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 12345678910111213141516public class FileFor &#123; public static void main(String[] args) &#123; File dir = new File(\"d:\\\\java_code\"); //获取当前目录下的文件以及文件夹的名称。 String[] names = dir.list(); for(String name : names)&#123; System.out.println(name); &#125; //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息 File[] files = dir.listFiles(); for (File file : files) &#123; System.out.println(file); &#125; &#125;&#125; 调用遍历方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。 可以遍历到隐藏的文件夹 1.6文件过滤器实现 java.io.FileFilter是一个接口，File过滤器。 该接口的对象可以传递给File类listFiles(FileFilter) 作为参数， 接口中只有一个方法。 boolean accept(File pathname) ：测试pathname是否应该包含在当前File目录中，符合则返回true。 分析： 接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。 accept方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则： 要么是.java文件。 要么是目录，用于继续遍历。 通过过滤器的作用，listFiles(FileFilter)返回的数组元素中，子文件对象都是符合条件的，可以直接打印。 代码实现： 123456789101112131415161718192021222324public class DiGuiDemo4 &#123; public static void main(String[] args) &#123; File dir = new File(\"D:\\\\aaa\"); printDir2(dir); &#125; public static void printDir2(File dir) &#123; // 匿名内部类方式,创建过滤器子类对象 File[] files = dir.listFiles(new FileFilter() &#123; @Override public boolean accept(File pathname) &#123; return pathname.getName().endsWith(\".java\")||pathname.isDirectory(); &#125; &#125;); // 循环打印 for (File file : files) &#123; if (file.isFile()) &#123; System.out.println(\"文件名:\" + file.getAbsolutePath()); &#125; else &#123; printDir2(file); &#125; &#125; &#125;&#125; 1.7文件过滤器实现Lambda优化分析：FileFilter是只有一个方法的接口，因此可以用lambda表达式简写。 lambda格式： 1()-&gt;&#123; &#125; 代码实现： 123456789101112131415public static void printDir3(File dir) &#123; // lambda的改写 File[] files = dir.listFiles(f -&gt;&#123; return f.getName().endsWith(\".java\") || f.isDirectory(); &#125;); // 循环打印 for (File file : files) &#123; if (file.isFile()) &#123; System.out.println(\"文件名:\" + file.getAbsolutePath()); &#125; else &#123; printDir3(file); &#125; &#125;&#125; 2.IO流2.1IO的分类根据数据的流向分为：输入流和输出流。 输入流 ：把数据从其他设备上读取到内存中的流。 输出流 ：把数据从内存 中写出到其他设备上的流。 格局数据的类型分为：字节流和字符流。 字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 2.2顶级父类 输入流 输出流 字节流 字节输入流InputStream 字节输出流OutputStream 字符流 字符输入流Reader 字符输出流Writer","tags":[{"name":"Java","slug":"Java","permalink":"http://goldcarpenter.github.io/tags/Java/"},{"name":"IO","slug":"IO","permalink":"http://goldcarpenter.github.io/tags/IO/"}]},{"title":"Tomcat","date":"2020-01-19T16:00:00.000Z","path":"2020/01/20/Tomcat_Part2/","text":"Tomcat4. Tomcat服务器配置4.1.server.xml server.xml是tomcat服务器的核心配置文件。包含了Tomcat的servlet容器( Catalina )的所有配置 4.1.1.Server Server是server.xml的根元素。用于创建一个Server实例，默认使用的实现类是org.apache.catalina.core.Standardserver 123&lt;Server port=\"8005\" shutdown=\"SHUTDOWN\"&gt; ...&lt;/Server&gt; port : Tomcat 监听的关闭服务器的端口。shutdown:关闭服务器的指令字符串。 Server内嵌的子元素为Listener, GlobaINamingResources，Service Listener 1234567891011121314# 用于以日志形式输出服务器 操作系统 JVM的版本信息&lt;Listener className=\"org.apache.catalina.startup.VersionLoggerListener\"/&gt;# 用于加载(服务器启动)和销毁(服务器停止) APP如果找不到APP库 则会输出日志，并不影响Tomcat启动 &lt;Listener className=\"org.apache.catalina.core.AprLifecycleListener\" SSLEngine=\"on\" /&gt;# 用于避免JRE内存泄漏问题&lt;Listener className=\"org.apache.catalina.core.JreMemoryLeakPreventionListener\" /&gt;# 用户加载(服务器启动)和销照(服务器停止) 全局命名服务&lt;Listener className=\"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener\" /&gt;# 用于在Context停止时重建Executor池中的线程，以避免Threedlocal 相关的内存泄漏&lt;Listener className=\"org.apache.catalina.core.ThreadLocalLeakPreventionListener\" /&gt; GlobalNamingResources中定义了全局命名服务 Service：一个server服务器.可以包含多个service服务 4.1.2.Service 该元素用于创建service实例，默认使用org.apache.catalina.core.StandardService.默认情况下 , Tomcat仅指定了Service的名称，值为”Catalina”。 Service 可以内嵌的元素为: Listener，Executor，Connector，Engine Listener用于为Service添加生命周期监听器 Executor 用于配置Service共享线程池 Connector用于配置service包含的链接器 Engine用于配置Service中链接器对应的Servlet容器引擎 123&lt;Service name=\"Catalina\"&gt; ...&lt;/Service&gt; 4.1.3.Executor 默认情况下, Service并未添加共享线程池配置。如果我们想添加一个线程池，可以在&lt;Service&gt; 添加如下配置 123456789&lt;Executor name=\"tomcatThreadPool\" namePrefix=\"catalina-exec-\" maxThreads=\"1000\" minSpareThreads=\"100\" maxIdleTime=\" 60000\" maxQueueSize=\"Integer.MAX_VALUE\" prestartminSpareThreads=\"false\" threadPriority=\"5\" className=\"org.apache.catalina.core.StandardThreadExecutor\"/&gt; 属性 含义 name 线程池名称,用于Connector中指定 namePrefix 所创建的每个线程的名称前缀，一个单独的线程名称为namePrefix+threadNumber maxThreads 池中最大线程数 minSpareThreads 活跃线程数/核心池线程数,这些线程不会被销毁会直存在 maxIdleTime 线程空闲时间,超过该时间后,空闲线程会被销毁,默认值为6000 ( 1分钟) , 单位毫秒。 maxQueueSize 在被执行前最大线程排队数目，默认为Int的最大值，也就是广义的无限。除非特殊情况,这个值不需要更改 否则会有请求不会被处理的情况发生 prestartminSpareThreads 启动线程池时是否启动minSpareThreads部分线程。默认值为false ,即不启动 threadPriority 线程池中线程优先级,默认值为5 ,值从1到10 className 线程池实现类,未指定情况下,默认实现类为org.apache.catalina.core.StandardThreadexecutor.如果想使用自定义线程池首先需要实现org.apache.catalina.Executor接口 如果不配置共享线程池，那么catalina各组件在用到线程池时会独立创建 4.1.4 Connector Connector用于创建链接器实例。默认情况下, server.xml配置了两个链接器, 一个支持Http协议，一个支持AJP协议。因此大多数情况下,我们并不需要新增链接器配置,只是根据需要对已有链接器进行优化。 123&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt;&lt;Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" executor=\"tomcatThreadPool\"/&gt; 属性说明: port: 端口号, Connector用于创建服务端Socket并进行监听，以等待客户端请求链接。 如果该属性设置为0 , Tomcat将会随机选择一个可用的端口号给当前Connector使用 connectionTimeout: connector 接收链接后的等待超时时间，单位为毫秒。-1 表示不超时。 redirectPort: 当前connector不支持ssl请求，接收到了一个请求，并且也符合security-constraint约束，需要ssl传输，Catalina自动将请求重定向到指定的端口 executor :指定共享线程池的名称，也可以通过maxThreads，minSpareThreads 等属性配置内部线程池。 URIEncoding :用于指定编码URI的字符编码， Tomcat8.x版本默认的编码为UTF-8 protocol :当前Connector支持的访问协议。默认为HTTP/1.1，并采用自动切换机制选择一个基于JAVA NIO的链接器或者基于本地APR的链接器(根据本地是否含有Tomcat的本地库判定)。 如果不希望采用上述自动切换的机制，而是明确指定协议 ，可以使用以下值 Http协议 123org.apache.coyote.http11.Http11NioProtocol 非阻塞式Java NIO链接器org.apache.coyote.http1l.Http11Nio2Protocol 非阻塞式JAVA NIO2链掖器org.apache.coyote.httpll.Http11AprProtocol APR链接器 AJP协议 123org.apache.coyote.ajp.AjpNioProtocol 非阻塞式Java NIO链按器org.apeche.coyote.ajp.AjpNio2Protocol 非阻塞式JAVA NI02链接器org.apache.coyote.ajp.AjpAprprotocol APR链接器 完整配置 12345678910111213&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" executor=\"tomcatThreadPool\" maxThreads=\"1000\" minSpareThreads=\"100\" acceptCount=\"1000\" maxConnections=\"1000” connectionTimeout=\"20000\" compression=\"on\" compreae1onM1n512e=\"2048\" disableUplondT imeout=\"true\" redirectPort=\"8443\" URIEncoding=\"UTF-8\"/&gt; 4.1.5 Engine Engine作为Servlet引擎的顶级元素,内部可以嵌入: Cluster，Listener，Realm, Valve和Host 123&lt;Engine name&#x3D;&quot;Catalina&quot; defaultHost&#x3D;&quot;localhost&quot;&gt; ...&lt;&#x2F;Engine&gt; 属性说明: name: 用于指定Engine的名称，默认为catalina 。该名称会影响一部分Tomcat的存储路径 (如临时文件) defaultHost :默认使用的虚拟主机名称，当客户端请求指向的主机无效时，将交由默认的虚拟主机处理， 默认为loalhost。 4.1.6 Host Host元素用于配置一个虚拟主机，它支持以下嵌入元素: Alias、Cluster、 Listener、 Valve、 Realm, Context。 如果在Engine下配置Realm，那么此配置将在当前Engine 下的所有Host中共享。 同样 。如果在Host中配置Realm，则在当前Host 下的所有Context中共享。 Context中的Realm优先級&gt; Host的Realm优先级&gt; Engine中的Realm优先级。 123&lt;Host name&#x3D;&quot;localhost&quot; appBase&#x3D;&quot;webapps&quot; unpackWARs&#x3D;&quot;true&quot; autoDeploy&#x3D;&quot;true&quot;&gt; ...&lt;\\Host&gt; 属性说明: name:当前Host通用的网络名称，必须与DNS服务器 上的注册信息一致。Engine中包含的Host必须存在一个名称与Engine的defaultHost设置一致 appBase: 当前Host的应用基础目录，当前Host上部署的web应用均在该目录下(可以是绝对目录,相对路径)。默认为webapps。 unpackWARs: 设置为true，Host在启动时会将appBase目录下war包解压为目录。设置为false, Host将直接从war文件启动。 autoDeploy :控制tomcat是否在运行时定期检测并自动部署新增或变更的web应用。 通过给Host添加别名。我们可以实现同-个Host拥有多个网络名称,配置如下: 123&lt;Host name&#x3D;&quot;www.web1.com&quot; appBase&#x3D;&quot;webapps&quot; unpackWARs&#x3D;&quot;true&quot; autoDeploy&#x3D;&quot;true&quot;&gt; &lt;Alias&gt;www.web1.com&lt;&#x2F;Alias&gt;&lt;\\Host&gt; 4.1.7 Context Context用于配置一个Web应用 。默认的配置如下: 123&lt;Context docBase&#x3D;&quot;myApp&quot; path&#x3D;&quot;&#x2F;myApp&quot;&gt; ...&lt;\\Context&gt; 属性描述: docBase : web应用目录或者war包的部署路径。可以是绝对路径,也可以是相对于Host appBase的相对路径。 path : web应用的Context路径。如果我们Host名为localhost，则该web应用访问的根路径为 : http://localhost:8080/myApp 它支持的内嵌元索为: CookieProcessor, Loader, Manager , Realm, Resources , WatchedResource，JarScanner , VaIve 12345678&lt;Host name&#x3D;&quot;www.tomcat.com&#39; appBase&#x3D;&quot;webapps&quot; unpackWARs&#x3D;&quot;true&quot; autoDeploy&#x3D;&quot;true&quot;&gt; &lt;Context docBase&#x3D;&quot;D:\\servlet_project03&quot; path&#x3D;&quot;&#x2F;myApp&quot;&gt;&lt;&#x2F;Context&gt; &lt;Valve className&#x3D;&quot;org.apache.catalina.valves.AccessLogValve&quot; directory&#x3D;&quot;logs&quot; prefix&#x3D;&quot;localhost_access_log&quot; suffix&#x3D;&quot;.txt&quot;pattern&#x3D;&quot;&amp;h %l %u %t &quot;%r%quot; %s &amp;b&quot; &#x2F;&gt;&lt;&#x2F;Host&gt; 4.2. tomcat-users.xml 该配置文件中。主要配置的是Tomcat的用户，角色等信息。用来控制Tomcat中manager，host-manager的访问权限。 5.Web配置文件 web.xml是web应用的描述文件，它支持的元素及属性来自于Servlet规范定义。 在Tomcat中，web应用的描述信息包括tomcat/conf/web.xml中默认配置以及Web应用WEB-INF/web. xml下的定制配置 5.1.ServletContext初始化参数1234&lt;context-param&gt; &lt;param-name&gt;project_param_01&lt;/param-name&gt; &lt;param-value&gt;itcast&lt;/param-value&gt;&lt;/context-param&gt; 1String value &#x3D; req.getServletContext().getInitParameter(&quot;project_param_01&quot;); 5.2会话配置&lt;session-config&gt;用于配置web应用会话,包括超时时间，Cookie配置以及会话追踪模式。它将覆盖server.xml和context.xml中的配置。 12345678910111213&lt;Session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;cookie-config&gt; &lt;name&gt;JESSIONID&lt;/name&gt; &lt;domain&gt;www.itcast.cn&lt;/domain&gt; &lt;path&gt;/&lt;/path&gt; &lt;comment&gt;Session Cookie&lt;/ comment&gt; &lt;http-only&gt;true&lt;/http-only&gt; &lt;secure&gt;false&lt;/secure&gt; &lt;max-age&gt;3600&lt;/max-age&gt; &lt;/cookie-config&gt; &lt;tracking-mode&gt;COOKIE&lt;/tracking-mode&gt;&lt;/session-config&gt; 12345678910111213141) session-timeout 会话超时时间,单位分钟2) cookie-config 用于配置会话追踪Cookie3) name Cookie的名称4) domain Cookie的域名5) path Cookie的路径6) comment 注释7) http-only cookie只能通过HTTP方式进行访问，Js无法读取或修改，此项可以增加网站访问的安全性8) secure 此cookie只能通过HTTPs连接传递到服务器,而HTTP连接则不会传递该信息。注意是从浏览器传递到服务器，服务器端的Cookie对象不受此项影响9) max-age 以秒为单位表示cookie的生存期，默认为-1表示是会话Cookie ,浏览器关闭时就会消失10) tracking-mode 用于配置会话追踪模式，Servlet3.0版本中支持的追踪模式 COOKIE、 URL、 SSL 1.COOKIE——通过HTTP Cookie 追踪会话是最常用的会话追踪机制，而且servlet规范也要求所有的Servlet规范都需要支持Cookie追踪。 2.URL——URL重写是最基本的会话追踪机制。当客户端不支持Cookie时，可以采用URI重写的方式。当采用URL追踪模式时,请求路径需要包含会话标识信息，Servlet容器会根据路径中的会话标识设置请求的会话信息。如: http:&#x2F;&#x2F;www.myserver.com&#x2F;user&#x2F;index.html;jessionid&#x3D;1234567890 3.SSL——对于ssL请求，通过ssl会话标识确定请求会话标识 1String session &#x3D; req.getSession().getId() 5.3. Servlet配置 Servlet的配置主要是两部分，servlet 和servlet-mapping 12345678910111213141516&lt;servlet&gt; &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt; &lt;servlet-c1ass&gt;cn.itcast.web.MyServlet&lt;/servlet-class&gt; &lt;init-param&gt; 此处的初始化参数只对本Servlet有效 &lt;param-name&gt;fileName&lt;/param-name&gt; &lt;param value&gt;init.conf&lt;/param value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;enabled&gt;true&lt;/enabled&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt; &lt;ur1-pattern&gt;*.do&lt;/url-pattern&gt; &lt;ur1-pattern&gt;/myservet/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 123451) servlet-name 指定servlet的名称 该属性在web.xml中唯一2) servlet-class 用于指定servlet类名3) init-param 用于指定servlet的初始化参数，在应用中可以通过HttpServlet.getInitParameter获取4) load-on-startup 用于控制在Web应用启动时，Servlet的加载顺序 值小于0第一次访问时加载5) enabled:true&#x2F;false 若为false 表示servlet不处理任何请求 5.4 Listener配置 Listener用于监听servlet中的事件，例如context，request，session对象的创建、修改、删除，并触发响应事件。 Listener是观察者模式的实现，在Servlet中主要用于对context、request、 session对象的生命周期进行监控。在servlet2.5规范中共定义了8种Listener。 在启动时, servletContextListener的执行顺序与web.xml中的配置顺序一致，停止时执行顺序相反 5.5 Filter配置 Filter用于配置web应用过滤器，用来过滤资源请求及响应。经常用于认证、日志、加密、数据转换等操作，配置如下: 1234567891011121314&lt;filter&gt; &lt;filter-name&gt;myFilter&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.MyFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;language&lt;/param-name&gt; &lt;param-value&gt;CN&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;myFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 123451) filter-name 用于指定过滤器名称 在web.xml中，过滤器名称必须唯一2) filter-class 过滤器的全限定类名，该类必须实现Filter接口3) async-supported 该过滤器是否支持异步4) init-param 用于配置Filter的初始化参数 可以配置多个 可以通过Fi lterConfig.getInitParameter获取5) ur1-pattern 指定该过滤器需要拦截的URL 5.6欢迎页面配置 welcome- file-list用于指定web应用的欢迎文件列表 尝试请求的顺序,从上到下 12345&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 5.7错误页面配置 error-page用于配置web应用访问异常时定向到的页面,支持HTTP响应码和异常类两种形式。 1234567891011121314&lt;error-page&gt; &lt;error-code&gt;404&lt;error-code&gt; &lt;location&gt;/404.html&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/500.html&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt; &lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt; 6.Tomcat 管理配置 从早期的Tomcat版本开始,就提供了web版的管理控制台,他们是两个独立的web应用,位于webapps目录下 Tomcat 提供的管理应用有用于管理Host的host-manager和用于管理web应用的manager 6.1 host-manager Tomcat启动之后,可以通过http://localhost:8080/host-manager/html访问该Web应用。 host-manager 默认添加了访问权限控制，当打开网址时,需要输入用户名和密码( conf/tomcat-users.xml中配置)。所以要想访问该页面,需要在conf/tomcat-users.xml中配置,并分配对应的角色: admin-gui :用于控制页面访问权限 admin-script :用于控制以简单文本的形式进行访问 12345# conf&#x2F;tomcat-users.xml&lt;role rolename&#x3D;&quot;admin-gui&quot;&#x2F;&gt;&lt;role rolename&#x3D;&quot;admin-script&quot;&#x2F;&gt;&lt;user username&#x3D;&quot;yyx&quot; passwd&#x3D;&quot;123456&quot; role&#x3D;&quot;admin-script,admin-gui&quot;&#x2F;&gt; 6.2. manager manager的访问地址为http://localhost:8080/manager，同样，manager也添加了 页面访问控制,因此我们需要为登录用户分配角色 12345# conf&#x2F;tomcat-users.xml&lt;role rolename&#x3D;&quot;manager-gui&quot;&#x2F;&gt;&lt;role rolename&#x3D;&quot;manager-script&quot;&#x2F;&gt;&lt;user username&#x3D;&quot;yyx&quot; password&#x3D;&quot;123456&quot; roles&#x3D;&quot;admin-script,admin-gui,manager-gui,manager-script&quot;&#x2F;&gt; 登录查看web应用 查看Server状态 7.JVM配置 最常见的JVM配置当属内存分配,因为在绝大多数情况下, JVM默认分配的内存可能不能够满足我们的需求,特别是在生产环境,此时需要手动修改Tomcat启动时的内存参数分配 7.1. JVM内存模型图 7.2. JVM配置选项 Windows平台（catalina.bat） 1set JAVA_OPTS&#x3D;-server -Xms2048m -Xmx2048m -XX:MetaspaceSize&#x3D;256m -XX:MaxMetaspaceSize&#x3D;256m -XX:SurvivorRatio&#x3D;8 linux平台（catalina.sh） 1JAVA_OPTS&#x3D;&quot;-server -Xms1024m -Xmx2048m -XX:MetaspaceSize&#x3D;256m -XX:MaxMetaspaceSize&#x3D;512m -XX:SurvivorRatio&#x3D;8&quot; 序号 参数 含义 1 -Xms 堆内存的初始大小 2 -Xmx 堆内存的最大大小 3 -Xmn 新生代的内存大小，官方建议是整个堆得3/8。 4 -XX:MetaspaceSize 元空间内存初始大小，在JDK1. 8版本之前配置为-xx:Permsize (永久代) 5 -XX:MaxMetaspaceSize 元空间内存最大大小，在JDK1 .8版本之前配置为-Xx:MaxPermsize (永久代} 6 -XX:NewRatio 设置新生代和老年代的相对大小比例。这种方式的优点是新生代大小会随着整个堆大小动态扩展。如-XX:NewRatio=3 指定老年代/新生代为3/1。老年代占堆大小的3/4.新生代占1/4。 7 -XX:SurvivoRatio 指定伊甸园区(Eden) 与幸存区大小比例。如-XX:survivorRatio=10 表示伊甸园区(Eden) 是幸存区To大小的10 倍(也是幸存区From 的10倍)。所以，伊甸园区(Eden) 占新生代大小的10/12， 幸存区From和幸存区To每个占新生代的1/12。注意， 两个幸存区永远是一样大的。 8.Tomcat集群8.1. 介绍 由于单台Tomcat的承载能力是有限的，当我们的业务系统用户量比较大，请求压力比较大时，单台Tomcat是扛不住的,这个时候,就需要搭建Tomcat的集群,而目前比较流程的做法就是通过Nginx来实现tomcat集群的负载均衡。 8.2.环境准备8.2.1. 准备多台Tomcat 在服务器上，安装两台tomcat【复制两个Tomcat目录】，然后分别改Tomcat服务器的端口号 关闭命令监听端口 HTTP监听端口 AJP监听端口 1234原配置 Tomcat1 Tomcat28005 ---------&gt; 8015 ---------&gt; 80258080 ---------&gt; 8888 ---------&gt; 99998009 ---------&gt; 8019 ---------&gt; 8029 8.2.2. 准备Nginx 在当前服务器上，安装Nginx，然后再配置Nginx,配置nginx.conf 1234567891011upstream serverpool&#123; server localhost:8888; server localhost:9999;&#125;server &#123; listen 99; server_name localhost; location &#x2F; &#123; proxy_pass http:&#x2F;&#x2F;serverpool&#x2F;; # 反向代理 &#125; 8.3. 负载均衡策略 轮询 最基本的配置方法,它是upstream模块默认的负载均衡默认策略。每个请求会按时间顺序逐一分配到不同的后端服务器。 1234upstream serverpool&#123; server localhost:8888; server localhost:9999;&#125; 描述 fail_timeout 与max_fails结合使用 max_fails 设置在fail_timeout参数设置的时间内最大失败次数,如果在这个时间内,所有针对该服务器的请求都失败了,那么认为该服务器会被认为是停机了 fail_time 服务器会被认为停机的时间长度,默认为10s backup 标记该服务器为备用服务器。当主服务器停止时，请求会被发送到它这里 down weight权重 权重方式,在轮询策略的基础上指定轮询的几率 1234upstream serverpool&#123; server localhost:8888 weight&#x3D;3; server localhost:9999 weight&#x3D;2;&#125; weight参数用于指定轮训几率, weight的默认值为1 ; weight的数值与访问比率成正比 此策略比较适合服务器的硬件配置差别比较大的情况 ip_hash 指定负载均衡器按照基于客户端IP的分配方式 这个方法确保了相同的客户端的请求一直发送到相同的服务器,以保证session会话。 这样每个访客都固定访问一个后端服务器,可以解决session不能跨服务器的问题。 12345upstream serverpool&#123; ip_hash; server 192.168.192.133:8080 weight&#x3D;3; server 192.168.192.137:8080 weight&#x3D;2;&#125; 8.4.Session共享方案 在Tomcat集群中,如果应用需要用户进行登录,那么这个时候,用于tomcat做了负载均衡,则用户登录并访问应用系统时,就会出现问题 8.4.1 ip_hash 策略 一个用户发起的请求,只会请求到tomcatA上进行操作，另一个用户发起的请求只在tomcatB上进行操作。那么这个时候,同一个用户发起的请求。都会通过nginx的ip_ hash策略,将请求转发到其中的一台Tomcat上。 8.4.2. Session复制 在sexvlet_demo01工程中，制作seession.jsp页面。分别将工程存放在两台tomcat的webapps/目录下 123456789101112131415161718192021222324&lt;%@ page language&#x3D;&quot;java&quot; contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot; pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;login&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;TOMCAT---A&#x2F;BsessionID: &lt;%&#x3D; session.getId() %&gt;&lt;% Object loginUser &#x3D; session.getAttribute(&quot;loginUser&quot;); if(loginUser !&#x3D; null &amp;&amp; loginUser.toString().length()&gt;0) &#123; out.println(&quot;session有值，loginUser &#x3D;&quot; + loginUser);&#125; else&#123; session.setAttribute(&quot;loginUser&quot;,&quot;ITCAST&quot;); out.println(&quot;session没有值&quot;); &#125;%&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 配置小规模Session复制负载均衡 配置前 第一次访问8888Tomcat 第一次访问9999Tomcat——之前访问8888记录未同步——session无值 配置 在conf/server.xml文件中 1&lt;Cluster className&#x3D;&quot;org.apache.catalina.ha.top.SimpleTopCluster&quot;&#x2F;&gt; 在工程web.xml中，增加一行 1&lt;distributable&#x2F;&gt; 配置后 第一次访问8888Tomcat 第一次访问9999Tomcat——之前访问8888记录同步——session有值 Session复制实现Session共享弊端 适用于较小的集群环境(节点数不超过4个) 如果集群的节点数比较多的话,通过这种广播的形式来完成session的复制，会消耗大量的网络带宽,影响服务的性能 8.4.3.SSO-单点登录【重点】 单点登录(Single Sign On) , 简称为SSO，是目前比较流行的企业业务整合的解决方案之一。 SSO的定义是在多个应用系统中,用户只需要登录一次就可以访问所有相互信任的应用系统,也是用来解决集群环境session共享的方案之一","tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://goldcarpenter.github.io/tags/Tomcat/"}]},{"title":"Tomcat","date":"2020-01-10T16:00:00.000Z","path":"2020/01/11/Tomcat_Part1/","text":"Tomcat1.Tomcat目录结构 目录 目录下文件 说明 bin / 存放Tomcat的启动、停止等批处理脚本文件 startup.bat/startup.sh 用于在windows和Iinux下的启动脚本 shutdown.bat/shutdown. sh 用于在windows和linus下的停止脚本 conf / 用于存放Tomcat的相关配置文件 Catalina 用于存储针对每个虚拟机的context配置 logging.properties Tomcat的日志配置文件，可以通过该文件修改tomcat的日志级别及日志路径等 server.xml Tomcat服务器的核心配置文件 tomcat-users.xml 定义Tomcat默认的用户及角色映射信息配置 web.xml Tomcat中所有应用默认的部署描述文件，主要定义了基础servlet和时 context.xml 用于定义所有web应用均需加载的context配置，如果web应用指定了自己的context. xml该文件将被覆盖 catalina.policy Tomcat运行的安全策略配置 catalina.properties Tomcat的环境变量配置l lib / Tomcat服务器的依赖包 logs / Tomcat默认的日志存放目录 webapps / Tomcat默认的web应用部署目录 work / Web应用JSP代码生成和编译的临时目录 2.Tomcat整体架构2.1.Http服务器处理请求 浏览器发给服务端的是一个Http格式的请求，Http服务器收到这个请求后，需要调用服务端程序来处理 所谓的服务端程序就是程序员写的Java类，一般来说不同的请求需要由不同的Java类来处理 如何确定所需要调用的业务Java代码？ 左图方案✖ Http服务器直接调用具体业务类，存在过多的if…else…判断，紧耦合 右图方案✔ Http服务器不直接调用业务类，而把请求交给Servlet容器处理，Servlet容器通过Servlet接口调用业务类 因此Servlet接口和servlet容器的出现，达到了Http服务器与业务类解耦的目的 Servlet接口和Servlet容器这一整套规范叫作Servlet规范 Tomcat按照Servlet规范的要求实现了Servlet容器，同时它们也具有HTTP服务器的功能 作为Java程序员。如果要实现新的业务功能，只需要实现一个Servlet ,并将Servlet注册到Tomcat (Servlet容器)中，剩下的事情就由Tomcat帮我们处理了 2.2.Servlet容器工作流程 为了解耦，Http服务器不直接调用Servlet，而是把请求交给servlet容器来处理，那Servlet容器又是怎么工作的呢? 当客户请求某个资源时 HTTP服务器会用一个ServletRequest对象把客户的请求信息封装起来,然后调用Servlet容器的service方法 【定位Servlet】Servlet容器拿到请求后,根据请求的URL和Servlet的映射关系,找到相应的Servlet 【加载Servlet】如果servlet还没有被加载,就用反射机制创建这个Servlet，并调用Servlet的init方法来完成初始化 【调用Servlet】接着调用Servlet的service方法来处理请求，把servletResponse对象返回给HTTP服务器, HTTP服务器会把响应发送给客户端。 2.3.Tomcat整体架构 我们知道如果要设计一个系统，首先是要了解需求，我们已经了解了Tomcat要实现两个核心功能: 处理socket连接 ,负责网络字节流与Request和Response对象的转化 加载和管理Servlet ,以及具体处理Request请求 因此Tomcat设计了两个核心组件连接器( Connector )和容器( Container )来分别做这两件事情。 连接器负责对外交流 容器负责内部处理 2.4.连接器–Coyote2.4.1.架构介绍 Coyote是Tomcat的连接器框架的名称，是Tomcat服务器提供的供客户端访问的外部按口。客户端通过coyote与服务器建立连接、发送请求并接受响应 Coyote封装了底层的网络通信(Socket请求及响应处理) , 为Catalina容器提供了统一的接口，使Catalina容器与具体的请求协议及IO操作方式完全解耦 Coyote将Socket输入转换封装为Request对象，交由Catalina容号进行处理，处理请求完成后，Catalina通过Coyote提供的Response对象将结果写入输出流 Coyote作为独立的模块，只负责具体协议和IO的相关操作，与Servlet规范实现没有直接关系，因此即便是Request和Response对象也并未实现servlet规范对应的接口，而是在Catalina中将他们进一步封装为ServletRequest 和ServletResponse。 2.4.2.IO模型与协议 在Coyote中，Tomcat支持的多种I/O模型和应用层协议 在8.0之前，Tomcat默认采用的I/O方式为BIO Tomcat支持的I/O模型（自8.5/9.0版本起，Tomcat移除了对BIO的支持） IO模型 描述 NIO 非阻塞I/O，采用Java NIO类库实现【8.5默认】 NIO2 异步I/O，采用JDK 7最新的NIO2类实现 APR 采用Apache可移植运行库实现，是C/C++编写的本地库。如果选择该方案，需要单独安装 Tomcat支持的应用层协议: 应用层协议 描述 HTTP/1.1 这是大部分Web应用采用的访问协议 AJP 用于和Web服务器集成(如Apache )。以实现对静态资源的优化以及集群部著，当前支持AJP/1.3 HTTP/2 HTTP 2. 0大幅度的提升了Web性能。下一代HTTP协议 ，自8 .5以及9.0版本之后支持 Tomcat为了实现支持多种I/O模型和应用层协议，一个容器可能对接多个连接器, 类比一个房间有多个门 单独的连接器或者容器都不能对外提供服务,需要把它们组装起来才能工作，组装后这个整体叫作Service组件。这里请你注意, Service本身没有做什么重要的事情，只是在连接器和容器外面多包了一层,把它们组装在一起 Tomcat内可能有多个Service ,这样的设计也是出于灵活性的考虑。通过在Tomcat中配置多个Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用 2.4.3.连接器组件 连接器中的各个组件的作用如下 Endpoint Coyote 通信端点，即通信监听的接口，是具体socket接收和发送处理器，是对传输层的抽象，因此Endpoint用来实现TCP/IP协议的 Tomcat并没有EndPoint接口，而是提供了一个抽象类AbstractEndpoint，里面定义了两个内部类: Acceptor和SocketProcessor。 Acceptor用于监听Socket连接请求。 SocketProcessor用于处理接收到的Socket请求,它实现Runnable接口。在Run方法里调用协议处理组件Processor进行处理。为了提高处理能力, Socketprocessor被提交到线程池来执行，而这个线程池叫作执行器(Executor) Processor Coyote协议处理接口，如果说EndPoint是用来实现Tcp/Ip协议的，那么Processor用来实现Http/AJP协议 Processor接收来自EndPoint的Socket ,读取字节流解析成Tomcat Request和Response对象 ，并通过Adapter将其提交到容器处理，Processor是对应用层协议的抽象。 ProtocolHandler Coyote协议接口，通过Endpoint和Processor，实现针对具体协议的处理能力。 Tomcat按照协议和I/O提供了6个实现类: AjpNioProtocol，AjpAprprotocol，AjpNio2Protocol ，Http11Nioprotocol ，Http11Nio2Protocol , Http11AprProtocol 我们在配置tomcat/conf/server.xml时，至少要指定具体的ProtocolHandler，当然也可以指定协议名称，如: HTTP/1.1, 如果安装了APR，那么将使用Http11AprProtocol，否则使用Http11NioProtocol。 Adapter 由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat定义了自己的Request类来”存放”这些请求信息。 ProtocolHandler接口负责解析请求并生成Tomcat Request类。但是这个Request对象不是标准的ServletRequest，也就意味着不能用Tomcat Request作为参数来调用容器。 Tomcat设计者的解决方案是引入CoyoteAdapter，这是适配器模式的经典运用，连接器调用CoyoteAdapter的Sevice方法，传入的是Tomcat Request对象，CoyoteAdapter负责将Tomcat Request转成ServletRequest，再调用容器的Service方法 2.5容器–Catalina Tomcat是由一系列可配置的组件构成的Web容器，而catalina是Tomcat的Servlet容器。 Catalina是Servlet容器实现，包含了之前讲到的所有的容器组件。以及后续章节涉及到的安全、会话、集群、管理等servlet容器架构的各个方面。 它通过松耦合的方式集成Coyote。以完成按照请求协议进行数据读写。同时,它还包括我们的启动入口、shell程序等。 2.5.1Catalina地位 Tomcat本质上就是一款Servlet容器，因此catalina才是Tomcat的核心，其他模块都是为Catalina提供支撑的。比如：通过Coyote模块提供链接通信，Jasper模块提供Jsp引擎，Naming提供JNDI服务，Juli提供日志服务。 2.5.2Catalina结构 Catalina负责管理Server ,而Server表示着整个服务器。 Server下面有多个服务Service。每个服务都包含着多个连接器组件Connector (coyote实现)和一个容器组件Container 在Tomcat启动的时候，会初始化一个Catalina的实例 Catalina各个组件的职责 组件 职责 Catalina 负责解析Tomcat的配置文件，以此来创建服务器Server组件,并根据命令来对其进行管理 Server 表示整个Catalina Servlet容器以及其它组件，负责组装并启动servlet引擎，Tomcat连接器。Server通过实现Lifecycle接口，提供了一种优雅的启动和关闭整个系统的方式 Service 是Server内部的组件，一个Server包含多个Service。它将若干个Connector组件绑定到一个Container (Engine)上 Connector 处理与客户端的通信，它负责接收客户请求，然后转给相关的容器处理，最后向客户返回响应结果 Container 负责处理用户的servlet请求,并返回对象给Web用户的模块 2.5.3.Container结构 Tomcat设计了4种容器，分别是Engine，Host，Context和Wrapper 这4种容器不是平行关系，而是父子关系 Tomcat通过一种分层的架构，使得servlet容器具有很好的灵活性 各个组件含义 容器 描述 Engine 表示整个Catalina的servlet引擎，用来管理多个虚拟站点，一个Service最多只能有一个Engine，但是一个引擎可包含多个Host Host 代表一个虚拟主机/站点。可以给Tomcat配置多个虚拟主机地址，而一个虚拟主机下可包含多个Context Context 表示个Web应用程序，一个Web应用可包含多个wrapper Wrapper 表示一个Servlet，Wrapper作为容眼中的最底层，不能包含子容器 可以通过Tomcat的Server.xml配置文件来加深对Tomcat容器的理解 Tomcat采用了组件化的设计,它的构成组件都是可配置的，其中最外层的是Server ,其他组件按照一定的格式要求配置在这个顶层容器中 Tomcat是怎么管理这些容器? Container接口部分方 这些容器具有父子关系，形成一个树形结构，Tomcat就是用组合模式来管理这些容器的 具体实现方法是,所有容器组件都实现了Container接口,因此组合模式可以使得用户对单容器对象和组合容器对象的使用具有一致性。 这里单容器对象指的是最底层的wrapper ,组合容器对象指的是上面的Context、Host或者Engine 2.6.Tomcat启动流程2.6.1流程 加载Tomcat的配置文件，初始化容器组件，监听对应的端口号，准备接受客户端请求 1234567891011121314- 启动tomcat，需要调用bin&#x2F;startup.bat (在linux目录下，需要调用bin&#x2F;startup.sh)，在startup.bat 脚本中，调用了catalina.bat- 在catalina.bat脚本文件中,调用了org.apache.catalina.startup.Bootstrap中的main方法- 在Bootstrap的main方法中调用了init方法，来创建catalina及初始化类加载器- 在Bootstrap的main方法中调用了load方法，在其中又调用了catalina的load方法- 在catalina的load方法中，需要进行一些初始化的工作，并需要构造Digester对象，用于解析XMI- 然后在调用后续组件的初始化操作Server----------------------------&gt;Service---------------------------&gt; Engine------------------------&gt; Host--------------------------&gt; Context-----------------------&gt;Executor--------------------------&gt;Connector-------------------------&gt;ProtocolHandler-------------------&gt; 2.6.2.源码解析2.6.2.1.Lifecycle 由于所有的组件均存在初始化、启动、停止等生命周期方法，拥有生命周期管理的特性 所以Tomcat在设计的时候，基于生命周期管理抽象成了一个接口Lifecycle , 而组件Server、Service, Container，Executor，Connector组件，都实现了一个生命周期的按口 从而具有了以下生命周期中的核心方法: init( ) :初始化组件 start( ) :启动组件 stop( ) :停止组件 destroy( ) :销毁组件 各个组件的默认实现 上面我们提到的server，service，Engine，Host，Context都是接口，下图中罗列了这些接口的默认实现类 当前对于Endpoint组件来说，在Tomcat中没有对应的Endpoint接口，但是有一个抽象类AbstractEndpoint , 其下有三个实现类：NioEndpoint，Nio2Endpoint，AprEndpoint，这三个实现类分别对应于前面讲解链接器Coyote时，提到的链接器支持的三种IO模型 : NIO，NIO2 , APR，Tomcat8 .5版本中,默认采用的是NioEndpoint ProtocolHandler : Coyote协议接口通过封装Endpoint和Processor，实现针对具体协议的处理功能。 Tomcat按照协议和IO提供 了6个实现类 AjpNioProtocol————Ajp协议 采用NIO的IO模型 AjpNio2Protocol————Ajp协议 采用NIO2的IO模型 AjpAprprotocol————Ajp协议 采用APR的IO模型 依赖于APR库 Http11Nioprotocol————Http协议 采用NIO的IO模型 默认使用的协议 Http11Nio2Protocol————Http协议 采用NIO2的IO模型 Http11AprProtocol————Http协议 采用APR的IO模型 依赖于APR库 2.6.2.2.码源跟踪 初试化过程 进入bootstrap.init()–发现其创建Catalina对象 返回main()继续 进入BootStrap的load()—–其调用了catalina对象load方法 打开catalina类 在load()重载方法中 catalina的load方法中初始化了Server 进入init()方法—发现是个接口 进入 发现使用模板方法——将共有的逻辑抽象到父类中 在子类中实现自身逻辑 进入initInternal()——寻找StandardServer实现类中的initInternal() 在Server的init()中初始化services 进入init()方法—发现又一次进入到顶级接口 进入实现LifecycleBase 再次进入initInternal 查找Service的标准实现StandarService Service中执行内容很多了 进入engine.init() executor.init()同理，此处跟踪connector.init() 进入protocolHandler.init() 进入实现类 再进入super.init()—-发现初始化endpoint bind()方法又是一个模板方法 选择默认IO模型 至此所有初始化代码跟踪结束 start过程 返回main()方法 上一个部分是从daemon.load()开始的 此次进入start()方法 通过反射调用了catalina.start()方法 找到catalina.start()方法 进入了Lifecycle接口 进入startInternal() 进入它的实现类 调用了services.start() 进入start()方法—-又回到了 又回到了 又回到了 又回到了 这次进入StanderService 直接进入connector.start() 进入Connector 进入protocolHandler.start() 进入start() 进入startAcceptorThreads() 进入第一个Acceptor 进入第二个位置createAcceptor(); 在run方法中 2.6.3.总结 从启动流程图中以及源码中，我们可以看出Tomcat的启动过程非常标准化，统一按照生命周期管理按口lifecycle的定义进行启动。 首先调用init()方法进行组件的逐级初始化操作，然后再调用start ()方法进行启动。 每一级的组件除了完成自身的处理外，还要负责调用子组件响应的生命周期管理方法，组件与组件之间是松耦合的,因为我们可以很容易的通过配置文件进行修改和替换。 2.7.Tomcat请求处理流程2.7.1.流程 设计了这么多层次的容器，Tomcat是怎么确定每一个请求应该由哪个wrapper容器里的servlet来处理的呢 ? 1Tomcat是用Mapper组件来完成这个任务的 Mapper组件的功能就是将用户请求的Url定位到一个servlet ,它的工作原理 多层次的Map Mapper组件里保存了web应用的配置信息 其实就是容器组件与访问路径的映射关系 123Host容器里配置的域名Context容器里的web应用路径Wrapper容器里serv1et映射的路径 当一个请求到来时，Mapper组件通过解析请求URL里的域名和路径，再到自己保存的Map里去查找,就能定位到一个Servlet。 一个请求URL最后只会定位到一个Wrapper容器，也就是一个Servlet 例子 总体分为两个部分 2.7.2.源码分析 在前面所讲解的Tomca t的整体架构中,我们发现Tomcat中的各个组件各司其职,组件之间松耦合，确保了整体架构的可伸缩性和可拓展性,那么在组件内部,如何增强组件的灵活性和拓展性呢? 在Tomcat中 ,每个Container组件采用责任链模式来完成具体的请求处理。 在Tomcat中定义了Pipeline和valve两个接口，Pipeline用于构建责任链，后者代表责任链 上的每个处理器。Pipeline中维护了一个基础的valve ,它始终位于Pipeline的末端(最后执行) , 封装了具体的请求处理和输出响应的过程。当然,我们也可以调用addvalve()方法，为pipeline 添加其他的valve，后添加的valve 位于基础的valve之前,并按照添加顺序执行。Pipiline通过获得首个valxe来启动整合链条的执行 在源码的Tomcat中部署一个Servlet，访问 进入process() 在进入实现 进入process() 进入service() 适配器对象调用service方法 getContainer()返回的就是Engine 进入 再次进入invoke() 3.Jasper 对于基于Jsp的Web应用来说,我们可以直接在Jsp页面中编写Java代码，添加第三方的标签库，以及使用r工表达式。但是无论经过何种形式的处理, 最终输出到客户端的都是标准的ITML页面(包含js , css… )，并不包含任何的java相关的语法。也就是说 ，我们可以把jsp看做是一种运行在服务端的脚本。那么服务器是如何将Jsp页面转换为HTMI页面的呢? Jasper模块是Tomcat的Jsp核心引擎,我们知道Jsp本质上是一个servlet。Tomcat使用Jasper对Jsp语法进行解析 ,生成servlet并生成class字节码,用户在进行访问jsp时,会访问servlet ,最终将访问的结果直接响应在浏览器端。 另外,在运行的时候, Jasper还会检测Jsp文件是否修改，如果修改，则会重新编译Jsp文件。 3.1.Jsp编译方式3.1.1.运行时编译 Tomcat并不会在启动jsp应用的时候自动编译jsp文件，而是在客户端第一次请求时 ，才编译需要访问的的jsp文件。 3.1.1.1.编译过程 Tomcat在默认的web.xml中配置了一个org.apache.jasper.servlet.JspServlet ,用于处理所有的.jsp或.jspx结尾的请求，该Servlet实现即是运行时编译的入口。 Jspservlet处理流程图: 获取jsp文件路径 是否是预编译请求 进入serviceJspFlie 进入service方法 进入ctxt.compile() 退回到ctxt.compile的下一行 放行到476 进入 执行我们的jsp的servlet 3.1.1.2.编译结果 如果在tomcat/conf/web.xml中配置了参数scratchdir，则jsp编译后的结果就会存储在该目录下 1234&lt;init-param&gt;&lt;par. am-name&gt; sora tahdir&lt;&#x2F;par am- name&gt;&lt;param-value&gt;D: &#x2F; tmp&#x2F;jsp&#x2F;&lt;&#x2F;param-value&gt;&lt;&#x2F;init -param&gt; 如果没有配置该选项，则会将编译后的结果,存储在Tomcat安装目录下的 123Tomcat安装目录&#x2F;work&#x2F;Catalina (Engine名称) &#x2F;localhost (Host名称)&#x2F;（Context名称）假设项目名称为jsp_demo_01，默认的目录为: work&#x2F;catalina&#x2F;localhost&#x2F;jsp_demo_01 如果使用的是IDEA开发工具集成tomcat访问web工程中的jsp，编译后的结果 1C:\\Users\\Administrator\\.IntelliJIdea2019.1\\system\\tomcat\\_project_ tomcat\\work\\Catalina\\localhost\\jsp_demo_01_war_exploded\\org\\apache\\jsp 3.1.2.预编译 除了运行时编译，我们还可以直接在web应用启动时，一次性将web应用中的所有的Jse页面一次性编译完成。 在这种情况下, web应用运行过程中，使可以不必再进行实时编译,而是直接调用Jsp页面对应的servlet完成请求处理，从而提升 系统性能。 Tomcat提供了一个shell程序JspC。用于支持JSP预编译,而且在Tomcat的安装目录下提供了一个catalina-tasks.xml文件，声明了Tomcat支持的Ant任务，因此，我们很容易使用Ant来执行JSP 预编译。( 要想使用这种方式,必须得确保在此之前已经下载并安装了Apache Ant )。 3.2. JSP编译原理 类名为index_jsp.java继承自org.apache.jasper . runtime.HttpJspBase，该类是HttpServlet的子类，所以Jsp本质就是一个servlet 通过属性_jspx_dependants 保存了当前Jsp页面依赖的资源，包含引入的外部的Jsp页面、 导入的标签、标签所在的jar包等，便于后续处理过程中使用（如重新编译检测,因此它以Map形式保存了每个资源的上次修改时间） 通过属性_jspx_imports_ packages存放导入的java包，默认导入javax.servlet，javax.servlet.http，javax.servlet.jsp 通过属性_jspx_imports_classes存放导入的类，通过import指令导入的DateFormat，SimpleDateFormat，Date都会包含在该集合中。_jspx_imports_ packages和jspx_imports_clases属性主要用于配置EL引擎上下文。 请求处理由方法_jspService完成，而在父类HttpJspBase中的service 方法通过模板方法模式，调用了子类的_jspService方法。 )) _jspService方法中定义了几个重要的局部变量:pageContext 、Session、 application、 config、 out、page。 由于整个页面的输出由_jspService方法完成,因此这些变量和参数会对整个Jsp页面生效。这也是我们为什么可以在Jsp页面使用这些变 量的原因。 指定文档类型的指令( page)最终转换为response.setContentType()方法调用 对于每一行的静态内容( HTML) ，调用out.write 输出 对于&lt;% … %&gt;中的java代码，将直接转换为Servlet 类中的代码。如果在 Java代码中嵌入了静态文件，则同样调用out.write输出","tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://goldcarpenter.github.io/tags/Tomcat/"}]},{"title":"ThreadLocal总结","date":"2019-12-21T15:19:21.000Z","path":"2019/12/21/ThreadLocal/","text":"ThreadLocal1.简介 ThreadLocal可以为当前线程关联一个数据【普通变量，对象，数组，集合】 可以像 Map一样存取数据，key 为当前线程，保证各个线程的变量相对独立于其他线程内的变量，解决多线程的数据安全问题。 每一个ThreadLocal对象，只能为当前线程关联一个数据，如果要为当前线程关联多个数据，就需要使用多个ThreadLocal对象 每个ThreadLocal对象实例定义的时候，一般都是static类型 ThreadLocal中保存数据，在线程销毁后。会由JVM虚拟自动释放 2.常用方法 方法声明 描述 ThreadLocal() 创建ThreadLocal对象 public T get() 设置当前线程绑定的局部变量 public void set(T value) 获取当前线程绑定的局部变量 public void remove() 移除当前线程绑定的局部变量 3.案例 线程隔离，在多线程并发的场景下，每个线程中的变量都是相互独立线程1——设置(变量1)——获取(变量1)线程2——设置(变量2)——获取(变量2) 12345678910111213141516171819202122public class Main &#123; String content; public String getContent() &#123; return this.content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public static void main(String[] args) &#123; Main main = new Main(); for (int i = 0; i &lt; 5; i++) &#123; Thread thread = new Thread(() -&gt; &#123; main.setContent(Thread.currentThread().getName() + \"的数据\"); System.out.println(\"--------------------\"); System.out.println(Thread.currentThread().getName() + \"---&gt;\" + main.getContent()); &#125;); thread.setName(\"线程\"+i); thread.start(); &#125; &#125;&#125; 12345678910--------------------线程2---&gt;线程2的数据--------------------线程3---&gt;线程3的数据--------------------线程0---&gt;线程4的数据--------------------线程4---&gt;线程1的数据--------------------线程1---&gt;线程1的数据 尝试使用Synchronized解决 1234567891011121314public static void main(String[] args) &#123; Main main = new Main(); for (int i = 0; i &lt; 5; i++) &#123; Thread thread = new Thread(() -&gt; &#123; synchronized (Load10.class) &#123; main.setContent(Thread.currentThread().getName() + \"的数据\"); System.out.println(\"--------------------\"); System.out.println(Thread.currentThread().getName() + \"---&gt;\" + main.getContent()); &#125; &#125;); thread.setName(\"线程\"+i); thread.start(); &#125; &#125; 从结果可以发现，加锁确实可以解决这个问题，但是在这里我们强调的是线程数据隔离的问题，并不是多线程共享数据的问题，在这个案例中使用synchronized关键字是不合适的。 ThreadLocal与synchronized的区别 虽然ThreadLocal模式与synchronized关键字都用于处理多线程并发访问变量的问题,不过两者处理问题的角度和思路不同。 synchronized ThreadLocal 原理 同步机制采用以时间换空间的方式，只提供了一份变量，让不同的线程排队访问 ThreadLocal采用以空间换时间的方式，为每一个线程原都提供了一份变量的副本，从而实现同时访问而相不干扰 侧重点 多个线程之间访问资源同步 多线程中让每个线程之间的数据相互隔离 ThreadLocal 12345678ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();public String getContent() &#123; String content = threadLocal.get(); return content;&#125;public void setContent(String content) &#123; this.threadLocal.set(content);&#125; 4.ThreadLocal方案的好处 线程隔离：各线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失【案例1】 传递数据：保存每个线程绑定的数据，在需要的地方可以直接获取，避免参数直接传递带来的代码耦合问题【Service层和Dao层传递Connection对象】 4.内部结构 早期 每个ThreadLocal都创建一个Map，然后用线程作为Map的key，要存储的局部变量作为Map的value ，这样就能达到各个线程的局部变量隔离的效果。 JDK8 每个Thread维护一个ThreadLocalMap，这个Map的key是ThreadLocal实例本身，value 才是真正要存储的值Object。 具体的过程是这样的: 每个Thread线程内部都有一个Map【ThreadLocalMap】 Map【ThreadLocalMap】key存储ThreadLocal对象和 value存储线程的变量副本 Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。 对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。 JDK8 VS 早期的优点 每个Map存储的Entry数量变少 当Thread销毁的时候, ThreadLocalMap也会随之销毁,减少内存的使用 5.ThreadLocal源码分析5.1.set方法1234567891011121314151617181920212223242526272829303132333435363738/** * 设置当前线程对应的ThreadLocal的值 * @param value 将要保存在当前线程对应的ThreadLocal的值 */ pub1ic void set(T value) &#123; //获取当前线程对象 Thread t = Thread.currentThread(); //获取此线程对象中维护的ThreadLocalMap对象 ThreadLocalMap map = getMap(t); //判断map是否存在 if (map != nu11)&#123; //存在则调用map.set设置此实体entry map.set(this, value); &#125;else&#123; // 1)当前线程Thread不存在ThreadLocalMap对象 // 2)则调用createMap进行ThreaduocalMap对象的初始化 // 3)并将t(当前线程)和value(t对应的值)作为第一 个entry存放至ThreadLocalMap中 createMap(t, value); &#125;/** * 获取当前线程Thr ead对应维护的ThreadLocalMap * @param t the current thread 当前线程 * @return the map 对应维护的ThreadLocalMap */ ThreadLocalMap getMap(Thread t) &#123; return t.threadlocals; &#125;/** * 创建当前线程Thread对应维护的ThreadLocalMap * @param t 当前线程 * @param firstValue存放到map中第一个entry的值 */ void createMap(Thread t,T firstValue) &#123; //这里的this 是调用此方法的threadLocal t.threadlocals = new ThreadLocalMap(this, firstValue); &#125; 代码执行流程 首先获取当前线程,并根据当前线程获取一个Map 如果获取的Map不为空,则将参数设置到Map中(当前ThreadLocal的引用作为key ) 如果Map为空,则给该线程创建Map，并设置初始值 5.2.get方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 返回当前线程中保存ThreadLocal的值 * 如果当前线程没有此ThreadLocal变量 * 则它会通过调用&#123;@link #initialvalue&#125; 方法进行初始化值 * * @return 返回当前线程对应此ThreadLocal的值 */ public T get() &#123; //获取当前线程对象 Thread t = Thread.currentThread(); //获取此线程对象中维护的ThreadLocalMap对象 ThreadLocalMap map = getMap(t) ; //如果此map存在 if (map != nu11) &#123; //以当前的ThreadLocal为key,调用getEntry获取对应的存储实体e ThreadLocalMap.Entry e = map.getEntry(this); //对e进行判空 if (e != nu11) &#123; @SuppressWarnings(\"unchecked\") //获取存储实体e对应的value值 //即为我们想要的当前线程对应此ThreadLocal的值 T result = (T)e.value; return result; &#125; &#125; /* 初始化:有两种情况有执行当前代码 第一种情况: map不存在，表示此线程没有维护的ThreadLocalMap对象 第二种情况: map存在， 但是没有与当前ThreadLocal关联的entry */ return setInitialvalue(); &#125;/** * 初始化 * @return the initial value初始化后的值 */ private T setInitialvalue() &#123; //调用initialvalue获取初始化的值 //此方法可以被子类重写，如果不重写默认返回null T value = initialValue(); //获取当前线程对象 Thread t = Thread.currentThread(); //获取此线程对象中维护的ThreadLocalMap对象 ThreadLocalMap map = getMap(t); //判断map是否存在 if (map != nu11)&#123; //存在则调用map.set设置此实体entry map.set(this,value); &#125;else&#123; // 1)当前线程Thread 不存在ThreadL oca 1Map对象 // 2)则调用cr eat eMap进行ThreadLoca 1Map对象的初始化 // 3)并将t(当前线程)和value(t对应的值)作为第一个entry存放至Thr eadL ocalMap中 createMap(t,value); &#125; //返回设置的值value return value; &#125; 代码执行流程 首先获取当前线程，根据当前线程获取一个Map 如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的Entry e，否则转到4 如果e不为null，则返回e.value，否则转到4 Map为空或者e为空,则通过initialValue函数获取初始值value ,然后用Threadlocal的引用和value作为firstKey和firstValue创建一个新的Map 总结：先获取当前线程的ThreadLocalMap变量，如果存在则返回值，不存在则创建并返回初始值。 5.3.remove方法12345678910111213/** * 删除当前线程中保存的Thr eadLoca 1对应的实体entry */ public void remove() &#123; //获取当前线程对象中维护的ThreadLocalMap对象 ThreadLocalMap m = getMap(Thread.currentThread()); //如果此map存在 if (m != nu11)&#123; //存在则调用map.remove //以当前ThreadLocal为key删除对应的实体entry m.remove(this); &#125; &#125; 代码执行流程 首先获取当前线程，并根据当前线程获取一个Map 如果获取的Map不为空，则移除当前ThreadLocal对象对应的entry 5.4.initialValue方法1234567891011121314/** * 方返回当前线程对应的Threadlocal的初始值 * 此方法的第一次调用发生在，当线程通过get方法访问此线程的ThreadLocal值时 * 除非线程先调用了set方法，在这种情况下，initialvalue才不会被这个线程调用。 * 通常情况下，每个线程最多调用一次这个方法。 * 这个方法仅仅简单的返回null &#123;@code nu11&#125;; * 如果程序员想ThreadLoca1线程局部变量有一个除null以外的初始值， * 必须通过子类继承&#123;@code ThreadLocal&#125; 的方式去重写此方法 * 通常，可以通过匿名内部类的方式实现 * @return 当前ThreadLocal的初始值*/protected T initialValue() &#123; return nu11;&#125; 此方法的作用是返回该线程局部变量的初始值。 这个方法是一个延迟调用方法，从上面的代码我们得知，在set方法还未调用而先调用了get方法时才执行，并且仅执行一次 这个方法缺省实现直接返回null 如果想要一个除null之外的初始值,可以重写此方法。( 备注:该访法是一个protected的方法，显然是为了让子类覆盖而设计的) 6.ThreadLocalMap源码分析 分析ThreadLocal方法了解到ThreadLocal的操作实际上是围绕ThreadLocalMap展开的。 ThreadLocalMap的源码相对比较复杂，以下三个方面进行讨论。 6.1基本结构 ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也是独立实现。 成员变量 12345678910111213141516171819/** * 初始容量--必须是2的整次幂 */ private static final int InItIAl_CAPACITY = 16;/* 存放数据的table，Entry类的定义在下面分析 * 同样，数组长度必须是2的整次幂。 */ private Entry[] table;/** * 数组里面entrys的个数，可以用于判断table当前使用量是否超过阈值。 */ private int size = 0;/*** 进行扩容的阈值，表使用量大于它的时候进行扩容。*/ private int threshold; // Default to 0 跟HashMap类似，INITIAL_CAPACITY代表这个Map的初始容量，table是一个Entry类型的数组，用于存储数据，size代表表中的存储数目， threshold代表需要扩容时对应size的阈值。 存储结构Entry 12345678910111213/* * Entry继承WeakReference，并且用ThreadLocal作为key * 如果key为null(entry.get() == nu11) 意味着key不再被引用 * 因此这时候entry也可以从tab1e中清除。 */static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this Threadocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, object v) &#123; super(k); value = v; &#125;&#125; 在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。不过Entry中的key只能是ThreadLocal对象 ,这点在构造方法中已经限定死了。 另外, Entry继承WeakReference，也就是key ( ThreadLocal )是弱引用，其目的是将ThreadLocal对象的生命周期和线程生命周期解绑。 6.2弱引用和内存泄漏 内存泄漏相关概念 Memory overflow：内存溢出,没有足够的内存提供申请者使用 Memory leak：内存泄漏是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。内存泄漏的堆积终将导致内存溢出。 弱引用相关概念 Java中的引用有4种类型：强、软、弱、虚。 强引用：最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾回收器就不会回收这种对象。 弱引用：垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。 在使用ThreadLocal的过程中有内存泄漏的情况发生 6.2.1与否与ThreadLocalMap中的key使用弱引用有关 假设在业务代码中使用完ThreadLocal ，threadLocalRef被回收了 由于ThreadLocalMap只持有ThreadLocal的弱引用，没有任何强引用指向threadlocal实例,所以threadlocal就可以顺利被GC回收，此时Entry中的key=null 【在没有手动删除这个Entry以及CurrentThread依然运行的前提下】，存在有强引用链threadRef-&gt; currentThread-&gt; threadLocalMap-&gt;entry-&gt;value，value不会被回收，而这块value永远不会被访问到了，导致value内存泄漏 ThreadLocalMap中的key使用了弱引用，有可能内存泄漏。 6.2.2假设ThreadLocalMap中的key使用强引用 假设ThreadLocalMap中的key使用了强引用，那么会出现内存泄漏吗? 此时ThreadLocal的内存图如下: 在业务代码中使用完ThreadLocal，threadLocalRef被回收了 因为threadLocalMap的Entry强引用了threadLocal，造成threadLocal无法被回收 【在没有手动删除这个Entry以及CurrentThread依然运行的前提下】，始终有强引用链threadRef-&gt; currentThread-&gt; threadLocalMap-&gt; entry，Entry就不会被回收（包括了ThreadLocal实例和value)，导致Entry内存泄漏 ThreadLocalMap中的key使用了强引用，是无法完全避免内存泄漏的。 6.2.3为什么使用弱引用 在ThreadLocalMap中的set/getEntry方法中，会对key为null (也即是ThreadLocal为null )进行判断，如果为null的话，那么是会对value置为null的 意味着使用完ThreadLocal ，CurrentThread依然运行的前提下，就算忘记调用remove方法，弱引比强引用可以多一层保障，弱引用的ThreadLocal会被回收，对应的value在下一次ThreadLocalMap调用set get remove中的任一方法的时候会被清除，从而避免内存泄漏。 6.2.4出现内存泄漏的真实原因 内存泄漏的发生跟ThreadLocalMap中的key使用哪种类型引用是没有关系的 在以上两种内存泄漏的情况中，都有两个前提: 没有手动删除这个Entry 只要在使用完ThreadLocal，调用其remove方法删除对应的Entry，就能避免内存泄漏 CurrentThread依然运行 ThreadLocalMap是Thread的一个属性，被当前线程所引用，所以它的生命周期跟Thread样长。 那么在使用完ThreadLocal的使用，如果当前Thread也随之执行结束，ThreadLocalMap自然也会被GC回收，从根源上避免了内存泄漏。【不好控制，使用线程池的时候，线程结束是不会销毁的】 综上，ThreadLocal内存泄漏的根源是：ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏。 6.3 hash冲突的解决 hash冲突的解决是Map中的一个重要内容。我们以hash冲突的解决为线索,来研究一下ThreadLocalMap的核心源码。 1234567891011121314151617181920212223/** * 设置当前线程对应的ThreadLocal的值 * @param value 将要保存在当前线程对应的ThreadLocal的值 */ pub1ic void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != nu11)&#123; //threadLocalMap的set方法 map.set(this, value); &#125;else&#123; createMap(t, value); &#125; &#125; ThreadLocalMap getMap(Thread t) &#123; return t.threadlocals; &#125; void createMap(Thread t,T firstValue) &#123; //threadLocalMap构造方法 t.threadlocals = new ThreadLocalMap(this, firstValue); &#125; 6.3.1构造方法123456789101112131415/* * firstKey : 本ThreadLocal实例(this) * firstValue :要保存的线程本地变量*/ ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; //初始化table table = new Entry[INITIAL_CAPACITY]; //计算索引(重点代码) int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); //设置值 table[i] = new Entry(firstKey, firstValue); size = 1; //设置阈值 setThreshold(INITIAL_CAPACITY); &#125; 构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的索引，然后存储到table中，并设置size和threshold 重点分析: int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); firstKey.threadLocalHashCode 123456789 private final int threadLocalHashCode = nextHashCode(); private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT); &#125; //AtomicInteger是一个提供原子操作的Integer类，通过线程安全的方式操作加减, 适合高并发情况下的使用private static AtomicInteger nextHashCode = new AtomicInteger(); //特殊的hash值 private static final int HASH_INCREMENT = 0x61c88647; 这里定义了一个AtomicInteger类型，每次获取当前值并加上HASH_INCREMENT，这个值跟斐波那契数列(黄金分割数)有关，其主要目的就是为了让哈希码能均匀的分布在2的n次方的数组里,也就是Entry[] table中，这样做可以尽星避免hash冲突。 (INITIAL_CAPACITY - 1) 计算hash的时候里面采用了hashCode &amp; (size - 1)的算法，这相当于取模运算hashCode % size的一个更高效的实现。正是因为这种算法，我们要求size必须是2的整次幂，这也能保证在索引不越界的前提下,使得hash发生冲突的次数减小。 6.3.2set方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; //计算索引(重点代码，刚才分析过了) int i = key.threadLocalHashCode &amp; (len-1); //使用线性探测法查找元素(重点代码) for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); //Threadlocal对应的key存在，直接覆盖之前的值 if (k == key) &#123; e.value = value; return; &#125; // key为null 但是值不为null 说明之前的ThreadLocal对象已经被回收了， // 当前数组中的Entry是一个陈旧(stale)的元素 if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; //Threadlocal对应的key不存在并且没有找到陈旧的元素，则在空元素的位置创建一个新的Entry tab[i] = new Entry(key, value); int sz = ++size; /** * cleanSomeSlots用于清除那些e.get()==null的元素， * 这种数据key关联的对象已经被回收，所以这个Entry(table[index])可以被置null * 如果没有清除任何entry ,并且当前使用量达到了负载因子所定义(长度的2/3)。那么进行rehash(执行一次全表的扫描清理工作)*/ if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125;/** *获取环形数组的下一个索引 */private static int nextIndex(int i, int len) &#123; return ((i + 1&lt; len)?i+1:0);&#125;private void rehash() &#123; expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size &gt;= threshold - threshold / 4) resize();&#125; 代码执行流程 首先还是根据key计算出索引i，然后查找i位置上的Entry 若是Entry已经存在并且key等于传入的key，那么这时候直接给这个Entry赋新的value值 若是Entry存在，但是key为null，则调用replaceStaleEntry来更换这个key为空的Entry 不断循环检测，直到遇到为null的地方，这时候要是还没在循环过程中return，则在空元素的位置创建一个新的Entry，并且插入同时size增加1。 最后调用cleanSomeSlots，清理key为null的Entry，最后返回是否清理了Entry，接下来再判断sz是否&gt;=threshold达到了rehash的条件，达到的话就会调用rehash函数执行一次全表的扫描清理。 重点分析: ThreadLocalMap使用线性探测法来解决哈希冲突的 该方法一次探测下一个地址，直到有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。 举个例子 假设当前table长度为16 ,也就是说如果计算出来key的hash值为14，如果table[14]上已经有值，并且其key与当前key不一致，那么就发生了hash冲突，这个时候将14加1得到15 ,取table[15]进行判断，这个时候如果还是冲突会回到0，取table[0]，以此类推,直到可以插入。 可以把Entry[] table看成一个环形数组","tags":[{"name":"ThreadLocal","slug":"ThreadLocal","permalink":"http://goldcarpenter.github.io/tags/ThreadLocal/"}]},{"title":"SpringMVC","date":"2019-11-18T16:00:00.000Z","path":"2019/11/19/SpringMVC_Part3/","text":"4.Spring返回模型数据和结果视图 处理模型数据方式一：将方法的返回值设置为ModelAndView 处理模型数据方式二：方法的返回值仍是String类型，在方法的入参中传入Map Model或者ModelMap 不管将处理器方法的返回值设置为ModelAndView还是在方法的入参中传入Map Model或者ModelMap，SpringMVC都会转换为一个ModelAndView对象 4.1.返回字符串类型4.1.1.直接返回目标jsp文件名 controller方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址 index.jsp 1&lt;a href=\"yyx/hello\"&gt;返回字符串&lt;/a&gt; Controlller.java 12345@RequestMapping(path = \"/hello\")public String sayHello(Model model)&#123; model.addAttribute(\"returnfunction\",\"string\"); return \"success\";&#125; success.jsp 1234&lt;h3&gt;入门成功&lt;/h3&gt;sessionScope.return: $&#123;sessionScope.returnfunction&#125;&lt;br&gt;requestScope.return: $&#123;requestScope.returnfunction&#125;&lt;br&gt; 4.1.2.返回使用forward转发 相当于Request.getRequestDispatcher (&quot;url&quot;).forward (request, response) 使用请求转发，既可以转发到jsp,也可以转发到其他的控制器方法 12345@RequestMapping(path = \"/hello\")public String sayHello(Model model)&#123; model.addAttribute(\"returnfunction\",\"string\"); return \"forward:/WEB-INF/pages/success.jsp\";&#125; 4.1.3.返回使用Redirect重定向 contrller方法提供了一个String类型返回值之后，需要在返回值里使用:redirect: 相当于Response.sendRedirect(url) 重定向到jsp页面，则jsp页面不能写在WEB-INF目录中，否则无法找到 12345@RequestMapping(path = \"/hello\")public String sayHello(Model model)&#123; model.addAttribute(\"returnfunction\",\"string\"); return \"redirect:/index.jsp\";&#125; 4.2.返回void类型 将上例中方法返回值修改为void 1234@RequestMapping(path = \"/hello\")public void sayHello(Model model)&#123; model.addAttribute(\"returnfunction\",\"string\");&#125; 执行程序报404的异常，默认查找页面没有找到。 会有默认请求路径：方法路径.jsp——请求转发或者重定向跳转到指定的页面 如果就想返回void，见下 4.2.1.方法一：Request使用请求转发 请求转发是一次请求 不用编写项目名称 但不会调用视图解析器 必须带.jsp 12345@RequestMapping(path = \"/hello\")public void sayHello(Model model, HttpServletRequest request, HttpServletResponse response) throws Exception&#123; request.getRequestDispatcher(\"/WEB-INF/pages/success.jsp\").forward(request,response); model.addAttribute(\"returnfunction\",\"string\");&#125; 4.2.2.方法二：Response页面重定向 重定向是两次请求 要编写项目名称 WEB-INF目录下文件无法访问 12345@RequestMapping(path = \"/hello\")public void sayHello(Model model, HttpServletRequest request, HttpServletResponse response) throws Exception&#123; Response.sendRedirect(request.getContextPath()+\"/index.jsp\"); model.addAttribute(\"returnfunction\",\"string\");&#125; 4.2.3.方法三：输出流直接响应123456@RequestMapping(path = \"/hello\")public void sayHello(HttpServletRequest request, HttpServletResponse response) throws Exception&#123; response.setCharacterEncoding(\"UTF-8\"); response.setContentType(\"text/html;charset=UTF-8\"); response.getWriter().println(\"早上好\");&#125; 4.3.返回ModelAndView类型【常用】 ModelAndView是SpringMVC为我们提供的一个对象，其既包含视图信息，也包含模型数据信息 SpringMVC会把ModelAndView的model中数据放入到request域对象中 添加模型数据：MoelAndView addObject(String attributeName, Object attributeValue) 设置视图：void setViewName(String viewName) 1234567@RequestMapping(path = \"/hello\")public ModelAndView sayHello()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"returnfunction\",\"ModelAndView\"); modelAndView.setViewName(\"success\"); return modelAndView;&#125; 4.4.返回@ResponseBody的json数据4.4.1.防止静态资源被拦截 DispatcherServlet会拦截到所有的资源，导致静态资源（images、 css，js） 会被拦截到，当成一个普通请求处理，因找不到对应处理器将导致错误，从而不能被使用。 解决问题就是需要配置静态资源不进行拦截，在springmvc.xml配置文件添加如下配置 springmvc.xml 123&lt;mvc:resources mapping=\"/js/**\" location=\"/js/\"/&gt;&lt;mvc:resources mapping=\"/css/**\" location=\"/css/\"/&gt;&lt;mvc:resources mapping=\"/images/**\" location=\"/images/\"/&gt; 在SpringMVC上下文中定义一个DefaultServletHttpRequestHandler,它会对进入DispatcherServlet的请求进行筛查，如果发现是没有经过映射的请求，就将该请求交由WEB应用服务器默认的Servlet处理，如果不是静态资源的请求，才由DispatcherServlet继续处理 一般WEB应用服务器默认的Servlet的名称都是default。若所使用的WEB服务器的默认Servlet名称不是default，则需要通过default-servlet-name属性显式指定 1&lt;mvc:default-servlet-handler/&gt; index.jsp 1234567891011121314151617181920212223&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(\"#btn\").click(function x() &#123; # 此时此处的按键将会有响应 alert(\"hello btn\"); &#125;) &#125;) &lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;h3&gt;入门程序&lt;/h3&gt; &lt;br/&gt; &lt;button id=\"btn\"&gt;发送ajax请求&lt;/button&gt; &lt;br/&gt; &lt;/body&gt;&lt;/html&gt; 4.4.2.使用json请求 使用@RequestBody注解把json的字符串转换成JavaBean的对象 导包 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; index.jsp 1234567891011121314151617181920212223242526272829303132&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(\"#btn\").click(function() &#123; $.ajax(&#123; // 编写json格式 设置属性和值 url:\"yyx/hello\", contentType: \"application/json; charset=UTF-8\" , data: '&#123;\"uname\": \"yyx\", \"age\" :\"123\"&#125;', dataType:\"json\", type: \"post\", success: function(data)&#123; // data : 服务器端响应的json数据 进行解析 alert(data); alert(data.age); &#125; &#125;) &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;入门程序&lt;/h3&gt; &lt;br/&gt; &lt;button id=\"btn\"&gt;发送ajax请求&lt;/button&gt; &lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 12345@RequestMapping(path = \"/hello\")public void sayHello(@RequestBody String body)&#123; // &#123;\"uname\": \"yyx\", \"age\" :123&#125; System.out.println(body);&#125; 4.4.3.使用@ResponseBody响应json12345@RequestMapping(path = \"/hello\")public @ResponseBody User sayHello(@RequestBody User user)&#123; System.out.println(user); return user;&#125; 4.4.4.原理 HttpMessageConverter&lt;T&gt;是 Spring3.0 新添加的一个接口，负责将请求信息转换为一个对象（类型为 T）或将对象（ 类型为 T）输出为响应信息 使用@RequestBody / @ResponseBody对处理方法进行标注 使用HttpEntity&lt;T&gt; / ResponseEntity&lt;T&gt;作为处理方法的入参或返回值 HttpMessageConverter&lt;T&gt;接口实现类 DispatcherServlet默认装配RequestMappingHandlerAdapter，而RequestMappingHandlerAdapter 默认装配如下HttpMessageConverter 加入 jackson jar 包后 新增[6] 原理 Spring 首先根据请求头或响应头的 Accept 属性选择匹配的HttpMessageConverter, 进而根据参数类型或泛型类型的过滤得到匹配的HttpMessageConverter, 若找不到可用的HttpMessageConverter将报错 自定义视图 常用的视图解析器实现类 自定义过程 编写自定时视图类并实现View接口 将@Component标致在只定义类上 使用BeanNameViewResolver作为视图解析器 12345&lt;!--配置视图BeanNameViewResolver 解析器:使用视图的名字来解析视图--&gt; &lt;!--通过order属性来定义视图解析器的优先级，order值越小优先级越高--&gt; &lt;bean class= \"org. springframework.web.servlet.view.BeanNameViewResolver\"&gt; &lt;property name= \"order\" value= \"100\"&gt;&lt;/ property&gt;&lt;/bean&gt;","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://goldcarpenter.github.io/tags/SpringMVC/"}]},{"title":"SpringMVC","date":"2019-11-15T16:00:00.000Z","path":"2019/11/16/SpringMVC_Part4/","text":"5.SpringMVC上传文件5.1.SpringMVC上传文件概念 文件上传要求 form表单的enctype取值必须是：multipart/form-data multipart/form-data：表单请求正文的类型 method属性的取值必须是Post 提供一个文件选择域&lt;input type=&quot;file&quot;/&gt; 文件上传原理分析 当form表单的enctype取值不是默认值后，request.getParameter()将失效 enctype=&quot;application/x-ww-form-urlencoded&quot;时，form 表单的正文内容是:key=value &amp;key=value &amp;key=value 当form表单的enctype取值为Mutilpart/form-data时，请求正文内容就变成: 12345678910111213------WebKitFormBoundaryYMJEn4NC2H3fo8LsContent-Disposition: form-data; name&#x3D;&quot;picname&quot;------WebKitFormBoundaryYMJEn4NC2H3fo8LsContent-Disposition: form-data; name&#x3D;&quot;uploadFile&quot;; filename&#x3D;&quot;exam.sql&quot;Content-Type: application&#x2F;octet-stream&#x2F;*select * from emp;select * from dept;select * from salgrade;*&#x2F;------WebKitFormBoundaryYMJEn4NC2H3fo8Ls-- 依赖的jar包 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; Spring MVC 为文件上传提供了直接的支持，这种支持是通过即插即用的 MultipartResolver 实现的。 Spring 用 Jakarta Commons FileUpload 技术实现了一个 MultipartResolver 实现类CommonsMultipartResovler 5.2.SpringMVC上传文件案例 编写按键 12345&lt;form action=\"yyx/upfile\" method=\"post\" enctype=\"multipart/form-data\" &gt; &lt;input type=\"text\" name=\"picname\" /&gt; &lt;input type=\"file\" name=\"uploadFile\"/&gt; &lt;input type=\"submit\" value=\"upload\"&gt;&lt;/form&gt; 编写控制器方法 123456789101112131415161718 @RequestMapping(path = \"upfile\") public String upFile(String picname, MultipartFile uploadFile, HttpServletRequest request) throws IOException &#123;// 1.设置文件名 String fileName = \"\"; String uploadFilename = uploadFile.getOriginalFilename(); fileName = uploadFilename;// 2. 获取文件路径 String context = request.getSession().getServletContext().getRealPath(\"/uploads\"); File file = new File(context); if(!file.exists()) &#123; file.mkdir(); &#125; //3. 上传 uploadFile.transferTo(new File(file, fileName)); return \"success\"; &#125; 配置文件解析器 Spring MVC上下文中默认没有装配MultipartResovler，因此默认情况下不能处理文件的上传工作，如果想使用 Spring 的文件上传功能，需现在上下文中配置MultipartResolver 文件上传的解析器id是固定的，不能起别的名称，否则无法实现请求参数的绑定。(不光是文件， 其他字段也将无法绑定) 123&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"maxInMemorySize\" value=\"5000000\"/&gt;&lt;/bean&gt; 6.SpringMVC异常处理6.1.SpringMVC 异常处理概念 系统的dao，service，controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理 Spring MVC通过HandlerExceptionResolver接口处理程序的异常，包括Handler映射、数据绑定以及目标方法执行时发生的异常 SpringMVC提供的HandlerExceptionResolver的实现类 ExceptionHandlerExceptionResolver ResponseStatusExceptionResolver DefaultHandlerExceptionResolver SimpleMappingExceptionResolver 使用了&lt;mvc:annotation-driven/&gt;配置DispatcherServlet默认装配的HandlerExceptionResolver 6.1.1 ExceptionHandlerExceptionResolver 主要处理Handler中用@ExceptionHandler注解定义的 方法 12345678910111213/** * 1.在@ExceptionHandler方法的入参中可以加入Exception类型的参数，该参数即对应发生的异常对象 * 2.@ExceptionHandler方法的入参中不能传入Map. 若希望把异常信息传导页面上,需要使用ModelAndView 作为返回值 * 3.@ExceptionHandler方法标记的异常有优先级的问题 * 4.@ControllerAdvice: 如果在当前Handler中找不到@ExceptionHandler方法来出来当前方法出现的异常，则将去@ControllerAdvice标记的类中查找@ExceptionHandler标记的方法来处理异常。*/@ExceptionHandler(&#123;ArithmeticException.class&#125;)public ModelAndView handleArithmeticException(Exception ex)&#123; System.out.println(\"出异常了:\"+ ex); ModelAndView mv = new ModelAndView(\"error\"); mv.addobject(\"exception\", ex); return mv;&#125; ExceptionHandlerMethodResolver内部若找不到@ExceptionHandler注解的话，会找@ControllerAdvice中的@ExceptionHandler注解方法 12345678910@ControllerAdvicepublic class HandleException &#123; @ExceptionHandler( &#123;ArithmeticException. class&#125;) public ModelAndView handleArithmeticException( Exception ex)&#123; System.out. println(\"----&gt;出异常了:\" + ex); ModelAndView mv = new ModelAndView(\"error\"); mv.add0bject(\"exception\", ex); return mv; &#125;&#125; 6.1.2 ResponseStatusExceptionResolver 在异常及异常父类中找到@ResponseStatus注解，然后使用这个注解的属性进行处理。 定义一个@ResponseStatus注解修饰的异常类 1234@ResponseStatus(value=HttpStatus.FORBIDDEN, reason= \"用户名和密码不匹配! \")public class UserNameNotMatchPasswordException extends RuntimeException&#123; private static final 1ong serialVersionUID = 1L;&#125; 由于触发的异常UnauthorizedException带有@ResponseStatus注解。因此会被ResponseStatusExceptionResolver解析到。 最后响应给客户端 6.1.3DefaultHandlerExceptionResolver 对一些特殊的异常进行处理 NoSuchRequestHandlingMethodException HttpReques tMethodNotSupportedException HttpMediaTypeNotSupportedException HttpMediaTypeNotAcceptableException等 6.1.4.SimpleMappingExceptionResolver 如果希望对所有异常进行统一处理，可以使用 SimpleMappingExceptionResolver，它将异常类名映射为视图名，即发生异常时使用对应的视图报告异常 12345678&lt;bean id=\"simpleMappingExceptionResolver\"class= \"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"&gt; &lt;property name= \"exceptionMappings\"&gt; &lt;props&gt; &lt;prop key=\"java.lang.ArithmeticException\"&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 6.2.SpringMVC 异常处理配置 编写自定义异常类(做提示信息的) 12345678910package top.carpenter.utils;public class MyError extends Exception&#123; private String message; public MyError(String message) &#123; this.message = message; &#125; //set get function&#125; 编写异常处理器 12345678910111213141516171819202122232425262728package top.carpenter.exception;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ExceptionResolver implements HandlerExceptionResolver &#123; public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123; Exception exception = null; MyError myError = null; ModelAndView modelAndView = new ModelAndView(); //如果抛出的是系统自定义异常则直接转换 if(e instanceof MyError) &#123; myError = (MyError)e; modelAndView.addObject(\"message\",myError.getMessage()); &#125; else&#123; //如果抛出的不是系统自定义异常则重新构造一个系统错误异常。 exception = new Exception (\"系统错误，请与系统管理员联系! \"); modelAndView.addObject(\"message\",exception.getMessage()); &#125; modelAndView.setViewName(\"fail\"); return modelAndView; &#125;&#125; 配置异常处理器(跳转到提示页面) 1&lt;bean id=\"exceptionResolver\" class=\"top.carpenter.exception.ExceptionResolver\"/&gt; 7.SpringMVC 拦截器7.1.SpringMVC 拦截器概念 SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理 用户可以自己定义一些拦截器来实现特定的功能。 拦截器链：将拦截器按一定的顺字联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 过滤器/拦截器区别 过滤器 过滤器是servlet规范中的一部分，任何java web工程都可以使用 过滤器在url-pattern中配置了/*之后，可以对所有要访问的资源拦截 拦截器 拦截器它是只会拦截访问的控制器方法，如果访问的是jsp，html，css,image或者js是不会进行拦载的 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能用。 它也是AOP思想的具体应用。 想自定义拦截器，要求必须实现HandlerInterceptor接口 7.2.SpringMVC 拦截器配置 自定义拦截器 123456789101112131415161718192021222324252627package top.carpenter.handler;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyHandlerInterceptor implements HandlerInterceptor &#123; // 预处理，controller方法执行前 // return true 放行，执行下一个拦截器，如果没有，执行controller中的方法 // return false 不放行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"preHandle~~\"); return true; &#125; // 后处理方法，controller方法执行后，***.jsp执行之前 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"postHandle~~\"); &#125; // ***.jsp页面执行后，该方法会执行 用于释放资源 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"afterCompletion~~\"); &#125;&#125; Springmvc.xml配置拦截器 12345678&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt;&lt;!-- 包含某些路径方法--&gt; &lt;mvc:mapping path=\"/yyx/**\"/&gt;&lt;!-- &lt;mvc:exclude-mapping path=\"\"/&gt;--&gt; &lt;bean id=\"myHandlerInterceptor\" class=\"top.carpenter.handler.MyHandlerInterceptor\"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 7.3.SpringMVC 拦截器相关细节 拦截器的放行 如果有下一个拦截器就执行下一个，如果该拦截器处于拦截器链的最后一个， 则执行控制器中的方法。 前置处理： 如何调用 按拦截器定义顺序调用 何时调用 只要配置了都会调用 有什么用: 如果程序员决定该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去进行处理，则返回true 如果程序员决定不需要再调用其他的组件去处理请求，则返回false。 后置处理 如何调用：按拦截器定义逆序调用 何时调用：在拦截器链内所有拦截器返成功调用 有什么用 在业务处理器处理完请求后，但是DispatcherServlet向客户端返回响应前被调用，在该方法中对用户请求request进行处理 AfterCompletion 如何调用：按拦截器定义逆序调用 何时调用：只有preHandle返回true才调用 有什么用 在DispatcherServlet完全处理完请求后被调用，进行一些资源清理的操作 多个拦截器的执行顺序 Spring MVC 与 Spring 问题：需要进行Spring整合SpringMVC吗/是否还需要再加入Spring的IoC容器/是否需要再web. xml文件中配置启动Spring IoC容器的ContextLoaderListener? 需要：通常情况下，类似于数据源，事务，整合其他框架都是放在Spring的配置文件中(而不是放在SpringMVC的配置文件中)。实际上放入Spring配置文件对应的IoC容器中的还有Service和Dao 问题：若Spring的IOC容器和SpringMVC的IoC容器扫描的包有重合的部分，就会导致有的bean会被创建2次。 Spring 的 IOC 容器不应该扫描 SpringMVC 中的 bean, 对应的 SpringMVC 的 IOC 容器不应该扫描 Spring 中的 bean 【方案一】使Spring的IOC容器扫描的包和SpringMVC的IOC容器扫描的包没有重合的部分. 【方案二】使用exclude- filter和include-filter子节点来规定只能扫描的注解 1234&lt;context:component-scan base-package=\"com.atguigu.springmvc\" use-default-filters=\"false\"&gt; &lt;context:include-filter type=\"annotation\" expression= \"org.springframework. stereotype.Controller\"/&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.controllerAdvice\"/&gt;&lt;/context:component-scan&gt; 多个 Spring IOC 容器之间可以设置为父子关系， 以实现良好的解耦。 Spring MVC WEB 层容器可作为 “业务层” Spring 容器的子容器：即 WEB 层容器可以引用业务层 容器的 Bean，而业务层容器却访问不到 WEB 层 容器的 Bean 100.说一下 spring mvc 运行流程？ 101.spring mvc 有哪些组件？ 102.@RequestMapping 的作用是什么？ 103.@Autowired 的作用是什么？","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://goldcarpenter.github.io/tags/SpringMVC/"}]},{"title":"SpringMVC","date":"2019-11-12T16:00:00.000Z","path":"2019/11/13/SpringMVC_Part2/","text":"3. 常用注解3.1.@RequestParam[重要] 原因：在绑定机制中，要求参数名称必须和控制器中方法的形参名称保持一致。 作用：把请求的名称参数给控制器中的形参赋值。 属性 value/name：请求参数的名称 required：请求参数中是否必须提供此参数。默认值: true。 表示必须提供，如果不提供将报错 defaultValue：请求参数的默认值 请求类型 Get请求 POST DELETE请求：请求头中的Content-Type 为 application/x-www-form-urlencoded[默认属性] 如果改用 json 字符串来传值的话，类型设置为 application/json，点击发送的话，会报错，后台接收不到值，为 null。——&gt;引入注解@RequestBody 1&lt;a href=\"yyx/hello?username=yyx\"&gt;入门程序&lt;/a&gt; 12345@RequestMapping(path = \"/hello\")public String sayHello(@RequestParam(value = \"username\", required= false) String name)&#123; System.out.println(name); return \"success\";&#125; 前端使用$.ajax的话，一定要指定 contentType: &quot;application/json;charset=utf-8;&quot;，默认为 application/x-www-form-urlencoded。 3.2.@RequestBody[重要] 作用：用于获取请求体内容 直接使用得到是key=values&amp;key=value&amp;..结构的数据 get请求方式不适用 用于处理非 Content-Type: application/x-www-form-urlencoded编码格式的数据 用于处理application/json、application/xml等类型的数据。 属性 required：是否必须有请求体。默认值true。当取值为true时,get请求方式会报错。如果取值false或 get，请求得到是null。 例1 12345&lt;form action=\"yyx/saveUser\" method=\"post\"&gt; 账户名：&lt;input type=\"text\" name=\"uname\"&gt;&lt;br/&gt; 年 龄：&lt;input type=\"text\" name=\"age\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"ok\"&gt;&lt;/form&gt; 123456@RequestMapping(path=\"/saveUser\") public String test(@RequestBody String str) &#123; System.out.println(str); // uname=%E6%9D%A8%E9%9B%A8%E9%91%AB&amp;age=23 return \"success\"; &#125; 例2 1234567891011121314@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer id; private String name; private Integer age; &#125; @RequestMapping(value = \"/test\", method = RequestMethod.POST) public void test(@RequestBody User user) &#123; log.info(\"id = &#123;&#125;, name = &#123;&#125;, age = &#123;&#125;\", user.getId(), user.getName(), user.getAge()); //id = 1, name = yc, age = 23 &#125; 小对比 使用@RequestParam：Content-Type为application/x-www-form-urlencoded，参数在FormData中 使用@RequestBody：Content-Type为application/json，参数在Request PayLoad中 Post从content-type方面总结：① form-data、x-www-form-urlencoded：不可以用@RequestBody；可以用@RequestParam。见postman的格局，这两种方式的时候没有json字符串部分。 ② application/json：json字符串部分可以用@RequestBody；url中的?后面参数可以用@RequestParam。见postman的格局 application/json格局图 form-data、x-www-form-urlencoded格局图 从两种注解方式总结：**@RequestBody 1234(@RequestBody Map map)(@RequestBody Object object)application/json时候可用form-data、x-www-form-urlencoded时候不可用 @RequestParam 12(@RequestParam Map map)application/json时候，json字符串部分不可用，url中的?后面添加参数即可用，form-data、x-www-form-urlencoded时候可用，但是要将Headers里的Content-Type删掉 1234(@RequestParam String waterEleId, @RequestParam String enterpriseName)application/json时候，json字符串部分不可用，url中的?后面添加参数即可用form-data、x-www-form-urlencoded时候可用，且参数可以没有顺序（即前端传过来的参数或者url中的参数顺序不必和后台接口中的参数顺序一致，只要字段名相同就可以），但是要将Headers里的Content-Type删掉 12(@RequestParam Object object)不管application/json、form-data、x-www-form-urlencoded都不可用 GET请求@RequestBody 12RequestBody Map / ObjectGET请求中不可以使用@RequestBody @RequestParam 123456(@RequestParam Map map)在url中的?后面添加参数即可使用(@RequestParam String waterEleId,@RequestParam String enterpriseName)在url中的?后面添加参数即可使用(@RequestParam Object object)GET请求中不可以使用 3.3.@PathVariable[重要]3.3.1.Rest风格 请求路径一样，可以根据不同的请求方式去执行后台的不同方法 Restful风格的URL优点 结构清晰 符合标准 易于理解 扩展方便 121.理解本真的REST架构风格: http:&#x2F;&#x2F;kb.cnblogs.com&#x2F;page&#x2F;186516&#x2F;2.深入浅出REST: http:&#x2F;&#x2F;www.infog.com&#x2F;cn&#x2F;articles&#x2F;rest-introduction 3.3.2.@PathVariable 作用：用于绑定url中的占位符。 请求url中/delete/{id}，这个{id}就是url占位符 url支持占位符是spring3.0之后加入的，是springmvc支持rest风格URL的一个重要标志。 属性 value：用于指定url中占位符名称 required：是否必须提供占位符 1&lt;a href=\"yyx/hello/yyx\"&gt;入门程序&lt;/a&gt; 12345@RequestMapping(path = \"/hello/&#123;abcd&#125;\")public String sayHello(@PathVariable(value = \"abcd\") String name)&#123; System.out.println(name); return \"success\";&#125; 1yyx 3.4.@RequestHeader 作用：用于获取请求消息头 属性：【同3.1@RequestParam】 在实际开发中一般不怎么用 1&lt;a href=\"yyx/hello\"&gt;入门程序&lt;/a&gt; 1234567@RequestMapping(path = \"/hello\")public String sayHello(@RequestHeader(value = \"Content-Type\",required = false) String contype,@RequestHeader(value = \"Date\") String date)&#123; System.out.println(contype); System.out.println(date); return \"success\";&#125; 使用API Test插件 12multipart&#x2F;form-dataBROKEN REFERENCE23 3.5.@CookieValue 作用：用于把指定cookie名称的值传入控制器方法参数 属性：【同3.1@RequestParam】 在实际开发中一般不怎么用 1&lt;a href&#x3D;&quot;yyx&#x2F;hello&quot;&gt;入门程序&lt;&#x2F;a&gt; 12345@RequestMapping(path = \"/hello\")public String sayHello(@CookieValue(value = \"JSESSIONID\",required = false) String id) &#123; System.out.println(id); return \"success\";&#125; 18115EE2160ABBA27808A76664D050473 总结1： Http协议常用的四种请求方式：Post、Get、Put、Delete等；其中Put、Delete请求方式很少见，都可用Post方式代替 对数据库而言： get 请求不修改数据库，只是查询。Post是增加记录，put是更新，Delete数据库删除 Put，Post，Delete 方式的请求参数会直接放在requestBody里 处理 request uri 部分的注解，路径参数变量：@PathVariable 处理request header部分的注解： @RequestHeader, @CookieValue，@RequestParam 处理request body部分的注解：@RequestParam， @RequestBody； 综上所述：@RequestParam注解既可以接收Get方式的请求头中的参数，也可以接收Post方式的请求体中的参数； 总结2： get请求的 headers 中没有 content-type 这个字段，post 的 content-type 有 ： application/x-www-form-urlencoded，这种就是一般的文本表单用 post 传地数据，只要将得到的 data 用 @RequestParam 或 request.getParamter() 获取即可； multipart/form-data ，用于文件上传，此时 form 的 enctype 属性必须指定为 multipart/form-data； application/json，将数据以json对象的格式传递 text/xml put 和 delete 请求的headers 是有 content-type 这个字段的，只不过这两个方法类型目前不常用； 3.6.@ModelAttribute 作用：该注解是SpringMVC4.3版本以后新加入的，它可以用于修饰方法和参数。 在方法上：当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。 在参数上，获取指定的数据给参数赋值。 属性: value/name：用于获取数据的key。key可以是POJO的属性名称，也可以是map结构的key。 应用场景：当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。 例如：我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据是肯定没有此字段的内容，一旦更新会把该字段内容置为null,此时就可以使用此注解解决问题 3.6.1.@ModelAttribute方法会在控制器的方法执行之前执行123456789101112131415161718 @RequestMapping(path=\"/saveUser\") public String testController(String uname, String age) &#123; System.out.println(\"testController\"+ uname + age); return \"success\"; &#125; @ModelAttribute public void testModelAttribute(String uname, String age) &#123; System.out.println(\"testModelAttribute\"+uname + age); &#125;//============================================================ &lt;form action=\"yyx/saveUser\" method=\"post\"&gt; 账户名：&lt;input type=\"text\" name=\"uname\"&gt;&lt;br/&gt; 年 龄：&lt;input type=\"text\" name=\"age\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"ok\"&gt; &lt;/form&gt; 3.6.2.@ModelAttribute方法带返回值——保证没有提交数据的字段使用数据库对象原来的数据1234567891011121314151617181920212223242526@RequestMapping(path=\"/saveUser\") public String testController(User user) &#123; System.out.println(\"testController\"+ user); return \"success\"; &#125; @ModelAttribute public User testModelAttribute(String uname, String age) &#123; User user = serviceFindByName(uname); System.out.println(\"testModelAttribute run...\"+ user); return user; &#125; /** * 模拟数据库查询 */ public User serviceFindByName(String username) &#123; User user = new User(); user.setUname(username); user.setAge(19); user.setDate(new Date()); return user; &#125; 12345&lt;form action=\"yyx/saveUser\" method=\"post\"&gt; 账户名：&lt;input type=\"text\" name=\"uname\"&gt;&lt;br/&gt; 年 龄：&lt;input type=\"text\" name=\"age\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"ok\"&gt;&lt;/form&gt; 表单中数据会覆盖从数据库读取的数据 3.6.3.@ModelAttribute方法不带返回值——保证没有提交数据的字段使用数据库对象原来的数据12345678910111213141516171819 @RequestMapping(path=\"/saveUser\") public String testController(@ModelAttribute(\"abcd\")User user) &#123; System.out.println(\"testController\"+ user); return \"success\"; &#125; @ModelAttribute public void testModelAttribute(String uname, String age, Map&lt;String,User&gt; map) &#123; User user = serviceFindByName(uname); System.out.println(\"testModelAttribute run...\"+ user); map.put(\"abcd\",user); &#125; /** * 模拟数据库查询 同上 *///============================================================ //表单提交 同上 表单中数据会覆盖从数据库读取的数据 3.7.@SessionAttributes[重要] 默认情况下Spring MVC将模型中的数据存储到request域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到session 作用：可以使得模型中的数据存储一份到session域中 范围：仅仅作用在类上 属性： value/names：存储到session域数据的属性名称 types：用于指定存入的数据类型 12开始EL表达式注解&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %&gt; success.jsp 1234567sessionScope.username: $&#123;sessionScope.username&#125;&lt;br&gt;sessionScope.password: $&#123;sessionScope.password&#125;&lt;br&gt;sessionScope.age: $&#123;sessionScope.age&#125;&lt;br&gt;requestScope.username: $&#123;requestScope.username&#125;&lt;br&gt;requestScope.password: $&#123;requestScope.password&#125;&lt;br&gt;requestScope.age: $&#123;requestScope.age&#125;&lt;br&gt; SessionAttributesTest 123456789101112131415161718192021222324252627282930313233343536373839package top.carpenter.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.SessionAttributes;import org.springframework.web.bind.support.SessionStatus;@Controller@SessionAttributes(value = &#123;\"username\",\"password\"&#125;)@RequestMapping(path=\"/springmvc\")public class SessionAttributesTest &#123; @RequestMapping(\"/sessionPut\") public String testPut(Model model) &#123; model.addAttribute(\"username\",\"gold\"); model.addAttribute(\"password\",\"123\"); model.addAttribute(\"age\",\"23\"); return \"success\"; &#125; @RequestMapping(\"/sessionGet\") public String testGet(ModelMap model) &#123; System.out.println(model.get(\"username\")); System.out.println(model.get(\"password\")); System.out.println(model.get(\"age\")); return \"success\"; &#125; @RequestMapping(\"/sessionClean\") public String testClean(SessionStatus sessionStatus) &#123; sessionStatus.setComplete(); return \"success\"; &#125;&#125; index.jsp 123&lt;a href=\"springmvc/sessionPut\"&gt;存入SessionAttribute&lt;/a&gt;&lt;a href=\"springmvc/sessionGet\"&gt;取出SessionAttribute&lt;/a&gt;&lt;a href=\"springmvc/sessionClean\"&gt;清除SessionAttribute&lt;/a&gt;","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://goldcarpenter.github.io/tags/SpringMVC/"}]},{"title":"SpringMVC","date":"2019-11-04T16:00:00.000Z","path":"2019/11/05/SpringMVC_Part1/","text":"1.SpringMVC入门1.1.MVC模式 MVC全名是Model View Controller是模型(model) 视图(view) 控制器(controller)的缩写，是一种用于设计创建Web应用程序表现层的模式。 MVC中每个部分各司其职: Model (模型) ：通常指的就是数据模型，JavaBean类。一般情况下用于封装数据 View (视图) ：通常指的就是我们的jsp/html。一般用于展示数据的 Controller (控制器) ：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。 1.2.SpringMVC模式 SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架 属于Spring FrameWork的后续产品，已经融合在Spring Web Flow 里面 Spring框架提供了构建Web应用程序的全功能MVC模块。 使用Spring可插入的MVC架构，从而在进行WEB开发时，可以选择Spring的Spring MVC框架或其他MVC开发框架，如Struts2等 1.3.入门程序 当启动Tomcat服务器的时候，因为配置了load-on-startup标签，所以会创建DispatcherServlet对象，就会加载springmvc.xml配置文件 springmvc.xml开启了注解扫描，Spring容器就会创建HelloController对象 打开浏览器，从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器，根据配置@RequestMapping注解找到执行的具体方法 根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件 Tomcat服务器渲染页面，做出响应 pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;top.carpenter&lt;/groupId&gt; &lt;artifactId&gt;SpringMVC_Study&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; web.xml 123456789101112131415&lt;!-- 配置中央调度器 拦截所有请求--&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--配置DispatcherServlet 的一个初始化参数:配置SpringMVC 配置文件的位置和名称--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; index.jsp 12345678910111213&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h3&gt;入门程序&lt;&#x2F;h3&gt;######注意！此处URL没有&#x2F; 如果有&#x2F;则访问时没有项目路径&lt;a href&#x3D;&quot;hello&quot;&gt;入门程序&lt;&#x2F;a&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; success.jsp 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;入门成功&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; springmvc.xml 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--注解扫描位置--&gt; &lt;context:component-scan base-package=\"top.carpenter\"/&gt;&lt;!-- 视图解析器对象--&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!--SpringMVC 框架支持注解--&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; HelloController 1234567891011121314package top.carpenter.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloController &#123; @RequestMapping(path = \"/hello\") public String sayHello()&#123; System.out.println(\"Hello MVC\"); return \"success\"; &#125;&#125; 1.4.组件方式执行流程 DispatcherServlet前端控制器 用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherservlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性 HandlerMapping处理器映射器 HandlerMapping负责根据用户请求找到Handler即处理器，SpringMVC提供了不同的映射器实现不同的映射方式，例如:配置文件方式，实现接口方式，注解方式等。 &lt;mvc:default-servlet-handler/&gt; Handler处理器 它就是我们开发中要编写的具体业务控制器。由DispatcherServlet把用户请求转发到Handler，由Handler对具体的用户请求进行处理。 HandlAdapter处理器适配器 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行 表单数据类型校验/转换…. View Resolver视图解析器 View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户 所有的视图解析器都必须实现 ViewResolver 接口 可以选择一种视图解析器或混用多种视图解析器 每个视图解析器都实现了Ordered接口并开放出一个order属性，可以通过order属性指定解析器的优先顺序，order越小优先级越高。 SpringMVC会按视图解析器顺序的优先顺序对逻辑视图名进行解析，直到解析成功并返回视图对象，否则将抛出 ServletException 异常 View视图 SpringMVC框架提供了很多的View视图类型的支持，包括:jstlView、freemarkerView、pdfView等，最常用的视图就是jsp 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面 视图对象由视图解析器负责实例化。由于视图是无状态的，所以不会有线程安全的问题 1.5.xml/注解配置说明 &lt;mvc:annotation-driven&gt; 在SpringMVC的各个组件中，处理器映射器、处理器适配器、视图解析器称为SpringMVC的三大组件 使用&lt;mvc: annotation-driven&gt;自动加载RequestMappingHandlerMapping (处理映射器)和RequestMappingHandlerAdapter(处理适配器) ExceptionHandlerExceptionResolver，可用在springMVC.xml配置文件中使用&lt;mvc:annotation-driven&gt;替代注解处理器和适配器的配置。 支持使用ConversionService实例对表单参数进行类型转换 支持使用@NumberFormat、@DateTimeFormat注解完成数据类型的格式化 支持使用@Valid注解对JavaBean实例进行JSR 303验证 支持使用@RequestBody和@ResponseBody注解 @RequestMaping 用于建立请求URL和处理请求方法之间的对应关系 属性 value/path:用于指定请求的URL method:用于指定请求的方式 params:用于限制请求的参数，即必须包含的参数。它支持简单的表达式，要求url请求参数的key和value必须和此参数配置的一模一样【不常用】 headers:用于限制请求消息头，即必须包含的消息头【不常用】 12345@RequestMapping(path = \"/hello\",params = &#123;\"name=yyx\"&#125;, method = RequestMethod.GET)public String sayHello(String name)&#123; System.out.println(\"Hello MVC\"+ name); return \"success\";&#125; 位置 类名——需要以/开头：第一级的访问目录 方法名：第二级的访问目录 2.SpringMVC请求参数的绑定 不使用@RequestParam注解直接进行对象属性赋值（不推荐使用，容易和@ReuqestBody混淆） 2.1绑定的机制 表单中请求参数都是基于key=value的 SpringMVC绑定请求参数的过程是通过表单提交请求参数，作为控制器中方法参数进行绑定的 1&lt;a href=\"yyx/hello?name=yyx\"&gt;入门程序&lt;/a&gt; 12345 @RequestMapping(path = \"/hello\") public String sayHello(String name)&#123; System.out.println(\"Hello MVC\"+ name); return \"success\";&#125; 2.2.支持的数据类型 SpringMVC绑定请求参数是自动实现的，但是要想使用，必须遵循使用要求 2.2.1.基本类型参数和String类型 参数名称必须和控制器中方法的形参名称保持一致【严格区分大小写】 2.2.2.pojo类型参数：包括实体类，以及关联的实体类 表单中参数名称和pojo类的属性名称保持一致。并且控制器方法的参数类型是pojo类型 如果一个JavaBean类中包含其他的引用类型， 那么表单的name属性需要编写成:对象.属性例如：address.name 12345678&lt;form action=\"yyx/accountSave\" method=\"post\"&gt; 账户名：&lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt; 密 码：&lt;input type=\"text\" name=\"password\"&gt;&lt;br/&gt; 金 额：&lt;input type=\"text\" name=\"money\"&gt;&lt;br/&gt; 用户名：&lt;input type=\"text\" name=\"user.uname\"&gt;&lt;br/&gt; 年 龄：&lt;input type=\"text\" name=\"user.age\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"ok\"&gt;&lt;/form&gt; 12345678910111213public class User implements Serializable &#123; private String uname; private Integer age; # set get toString方法&#125;public class Account implements Serializable &#123; private String username; private String password; private Double money; private User user; # set get toString方法&#125; 12345678 @RequestMapping(path=\"/accountSave\") public String test(Account account) &#123; System.out.println(account); return \"success\"; &#125;//========================================================Account&#123;username='杨雨鑫', password='123', money=4.0, user=User&#123;uname='杨雨鑫', age=23&#125;&#125; 2.2.3.数组，List结构和Map结构的集合 在表单中请求参数名称要和pojo中集合属性名称相同 给List集合中的元素赋值，使用下标 给Map集合中的元素赋值，使用键值对 12345678910&lt;form action=\"yyx/accountSave\" method=\"post\"&gt; 账户名：&lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt; 密 码：&lt;input type=\"text\" name=\"password\"&gt;&lt;br/&gt; 金 额：&lt;input type=\"text\" name=\"money\"&gt;&lt;br/&gt; 用户名：&lt;input type=\"text\" name=\"list_users[0].uname\"&gt;&lt;br/&gt; 用户名：&lt;input type=\"text\" name=\"map_users['yyx'].uname\"&gt;&lt;br/&gt; 年 龄：&lt;input type=\"text\" name=\"list_users[0].age\"&gt;&lt;br/&gt; 年 龄：&lt;input type=\"text\" name=\"map_users['yyx'].age\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"ok\"&gt;&lt;/form&gt; 1234567891011121314public class Account implements Serializable &#123; private String username; private String password; private Double money; private List&lt;User&gt; list_users; private Map&lt;String,User&gt; map_users; //set get toString方法&#125;public class User implements Serializable &#123; private String uname; private Integer age; //set get toString方法&#125; 123456789@RequestMapping(path=\"/accountSave\")public String test(Account account)&#123; System.out.println(account); return \"success\";&#125;========================================================Account&#123;username='杨雨鑫', password='123', money=4.0, list_users=[User&#123;uname='杨雨鑫', age=23&#125;], map_users=&#123;yyx=User&#123;uname='杨雨鑫', age=23&#125;&#125;&#125; 2.2.4 数据绑定流程 Spring MVC主框架将ServletRequest对象及目标方法的入参实例传递给WebDataBinderFactory实例，以创建DataBinder实例对象 DataBinder调用装配在Spring MVC下文中的ConversionService组件进行数据类型转换、数据格式化工作。将 Servlet 中的请求信息填充到入参对象中 调用Validator组件对已经绑定了请求消息的入参对象进行数据合法性校验，并最终生成数据绑定结果BindingData对象 Spring MVC抽取BindingResult中的入参对象和校验错误对象，将它们赋给处理方法的响应入参 数据绑定的核心部件是 DataBinder 2.2.5.自定义类型转换器 ConversionService是 Spring 类型转换体系的核心接口 可以利用ConversionServiceFactoryBean在Spring的IOC容器中定义一个ConversionService ，Spring将自动识别出 IOC 容器中的ConversionService，并在 Bean 属性配置及 Spring MVC 处理方法入参绑定等场合使用它进行数据的转换 可通过ConversionServiceFactoryBean的converters属性注册自定义的类型转换器 &lt;mvc:annotation-driven conversion-service= &quot;conversionService&quot;/&gt;会将自定义的ConversionService注册到Spring MVC的上下文中 Spring 定义了 3 种类型的转换器接口，实现任意一个转换 器接口都可以作为自定义转换器注册到 ConversionServiceFactroyBean 中 Converter&lt;S,T&gt;：将 S 类型对象转为 T 类型对象 ConverterFactory：将相同系列多个 “同质” Converter 封装在一 起。如果希望将一种类型的对象转换为另一种类型及其子类的对 象（例如将 String 转换为 Number 及 Number 子类 （Integer、Long、Double 等）对象）可使用该转换器工厂类 GenericConverter：会根据源类对象及目标类对象所在的宿主类 中的上下文信息进行类型转换 实例 表单提交的任何数据类型全部都是字符串类型，但是后台定义Integer类型，数据也可以封装上，说明Spring框架内部会默认进行数据类型转换 如果想自定义数据类型转换，可以实现Converter的接口 问题引入 123456&lt;form action=\"yyx/saveUser\" method=\"post\"&gt; 账户名：&lt;input type=\"text\" name=\"uname\"&gt;&lt;br/&gt; 密 码：&lt;input type=\"text\" name=\"age\"&gt;&lt;br/&gt; 日 期：&lt;input type=\"text\" name=\"date\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"ok\"&gt;&lt;/form&gt; 12345678910111213public class User implements Serializable &#123; private String uname; private Integer age; private Date date; //set get toString方法&#125;@RequestMapping(path=\"/saveUser\")public String test(User user)&#123; System.out.println(user); return \"success\";&#125; 12//输入 xxxx/xx/xx成功封装User&#123;uname='杨雨鑫', age=123, date=Wed Mar 03 00:00:00 CST 2010&#125; 1//输入 xxxx-xx-xx封装失败 定义一个类实现Converter接口，实现自定义的转换器 12345678910111213141516171819202122232425package top.carpenter.utils;import org.springframework.core.convert.converter.Converter;import org.springframework.util.StringUtils;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123;// 实现其唯一抽象方法 public Date convert(String str) &#123; DateFormat formate = null; Date date = null; try &#123; if (StringUtils.isEmpty(str)) throw new NullPointerException(\"请输入日期\"); formate = new SimpleDateFormat(\"yyyy-MM-dd\"); date = formate.parse(str); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125;&#125; 在Spring配置文件中配置类型转换器 Spring配置类型转换器的机制是，将自定义的转换器注册到类型转换服务中去。 123456789&lt;!-- 在Spring配置文件中配置类型转换器工厂--&gt; &lt;bean id =\"converterService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt;&lt;!-- 使用工厂类的set注入一个新的类型转换器（自定义的）--&gt; &lt;property name=\"converters\"&gt; &lt;set&gt; &lt;bean class=\"top.carpenter.utils.StringToDateConverter\"/&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 在annotation-driven标签中引用配置的类型转换服务 1&lt;mvc:annotation-driven conversion-service=\"converterService\"/&gt; 1User&#123;uname&#x3D;&#39;杨雨鑫&#39;, age&#x3D;123, date&#x3D;Sat Mar 02 00:00:00 CST 2019&#125; 2.2.6数据格式化 Spring在格式化模块中定义了一个实现ConversionService接口的FormattingConversionService实现类，该实现类扩展了GenericConversionService，因此它既具有类型转换的功能，又具有格式化的功能 FormattingConversionService拥有一个FormattingConversionServiceFactroyBean工厂类， 后者用于在 Spring 上下文中构造前者 FormattingConversionServiceFactroyBean 内部已经注册了 NumberFormatAnnotationFormatterFactroy：支持对数字类型的属性 使用 @NumberFormat 注解 JodaDateTimeFormatAnnotationFormatterFactroy：支持对日期类型 的属性使用 @DateTimeFormat 注解 装配了FormattingConversionServiceFactroyBean后，就可以在Spring MVC入参绑定及模型数据输出时使用注解驱动了。 &lt;mvc:annotation-driven/&gt;默认创建的ConversionService实例即为FormattingConversionServiceFactroyBean 日期格式化 @DateTimeFormat注解可对java.util.Date java.util.Calendar java.long.Long时间 类型进行标注： pattern属性：类型为字符串。指定解析/格式化字段数据的模式， 如：yyyy-MM-dd hh:mm:ss 数值格式化 @NumberFormat可对类似数字类型的属性进行标注 2.2.7 JSR 303 JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对 Bean 进行验证 Hibernate Validator 是 JSR 303 的一个参考实现，除支持 所有标准的校验注解外，它还支持以下的扩展注解 Spring 4.0 拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。 Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在 Spring MVC 中，可直接通过注解驱动的方式进行数据校验 Spring 的 LocalValidatorFactroyBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在 Spring 容器中定义了一个 LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean 中。 &lt;mvc:annotation-driven/&gt;会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标 注 @valid 注解即可让 Spring MVC 在完成数据绑定后执行 数据校验的工作 校验结果保存到随后的入参中，这个保存校验结果的入参必须是 BindingResult 或 Errors 类型，这两个类都位于 org.springframework.validation 包中 Spring 本身并没有提供 JSR303 的实现，所以必须将 JSR303 的实现者的 jar 包放到类路径下。 12345678910111213@RequestMapping(value=\"/emp\", method=RequestMethod.POST)public String save(@Valid Employee employee, BindingResult result, Map&lt;String, Object&gt; mapl)&#123; if(result.getErrorCount() &gt; 0)&#123; System.out.println(\"出错了!\"); for(FieldError error : result. getFieldErrors())&#123; System.out.println(error.getField() + \":\" + error.getDefaultMessage()); &#125; //若验证出错，则转向定制的页面 return \" input\"; &#125; employeeDao.save( employee); return \"redirect:/emps\";&#125; 需校验的 Bean 对象和其绑定结果对象或错误对象时成对出现的，之间不允许声明其他的入参 Errors 接口提供了获取错误信息的方法 * getErrorCount() * getFieldErrors(String field) BindingResult 扩展了 Errors 接口 2.3.解决中文乱码问题 SpringMVC可以配置中文乱码 web.xml 12345678910111213&lt;!-- 配置中文乱码过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2.4.使用ServletAPI对象作为方法参数[重要] SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数。 支持原始ServletAPI对象有: HttpServletRequest HttpServletResponse HttpSession java.security.Principal Locale InputStream OutputStream Reader Writer 我们可以把上述对象，直接写在控制的方法参数中使用 1234567@RequestMapping(path=\"/saveUser\") public String test(User user, HttpServletRequest request) &#123; System.out.println(user); System.out.println(request.getSession()); return \"success\"; &#125;","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://goldcarpenter.github.io/tags/SpringMVC/"}]},{"title":"String底层总结","date":"2019-11-01T14:54:45.000Z","path":"2019/11/01/String总结/","text":"String底层总结1.字符串创建方式 字符串有六种基本的创建方式 使用char[]数组配合new来创建 使用byte[]数组配合new来创建 使用int[]数组配合new来创建 使用 已有字符串 配合new来创建 使用字面量创建（不使用new） 合二为一，使用+运算符来拼接创建 可以看到，至少从表面上讲，后两种都没有用到 new 关键字 1.1 char[] 数组创建 这种是最基本的，因为字符串本身就是将字符串起来 String底层结构就是多个字符的 char[] 数组 1String s = new String(new char[]&#123;'a', 'b', 'c'&#125;); 它的内部结构如下（1.8） 其中 97 其实就是 ‘a’ ，98 其实就是 ‘b’ ，99 其实就是 ‘c’ 1.2 byte[] 数组创建 什么时候会根据 byte[] 数组来创建字符串呢【从 byte[] 转为字符串的需求】 从网络（例如一个浏览器的 http 请求）传递过来的字节数据 从 I/O（例如从一个文本文件）读取到的数据 例如 1String s = new String(new byte[]&#123;97, 98, 99&#125;); // abc 其中 new byte[]{97, 98, 99} 就可以是 从网络（例如一个浏览器的 http 请求）传递过来的字节数据 从 I/O（例如从一个文本文件）读取到的数据 它的内部结构其实也是 这时 byte[] 会在构造时被转换为 char[]，其中 byte[] 和 char [] 的结构如下 看到上幅图有同学会说，对于 byte[] 转换为 char[]，97 还是对应 97，98 还是对应 98，99 还是对应 99 啊，看不出 byte[] 和 char[] 的任何区别啊？你要知道，首先他们的大小不一样，其次上面的 char[] 中的 97（a），98（b），99（c） 都属于拉丁字符集，如果用到其它字符集，那么结果就不一样了，看下面的例子 按 gbk 字符集转换 123byte[] bytes = &#123;(byte) 0xD5, (byte) 0xC5&#125;;String str = new String(bytes, Charset.forName(\"gbk\"));System.out.println(str); 这时 其中两个byte 0xD5和 0xC5被转换成了一个 char 0x5F20（汉字【张】） 按utf-8字符集转换 1234 byte[] bytes = &#123;(byte) 0xE5, (byte) 0xBC, (byte) 0xA0&#125;; String str = new String(bytes, Charset.forName(\"utf-8\"));//String str = new String(bytes); 等价 System.out.println(str); 其中三个byte 0xE5，0xBC 和0xA0 被转换成了一个char 0x5F20（汉字【张】） 其实 java 中的 char 字符都是以 unicode 编码的，从外界不同的编码（如 gbk，utf-8）传过来的 byte[] 最终到 java 中的 char 都统一了 1.3 int[] 数组创建有时候我们还需要用两个 char 表示一个字符，比如 😂 这个笑哭的字符，它用 unicode 编码表示为 0x1F602，存储范围已经超过了 char 能表示的最大值 0xFFFF，因此需要使用 int[] 来构造这样的字符串，如下 1String s = new String(new int[]&#123;0x1F602&#125;, 0, 1); 转换过程如图所示 参考 unicode 9.0 说明 unicode 中的 emoji 表情 1.4 从已有字符串创建直接看源码 1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; 这种最为简单，但要注意是两个字符串对象引用同一个 char[] 对象，但是引用值不相等 12String s1 = new String(new char[]&#123;'a', 'b', 'c'&#125;);String s2 = new String(s1); 内存结构如下 1.5 字面量创建以上四种创建方式，大家用的实际上相对少一点，最熟悉的是这种字面量的方式： 123public static void main(String[] args) &#123; String s = \"abc\";&#125; &quot;abc&quot; 被叫做字符串字面量（英文 Literal），但恰恰是这种方式其实奥妙最多 非对象 懒加载 不重复 1.5.1非对象严格地说，字面量在代码运行到它所在语句之前，它还不是字符串对象 要理解从字面量变成字符串对象的过程，需要从字节码的角度来分析 在上面的 java 代码被编译为 class 文件后，&quot;abc&quot; 存储于【类文件常量池】中 1234Constant pool: &#x2F;&#x2F; 常量池 #1 &#x3D; Methodref #19.#41 &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V #2 &#x3D; String #42 &#x2F;&#x2F; abc ... 当 class 完成类加载之后，&quot;abc&quot; 这个字面量被存储于【运行时常量池】（归属于方法区）中，其中 #1 #2 都会被翻译为运行时真正的内存地址 再看一下 class 中 main 方法的字节码 123456789public static void main(java.lang.String[]); &#x2F;&#x2F; 字节码指令 descriptor: ([Ljava&#x2F;lang&#x2F;String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack&#x3D;1, locals&#x3D;2, args_size&#x3D;1 0: ldc #2 &#x2F;&#x2F; String abc 2: astore_1 3: return ... 将来 main 方法被调用时，就会执行里面的字节码指令 1230: ldc #2 &#x2F;&#x2F; String abc2: astore_13: return ldc #2 就是到运行时常量池中找到 #2 的内存地址，找到 &quot;abc&quot; 这个字面量，再根据它创建一个 String 对象。 1.5.2懒加载 当第一次用到 &quot;abc&quot; 字面量时（就是执行到 ldc #2 时） ，才会创建对应的字符串对象 如何验证呢？ 例如有如下代码 1234System.out.println();System.out.println(\"1\"); // 断点1 2411System.out.println(\"2\"); // 断点2 2412System.out.println(\"3\"); // 断点3 可以给每行语句加上断点，然后用 idea 的 debug 界面中的 memory 工具来查看字符串对象的数量 刚开始在断点1 处，其它类中创建的字符串对象有 2411 个 执行到断点2 处，这时新创建了 &quot;1&quot; 对应的字符串对象，个数为 2412 执行到断点3 处，这时新创建了 &quot;2&quot; 对应的字符串对象，个数为 2413 1.5.3不重复同一个类中的值相同字面量，其实只有一份 123456public class TestString1 &#123; public static void main(String[] args) &#123; String s1 = \"abc\"; String s2 = \"abc\"; &#125;&#125; 常量池为 1234Constant pool: #1 &#x3D; Methodref #25.#48 &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V #2 &#x3D; String #49 &#x2F;&#x2F; abc ... 对应的字节码为 1234567891011public static void main(java.lang.String[]); descriptor: ([Ljava&#x2F;lang&#x2F;String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack&#x3D;1, locals&#x3D;3, args_size&#x3D;1 0: ldc #2 &#x2F;&#x2F; String abc 2: astore_1 3: ldc #2 &#x2F;&#x2F; String abc 5: astore_2 6: return ... 可以看到 &quot;abc&quot; 这个字面量虽然出现了 2 次，但实际上都是对应着常量池中 #2 这个地址 如果是不同类中的 &quot;abc&quot; 呢？【类文件常量池】包括【运行时常量池】都是以类为单位的 例如，另一个类中 123456public class TestString2 &#123; public static void main(String[] args) &#123; String s1 = \"a\"; String s2 = \"abc\"; &#125;&#125; 对应的常量池 1234Constant pool: #1 = Methodref #5.#22 // java/lang/Object.\"&lt;init&gt;\":()V #2 = String #23 // a #3 = String #24 // abc 可以看到在这个类中，&quot;abc&quot; 对应的常量池的编号是 #3，与 TestString1 中的已经不同 这时候【字面量】是两份，而【字符串对象】会有几个呢？ 我们来做个实验，把刚才的代码做个改写 12345678910111213141516public class TestString1 &#123; public static void main(String[] args) &#123; String s1 = \"abc\"; // 字符串对象 \"abc\" String s2 = \"abc\"; // 字符串对象 \"abc\" TestString2.main(new String[]&#123;s1, s2&#125;); &#125;&#125;public class TestString2 &#123; public static void main(String[] args) &#123; // args[0] \"abc\", args[1] \"abc\" String s1 = \"a\"; String s2 = \"abc\"; System.out.println(args[0] == s2); System.out.println(args[1] == s2); &#125;&#125; 运行结果 12truetrue 具体原理我们下一个章节再讲 1.5 拼接创建最后还可以通过 + 运算符将两个字符串（其中一个也可以是其它类型）拼接为一个新字符串，例如 例1 1String s = \"a\" + \"b\"; 例2 12final String x = \"b\";String s = \"a\" + x; 例3 12String x = \"b\";String s = \"a\" + x; 例4 1String s = \"a\" + 1; 有同学会问，例1与例2与例3 不同吗？还别说，真就不同，其中例1 与例2 原理是一样的，例3 与例4 原理是一样的，反编译一下 例1 1String s = \"a\" + \"b\"; 常量池 1234Constant pool: #1 &#x3D; Methodref #4.#20 &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V #2 &#x3D; String #21 &#x2F;&#x2F; ab ... 主方法 123456789public static void main(java.lang.String[]); descriptor: ([Ljava&#x2F;lang&#x2F;String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack&#x3D;1, locals&#x3D;2, args_size&#x3D;1 0: ldc #2 &#x2F;&#x2F; String ab 2: astore_1 3: return ... 可以看到，其实并没有真正的【拼接】操作发生，从源码编译为字节码时，javac 就已经把 “a” 和 “b” 串在一起了，这是一种编译期的优化处理 例2 12final String x = \"b\";String s = \"a\" + x; 常量池 12345Constant pool: #1 &#x3D; Methodref #5.#22 &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V #2 &#x3D; String #23 &#x2F;&#x2F; b #3 &#x3D; String #24 &#x2F;&#x2F; ab ... 主方法 1234567891011public static void main(java.lang.String[]); descriptor: ([Ljava&#x2F;lang&#x2F;String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack&#x3D;1, locals&#x3D;3, args_size&#x3D;1 0: ldc #2 &#x2F;&#x2F; String b final b 2: astore_1 3: ldc #3 &#x2F;&#x2F; String ab 5: astore_2 6: return ... 可以看到，还是没有真正的【拼接】操作发生，final 意味着 x 的值不可改变，因此其它引用 x 的地方都可以安全地被替换为 “b”，而不用担心 x 被改变，从源码编译为字节码时，javac 就也进行了优化，把所有出现 x 的地方都替换成为了 “b” 那么，什么是真正的【拼接】操作呢？看一下例3 反编译后的结果 12String x = \"b\";String s = \"a\" + x; 常量池 1234567Constant pool: #1 &#x3D; Methodref #9.#26 &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V #2 &#x3D; String #27 &#x2F;&#x2F; b #3 &#x3D; Class #28 &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder #4 &#x3D; Methodref #3.#26 &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V #5 &#x3D; String #29 &#x2F;&#x2F; a ... 可以看到常量池中并没有 ab 字面量 主方法 1234567891011121314151617public static void main(java.lang.String[]); descriptor: ([Ljava&#x2F;lang&#x2F;String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1 0: ldc #2 &#x2F;&#x2F; String b 2: astore_1 3: new #3 &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder 6: dup 7: invokespecial #4 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V 10: ldc #5 &#x2F;&#x2F; String a 12: invokevirtual #6 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder; 15: aload_1 16: invokevirtual #6 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder; 19: invokevirtual #7 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String; 22: astore_2 23: return 翻译成人能读懂的就是 12345String x = \"b\";String s = \"a\" + x;String x = \"b\";String s = new StringBuilder().append(\"a\").append(x).toString(); StringBuilder 的 toString() 方法又是怎么实现的呢？ 12345678910111213public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence &#123; // 从 AbstractStringBuilder 继承的属性，方便阅读加在此处 char[] value; @Override public String toString() &#123; // Create a copy, don't share the array return new String(value, 0, count); &#125; &#125; 可以看到，本质上就是根据 StringBuilder 维护的 char[] 创建了新的 String 对象 1.6 JDK 9 之后的改变前面我们讲的是 JDK 8 中的字符串，但从 JDK 9 开始，String 的内部存储方式、以及拼接方式又发生了较大的改变 不再用 char[] 存储字符，改为了 byte[]，目的是更节约内存 使用 invokedynamic 指令扩展了字符串的拼接的实现方式 1.6.1内存结构改变例如，字符串中仅有拉丁字符 1String s = new String(new byte[]&#123;97, 98, 99&#125;); 例如，字符串中有中文字符 1234String s = new String( new byte[]&#123;(byte) 0xd5, (byte) 0xc5&#125;, Charset.forName(\"gbk\")); 例如，既有中文字符也有拉丁字符 1234String s = new String( new byte[]&#123;(byte) 0xd5, (byte) 0xc5, 97&#125;, Charset.forName(\"gbk\")); 1.6.2拼接方式改变例如 1234public static void main(String[] args) &#123; String x = \"b\"; String s = \"a\" + x;&#125; 常量池 1234Constant pool: #1 &#x3D; Methodref #5.#22 &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V #2 &#x3D; String #23 &#x2F;&#x2F; b ... 主方法 123456789101112public static void main(java.lang.String[]); descriptor: ([Ljava&#x2F;lang&#x2F;String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack&#x3D;1, locals&#x3D;3, args_size&#x3D;1 0: ldc #2 &#x2F;&#x2F; String b 2: astore_1 3: aload_1 4: invokedynamic #3, 0 &#x2F;&#x2F; InvokeDynamic #0:makeConcatWithConstants:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String; 9: astore_2 10: return ... 直接跟 invokedynamic 对应的字节码比较难，我直接翻译成人能看懂的代码 1234567891011121314151617181920public static void main(String[] args) throws Throwable &#123; String x = \"b\"; // String s = \"a\" + x; // 会生成如下等价的字节码 // 编译器会提供 lookup，用来查找 MethodHandle MethodHandles.Lookup lookup = MethodHandles.lookup(); CallSite callSite = StringConcatFactory.makeConcatWithConstants( lookup, // 方法名，不重要，编译器会自动生成 \"arbitrary\", // 方法的签名，第一个 String 为返回值类型，之后是入参类型 MethodType.methodType(String.class, String.class), // 具体处方格式，其中 \\1 意思是变量的占位符，将来被 x 代替 \"a\\1\" ); // callSite.getTarget() 返回的是 MethodHandle 对象，用来反射执行拼接方法 String s = (String) callSite.getTarget().invoke(x);&#125; 为什么搞这么麻烦！！！主要是为了对字符串的拼接做各种扩展优化，多了扩展途径。其中最为重要的是 MethodHandle ，它使用了策略模式生成，JDK 提供的所有的策略可以在 StringConcatFactory.Strategy 中找到： 策略名 内部调用 解释 BC_SB 字节码拼接生成 StringBuilder 代码 等价于 new StringBuilder() BC_SB_SIZED 字节码拼接生成 StringBuilder 代码 等价于 new StringBuilder(n) n为预估大小 BC_SB_SIZED_EXACT 字节码拼接生成 StringBuilder 代码 等价于 new StringBuilder(n) n为准确大小 MH_SB_SIZED MethodHandle 生成 StringBuilder 代码 等价于 new StringBuilder(n) n为预估大小 MH_SB_SIZED_EXACT MethodHandle 生成 StringBuilder 代码 等价于 new StringBuilder(n) n为准确大小 MH_INLINE_SIZED_EXACT MethodHandle 内部使用字节数组直接构造出 String 默认策略 如果想改变策略，可以在运行时添加 JVM 参数，例如将策略改为 BC_SB 123-Djava.lang.invoke.stringConcat&#x3D;BC_SB-Djava.lang.invoke.stringConcat.debug&#x3D;true-Djava.lang.invoke.stringConcat.dumpClasses&#x3D;匿名类导出路径 还有一种选择，是在 javac 编译时仍使用JDK1.5StringBuilder的办法拼接字符串，而不是采用 invokedynamic，就是在 javac 时加上参数 1-XDstringConcat&#x3D;inline 1.6.3默认拼接策略默认策略为 MH_INLINE_SIZED_EXACT，使用字节数组直接构造出 String 例如有下面的字符串拼接代码 12String x = \"b\";String s = \"a\" + x + \"c\" + \"d\"; 使用了 MH_INLINE_SIZED_EXACT 策略后，内部会执行如下等价调用 123456789101112131415161718String x = \"b\";// 预先分配字符串需要的字节数组byte[] buf = new byte[4];// 创建新字符串，这时内部字节数组值为 [0,0,0,0]String s = StringConcatHelper.newString(buf, 0);// 执行【拼接】，字符串内部字节数组值为 [97,0,0,0]StringConcatHelper.prepend(1, buf, \"a\");// 执行【拼接】，字符串内部字节数组值为 [97,98,0,0]StringConcatHelper.prepend(2, buf, x);// 执行【拼接】，字符串内部字节数组值为 [97,98,99,100]StringConcatHelper.prepend(4, buf, \"cd\");// 到此【拼接完毕】 注意 StringConcatHelper 对外是不可见的，因此无法直接测试，只能反射测试 prepend 可以直接修改字符串中的 bytes 属性值，他们都是 java.lang 包下的 1.6.4模仿 BC_SB 策略接下来我模拟其中一种策略的实现过程：以字节码指令生成拼接方法为例 先说明一下我的目的 123String x = \"hello,\";String y = \"world\";String s = x + y; 其中 + 可以被 invokedynamic 优化为多种实现策略，如果让我自己来实现，我仅会用 StringBuilder 来拼接，因此我希望 x+y 能够被翻译为对下面方法的调用 123public static String concat(String x, String y) &#123; return new StringBuilder().append(x).append(y).toString();&#125; 1. 方法手动生成提供一个拼接方法 123public static String concat(String x, String y) &#123; return new StringBuilder().append(x).append(y).toString();&#125; 用 MethodHandle 反射调用 123456789String x = \"hello,\";String y = \"world\";MethodHandle mh = MethodHandles.lookup().findStatic( TestString4.class, \"concat\", MethodType.methodType(String.class, String.class, String.class));String s = (String) mh.invoke(x,y);System.out.println(s); 输出 1hello,world 但这样需要自己提供 concat 方法，而且其参数个数都固定死了，能否动态生成这么一个方法呢，答案是肯定的，为了简化生成逻辑，这里我仍然以固定参数为例 2. 字节码生成方法Unsafe 对象访问类 123456789101112public class UnsafeAccessor &#123; static Unsafe UNSAFE; static &#123; try &#123; Field theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\"); theUnsafe.setAccessible(true); UNSAFE = (Unsafe) theUnsafe.get(null); &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 可以使用 asm 生成匿名类字节码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public static byte[] dump() &#123; ClassWriter cw = new ClassWriter(0); FieldVisitor fv; MethodVisitor mv; AnnotationVisitor av0; cw.visit(52, ACC_PUBLIC + ACC_SUPER, \"cn/itcast/string/TestString4\", null, \"java/lang/Object\", null); cw.visitSource(\"TestString4.java\", null); &#123; mv = cw.visitMethod(ACC_PUBLIC, \"&lt;init&gt;\", \"()V\", null, null); mv.visitCode(); Label l0 = new Label(); mv.visitLabel(l0); mv.visitLineNumber(3, l0); mv.visitVarInsn(ALOAD, 0); mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Object\", \"&lt;init&gt;\", \"()V\", false); mv.visitInsn(RETURN); Label l1 = new Label(); mv.visitLabel(l1); mv.visitLocalVariable(\"this\", \"Lcn/itcast/string/TestString4;\", null, l0, l1, 0); mv.visitMaxs(1, 1); mv.visitEnd(); &#125; &#123; mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, \"concat\", \"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;\", null, null); mv.visitCode(); Label l0 = new Label(); mv.visitLabel(l0); mv.visitLineNumber(9, l0); mv.visitTypeInsn(NEW, \"java/lang/StringBuilder\"); mv.visitInsn(DUP); mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/StringBuilder\", \"&lt;init&gt;\", \"()V\", false); mv.visitVarInsn(ALOAD, 0); mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(Ljava/lang/String;)Ljava/lang/StringBuilder;\", false); mv.visitVarInsn(ALOAD, 1); mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(Ljava/lang/String;)Ljava/lang/StringBuilder;\", false); mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"toString\", \"()Ljava/lang/String;\", false); mv.visitInsn(ARETURN); Label l1 = new Label(); mv.visitLabel(l1); mv.visitLocalVariable(\"x\", \"Ljava/lang/String;\", null, l0, l1, 0); mv.visitLocalVariable(\"y\", \"Ljava/lang/String;\", null, l0, l1, 1); mv.visitMaxs(2, 2); mv.visitEnd(); &#125; cw.visitEnd(); return cw.toByteArray();&#125; 这么多字节码主要目的仅仅是生成一个匿名类的字节码，其中包括了拼接方法 123public static String concat(String x, String y) &#123; return new StringBuilder().append(x).append(y).toString();&#125; 接下来就可以生成匿名类，供 MethodHandler 反射调用 12345678910111213// 生成匿名类所需字节码byte[] bytes = dump();// 根据字节码生成匿名类.classClass&lt;?&gt; innerClass = UnsafeAccessor.UNSAFE .defineAnonymousClass(TestString4.class, bytes, null);// 确保匿名类初始化UnsafeAccessor.UNSAFE.ensureClassInitialized(innerClass);// 找到匿名类中 String concat(String x, String y)MethodHandle mh = MethodHandles.lookup().findStatic( innerClass, \"concat\", MethodType.methodType(String.class, String.class, String.class)); 最终就可以使用该 MethodHandle 反射完成字符串拼接了 123String x = \"hello,\";String y = \"world\";String s = (String) mh.invoke(x, y); 输出 1hello,world JDK 9 当然做的更为专业，可以适配生成不同的参数个数、类型的 MethodHandle，但原理就是这样。 2.字符串之家 - StringTable2.1 家养与野生其实字符串分为家养的和野生的。 前面我们讲解了 String 的六种创建方式，除了字面量方式创建的字符串是家养的以外，其它方法创建的字符串都是野生的。什么意思呢？ 字面量方式创建的字符串，会放入 StringTable 中，StringTable 管理的字符串，才具有不重复的特性，这种就像是家养的 而 char[]，byte[]，int[]，String，以及 + 方式本质上都是使用 new 来创建，它们都是在堆中创建新的字符串对象，不会考虑字符串重不重复，这种就像是野生的，野生字符串的缺点就是如果存在大量值相同的字符串，对内存占用非常严重 如何保证家养的字符串对象不重复呢？JDK 使用了 StringTable 来解决，StringTable 是采用 c++ 代码编写的，数据结构上就是一个 hash 表，字符串对象就充当 hash 表中的 key，key 的不重复性，是 hash 表的基本特性 当代码运行到一个字面量 “abc” 时，会首先检查 StringTable 中有没有相同的 key，如果没有，创建新字符串对象加入；否则直接返回已有的字符串对象 2.2 收留野生字符串野生的字符串也有机会得到教育 字符串提供了 intern 方法来实现去重，让字符串对象有机会受到 StringTable 的管理 1public native String intern(); 它会尝试将调用者放入 StringTable 2.2.1如果 StringTable 中已有12String x = ...;String s = x.intern(); 总会返回家养的 String 对象 12345678sequenceDiagram participant x as xparticipant s as sparticipant st as StringTablex -&gt;&gt; st : intern()st -&gt;&gt; st : 如果已有st --&gt;&gt; s : 返回 StringTable 对象 例子 12345String x = new String(new char[]&#123;'a', 'b', 'c'&#125;); // 野生的String y = \"abc\"; // 将 \"abc\"字符串对象 加入 StringTableString z = x.intern(); // 已有，返回 StringTable 中 \"abc\"，即 ySystem.out.println(z == y);System.out.println(z == x); 输出 12truefalse 2.2.2如果 StringTable 中没有（1.7 以上 JDK 的做法）12String x = ...;String s = x.intern(); 123456789sequenceDiagram participant x as xparticipant s as sparticipant st as StringTablex -&gt;&gt; st : intern()st -&gt;&gt; st : 如果没有st -&gt;&gt; st : 将x引用的对象加入st --&gt;&gt; s : 返回 StringTable 对象 例子 12345String x = new String(new char[]&#123;'a', 'b', 'c'&#125;); // 野生的String z = x.intern(); // 野生的 x 加入 StringTable，StringTable 中有了 \"abc\"String y = \"abc\"; // 已有，不会产生新的对象，用的是 StringTable 中 \"abc\"System.out.println(z == x);System.out.println(z == y); 输出 12truetrue 2.2.3如果 StringTable 中没有（1.6 JDK 的做法）12String x = ...;String s = x.intern(); 12345678910sequenceDiagramparticipant x as xparticipant s as sparticipant st as StringTablex -&gt;&gt; st : intern()st -&gt;&gt; st : 如果没有st -&gt;&gt; st : 将x引用的对象复制st -&gt;&gt; st : 将复制后的对象加入st --&gt;&gt; s : 返回 StringTable 对象 例子，代码同上面 1.7 相同 12345String x = new String(new char[]&#123;'a', 'b', 'c'&#125;); // 野生的String z = x.intern(); // 野生的 x 被复制后加入 StringTable，StringTable 中有了 \"abc\"String y = \"abc\"; // 已有，不会产生新的对象，用的是 StringTable 中 \"abc\"System.out.println(z == x);System.out.println(z == y); 输出 12falsetrue 2.3 去重的好处123456789101112131415161718192021222324/** * 演示 intern 减少内存占用 */public class Demo1 &#123; public static void main(String[] args) throws IOException &#123; List&lt;String&gt; address = new ArrayList&lt;&gt;(); System.in.read(); for (int i = 0; i &lt; 10; i++) &#123; try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(\"linux.words\"), \"utf-8\"))) &#123; String line = null; long start = System.nanoTime(); while (true) &#123; line = reader.readLine(); if(line == null) &#123; break; &#125; address.add(line.intern()); &#125; System.out.println(\"cost:\" +(System.nanoTime()-start)/1000000); &#125; &#125; System.in.read(); &#125;&#125; 2.4 家的位置StringTable 的位置（1.6） StringTable 的位置（1.8） ![]( 9.png) 如何证明 1.6 不断将字符串用 intern 加入 StringTable，最后撑爆的是永久代内存，为了让错误快速出现，将永久代内存设置的小一些：-XX:MaxPermSize=10m，最终会出现 java.lang.OutOfMemoryError: PermGen space 1.8 不断将字符串用 intern 加入 StringTable，最后撑爆的是堆内存，为了让错误快速出现，将堆内存设置的小一些：-Xmx10m -XX:-UseGCOverheadLimit 后一个虚拟机参数是避免 GC 频繁引起其他错误而不是我们期望的 java.lang.OutOfMemoryError: Java heap space 代码 12345678910111213141516171819202122/** * 演示 StringTable 位置 * 在jdk8下设置 -Xmx10m -XX:-UseGCOverheadLimit * 在jdk6下设置 -XX:MaxPermSize=10m */public class Demo2 &#123; public static void main(String[] args) throws InterruptedException &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); int i = 0; try &#123; for (int j = 0; j &lt; 260000; j++) &#123; list.add(String.valueOf(j).intern()); i++; &#125; &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(i); &#125; &#125;&#125; 2.5 intern 去重原理查阅一下 jdk 的源码 http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/5bd0e0bcb152/src/share/vm/classfile/symbolTable.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// string_or_null 字符串对象// name 字符串原始指针// len 字符串长度oop StringTable::intern(Handle string_or_null, jchar* name, int len, TRAPS) &#123; // 获取字符串的 hash 值 unsigned int hashValue = hash_string(name, len); // 算出 hash table 桶下标 int index = the_table()-&gt;hash_to_index(hashValue); // 看字符串在 hash table 中有没有 oop found_string = the_table()-&gt;lookup(index, name, len, hashValue); // 如果有，直接返回（避免重复加入） if (found_string != NULL) &#123; // 确保该字符串对象没有被垃圾回收 ensure_string_alive(found_string); return found_string; &#125; debug_only(StableMemoryChecker smc(name, len * sizeof(name[0]))); assert(!Universe::heap()-&gt;is_in_reserved(name), \"proposed name of symbol must be stable\"); Handle string; // try to reuse the string if possible if (!string_or_null.is_null()) &#123; string = string_or_null; &#125; else &#123; // 根据 unicode 创建【字符串对象 string】 string = java_lang_String::create_from_unicode(name, len, CHECK_NULL); &#125;#if INCLUDE_ALL_GCS if (G1StringDedup::is_enabled()) &#123; // Deduplicate the string before it is interned. Note that we should never // deduplicate a string after it has been interned. Doing so will counteract // compiler optimizations done on e.g. interned string literals. G1StringDedup::deduplicate(string()); &#125;#endif // Grab the StringTable_lock before getting the_table() because it could // change at safepoint. oop added_or_found; &#123; MutexLocker ml(StringTable_lock, THREAD); // 将【字符串对象 string】加入 hash table added_or_found = the_table()-&gt;basic_add(index, string, name, len, hashValue, CHECK_NULL); &#125; ensure_string_alive(added_or_found); return added_or_found;&#125; 其中 lookup 的定义为 123456789101112131415161718192021// index 桶下标// name 字符串原始指针// len 字符串长度// hash 哈希码oop StringTable::lookup(int index, jchar* name, int len, unsigned int hash) &#123; int count = 0; for (HashtableEntry&lt;oop, mtSymbol&gt;* l = bucket(index); l != NULL; l = l-&gt;next()) &#123; count++; if (l-&gt;hash() == hash) &#123; if (java_lang_String::equals(l-&gt;literal(), name, len)) &#123; return l-&gt;literal(); &#125; &#125; &#125; // 如果链表过长，需要 rehash if (count &gt;= rehash_count &amp;&amp; !needs_rehashing()) &#123; _needs_rehashing = check_rehash_table(count); &#125; return NULL;&#125; 其中 basic_add 的定义为 12345678910111213141516171819202122232425262728293031323334353637383940// index_arg 桶下标// string 字符串对象// name 字符串原始指针// len 字符串长度oop StringTable::basic_add(int index_arg, Handle string, jchar* name, int len, unsigned int hashValue_arg, TRAPS) &#123; assert(java_lang_String::equals(string(), name, len), \"string must be properly initialized\"); // Cannot hit a safepoint in this function because the \"this\" pointer can move. No_Safepoint_Verifier nsv; // Check if the symbol table has been rehashed, if so, need to recalculate // the hash value and index before second lookup. unsigned int hashValue; int index; if (use_alternate_hashcode()) &#123; hashValue = hash_string(name, len); index = hash_to_index(hashValue); &#125; else &#123; hashValue = hashValue_arg; index = index_arg; &#125; // Since look-up was done lock-free, we need to check if another // thread beat us in the race to insert the symbol. oop test = lookup(index, name, len, hashValue); // calls lookup(u1*, int) if (test != NULL) &#123; // Entry already added return test; &#125; // 构造新的 HashtableEntry 节点 HashtableEntry&lt;oop, mtSymbol&gt;* entry = new_entry(hashValue, string()); // 加入链表 add_entry(index, entry); // 返回字符串对象 return string();&#125; 2.6 G1 去重懒惰是程序员的一大美德，不追求懒惰的程序员不是好程序员 如果你使用的 JDK 8u20，那么可以使用下面的 JVM 参数开启 G1 垃圾回收器，并开启字符串去重功能 1-XX:+UseG1GC -XX:+UseStringDeduplication 原理是让多个字符串对象引用同一个 char[] 来达到节省内存的目的 特点 由 G1 垃圾回收器在 minor gc 阶段自动分析优化，不需要程序员自己干预 只有针对那些多次回收还不死的字符串对象，才会进行去重优化，可以通过 -XX:StringDeduplicationAgeThreshold=n 来调整 可以通过 -XX:+PrintStringDeduplicationStatistics 查看 G1 去重的统计信息 与调用 intern 去重相比，G1 去重好处在于自动，但缺点是即使 char[] 不重复，但字符串对象本身还要占用一定内存（对象头、value引用、hash），intern 去重是字符串对象只存一份，更省内存 2.7 家的大小StringTable 足够大，才能发挥性能优势，大意味着 String 在 hash 表中冲突减少，链表短，性能高。 可以通过 -XX:+PrintStringTableStatistics 来查看 StringTable 的大小，JDK 8 中它的默认大小为 60013 要注意 StringTable 底层的 hash 表在 JVM 启动后大小就固定不变了 这个 hash 表可以在链表长度太长时进行 rehash，但不是利用扩容实现的 rehash，而是通过重新计算字符串的 hash 值来让它们分布均匀 如果想在启动前调整 StringTable 的大小，可以通过 -XX:StringTableSize=n 来指定 代码 123456789101112131415161718192021/** * 演示串池大小对性能的影响 * -XX:+PrintStringTableStatistics -XX:StringTableSize=1009 */public class Demo3 &#123; public static void main(String[] args) throws IOException &#123; try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(\"linux.words\"), \"utf-8\"))) &#123; String line = null; long start = System.nanoTime(); while (true) &#123; line = reader.readLine(); if (line == null) &#123; break; &#125; line.intern(); &#125; System.out.println(\"cost:\" + (System.nanoTime() - start) / 1000000); &#125; &#125;&#125; 2.8 字符串之死字符串也是一个对象，只要是对象，终究逃不过死亡的命运。字符串对象与其它 Java 对象一样，只要失去了利用价值，就会被垃圾回收，无论是野生字符串，还是家养字符串 怎么证明家养的字符串也能被垃圾回收呢，可以用以下 JVM 参数来查看 1-XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc 代码 1234567891011121314151617181920/** * 演示 StringTable 垃圾回收 * -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc */public class Demo4 &#123; public static void main(String[] args) throws InterruptedException &#123; int i = 0; try &#123; for (int j = 0; j &lt; 100000; j++) &#123; // j=100, j=10000 String.valueOf(j).intern(); i++; &#125; &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(i); &#125; &#125;&#125; 三、面试题讲解1. 判断输出 123456String str1 = \"string\"; // 家String str2 = new String(\"string\"); // 野生String str3 = str2.intern(); // 家System.out.println(str1==str2);//#1 falseSystem.out.println(str1==str3);//#2 true 2. 判断输出 12345678910111213String baseStr = \"baseStr\";final String baseFinalStr = \"baseStr\";String str1 = \"baseStr01\"; // 家String str2 = \"baseStr\"+\"01\"; // 家String str3 = baseStr + \"01\"; // 野生String str4 = baseFinalStr+\"01\";// 家String str5 = new String(\"baseStr01\").intern(); // 家System.out.println(str1 == str2);//#3 trueSystem.out.println(str1 == str3);//#4 false System.out.println(str1 == str4);//#5 trueSystem.out.println(str1 == str5);//#6 true 3. 判断输出（注意版本） 1234String str2 = new String(\"str\")+new String(\"01\");str2.intern(); //1.6String str1 = \"str01\";System.out.println(str2==str1);//#7 1.7 true, 1.6 false 4. 判断输出 1234String str1 = \"str01\";String str2 = new String(\"str\")+new String(\"01\");str2.intern();System.out.println(str2 == str1);//#8 false 5. String s = new String(“xyz”)，创建了几个String Object? 6. 判断输出 123String s1 = \"abc\";String s2 = \"abc\";System.out.println(s1 == s2); // true 7. 判断输出 123String s1 = new String(\"abc\");String s2 = new String(\"abc\");System.out.println(s1 == s2); //false 8. 判断输出 12345String s1 = \"abc\";String s2 = \"a\";String s3 = \"bc\";String s4 = s2 + s3;System.out.println(s1 == s4); //false 9. 判断输出 12345String s1 = \"abc\";final String s2 = \"a\";final String s3 = \"bc\";String s4 = s2 + s3;System.out.println(s1 == s4);//true 10. 判断输出 123456String s = new String(\"abc\"); // 野生String s1 = \"abc\"; // 家String s2 = new String(\"abc\"); // 野生System.out.println(s == s1.intern()); // falseSystem.out.println(s == s2.intern()); // falseSystem.out.println(s1 == s2.intern()); // true","tags":[{"name":"JVM","slug":"JVM","permalink":"http://goldcarpenter.github.io/tags/JVM/"},{"name":"String","slug":"String","permalink":"http://goldcarpenter.github.io/tags/String/"}]},{"title":"Spring FrameWork","date":"2019-09-22T15:19:21.000Z","path":"2019/09/22/Spring_AOP/","text":"6.AOP引入6.1.环境准备——引出问题 sql 1234567CREATE TABLE table1 ( id int primary key auto_increment, name varchar(40), money float)character set utf8 collate utf8_general_ci;insert into table1(name,money) values(\"aaa\",1000); pojo.Account.java 123456789101112131415161718192021package top.carpenter.pojo;import org.springframework.stereotype.Component;import java.io.Serializable;@Componentpublic class Account implements Serializable &#123; private Integer id; private String name; private Float money; @Override public String toString() &#123; return \"Account&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", money=\" + money + '&#125;'; &#125; //get set function&#125; dao.impl.AccountDaoImpl.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package top.carpenter.dao.impl;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import top.carpenter.dao.IAccountDao;import top.carpenter.pojo.Account;import top.carpenter.utils.ConnectionUtils;import java.sql.SQLException;import java.util.List;@Repositorypublic class AccountDaoImpl implements IAccountDao &#123; @Autowired private QueryRunner runner; @Autowired private ConnectionUtils connectionUtils; public List&lt;Account&gt; findAllAccount() throws SQLException &#123; return runner.query(connectionUtils.getThreadConnection(), \"select * from table1\",new BeanListHandler&lt;Account&gt;(Account.class)); &#125; public Account findAccountById(Integer accountId) throws SQLException &#123; return runner.query(connectionUtils.getThreadConnection(), \"select * from table1 where id = ?\",new BeanHandler&lt;Account&gt;(Account.class),accountId); &#125; public void saveAccount(Account account) throws SQLException &#123; runner.update(connectionUtils.getThreadConnection(), \"insert into table1(name,money) values(?,?) \",account.getName(),account.getMoney()); &#125; public void updateAccount(Account account) throws SQLException &#123; runner.update(connectionUtils.getThreadConnection(), \"update table1 set name=?, money=? where id = ?\",account.getName(),account.getMoney(),account.getId()); &#125; public void deleteAccount(Integer accountId) throws SQLException &#123; runner.update(connectionUtils.getThreadConnection(), \"delete from table1 where id=?\",accountId); &#125; public Account findAccountByName(String accountName) throws SQLException &#123; try &#123; List&lt;Account&gt; accounts = runner.query(connectionUtils.getThreadConnection(), \"select * from table1 where name=?\", new BeanListHandler&lt;Account&gt;(Account.class), accountName); if (accounts == null || accounts.size() == 0) &#123; return null; &#125; if (accounts.size() &gt; 1) &#123; throw new RuntimeException(\"&gt;0\"); &#125; return accounts.get(0); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; dao.IAccountDao 12345678910111213141516package top.carpenter.dao;import top.carpenter.pojo.Account;import java.sql.SQLException;import java.util.List;public interface IAccountDao &#123; List&lt;Account&gt; findAllAccount() throws SQLException; Account findAccountById(Integer accountId) throws SQLException; Account findAccountByName(String accountName) throws SQLException; void saveAccount(Account account) throws SQLException; void updateAccount(Account account) throws SQLException; void deleteAccount(Integer accountId) throws SQLException;&#125; service.IAccountService 12345678910111213141516package top.carpenter.service;import top.carpenter.pojo.Account;import java.sql.SQLException;import java.util.List;public interface IAccountService &#123; List&lt;Account&gt; findAllAccount() throws SQLException; Account findAccountById(Integer accountId) throws SQLException; void saveAccount(Account account) throws SQLException; void updateAccount(Account account) throws SQLException; void deleteAccount(Integer accountId) throws SQLException; void transfer(String sourceName, String targetName, Float money) throws SQLException;&#125; service.impl.AccountServiceImpl 存在问题：大量【事务控制】的重复代码，引出问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package top.carpenter.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import top.carpenter.dao.IAccountDao;import top.carpenter.pojo.Account;import top.carpenter.service.IAccountService;import top.carpenter.utils.TransactionManager;import java.sql.SQLException;import java.util.List;@Servicepublic class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Autowired private TransactionManager tx; public List&lt;Account&gt; findAllAccount() throws SQLException &#123; List&lt;Account&gt; allAccount = null; try &#123; tx.beginTransaction(); allAccount = accountDao.findAllAccount(); tx.commit(); &#125; catch (Exception e) &#123; tx.rollback(); e.printStackTrace(); &#125;finally &#123; tx.release(); &#125; return allAccount; &#125; public Account findAccountById(Integer accountId) throws SQLException &#123; Account account = null; try &#123; tx.beginTransaction(); account = accountDao.findAccountById(accountId); tx.commit(); &#125; catch (Exception e) &#123; tx.rollback(); e.printStackTrace(); &#125;finally &#123; tx.release(); &#125; return account; &#125; public void saveAccount(Account account) throws SQLException &#123; try &#123; tx.beginTransaction(); accountDao.saveAccount(account); tx.commit(); &#125; catch (Exception e) &#123; tx.rollback(); e.printStackTrace(); &#125;finally &#123; tx.release(); &#125; &#125; public void updateAccount(Account account) throws SQLException &#123; try &#123; tx.beginTransaction(); accountDao.updateAccount(account); tx.commit(); &#125; catch (Exception e) &#123; tx.rollback(); e.printStackTrace(); &#125;finally &#123; tx.release(); &#125; &#125; public void deleteAccount(Integer accountId) throws SQLException &#123; try &#123; tx.beginTransaction(); accountDao.deleteAccount(accountId); tx.commit(); &#125; catch (Exception e) &#123; tx.rollback(); e.printStackTrace(); &#125;finally &#123; tx.release(); &#125; &#125; public void transfer(String sourceName, String targetName, Float money) throws SQLException &#123; try &#123; tx.beginTransaction(); Account sourceAccount = accountDao.findAccountByName(sourceName); Account targetAccount = accountDao.findAccountByName(targetName); sourceAccount.setMoney(sourceAccount.getMoney() - money); targetAccount.setMoney(targetAccount.getMoney() + money); accountDao.updateAccount(sourceAccount); accountDao.updateAccount(targetAccount); tx.commit(); &#125; catch (Exception e) &#123; tx.rollback(); e.printStackTrace(); &#125;finally &#123; tx.release(); &#125; &#125;&#125; Client.java 1234567891011121314151617181920212223242526package top.carpenter.ui;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import top.carpenter.pojo.Account;import top.carpenter.service.IAccountService;import java.util.List;public class Client &#123; public static void main(String[] args) throws Exception &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); IAccountService accountService = (IAccountService) ac.getBean(\"accountServiceImpl\"); List&lt;Account&gt; allAccount = accountService.findAllAccount(); for(Account item : allAccount) &#123; System.out.println(item.toString()); &#125; accountService.transfer(\"aaa\",\"bbb\",100f); allAccount = accountService.findAllAccount(); for(Account item : allAccount) &#123; System.out.println(item.toString()); &#125; &#125;&#125; bean.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;context:component-scan base-package=\"top.carpenter\"/&gt;以下注释已用注解方式完成其功能 此处仅作参看&lt;!-- &lt;bean id=\"accountService\" class=\"top.carpenter.service.impl.AccountServiceImpl\"&gt;--&gt;&lt;!-- &lt;property name=\"tx\" ref=\"transactionManager\"/&gt;--&gt;&lt;!-- &lt;property name=\"accountDao\" ref=\"accountDaoImpl\"/&gt;--&gt;&lt;!-- &lt;/bean&gt;--&gt;&lt;!-- &lt;bean id=\"tx\" class=\"top.carpenter.utils.TransactionManager\"&gt;--&gt;&lt;!-- &lt;property name=\"connectionUtils\" ref=\"connectionUtils\"/&gt;--&gt;&lt;!-- &lt;/bean&gt;--&gt;&lt;!-- &lt;bean id=\"accountDao\" class=\"top.carpenter.dao.impl.AccountDaoImpl\"&gt;--&gt;&lt;!-- &lt;property name=\"connectionUtils\" ref=\"connectionUtils\"/&gt;--&gt;&lt;!-- &lt;property name=\"runner\" ref=\"runner\"/&gt;--&gt;&lt;!-- &lt;/bean&gt;--&gt;&lt;!-- &lt;bean id=\"connectionUtils\" class=\"top.carpenter.utils.ConnectionUtils\"&gt;--&gt;&lt;!-- &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;--&gt;&lt;!-- &lt;/bean&gt;--&gt; &lt;bean id=\"runner\" class=\"org.apache.commons.dbutils.QueryRunner\" scope=\"prototype\"&gt; &lt;/bean&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/spring_study\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"\"/&gt; &lt;/bean&gt;&lt;/beans&gt; pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;top.carpenter&lt;/groupId&gt; &lt;artifactId&gt;spring_restudy_day01&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 6.2.代理前置知识6.2.1静态代理继承 代理对象继承目标对象，重写需要增强的方法 缺点：会代理类过多,非常复杂 日志子类 权限验证子类 运行时间计算子类 日志子类的权限验证继承类 权限验证子类的日志继承类 日志子类的运行时间计算继承类… … 聚合 【代理模式】 动态代理 本质：生成.class字节数组，使用本地方法defineClass0生成class对象 特点：字节码随用随创建，随用随加载 作用：不修改源码的基础上对方法增强 基于接口的动态代理 涉及类：Proxy 提供者：JDK官方 创建代理对象要求：被代理对象至少实现一个接口，如果没有则不能使用【已经继承了Proxy 不能多继承】 如何创建代理对象：Proxy类的newProxyInstance() ClassLoader 用于加载代理对象字节码的，和被代理对象使用相同的类加载器。 固定写法：被代理对象.getClass().getClassLoader() Class[] interfaces 是用于让反射得到的代理对象和被代理对象有相同方法 固定写法：被代理对象.getClass().getInterfaces() InvocationHandler： 写具体如何代理，一般都是接口的实现类。通常情况下都是匿名内部类，但不是必须的 此接口的实现类都是谁用谁写 IProducer.java 12345package top.carpenter.proxy;public interface IProducer &#123; public void saleProduct(float money);&#125; Producer.java 1234567package top.carpenter.proxy;public class Producer implements IProducer&#123; public void saleProduct(float money)&#123; System.out.println(\"sale bonus is \"+money); &#125;&#125; Main.java 123456789101112131415161718192021222324package top.carpenter.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class Main &#123; public static void main(String[] args) &#123; final IProducer producer = new Producer(); IProducer producerProxy = (IProducer)Proxy.newProxyInstance(producer.getClass().getClassLoader(), producer.getClass().getInterfaces(), new InvocationHandler() &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object returnValue = null; Float money = (Float)args[0]; if(\"saleProduct\".equals(method.getName())) returnValue = method.invoke(producer,money*0.8f); return returnValue; &#125; &#125;); producerProxy.saleProduct(10000); &#125;&#125; 可以将生成的Class对象保存下来 1System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\"); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;final class $Proxy0 extends Proxy implements IProducer &#123; private static Method m1; private static Method m3; private static Method m2; private static Method m0; // 唯一的一个构造方法 就是传入InvocationHandler public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; // protected InvocationHandler h; 解释了三个参数的由来 return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final void saleProduct(float var1) throws &#123; try &#123; super.h.invoke(this, m3, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return (Integer)super.h.invoke(this, m0, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\")); m3 = Class.forName(\"top.carpenter.IProducer\").getMethod(\"saleProduct\", Float.TYPE); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\"); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 基于子类的动态代理 pom.xml 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt; 涉及类：Enhancer 提供者：第三方cglib库 创建代理对象要求：被代理类不能是最终类 如何创建代理对象：Enhancer类的create() Class 固定写法：被代理对象.getClass() Callback： 提供增强代码 写如何代理，一般都是接口的实现类。通常情况下都是匿名内部类，但不是必须的 此接口的实现类都是谁用谁写 一般写的都是该接口的子接口实现类：MethodInterceptor Producer.java 1234567package top.carpenter.proxy;public class Producer implements IProducer&#123; public void saleProduct(float money)&#123; System.out.println(\"sale bonus is \"+money); &#125;&#125; Main.java 1234567891011121314151617181920212223242526package top.carpenter.cglib;import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class Main &#123; public static void main(String[] args) &#123; final Producer producer = new Producer(); System.out.println(producer); Producer producerProxy = (Producer) Enhancer.create(producer.getClass(), new MethodInterceptor() &#123; public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; Object returnValue = null; Float money = (Float)args[0]; if(\"saleProduct\".equals(method.getName())) returnValue =method.invoke(producer,money*0.8f); return returnValue; &#125; &#125;); producerProxy.saleProduct(10000); &#125;&#125; 6.3.基于动态代理的问题解决 factory.BeanFactory.java——用于创建Service的代理类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package top.carpenter.factory;import top.carpenter.service.IAccountService;import top.carpenter.utils.TransactionManager;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class BeanFactory &#123; private IAccountService accountService; private TransactionManager tx; public void setTx(TransactionManager tx) &#123; this.tx = tx; &#125; public final void setAccountService(IAccountService accountService) &#123; this.accountService = accountService; &#125; public IAccountService getAccountService() &#123; IAccountService proxyInstance = (IAccountService)Proxy.newProxyInstance(accountService.getClass().getClassLoader(), accountService.getClass().getInterfaces(), new InvocationHandler() &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object reValue = null; try &#123; tx.beginTransaction(); reValue = method.invoke(accountService, args); tx.commit(); &#125; catch (Exception e) &#123; tx.rollback(); e.printStackTrace(); &#125;finally &#123; tx.release(); &#125; return reValue; &#125; &#125;); return proxyInstance; &#125;&#125; AccountServiceImpl——文件变得清爽，问题解决 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package top.carpenter.service.impl;import org.springframework.stereotype.Service;import top.carpenter.dao.IAccountDao;import top.carpenter.pojo.Account;import top.carpenter.service.IAccountService;import java.sql.SQLException;import java.util.List;@Servicepublic class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125; public List&lt;Account&gt; findAllAccount() throws SQLException &#123; return accountDao.findAllAccount(); &#125; public Account findAccountById(Integer accountId) throws SQLException &#123; return accountDao.findAccountById(accountId); &#125; public void saveAccount(Account account) throws SQLException &#123; accountDao.saveAccount(account); &#125; public void updateAccount(Account account) throws SQLException &#123; accountDao.updateAccount(account); &#125; public void deleteAccount(Integer accountId) throws SQLException &#123; accountDao.deleteAccount(accountId); &#125; public void transfer(String sourceName, String targetName, Float money) throws SQLException &#123; Account sourceAccount = accountDao.findAccountByName(sourceName); Account targetAccount = accountDao.findAccountByName(targetName); sourceAccount.setMoney(sourceAccount.getMoney() - money); targetAccount.setMoney(targetAccount.getMoney() + money); accountDao.updateAccount(sourceAccount); accountDao.updateAccount(targetAccount); &#125;&#125; bean.xml——修改一下部分内容 123456789101112 &lt;bean id=\"proxyAccountService\" factory-bean=\"beanFactory\" factory-method=\"getAccountService\"/&gt; &lt;bean id=\"beanFactory\" class=\"top.carpenter.factory.BeanFactory\"&gt; &lt;property name=\"accountService\" ref=\"accountService\"/&gt; &lt;property name=\"tx\" ref=\"transactionManager\"/&gt; &lt;/bean&gt; &lt;bean id=\"accountService\" class=\"top.carpenter.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 6.4.基于Spring框架中AOP的问题解决 @EnableAspectJAutoProxy (proxyTargetClass=true)——使用CGLib @EnableAspectJAutoProxy (proxyTargetClass=false) 实现接口——JDK官方动态代理 不实现接口——使用CGLib 见7.2 &amp; 7.3 7.AOPAOP &amp; SpringAOP AOP是一种思想 SpringAOP是AOP的一种实现 同样，AspectJ是AOP的一种实现 Spring旧版有自己的AOP语法，但是非常复杂。 故：Spring借助AspectJ的语法(AspectJ的注解，故要导入AspectJ的Jar包)，但底层使用自己Spring实现 12@Configuration@EnableAspectJAutoProxy 7.1.AOP基础知识 AOP：全称是Aspect oriented Programming面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术 作用：解决与主业务逻辑无关的横切性问题，把程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对已有方法进行增强 优势 减少重复代码 提高开发效率 维护方便 与OOP对比，面向切面，传统的OOP开发中的代码逻辑是至上而下的，在这些至上而下的过程中会产生一些横切性的问题，这些横切性的问题和我们的主业务逻辑关系不大，会散落在代码的各个地方，造成难以维护，AOP的编程思想就是把业务逻辑和横切的问题进行分离，从而达到解耦的目的，使代码的重用性和开发效率高 应用场景 日志记录 权限验证 效率检查 事务管理 专业词汇 Joinpoint（连接点） 被拦截到的点【如Service层的所有需要增强（目标对象）的方法】。在spring中，这些点指的是方法，因为spring只支持方法类型的连接点。 Pointcut （切入点） 要对哪些Joinpoint进行拦截并增强【如Service层的需要增强的方法】，连接点的集合 Advice（通知/增强） 所谓通知是指拦截到Joinpoint之后所要做的事情就是通知 增强的位置 增强的内容 通知的类型： 前置通知，后置通知，异常通知，最终通知 环绕通知 Introduction（引介）: 一种特殊的通知。在不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法或Field 12345@Aspectpublic class UsageTracking &#123; @DeclareParents(value=\"com.xzy.myapp.service.*\", defaultImpl=DefaultUsageTracked.class) public static sageTracked mixin;&#125; Target（目标对象） 被代理的对象 Weaving（织入） 织入：目标对象的需要增强的方法变成代理对象的方法的过程 代理：目标对象变成代理对象的过程 spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入 Proxy（代理） 一个类被AOP织入增强后，就产生一个结果代理类 Aspect （切面） 切入点和通知(引介)的结合 pom.xml 12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt;&lt;/dependency&gt; 7.2.Spring中基于XML的AOP配置步骤 通知Bean也交给spring来管理 使用&lt;aop:config&gt;标签表明开始AOP的配置 使用&lt;aop:aspect&gt;标签表明配置切面 id属性：切面唯一标识 ref属性：通知类bean的Id 在&lt;aop:aspect&gt;标签的内部使用对应标签来配置通知的类型 &lt;aop:before&gt;：表示配置前置通知 method属性：通知类中哪个方法是前置通知 pointcut属性：切入点表达式，对业务层中哪些方法增强 切入点表达式写法： 关键字execution(表达式) 标准表达式：访问修饰符 返回值 包名.包名.包名...类名.方法名(参数列表) 访问修饰符可以省略：返回值 包名.包名.包名...类名.方法名(参数列表) 返回值可以使用通配符，表示任意返回值：* 包名.包名.包名...类名.方法名(参数列表) 包名可以使用通配符，表示任意包。但是有几级包，需要写几个*：* *.*.*.类名.方法名(参数列表) 包名可以使用..表示当前包及其子包：* *..类名.方法名(参数列表) 类名和方法名都可以使用*来实现通配：* *..*.*(参数列表) 参数列表可以直接写数据类型 基本类型直接写名称——int 引用类型写包名.类名的方式——java.lang.String 可以使用通配符表示任意类型，但是必须有参数 可以使用..表示有无参数均可，有参数可以是任意类型 全通配写法：* *..*.*(..) 实际开发中切入点表达式的通常写法: 切到业务层实现类下的所有方法：top.carpenter.service.impl.*.*(..) 关键字withIn以类作为控制粒度 关键字args以参数作为控制粒度 关键字@annotation以注解作为控制粒度 关键字@withIn(X)以类是否加了X注解作为控制粒度 关键字@args(X)以参数是否加了X注解作为控制粒度 关键字this(X)是否是X的代理对象 关键字target(X)是否是X的目标对象 上述所有的表达式在通知中可以混合使用|| &amp;&amp; bean.xml约束 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; 7.2.基于Spring框架中AOP的问题解决7.2.1.基于前置 后置 异常以及最终通知的问题解决 Bean.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748...约束头...&lt;context:component-scan base-package=\"top.carpenter\"/&gt;&lt;!-- 配置AOP--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"servicePointcut\" expression=\"execution(* top.carpenter.service.impl.AccountServiceImpl.*(..))\"/&gt; &lt;aop:aspect id=\"txManagerAdvice\" ref=\"transactionManager\" &gt;&lt;!-- 配置前置通知--&gt; &lt;aop:before method=\"beginTransaction\" pointcut-ref=\"servicePointcut\"/&gt;&lt;!-- 配置后置通知--&gt; &lt;aop:after-returning method=\"commit\" pointcut-ref=\"servicePointcut\"/&gt;&lt;!-- 配置异常通知--&gt; &lt;aop:after-throwing method=\"rollback\" pointcut-ref=\"servicePointcut\"/&gt;&lt;!-- 配置最终通知--&gt; &lt;aop:after method=\"release\" pointcut-ref=\"servicePointcut\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;bean id=\"account\" class=\"top.carpenter.pojo.Account\"/&gt; &lt;bean id=\"accountService\" class=\"top.carpenter.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"/&gt; &lt;/bean&gt; &lt;bean id=\"accountDao\" class=\"top.carpenter.dao.impl.AccountDaoImpl\"&gt; &lt;property name=\"connectionUtils\" ref=\"connectionUtils\"/&gt; &lt;property name=\"runner\" ref=\"runner\"/&gt; &lt;/bean&gt; &lt;bean id=\"transactionManager\" class=\"top.carpenter.utils.TransactionManager\"&gt; &lt;property name=\"connectionUtils\" ref=\"connectionUtils\"/&gt; &lt;/bean&gt; &lt;bean id=\"connectionUtils\" class=\"top.carpenter.utils.ConnectionUtils\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;bean id=\"runner\" class=\"org.apache.commons.dbutils.QueryRunner\" scope=\"prototype\"&gt; &lt;/bean&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/spring_study\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"\"/&gt; &lt;/bean&gt;&lt;/beans&gt; AccountServiceImpl——同6.3无需更改 7.2.2.基于环绕通知的问题解决 Spring框架为我们提供了一个接口：ProceedingJoinPoint 该接口有一个方法proceed()，此方法就相当于明确调用切入点方法 该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。 环绕通知：spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。 bean.xml 1234567# 修改7.3.1中配置&lt;aop:config&gt; &lt;aop:pointcut id=\"servicePointcut\" expression=\"execution(* top.carpenter.service.impl.AccountServiceImpl.*(..))\"/&gt; &lt;aop:aspect id=\"txManagerAdvice\" ref=\"transactionManager\" &gt; &lt;aop:around method=\"aroundTransaction\" pointcut-ref=\"servicePointcut\"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; TransactionManager——新增aroundTransaction() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package top.carpenter.utils;import org.aspectj.lang.ProceedingJoinPoint;import java.sql.SQLException;public class TransactionManager &#123; private ConnectionUtils connectionUtils; public void setConnectionUtils(ConnectionUtils connectionUtils) &#123; this.connectionUtils = connectionUtils; &#125; public void beginTransaction() throws SQLException &#123; System.out.println(\"beginTransaction\"); connectionUtils.getThreadConnection().setAutoCommit(false); &#125; public void commit() throws SQLException &#123; System.out.println(\"commit\"); connectionUtils.getThreadConnection().commit(); &#125; public void rollback() throws SQLException &#123; System.out.println(\"rollback\"); connectionUtils.getThreadConnection().rollback(); &#125; public void release() throws SQLException &#123; System.out.println(\"release\"); connectionUtils.getThreadConnection().close(); connectionUtils.removeThreadConnection(); &#125; public Object aroundTransaction(ProceedingJoinPoint pjp) throws SQLException &#123; Object[] args = pjp.getArgs(); Object rtValue = null; try&#123; beginTransaction(); rtValue = pjp.proceed(args); commit(); &#125; catch (SQLException e) &#123; rollback(); e.printStackTrace(); &#125; catch (Throwable throwable) &#123; release(); throwable.printStackTrace(); &#125; return rtValue; &#125;&#125; 7.3.Spring中基于注解的AOP bean.xml 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; @Aspect ——表示当前类是个切面类 @Before——前置通知方法 @AfterReturning()——后置通知方法 @AfterThrowing()——异常通知方法 @After()——最终通知方法 @Around()——环绕通知方法 @Pointcut——切入点表达式 7.3.基于Spring框架中AOP的问题解决7.3.1.基于前置 后置 异常以及最终通知的问题解决[不建议使用 Spring框架存在一定bug] bean.xml 1234&lt;!-- @EnableAspectJAutoProxy配置Spring开启注解AOP支持--&gt;&lt;aop:aspectj-autoproxy/&gt; TransactionManager切面类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package top.carpenter.utils;import org.aspectj.lang.annotation.*;import java.sql.SQLException;@Component //将切面类放入Spring容器管理@Aspect //表明切面类public class TransactionManager &#123; private ConnectionUtils connectionUtils; // 声明一个切点 包含了众多连接点/方法 @Pointcut(\"execution(* top.carpenter.service.impl.AccountServiceImpl.*(..))\") private void pt1()&#123;&#125; public void setConnectionUtils(ConnectionUtils connectionUtils) &#123; this.connectionUtils = connectionUtils; &#125; //通知：位置+逻辑 @Before(\"pt1()\") public void beginTransaction() throws SQLException &#123; System.out.println(\"beginTransaction\"); connectionUtils.getThreadConnection().setAutoCommit(false); &#125; @AfterReturning(\"pt1()\") public void commit() throws SQLException &#123; System.out.println(\"commit\"); connectionUtils.getThreadConnection().commit(); &#125; @AfterThrowing(\"pt1()\") public void rollback() throws SQLException &#123; System.out.println(\"rollback\"); connectionUtils.getThreadConnection().rollback(); &#125; @After(\"pt1()\") public void release() throws SQLException &#123; System.out.println(\"release\"); connectionUtils.getThreadConnection().close(); connectionUtils.removeThreadConnection(); &#125;&#125; JoinPoint可以作为方法参数 12345678@Before(\"pt1()\")public void before(JoinPoint joinPoint) &#123; Object[] args = joinPoint.getArgs(); Object target = joinPoint.getTarget(); //top.carpenter.UserService1@79da1ec0 Object aThis = joinPoint.getThis(); //UserService1$$EnhancerBySpringCGLlB$$8fa9ac4d@2552 Object signature = joinPoint.getSignature(); //void top.carpenter.UserService1.print() System.out.println(\"beginTransaction\");&#125; 7.3.2.基于环绕通知的问题解决 bean.xml 1234&lt;!-- @EnableAspectJAutoProxy配置Spring开启注解AOP支持--&gt;&lt;aop:aspectj-autoproxy/&gt; TransactionManager 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package top.carpenter.utils;import org.aspectj.lang.annotation.*;import java.sql.SQLException;@Component@Aspectpublic class TransactionManager &#123; private ConnectionUtils connectionUtils; @Pointcut(\"execution(* top.carpenter.service.impl.AccountServiceImpl.*(..))\") private void pt1()&#123;&#125; public void setConnectionUtils(ConnectionUtils connectionUtils) &#123; this.connectionUtils = connectionUtils; &#125; public void beginTransaction() throws SQLException &#123; System.out.println(\"beginTransaction\"); connectionUtils.getThreadConnection().setAutoCommit(false); &#125; public void commit() throws SQLException &#123; System.out.println(\"commit\"); connectionUtils.getThreadConnection().commit(); &#125; public void rollback() throws SQLException &#123; System.out.println(\"rollback\"); connectionUtils.getThreadConnection().rollback(); &#125; public void release() throws SQLException &#123; System.out.println(\"release\"); connectionUtils.getThreadConnection().close(); connectionUtils.removeThreadConnection(); &#125; @Around(\"pt1()\") public Object aroundTransaction(ProceedingJoinPoint pjp) throws SQLException &#123; Object[] args = pjp.getArgs(); //⭐ Object rtValue = null; try&#123; beginTransaction(); rtValue = pjp.proceed(args); //⭐ commit(); &#125; catch (SQLException e) &#123; rollback(); e.printStackTrace(); &#125; catch (Throwable throwable) &#123; release(); throwable.printStackTrace(); &#125; return rtValue; &#125;&#125; ProceedIngjoinpoint继承了JoinPoint，proceed()这个是aop代理链执行的方法。 proceed()有重载，有个带参数的方法,可以修改目标方法的的参数 8.Sping事务控制API8.1.明确前提 JavaEE体系进行分层开发，事务处理位于业务层，Spring提供了分层设计业务层的事务处理解决方案。 Spring框架为我们提供了一组事务控制的接口。这组接口是在spring-tx-5.0.2.RELEASE.jar中 Spring的事务控制都是基于AOP的 可以使用编程式事务实现【太麻烦】 可以使用声明式事务实现。重点是使用声明式事务实现 8.2.事务控制API pom.xml 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--配合AOP使用--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt;&lt;/dependency&gt; PlatformTransactionManager 此接口是Spring的事务管理器，提供了常用的操作事务方法 void commit(TransactionStatus status) void rollback(TransactionStatus status) TransactionStatus getTransaction(TransactionDefinition definition) 开发中使用其实现类管理事务的对象 org.springframework.jdbc.datasource.DataSourceTransactionManager使用 SpringJDBC或iBatis进行持久化数据时使用 org.springframework.orm. hibernate5.HibernateTransactionManager使用Hibernate版本进行持久化数据时使用 TransactionDefinition 事务的定义信息对象 String getName()——获取事务对象名称 int getlsolationLevel()——获取事务隔离级【默认同数据库】 int getPropagationBehavior()——获取事务传播行为 int getTimeout()——获取事务超时时间 boolean isReadOnly()——获取事务是否只读 事务的隔离级别 事务隔离级反映事务提交并发访问时的处理态度 ISOLATION_DEFAULT——默认级别，归属下列某一种 ISOLATION _READ_UNCOMMITTED——可以读取未提交数据 ISOLATION READ_COMMITTED——只能读取已提交数据，解决脏读问题(Oracle默认级别) ISOLATION_REPEATABLE_READ——是否读取其他事务提交修改后的数据，解决不可重复读问题(MySQL默认级别) ISOLATION_SERIALIZABLE——是否读取其他事务提交添加后的数据，解决幻影读问题 事务的传播行为 REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择【默认值】 SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行(没有事务) 超时时间 默认值是-1，没有超时限制 如果有，以秒为单位进行设置 是否是只读事务 建议查询设置为只读 TransactionStatus 此接口提供的事务具体的运行状态包含有6个具体的操作 void flush()——刷新事务 boolean hasSavepoint()——获取是否是否存在存储点 boolean isCompleted()——获取事务是否完成 boolean isNewTransaction()——获取事务是否为新的事务 boolean isRollbackOnly()——获取事务是否回滚 void setRollbackOnly()——设置事务回滚 ​ 8.3.基于XML的实现 需要导入事务的的约束 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; 配置事务管理器 使用&lt;tx:advice&gt;标签配置事务的通知，以及配置的事务属性 在&lt;tx:advice&gt;标签内部 属性 id：事务通知唯一标识 transaction-manager：给事务通知提供一个事务管理器引用 配置AOP中的通用切入点表达式，并建立事务通知和切入点表达式的对应关系 8.4.基于注解的实现 需要导入事务的的约束 配置事务管理器 开启Spring对注解事物的支持 12&lt;!-- @EnableTransactionManagement 等价于 --&gt;&lt;tx:annotation-driven transacannotation-drivention-manager=\"transactionManager\"/&gt; 在需要事务支持的地方使用@Transactional注解 8.5.事务的传播特性[1]死活不要事务的 PROPAGATION_NEVER：没有就非事务执行，有就抛出异常 PROPAGATION_NOT_SUPPORTED：没有就非事务执行，有就直接挂起，然后非事务执行 [2]可有可无的 PROPAGATION_SUPPORTS: 有就用，没有就算了 [3]必须有事务的 PROPAGATION_REQUIRES_NEW：有没有都新建事务，如果原来有，就将原来的挂起。 PROPAGATION_NESTED: 如果没有，就新建一个事务；如果有，就在当前事务中嵌套其他事务。 PROPAGATION_REQUIRED: 如果没有，就新建一个事务；如果有，就加入当前事务 PROPAGATION_MANDATORY: 如果没有，就抛出异常；如果有，就使用当前事务。 9.面试 Spring 动态代理是如何实现的 为什么要使用 spring？ 解释一下什么是 aop？ 解释一下什么是 ioc？ spring 有哪些主要模块？ spring 常用的注入方式有哪些？ spring 中的 bean 是线程安全的吗？ spring 支持几种 bean 的作用域？ spring 自动装配 bean 有哪些方式？ spring 事务实现方式有哪些？ spring 的事务隔离？","tags":[{"name":"Spring","slug":"Spring","permalink":"http://goldcarpenter.github.io/tags/Spring/"}]},{"title":"Spring FrameWork","date":"2019-09-12T14:43:11.000Z","path":"2019/09/12/Spring_IOC/","text":"1.Spring FrameWork Spring是一个开源框架，Spring是于2003年兴起的一个轻量级的Java开发框架，它是为了解决企业应用开发的复杂性而创建的。 Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。 简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。 1.1.Sping 优点 方便解耦，简化开发 Spring就是一个大工厂，专门负责生成Bean，可以将所有对象创建和依赖关系维护由Spring管理 提供面向切面编程 方便的实现对程序进行权限拦截、运行监控等功能 声明式事务的支持 只需要通过配置就可以完成对事务的管理，而无需手动编程 方便程序的测试 Spring对Junit4支持，可以通过注解方便的测试Spring程序 方便集成各种优秀框架 内部提供了对各种优秀框架（如：Struts Hibernate MyBatis Quartz等）的支持 降低JavaEE API的使用难度 对JavaEE开发中一些难用的API（JDBC、JavaMail、远程调webservice用等）都提供了封装，使这些API应用难度大大降低 1.2.体系结构 Core Container——其他所有内容都需要核心容器（IOC）支持 Core technologies: dependency injection, events, resources, i18n, validation, data binding, type conversion, SpEL, AOP. Testing: mock objects, TestContext framework, Spring MVC Test, WebTestClient. Data Access: transactions, DAO support, JDBC, ORM, Marshalling XML. Spring MVC and Spring WebFlux web frameworks. Integration: remoting, JMS, JCA, JMX, email, tasks, scheduling, cache. Languages: Kotlin, Groovy, dynamic languages. 1.3Spring编程的风格 可以配合使用 schemal-based------xml annotation-based----- annotation java-based----java Configuration 2.Spring IOC原理入门2.1.问题：程序间耦合 耦合——程序间的依赖关系 类（jar包）之间的依赖 方法之间的依赖 实际开发中——目标：编译期不依赖，运行时依赖（方便动态代理，让Spring返回我们需要的对象【是否添加AOP/事务控制内容】） 解耦思路 步骤一：使用反射创建对象，而避免使用new关键字–&gt;导致字符串写‘死’ 步骤二：通过读取配置文件来获取要创建的对象全限定类名 以JDBC为例 以视图层-业务层-表现层为例 以下两张图耦合性非常强 2.2.解决方案 创建Bean对象工厂 Bean：可重用组件 第一步：一个配置文件中唯一标识id=全限定类名(key=value)（配置service和dao对象信息） 配置文件种类：xml/properties 第二步：通过读取配文件中配的内容，反射创建对象 bean.properties 1accountService=top.carpenter.service.impl.AccountServiceImpl IAccountService.java &amp; AccountServiceImpl.java 12345678910111213141516package top.carpenter.service;public interface IAccountService &#123; public void save();&#125;package top.carpenter.service.impl;import top.carpenter.service.IAccountService;public class AccountServiceImpl implements IAccountService &#123; public void save() &#123; System.out.println(\"save ok\"); &#125;&#125; BeanFactory.java多例版本 123456789101112131415161718192021222324252627282930313233343536package top.carpenter.factory;import java.io.InputStream;import java.util.Properties;public class BeanFactory &#123; // 定义个Properties对象 private static Properties props; // 使用静态代码块为Properties对象赋值 static &#123; try &#123; // 实例化对象 props = new Properties(); // 获取properties文件的流对象，获取编译后classes下资源文件 InputStream in = BeanFactory.class.getPropertiesClassLoader().getResourceAsStream(\"bean.properties\"); props.load(in); &#125; catch (Exception e) &#123; throw new ExceptionInInitializerError(\"系统初始化失败\"); &#125; &#125; /** * 根据Bean名称获取Bean对象 * @param beanName * @return * @throws ClassNotFoundException */ public static Object getBean(String beanName) throws Exception&#123; Object bean; String beanPath = props.getProperty(beanName); bean = Class.forName(beanPath).newInstance(); return bean; &#125;&#125; BeanFactory.java单例版本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package top.carpenter.factory;import java.io.InputStream;import java.util.Enumeration;import java.util.HashMap;import java.util.Map;import java.util.Properties;public class BeanFactory &#123; // 定义一个Properties对象 private static Properties props; // 定义一个Map 用于存放我们要创建的对象 即容器 private static Map&lt;String,Object&gt; beans; // 使用静态代码块为Properties对象赋值 static &#123; try &#123; // 实例化对象 props = new Properties(); // 获取properties文件的流对象，获取编译后classes下资源文件 InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(\"bean.properties\"); props.load(in); // 实例化容器 beans = new HashMap&lt;String, Object&gt;(); // 取出配置文件中所有key Enumeration keys = props.keys(); // 遍历枚举 while (keys.hasMoreElements()) &#123; // 取出每一个key String key = keys.nextElement().toString(); // 根据key值获取value String beanPath = props.getProperty(key); // 反射创建对象 Object value = Class.forName(beanPath).newInstance(); // 把key值放入容器 beans.put(key,value); &#125; &#125; catch (Exception e) &#123; throw new ExceptionInInitializerError(\"系统初始化失败\"); &#125; &#125; /** * 根据Bean名称获取Bean对象 * @param beanName * @return * @throws Exception */ public static Object getBean(String beanName) throws Exception&#123; return beans.get(beanName); &#125;&#125; Client.java 1234567891011package top.carpenter.ui;import top.carpenter.factory.BeanFactory;import top.carpenter.service.IAccountService;public class Client &#123; public static void main(String[] args) throws Exception &#123; IAccountService accountService =(IAccountService)BeanFactory.getBean(\"accountService\"); accountService.save(); &#125;&#125; 3.控制反转(IOC) 控制反转：把创建对象的权利交给框架，由框架控制对象的生命周期，是框架的重要特征 IOC作用：削减计算机程序的耦合，降低程序间的依赖关系 3.1.Spring IOC容器构建 pom.xml 123456&lt;!--这个依赖可以解决Spring IOC 90%功能--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 核心容器本质是个Map applicationContext.xml 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置文件中`唯一标识==全限定类名(key=value)`--&gt; &lt;bean id=\"accountService\" class=\"top.carpenter.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; Client.java 12345678910111213141516package top.carpenter.ui;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import top.carpenter.service.IAccountService;public class Client &#123; public static void main(String[] args) throws Exception &#123; // 创建Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");//显现类选择见下图 // 从容器中提取Bean IAccountService accountService = (IAccountService) ac.getBean(\"accountService\"); // 或：IAccountService accountService1 = ac.getBean(\"accountService\", IAccountService.class); accountService.save(); &#125;&#125; Spring工厂类结构图 BeanFactory是核心容器的顶层接口 三个常用实现类 ClassPathXmlApplicationContext——可以加载类路径下的配置文件，要求配置文件必须在类路径下，否则加载不了。 FileSystemXmlApplicationContext——可以加载磁盘任意路径下的配置文件(必须有访问权限) AnnotationConfigApplicationContext——用于读取注解创建容器的 两个常用接口 BeanFactory——构建核心容器时，创建对象采取的策略是采用延迟加载的方式。即根据id获取对象时才创建对象 ApplicationContext——构建核心容器时，创建对象采取的策略是采用立即加载的方式。即只要读取完配置文件马上就创建配置文件中配置的对象 3.2.Bean的三种创建方式3.2.1.使用默认构造函数创建，并存入spring容器 在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签 构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建 applicationContext.xml 1&lt;bean id=\"accountService\" class=\"top.carpenter.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt; 3.2.2.使用普通工厂中的方法创建对象/使用某个类中的方法创建对象，并存入spring容器 InstanceFactory.java 123456789101112// 模拟存在于jar包中的 我们无法修改package top.carpenter;import top.carpenter.service.IAccountService;import top.carpenter.service.impl.AccountServiceImpl;public class InstanceFactory &#123; public IAccountService getIAccountService() &#123; return new AccountServiceImpl(); &#125;&#125; applicationContext.xml 123&lt;bean id=\"instanceFactory\" class=\"top.carpenter.InstanceFactory\"&gt;&lt;/bean&gt;&lt;bean id=\"accountService\" factory-bean=\"instanceFactory\" factory-method=\"getIAccountService\"&gt;&lt;/bean&gt; 3.2.3.使用工厂中的静态方法创建对象/使用某个类中的静态方法创建对象，并存入spring容器 InstanceFactory.java 123456789101112// 模拟存在于jar包中的 我们无法修改 package top.carpenter; import top.carpenter.service.IAccountService; import top.carpenter.service.impl.AccountServiceImpl; public class InstanceStaticFactory &#123; public static IAccountService getIAccountService() &#123; return new AccountServiceImpl(); &#125; &#125; applicationContext.xml 1&lt;bean id=\"accountService\" class=\"top.carpenter.InstanceStaticFactory\" factory-method=\"getIAccountService\"&gt;&lt;/bean&gt; 3.3.Bean对象的作用范围 用于指定bean的作用范围 singleton——单例（默认） prototype——多例 request——作用于web应用的请求范围 session——作用于web应用的会话范围 global-session——作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session 在Singleton当中引用了一个Prototype的bean的时候，会使得Prototype失效 容器只创建单例Singleton一次，只有一次机会设置属性值 解决问题 1234567891011121314//单例的@Componentpublic class UserService1 implements ApplicationContextAware&#123; private ApplicationContext applicationContext; @Autowired private UserDao userDao; //原型的 @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125;&#125; 3.4.Bean对象的生命周期 单例对象 创建：当容器创建时，对象创建 存活：容器存在，对象一直存在 销毁：与容器同时销毁 多例对象 创建：当使用对象时，容器创建对象 存活：对象只要使用过程中就一直活着 销毁：长时间不用，且没有其他对象引用时，由JVM自动回收 4.依赖注入(Dependency Injection) IoC的作用：降低程序间的耦合(依赖关系) 依赖关系的管理： 在当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中说明 以后都交给spring来维护依赖关系，就称之为依赖注入 依赖注入的数据 基本类型和String 其他bean类型(在配置文件中或者注解配置过的bean) 复杂类型/集合类型 4.1.依赖注入的方式4.1.1.使用构造函数提供 AccountServiceImpl.java 1234567891011121314151617181920212223package top.carpenter.service.impl;import top.carpenter.service.IAccountService;import java.util.Date;public class AccountServiceImpl implements IAccountService &#123; private String name; private int age; private Date birthday; public AccountServiceImpl(String name, int age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday; &#125; public void save() &#123; System.out.println(this.name); System.out.println(this.age); System.out.println(this.birthday); &#125;&#125; bean.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置文件中`唯一标识==全限定类名(key=value)`--&gt; &lt;bean id=\"accountService\" class=\"top.carpenter.service.impl.AccountServiceImpl\"&gt; &lt;constructor-arg name=\"name\" value=\"yyx\"/&gt; &lt;constructor-arg name=\"age\" value=\"18\"/&gt; &lt;constructor-arg name=\"birthday\" ref=\"date\"/&gt; &lt;/bean&gt; &lt;bean id=\"date\" class=\"java.util.Date\"/&gt;&lt;/beans&gt; 使用的标签：constructor-arg 标签出现的位置：bean标签的内部 标签中的属性 type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型（容易混） index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始 name：用于指定给构造函数中指定名称的参数赋值【常用】=================以上三个用于指定给构造函数中哪个参数赋值============ value：用于提供基本数据类型和String类型的数据 ref：用于指定其他的bean类型数据。它指的就是在spring的IoC核心容器中出现过的bean对象 优势 在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功 劣势 bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供 4.1.2.使用set方法提供 AccountServiceImpl.java 12345678910111213141516171819202122232425262728293031package top.carpenter.service.impl;import top.carpenter.service.IAccountService;import java.util.Date;public class AccountServiceImpl implements IAccountService &#123; private String name; private int age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public void save() &#123; System.out.println(this.name); System.out.println(this.age); System.out.println(this.birthday); &#125;&#125; bean.xml 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置文件中`唯一标识==全限定类名(key=value)`--&gt; &lt;bean id=\"accountService\" class=\"top.carpenter.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"name\" value=\"yyx\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"18\"&gt;&lt;/property&gt; &lt;property name=\"birthday\" ref=\"date\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"date\" class=\"java.util.Date\"/&gt;&lt;/beans&gt; 使用的标签：property 标签出现的位置：bean标签的内部 标签的属性 name:用于指定注入时所调用的set方法名称 value: 用于提供基本类型和String类型的数据 ref:用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象 优势: 创建对象时没有明确的限制，可以直接使用默认构造函数 弊端: 如果有某个成员必须有值，则获取对象是有可能set方法没有执行 补充：复杂类型/集合类型注入（set方法 &amp; 构造函数） AccountServiceImpl.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package top.carpenter.service.impl;import top.carpenter.service.IAccountService;import java.util.*;public class AccountServiceImpl implements IAccountService &#123; private String[] myStrs; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String ,String&gt; myMap; private Properties myProps; public AccountServiceImpl(String[] myStrs, List&lt;String&gt; myList, Set&lt;String&gt; mySet, Map&lt;String, String&gt; myMap, Properties myProps) &#123; this.myStrs = myStrs; this.myList = myList; this.mySet = mySet; this.myMap = myMap; this.myProps = myProps; &#125; public void setMyStrs(String[] myStrs) &#123; this.myStrs = myStrs; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, String&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125; public void save() &#123; System.out.println(myList); System.out.println(myMap); System.out.println(myProps); System.out.println(mySet); System.out.println(Arrays.toString(myStrs)); &#125;&#125; bean.xml（set方法） 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置文件中`唯一标识==全限定类名(key=value)`--&gt; &lt;bean id=\"accountService\" class=\"top.carpenter.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"myList\"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"myStrs\"&gt; &lt;array&gt; &lt;value&gt;A&lt;/value&gt; &lt;value&gt;B&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"mySet\"&gt; &lt;set&gt; &lt;value&gt;AA&lt;/value&gt; &lt;value&gt;BB&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"myMap\"&gt; &lt;map&gt; &lt;entry key=\"AAAA\" value=\"BBBB\"&gt;&lt;/entry&gt; &lt;entry key=\"CCCC\" value=\"DDDD\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"myProps\"&gt; &lt;props&gt; &lt;prop key=\"2\"&gt;ccc&lt;/prop&gt; &lt;!-- 没有value属性了 --&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; bean.xml（构造函数） 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置文件中`唯一标识==全限定类名(key=value)`--&gt; &lt;bean id=\"accountService\" class=\"top.carpenter.service.impl.AccountServiceImpl\"&gt; &lt;constructor-arg name=\"myList\"&gt; &lt;list&gt; &lt;value&gt;a&lt;/value&gt; &lt;value&gt;b&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name=\"myStrs\"&gt; &lt;array&gt; &lt;value&gt;a&lt;/value&gt; &lt;value&gt;b&lt;/value&gt; &lt;/array&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name=\"myMap\"&gt; &lt;map&gt; &lt;entry key=\"a\" value=\"b\"/&gt; &lt;entry key=\"a\" value=\"b\"/&gt; &lt;/map&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name=\"myProps\"&gt; &lt;props&gt; &lt;prop key=\"a\"&gt;b&lt;/prop&gt; &lt;prop key=\"a\"&gt;b&lt;/prop&gt; &lt;/props&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name=\"mySet\"&gt; &lt;set&gt; &lt;value&gt;a&lt;/value&gt; &lt;value&gt;b&lt;/value&gt; &lt;/set&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 使用标签：List结构集合 list array set 使用标签：Map结构集合 map&amp;entry props&amp;prop set方法标签出现的位置：property标签的内部 构造函数标签出现的位置：bean标签的内部 4.1.3.使用注解提供1. 注解知识引入 曾经的XML配置 123&lt;bean id=\"accountService\" class=\"top.carpenter.service.impl.AccountServiceImpl\" scope=\"...\" init-method=\"...\" destroy-method=\"..\" depends-on=\"..\" lazy- init=\"true\"&gt;&lt;/bean&gt; 创建对象的注解 作用：同在XML配置文件中编写一个&lt;bean&gt;标签 @Component 把当前类存入Spring容器 属性 value：用于指定bean的id，当不写时，它的默认是当前类名，且首字母改小写 @Controller——spring框架明确提供的三层中表现层使用的 @Service——spring框架明确提供的三层中业务层使用的 @Repository——spring框架明确提供的三层中持久层使用的 注入数据的注解 作用：同在XML配置文件中的bean标签中写一个&lt;property&gt;标签 @Autowired——自动按照类型注入 出现位置： 变量 方法(比如配合@Bean使用 需要添加属性) 只要容器中有唯一一个bean对象类型和要注入的变量类型匹配，就可以注入成功 如果ioc容器中没有任何bean的类型和要注入的变至类型匹配，则报错 如果Ioc容器中有多个类型匹配时 如果在多个类型匹配中存在id与变量名称相同，就可以注入成功 如果在多个类型匹配中不存在id与变量名称相同，则报错 id与变量名称必须相同，存在不方便，引出@Qualifier ![1577891921173](1577891921173.png) * 细节： * **在使用注解注入时，set方法就不是必须的** ![1577891716576](1577891716576.png) @Qualifier 按照数据类型注入的基础之上再按照名称注入 它在给类成员注入时配合@Autowired使用，不能单独使用。 在给方法参数往入时可以单独使用 属性 value：用于指定注入bean的id 123@Autowired@Qualifier(\"accountServiceImpl1\")private IAccountService accountServiceImpl2; // 以注解的名称为准 @Resource 作用：直接按照bean的id注入，独立使用 属性： name：用于指定bean的id ===============以上三个注入都只能注入其他bean类型的数据========================== ===============基本类型和String类型无法使用上述注解实现，使用@Value=============== @Value 作用：用于注入基本类型和String类型的数据 属性 value：用于指定数据的值。它可以使用spring中SpEL（spring的el表达式） SpEL的写法: ${表达式} ===============集合类型的注入只能通过XML来实现============================== 改变作用范围的注解 作用：同在XML配置文件中的bean标签中使用scope @Scope： value属性： 单例：singleton 多例：prototype 生命周期相关的注解 作用：同在XML配置文件中的标签中使用init-method和destroy-method @PreDestroy：指定生命周期结束销毁的回调方法 @PostConstruct：指定生命周期初始化的回调方法（在构造方法之后执行） 【官网不推荐】还可以使得类实现接口InitializingBean，DisposableBean Destroy methods are called in the same order Methods annotated with @PreDestroy destroy() as defined by the DisposableBean callback interface A custom configured destroy() method 2.为什么要添加注解扫描 程序在创建容器的解析配置文件过程中，只读了bean.xml，并不知道你在哪里使用了注解 1ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); 故需告知Spring在创建容器时，要扫描的包 配置所需要的标签不是在beans的约束中，而是在一个名称为context名称空间和约束中 1&lt;context:component-scan base-package=\"top.carpenter\"/&gt; 即开启Spring注解支持，又开启注解扫描 12&lt;!-- 已经二合一了 下边这个不用了--&gt;&lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; 3. 使用注解提供 AccountServiceImpl.java 1234567891011121314151617181920212223242526package top.carpenter.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;import top.carpenter.service.IAccountService;import java.util.Date;@Servicepublic class AccountServiceImpl implements IAccountService &#123; @Value(\"yyx\") private String name; @Value(\"18\") private int age; @Autowired private Date birthday; public void save() &#123; System.out.println(this.name); System.out.println(this.age); System.out.println(this.birthday); &#125;&#125; bean.xml 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;context:component-scan base-package=\"top.carpenter\"/&gt; &lt;bean id=\"date\" class=\"java.util.Date\"/&gt; &lt;!--jar包中的类需要在`bean.xml`配置--&gt;&lt;/beans&gt; 4.优化 去除配置文件 之前所使用的注解只能使用在自己写的类上，jar包中的类需要在bean.xml配置，导致无法彻底删除bean.xml 使用top.carpenter.config.SpringConfiguration.java代替bean.xml @Configuration——指定当前类是个配置类 123456789101112131415161718192021package top.carpenter.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import java.util.Date;// 使用注解new AnnotationConfigApplicationContext 但是XML内容还可以用@ImportResource(\"Classpath:spring.xml\")@Configuration@ComponentScan(value = &#123;\"top.carpenter\"&#125;)public class SpringConfiguration &#123; @Bean public Date createDate() &#123; return new Date(); &#125;&#125; @ComponentScan——指定Spring在创建容器时要扫描的包 12&lt;!-- @ComponentScan(value = &#123;\"top.carpenter\"&#125;) 等价于 --&gt;&lt;context:component-scan base-package=\"top.carpenter\"/&gt; @EnableAspectJAutoProxy——使用注解开启AOP支持 12&lt;!-- @EnableAspectJAutoProxy 等价于 --&gt;&lt;aop:aspectj-autoproxy/&gt; @EnableTransactionManagement——开启对事务的支持 12&lt;!-- @EnableTransactionManagement 等价于 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; @Bean——用于把当前方法的返回值作为bean对象存入Spring的IOC容器中 属性 name：用于指定bean的id。当不写时，默认值是当前方法的名称 12345678 &lt;!-- @Bean public Date createDate()&#123; return new Date(); &#125; 等价于 --&gt; &lt;bean id=\"date\" class=\"java.util.Date\"/&gt; @Import——当存在多个配置类时，用于导入其他的配置类 属性: value：用于指定其他配置类的字节码 当我们使用@Import的注解之后，有@Import注解的类就父配置类，而导入的都是子配置类 SpringConfiguration.java 123456789101112package top.carpenter.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;@Configuration@ComponentScan(value = &#123;\"top.carpenter\"&#125;)@Import(DateConfiguration.class)public class SpringConfiguration &#123;&#125; DateConfiguration.java 123456789101112131415161718192021package top.carpenter.config; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.PropertySource; import java.util.Date; @PropertySource(\"classpath:dateConfig.properties\") public class DateConfiguration &#123; // 使用EL表达式注入 @Value(\"$&#123;date&#125;\") private int date; @Bean public Date createDate() &#123; return new Date(date); &#125; &#125; @PropertySource 作用：用于指定properties文件的位置 属性： * `value`：指定文件的名称和路径。关键词：classpath 表示类路径下 dateConfig.properties 1date=10000 Client.java 123ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");//等价于 ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class); 5.Spring整合JUnit junit单元测试内部继承了main方法，该方法就会判断当前测试类中哪些方法有@Test注解，然后让方法执行 junit在执行测试方法时，junit根本不知道是否使用了spring框架，所以也就不会读取配置文件/配置类创建spring核心容器，报空指针异常 12345678910111213public class ClientTest &#123; @Autowired private IAccountService accountService; @Test public void testClient() &#123; accountService.save(); &#125;&#125;// 报空指针异常 Spring整合JUnit 导入Spring整合JUnit的jar包 12345678910&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 使用JUnit提供的@RunWith(SpringJUnit4ClassRunner.class)注解把原有的main方法替换 换成spring提供的 123@RunWith(SpringJUnit4ClassRunner.class)public class ClientTest &#123;... @ContextConfiguration告知Spring运行器，Spring和Ioc创建是基于XML还是注解的 locations：指定xml文件的位置，加上classpath关键字，表示在类路径下 classes：指定注解类所在位置 12345@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfiguration.class)//@ContextConfiguration(locations = \"classpath:bean.xml\")public class ClientTest &#123;... 注意：Spring5.0.+要求JUnit4.12+","tags":[{"name":"Spring","slug":"Spring","permalink":"http://goldcarpenter.github.io/tags/Spring/"}]},{"title":"多线程编程","date":"2019-08-30T16:00:00.000Z","path":"2019/08/31/多线程_Part10/","text":"8 共享模型之并发工具8.2 J.U.C8.2.1AQS原理概述 抽象父类，全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的父类 123public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123; 特点： 用private volatile int state;属性来表示资源的状态（独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁 getState - 获取 state 状态 setState - 设置 state 状态 compareAndSetState - cas 机制设置 state 状态 独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源 提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet 子类主要实现这样一些方法（默认抛出UnsupportedOperationException） tryAcquire——尝试获取锁 tryRelease ——尝试释放锁 tryAcquireShared tryReleaseShared isHeldExclusively——是否持有独占锁 获取锁的姿势 1234// 如果获取锁失败 if (!tryAcquire(arg)) &#123; // 入队, 可以选择阻塞当前线程 park unpark&#125; 释放锁的姿势 1234// 如果释放锁成功 if (tryRelease(arg)) &#123; // 让阻塞线程恢复运行&#125; 自定义同步器类实现不可重入锁123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; public static void main(String[] args) &#123; MyLock lock = new MyLock(); new Thread(() -&gt; &#123; lock.lock(); try &#123; log.debug(\"locking...\"); Sleeper.sleep(1); &#125; finally &#123; log.debug(\"unlocking...\"); lock.unlock(); &#125; &#125;,\"t1\").start(); new Thread(() -&gt; &#123; lock.lock(); try &#123; log.debug(\"locking...\"); &#125; finally &#123; log.debug(\"unlocking...\"); lock.unlock(); &#125; &#125;,\"t2\").start(); &#125;&#125;// 自定义锁（不可重入锁）class MyLock implements Lock &#123; // 独占锁 ⭐同步器类 class MySync extends AbstractQueuedSynchronizer &#123; @Override//尝试获取锁 protected boolean tryAcquire(int arg) &#123; if(compareAndSetState(0, 1)) &#123; // 加上了锁，并设置 owner 为当前线程 与Monitor相似 setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; @Override//尝试释放锁 protected boolean tryRelease(int arg) &#123; setExclusiveOwnerThread(null); setState(0); // state 变量是volatile的 具有写屏障 所以放在set..后边 return true; &#125; @Override // 是否持有独占锁 protected boolean isHeldExclusively() &#123; return getState() == 1; &#125; public Condition newCondition() &#123; return new ConditionObject(); &#125; &#125; private MySync sync = new MySync(); @Override // 加锁（不成功会进入等待队列） public void lock() &#123; sync.acquire(1); &#125; @Override // 加锁，可打断 public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; @Override // 尝试加锁（一次） public boolean tryLock() &#123; return sync.tryAcquire(1); &#125; @Override // 尝试加锁，带超时 public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(time)); &#125; @Override // 解锁 public void unlock() &#123; sync.release(1); &#125; @Override // 创建条件变量 public Condition newCondition() &#123; return sync.newCondition(); &#125;&#125; 8.2.2 ReentrantLock 原理 非公平锁实现原理——加锁解锁流程 先从构造器开始看，默认为非公平锁实现 123public ReentrantLock() &#123; sync = new NonfairSync();&#125; 加锁 123public void lock() &#123; sync.lock();&#125; 123456789101112final void lock() &#123; //和自定义的同步器很像 if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); //尝试加锁失败&#125; public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; /*再尝试一次*/ acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // 失败 创建一个节点对象 selfInterrupt(); // 被打断时可以执行到此处&#125; 没有竞争时 有竞争时，Thread-1 执行了 CAS 尝试将 state 由 0 改为 1，结果失败 进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败 接下来进入addWaiter逻辑，构造 Node 队列 图中黄色三角表示该Node的waitStatus状态，其中 0 为默认正常状态 Node 的创建是懒惰的 其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程 当前线程进入 acquireQueued 逻辑 acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞 如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败 进入shouldParkAfterFailedAcquire逻辑，将前驱node，即head的 waitStatus 改为 -1，这次返回 false 123456789101112131415161718192021222324252627final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁 final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())/*阻塞这了 当被unpark后 从这再来*/ interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; * shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败 * 当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true * 进入 parkAndCheckInterrupt， Thread-1 park（灰色表示） ![1582364649949](1582364649949.png) * 再次有多个线程经历上述过程竞争失败，变成这个样子 ![1582365419165](1582365419165.png) * Thread-0 释放锁 1234567891011121314151617181920212223242526272829public void unlock() &#123; sync.release(1);&#125;public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; 12345678910111213141516171819202122232425 * 进入 tryRelease 流程，如果成功 * 设置 exclusiveOwnerThread 为 null * state &#x3D; 0 ![1582365023929](1582365023929.png) * 当前队列不为 null，并且 head 的 waitStatus &#x3D; -1，进入 unparkSuccessor 流程 * 找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1 * 回到 Thread-1 的 acquireQueued 流程 ![1582365235446](1582365235446.png) * **如果加锁成功（没有竞争）**，会设置 * exclusiveOwnerThread 为 Thread-1，state &#x3D; 1 * head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread * 原本的 head 因为从链表断开，而可被垃圾回收* **如果这时候有其它线程来竞争（非公平的体现）**，例如这时有 Thread-4 来了 ![1582365722681](1582365722681.png) * 如果不巧又被 Thread-4 占了先 * Thread-4 被设置为 exclusiveOwnerThread，state &#x3D; 1 * Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞可重入原理 见单独插页 可打断原理 见单独插页 公平锁实现原理 见单独插页 条件变量实现原理 见单独插页 8.2.3 读写锁ReentrantReadWriteLock基本使用 当读操作远远高于写操作时，这时候使用 读写锁 让 读-读 可以并发，提高性能。 类似于数据库中的 select … from … lock in share mode 提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; public static void main(String[] args) &#123; DataContainer dataContainer = new DataContainer(); new Thread(dataContainer::read, \"t1\").start(); new Thread(dataContainer::read, \"t2\").start(); &#125;&#125;@Slf4j(topic = \"c.DataContainer\")class DataContainer &#123; private Object data; private ReentrantReadWriteLock rw = new ReentrantReadWriteLock(); private ReentrantReadWriteLock.ReadLock r = rw.readLock(); private ReentrantReadWriteLock.WriteLock w = rw.writeLock(); public Object read() &#123; log.debug(\"获取读锁...\"); r.lock(); try &#123; log.debug(\"读取\"); Sleeper.sleep(1); return data; &#125; finally &#123; log.debug(\"释放读锁...\"); r.unlock(); &#125; &#125; public void write() &#123; log.debug(\"获取写锁...\"); w.lock(); try &#123; log.debug(\"写入\"); Sleeper.sleep(1); &#125; finally &#123; log.debug(\"释放写锁...\"); w.unlock(); &#125; &#125;&#125;/*22:18:20.094 [t2] c.DataContainer - 获取读锁...22:18:20.094 [t1] c.DataContainer - 获取读锁...22:18:20.098 [t1] c.DataContainer - 读取22:18:20.101 [t2] c.DataContainer - 读取22:18:21.102 [t1] c.DataContainer - 释放读锁...22:18:21.102 [t2] c.DataContainer - 释放读锁...*/ 注意事项 读锁不支持条件变量 重入时升级不支持【即持有读锁的情况下去获取写锁】会导致获取写锁永久等待 123456789101112r.lock(); try &#123; // ... w.lock(); try &#123; // ... &#125; finally&#123; w.unlock(); &#125;&#125; finally&#123; r.unlock();&#125; 重入时降级支持【持有写锁的情况下去获取读锁】 读写锁应用：缓存更新策略 不加锁更新时，是先清缓存还是先更新数据库 先清缓存【问题更严重】 先更新数据库【有点问题】 将1 3 锁定 可以适当解决 数据库读写锁应用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 class GenericDaoCached extends GenericDao &#123; private GenericDao dao = new GenericDao(); private Map&lt;SqlPair, Object&gt; map = new HashMap&lt;&gt;(); private ReentrantReadWriteLock rw = new ReentrantReadWriteLock(); @Override public &lt;T&gt; T queryOne(Class&lt;T&gt; beanClass, String sql, Object... args) &#123; // 先从缓存中找，找到直接返回 SqlPair key = new SqlPair(sql, args); rw.readLock().lock(); try &#123; T value = (T) map.get(key); if(value != null) &#123; return value; &#125; &#125; finally &#123; rw.readLock().unlock(); &#125; rw.writeLock().lock(); try &#123; // 多个查询到为null的线程 双重检查 T value = (T) map.get(key); if(value == null) &#123; // 缓存中没有，查询数据库 value = dao.queryOne(beanClass, sql, args); map.put(key, value); &#125; return value; &#125; finally &#123; rw.writeLock().unlock(); &#125; &#125; @Override public int update(String sql, Object... args) &#123; rw.writeLock().lock(); try &#123; // 先更新库 int update = dao.update(sql, args); // 清空缓存 map.clear(); return update; &#125; finally &#123; rw.writeLock().unlock(); &#125; &#125; class SqlPair &#123; private String sql; private Object[] args; public SqlPair(String sql, Object[] args) &#123; this.sql = sql; this.args = args; &#125; &#125;&#125; 适合读多写少，如果写操作比较频繁，性能较低 没有考虑缓存容量 没有考虑缓存过期 原理 见单独插页 8.2.4 StampedLock基本使用 该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用 加解读锁 12long stamp = lock.readLock(); lock.unlockRead(stamp); 加解写锁 12long stamp = lock.writeLock(); lock.unlockWrite(stamp); 乐观读，StampedLock支持tryOptimisticRead()方法（乐观读），读取完毕后需要做一次戳校验。如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。 1234long stamp = lock.tryOptimisticRead(); // 验戳if(!lock.validate(stamp))&#123; // 锁升级&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public static void main(String[] args) &#123; DataContainer dataContainer = new DataContainer(); new Thread(()-&gt;&#123; int read = dataContainer.read(1); &#125;).start(); sleep(0.5); new Thread(()-&gt; dataContainer.write()).start();&#125;@Slf4j(topic = \"c.DataContainerStamped\")class DataContainerStamped &#123; private int data; private final StampedLock lock = new StampedLock(); public DataContainerStamped(int data) &#123; this.data = data; &#125; public int read(int readTime) &#123; long stamp = lock.tryOptimisticRead(); log.debug(\"optimistic read locking...&#123;&#125;\", stamp); sleep(readTime); if (lock.validate(stamp)) &#123; //戳验证成功 log.debug(\"read finish...&#123;&#125;, data:&#123;&#125;\", stamp, data); return data; &#125; // 验戳失败 锁升级 乐观读 -&gt; 读锁 log.debug(\"updating to read lock... &#123;&#125;\", stamp); try &#123; stamp = lock.readLock(); log.debug(\"read lock &#123;&#125;\", stamp); sleep(readTime); log.debug(\"read finish...&#123;&#125;, data:&#123;&#125;\", stamp, data); return data; &#125; finally &#123; log.debug(\"read unlock &#123;&#125;\", stamp); lock.unlockRead(stamp); &#125; &#125; public void write(int newData) &#123; long stamp = lock.writeLock(); log.debug(\"write lock &#123;&#125;\", stamp); try &#123; sleep(2); this.data = newData; &#125; finally &#123; log.debug(\"write unlock &#123;&#125;\", stamp); lock.unlockWrite(stamp); &#125; &#125;&#125;/*10:00:51.141 [Thread-0] c.DataContainer - optimistic read locking...25610:00:51.640 [Thread-1] c.DataContainer - 获取写锁...10:00:51.640 [Thread-1] c.DataContainer - 写入10:00:52.155 [Thread-0] c.DataContainer - updating to read lock... 25610:00:52.640 [Thread-1] c.DataContainer - 释放写锁...10:00:52.640 [Thread-0] c.DataContainer - read lock 51310:00:53.640 [Thread-0] c.DataContainer - read finish...513, data:010:00:53.640 [Thread-0] c.DataContainer - read unlock 513*/ 注意事项 StampedLock 不支持条件变量 StampedLock 不支持可重入 8.2.5 信号量Semaphore基本使用 信号量，用来限制能同时访问共享资源的线程上限。 12345678910111213141516171819202122232425262728293031323334353637@Slf4j(topic = \"c.TestSemaphore\")public class TestSemaphore &#123; public static void main(String[] args) &#123; // 1. 创建 semaphore 对象 Semaphore semaphore = new Semaphore(3); // 参数：最大访问线程数量 // 2. 10个线程同时运行 for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; try &#123; semaphore.acquire(); // ⭐ &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; log.debug(\"running...\"); sleep(1); log.debug(\"end...\"); &#125; finally &#123; semaphore.release(); &#125; &#125;).start(); &#125; &#125;&#125;/*11:37:42.736 [Thread-0] MyTest - running...11:37:42.736 [Thread-1] MyTest - running...11:37:42.736 [Thread-2] MyTest - running...11:37:43.746 [Thread-1] MyTest - end...11:37:43.746 [Thread-0] MyTest - end...11:37:43.746 [Thread-3] MyTest - running...11:37:43.746 [Thread-2] MyTest - end...11:37:43.746 [Thread-4] MyTest - running...11:37:44.746 [Thread-4] MyTest - end...11:37:44.746 [Thread-3] MyTest - end...*/ 应用 使用Semaphore限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机线程数量，并且仅是限制线程数，而不是限制资源数（例如连接数，请对比Tomcat LimitLatch的实现） 用Semaphore实现简单连接池，对比【享元模式】下的实现(用wait notify) ，性能和可读性显然更好 12345678910111213141516171819202122232425262728293031// 5. 借连接 public Connection borrow() &#123;// t1, t2, t3 // 获取许可 try &#123; semaphore.acquire(); // 没有许可的线程，在此等待 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for (int i = 0; i &lt; poolSize; i++) &#123; // 获取空闲连接 if(states.get(i) == 0) &#123; if (states.compareAndSet(i, 0, 1)) &#123; log.debug(\"borrow &#123;&#125;\", connections[i]); return connections[i]; &#125; &#125; &#125; // 不会执行到这里 return null; &#125; // 6. 归还连接 public void free(Connection conn) &#123; for (int i = 0; i &lt; poolSize; i++) &#123; if (connections[i] == conn) &#123; states.set(i, 0); log.debug(\"free &#123;&#125;\", conn); semaphore.release(); break; &#125; &#125; &#125; 原理 见单独插页 8.2.6倒计时锁CountdownLatch 用来进行线程同步协作，等待所有线程完成倒计时。 其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一 CountDownLatch能够使一个或多个线程等待其他线程完成各自的工作后再执行。 可以理解为一个计数器。在初始化 CountDownLatch 的时候会在类的内部初始化一个int的变量，每当调用 countDownt() 方法的时候这个变量的值减1，而 await() 方法就是去判断这个变量的值是否为0，是则表示所有的操作都已经完成，否则继续等待。 特有方法： 123456789101112//指定计数的次数，只能被设置1次 public CountDownLatch(int count); //调用此方法则计数减1 public void countDown(); //调用此方法会一直阻塞当前线程，直到计时器的值为0，除非线程被中断。 public void await() throws InterruptedException //得到当前的计数 Public Long getCount(); //调用此方法会一直阻塞当前线程，直到计时器的值为0，除非线程被中断或者计数器超时，返回false代表计数器超时。Public boolean await(long timeout, TimeUnit unit) From Object Inherited：Clone、equals、hashCode、notify、notifyALL、wait等 使用场景 开启多个线程分块下载一个大文件，每个线程只下载固定的一截，最后由另外一个线程来拼接所有的分段。 应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。 确保一个计算不会执行，直到所需要的资源被初始化。 实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Main &#123; static public void main(String[] args) throws InterruptedException &#123; CountDownLatch startSignal = new CountDownLatch(1); CountDownLatch doneSignal = new CountDownLatch(10); for (int i = 0; i &lt; 10; ++i) // create and start threads new Thread(new Worker(startSignal, doneSignal)).start(); System.out.println(\"don't let run yet\"); System.out.println(\"主线程喊开始...\"); startSignal.countDown(); // let all threads proceed doneSignal.await(); // wait for all to finish System.out.println(\"都干完就好...\"); &#125;&#125;class Worker implements Runnable &#123; private final CountDownLatch startSignal; private final CountDownLatch doneSignal; Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123; this.startSignal = startSignal; this.doneSignal = doneSignal; &#125; public void run() &#123; try &#123; System.out.println(\"准备...\"); startSignal.await(); System.out.println(\"Working...\"); Thread.sleep(1000); System.out.println(Thread.currentThread().getName()+\"done...\"); doneSignal.countDown(); &#125; catch (InterruptedException ex) &#123;&#125; // return; &#125;/*准备...准备...准备...准备...准备...准备...准备...准备...准备...准备...主线程喊开始...Working...Working...Working...Working...Working...Working...Working...Working...Working...Working...Thread-5done...Thread-2done...Thread-6done...Thread-8done...Thread-3done...Thread-0done...Thread-7done...Thread-4done...Thread-9done...Thread-1done...都干完就好...*/ 8.2.7 循环栅栏CyclicBarrier 循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行 CyclicBarrier 与 CountDownLatch 的主要区别在于 CyclicBarrier 是可以重用的 CyclicBarrier 可以被比喻为『人满发车』 123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) &#123; //注意：线程池与Count数一致 否则由于时间不同 导致出发await的不是预期的线程 ExecutorService service = Executors.newFixedThreadPool(2); CyclicBarrier barrier = new CyclicBarrier(2, ()-&gt; &#123; log.debug(\"task1, task2 finish...\"); &#125;); //第二个参数可以在计数个数到0的时候执行 for (int i = 0; i &lt; 3; i++) &#123; // task1 task2 task1 service.submit(() -&gt; &#123; log.debug(\"task1 begin...\"); Sleeper.sleep(1); try &#123; barrier.await(); // 2-1=1 &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;); service.submit(() -&gt; &#123; log.debug(\"task2 begin...\"); Sleeper.sleep(2); try &#123; barrier.await(); // 1-1=0 &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; service.shutdown(); &#125;/* 09:43:36.933 [pool-1-thread-1] MultiThread - task1 begin...09:43:36.933 [pool-1-thread-2] MultiThread - task2 begin...09:43:38.936 [pool-1-thread-2] MultiThread - task1, task2 finish...09:43:38.936 [pool-1-thread-1] MultiThread - task1 begin...09:43:38.936 [pool-1-thread-2] MultiThread - task2 begin...09:43:40.936 [pool-1-thread-2] MultiThread - task1, task2 finish...*/ 注意事项 线程池线程数和CyclicBarrier的参数数量一样","tags":[{"name":"多线程","slug":"多线程","permalink":"http://goldcarpenter.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"多线程编程","date":"2019-08-24T14:24:02.000Z","path":"2019/08/24/多线程_Part9/","text":"8 共享模型之并发工具8.1 线程池8.1.1 线程池优点 减少了创建线程的时间，提高响应速度 重复利用线程池中的线程，避免多次创建 线程数量过多缺点：①每个线程都要分配内存开销②线程上下文切换系统开销 阻塞队列：平衡生产者和线程池消费者速率不同的消息队列 8.1.2 自定义线程池123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; public static void main(String[] args) &#123; // 线程池中执行单元 , 执行单元超时销毁时间, 执行单元超时销毁单位, 阻塞队列长度, 执行单元不足时 策略 ThreadPool threadPool = new ThreadPool(1, 1000, TimeUnit.MILLISECONDS, 2, new RejectPolicy&lt;Runnable&gt;() &#123; @Override public void reject(BlockingQueue&lt;Runnable&gt; queue, Runnable task) &#123; // 1. 阻塞队列满后 生产者死等队列空出 //queue.put(task); // 2) 阻塞队列满后 生产者带超时等待队列空出 //queue.offer(task, 100, TimeUnit.MILLISECONDS); // 3) 没有设计阻塞队列 执行单元不足时让调用者放弃任务执行 //log.debug(\"放弃&#123;&#125;\", task); // 4) 没有设计阻塞队列 执行单元不足时让让调用者抛出异常 //throw new RuntimeException(\"任务执行失败 \" + task); // 5) 没有设计阻塞队列 让调用者（main)自己执行任务 //task.run(); &#125; &#125;); for (int i = 0; i &lt; 6; i++) &#123; int j = i; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; Sleeper.sleep(6); System.out.println(j); &#125; &#125;); &#125; &#125;&#125;//执行单元不足时 策略接口【设计模式:策略模式】interface RejectPolicy&lt;T&gt;&#123; void reject(BlockingQueue&lt;T&gt; queue, T task);&#125;@Slf4j(topic = \"c.ThreadPool\")class ThreadPool&#123; // 任务队列 private BlockingQueue&lt;Runnable&gt; taskQueue; // 运行单元集合 private HashSet&lt;Worker&gt; workers = new HashSet&lt;&gt;(); // 核心线程数 private int coreSize; // 获取任务时的超时时间 private long timeout; private TimeUnit timeUnit; private RejectPolicy&lt;Runnable&gt; rejectPolicy; //线程池构造方法 public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit,int queueCapcity, RejectPolicy&lt;Runnable&gt; rejectPolicy) &#123; this.coreSize = coreSize; this.timeout = timeout; this.timeUnit = timeUnit; this.taskQueue = new BlockingQueue&lt;&gt;(queueCapcity); this.rejectPolicy = rejectPolicy; &#125; // 执行线程 public void execute(Runnable task) &#123; //works并非线程安全 synchronized (workers) &#123; // 当任务数没有超过 coreSize 时，直接创建线程交给 worker 对象执行 // 如果任务数超过 coreSize 时，加入任务队列暂存 if (workers.size() &lt; coreSize)&#123; Worker worker = new Worker(task); log.debug(\"新增执行单元worker&#123;&#125;\", worker); workers.add(worker); worker.start(); &#125; else rejectPolicy.reject(taskQueue,task); &#125; &#125; // 执行单元 class Worker extends Thread&#123; private Runnable task; public Worker(Runnable task) &#123; this.task = task; &#125; @Override public void run() &#123; //1）当task不为空 执行任务 //2) 当task执行完毕 再接着获取任务队列 //while (task != null ||(task = taskQueue.take()) != null)// 执行单元永不销毁,始终阻塞在任务队列中等待任务 //没有任务 run执行结束 将worker从线程池移除 while (task != null ||(task = taskQueue.poll(timeout,timeUnit)) != null) &#123; try&#123; log.debug(\"执行单元worker执行&#123;&#125;\",task); task.run(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; task = null; &#125; &#125; synchronized (workers) &#123; log.debug(\"执行单元&#123;&#125;从集合中退出\",this); workers.remove(this); &#125; &#125; &#125;&#125;@Slf4j//阻塞队列 基于泛型的生产者消费者模式class BlockingQueue&lt;T&gt;&#123; // 任务的阻塞双向链表 private Deque&lt;T&gt; queue = new ArrayDeque&lt;&gt;(); private ReentrantLock lock = new ReentrantLock(); // 生产者条件变量 private Condition fullWaitSet = lock.newCondition(); // 消费者条件变量 private Condition emptyWaitSet = lock.newCondition(); // 容量 private int capcity; public BlockingQueue(int capcity) &#123; this.capcity = capcity; &#125; // 阻塞获取 public T take()&#123; lock.lock(); try&#123; while (queue.isEmpty()) &#123; try &#123; emptyWaitSet.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; T t = queue.removeFirst(); fullWaitSet.signal(); return t; &#125; finally &#123; lock.unlock(); &#125; &#125; // 阻塞添加 public void put(T task) &#123; lock.lock(); try&#123; while (queue.size() == capcity) &#123; try &#123; fullWaitSet.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; log.debug(\"task&#123;&#125;加入阻塞队列\",task); queue.addLast(task); emptyWaitSet.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125; // 带超时时间阻塞添加 public boolean offer(T task,long timeout, TimeUnit timeUnit) &#123; lock.lock(); try&#123; long nanos = timeUnit.toNanos(timeout); while (queue.size() == capcity) &#123; try &#123; if (nanos &lt;= 0) &#123; log.debug(\"task&#123;&#125;加入阻塞队列超时丢弃\",task); return false; &#125;nanos = fullWaitSet.awaitNanos(nanos); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; log.debug(\"task&#123;&#125;加入阻塞队列\",task); queue.addLast(task); emptyWaitSet.signal(); return true; &#125;finally &#123; lock.unlock(); &#125; &#125; // 带超时阻塞获取 public T poll(long timeout, TimeUnit unit) &#123; lock.lock(); try &#123; // 将 timeout 统一转换为 纳秒 long nanos = unit.toNanos(timeout); while (queue.isEmpty()) &#123; try &#123; // 返回值是剩余时间 if (nanos &lt;= 0) &#123; return null; &#125; nanos = emptyWaitSet.awaitNanos(nanos); // 返回值就是剩余时间 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; T t = queue.removeFirst(); fullWaitSet.signal(); return t; &#125; finally &#123; lock.unlock(); &#125; &#125; public int size() &#123; lock.lock(); try &#123; return queue.size(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 8.1.3 Executor接口1234567public interface Executor &#123; /** * Executor只是接口 内部只有execute方法 * 执行给定的命令 */ void execute(Runnable command);&#125; 自定义Executor接口实现 123456789101112131415161718class Main implements Executor&#123; @Override public void execute(Runnable command) &#123; //new Thread(command).start(); command.run(); &#125; public static void main(String[] args) &#123; new Main().execute(()-&gt;System.out.println(\"自定义Executor\")); &#125;&#125;/*15:03:14.523 [main] MyTest - 自定义Executor*//*15:02:52.026 [Thread-0] MyTest - 自定义Executor15:02:52.026 [main] MyTest - 自定义Executor*/ 8.1.4 ExecutorService接口 ExecutorService接口：真正的线程池接口，常用子类ThreadPoolExecutors 1234public interface ExecutorService extends Executor &#123; //...&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Main&#123; public static void main(String[] args) throws Exception &#123; ExecutorService service = Executors.newFixedThreadPool(3); for(int i =0; i &lt; 10 ; i++) &#123; service.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\"running...\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; System.out.println(service); System.out.println(\"================================================\"); service.shutdown(); System.out.println(\"service.isTerminated():\" + service.isTerminated()); System.out.println(\"service.isShutdown():\" + service.isShutdown()); System.out.println(service); Thread.sleep(10000); //保证所有线程运行完 System.out.println(\"================================================\"); System.out.println(\"service.isTerminated():\" + service.isTerminated()); System.out.println(\"service.isShutdown():\" + service.isShutdown()); System.out.println(service); &#125;&#125;/*pool-1-thread-1running...pool-1-thread-3running...pool-1-thread-2running...java.util.concurrent.ThreadPoolExecutor@7ba4f24f[Running, pool size = 3, active threads = 3, queued tasks = 7, completed tasks = 0]================================================service.isTerminated():falseservice.isShutdown():truejava.util.concurrent.ThreadPoolExecutor@7ba4f24f[Shutting down, pool size = 3, active threads = 3, queued tasks = 7, completed tasks = 0]pool-1-thread-1running...pool-1-thread-3running...pool-1-thread-2running...pool-1-thread-1running...pool-1-thread-2running...pool-1-thread-3running...pool-1-thread-1running...================================================service.isTerminated():trueservice.isShutdown():truejava.util.concurrent.ThreadPoolExecutor@7ba4f24f[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 10]*/ 8.1.5 ThreadPoolExecutor线程池状态 ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量 状态名 高3位 接收新任务 处理阻塞队列任务 说明 RUNNING 111 Y Y SHUTDOWN 000 N Y 不会接收新任务，但会处理阻塞队列剩余任务 STOP 001 N N 会中断正在执行的任务，并抛弃阻塞队列任务 TIDYING 010 - - 任务全执行完毕，活动线程为 0 即将进入终结 TERMINATED 011 - - 终结状态 从数字上比较，TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING 这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作进行赋值 1234// c 为旧值， ctlOf 返回结果为新值ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们 private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; 构造方法 根据这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize核心线程数目 (最多保留的线程数) maximumPoolSize最大线程数目 keepAliveTime救急线程生存时间 unit救急线程时间单位 workQueue阻塞队列 threadFactory线程工厂 - 可以为线程创建时起个好名字 handler拒绝策略 线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。 当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程。 如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。 如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。 jdk 提供了 4 种拒绝策略实现，其它著名框架也提供了拒绝策略实现 AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略 CallerRunsPolicy 让调用者运行任务 DiscardPolicy 放弃本次任务 DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之 Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题 Netty 的实现，是创建一个新线程来执行任务 ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略 PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略 Future接口12345678910111213141516171819public interface Future&lt;V&gt; &#123; // 泛型代表了执行任务返回值类型 // 取消任务的执行。参数指定是否立即中断任务执行，或者等等任务结束 boolean cancel(boolean mayInterruptIfRunning); // 任务是否已经取消，任务正常完成前将其取消，则返回 true boolean isCancelled(); // 任务是否已经完成。需要注意的是如果任务正常终止、异常或取消，都将返回true boolean isDone(); // 阻塞直到任务返回结果 InterruptedException 线程被中断异常， ExecutionException任务执行异常，如果任务被取消，还会抛出CancellationException V get() throws InterruptedException, ExecutionException; // 多了设置超时时间 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 1234567891011121314151617181920212223class Main&#123; public static void main(String[] args) throws Exception &#123; ExecutorService service = Executors.newFixedThreadPool(3); Future&lt;Integer&gt; task = service.submit(()-&gt;&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return 1000; &#125;); System.out.println(task.isDone()); System.out.println(task.get()); System.out.println(task.isDone()); &#125;&#125;/*false1000true*/ FutureTask类 Future接口的一个唯一实现类 既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。 1234567891011public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123; //...&#125;public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run();&#125; 构造器 1234567891011public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable &#125; public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable &#125; 实例 12345678910111213141516171819class Main&#123; public static void main(String[] args) throws Exception &#123; ExecutorService service = Executors.newFixedThreadPool(3); FutureTask&lt;Boolean&gt; task = new FutureTask&lt;&gt;(()-&gt;&#123; System.out.println(\"running\"); Thread.sleep(1000); System.out.println(\"end\"); return true; &#125;); new Thread(task).start(); System.out.print(task.get()); &#125;&#125;/*runningendtrue*/ 8.1.6 Executors工具类 Executors类：线程池的工具类，用于创建不同的线程池，大多都是静态方法 12345678// 创建线程池对象ExecutorService ser = Executors.newFixedThreadPool(2);// 执行任务 有返回值 参数一般为Callable接口ser.submit(/*Callable接口*/);// 执行任务 无返回值 参数一般为Runnable接口ser.execute(/*Runnable接口*/);// 关闭连接池ser.shutdown(); executor &amp; submit区别 executor Executor接口中的方法 接受runnable接口 无返回值 submit ExecutorService接口【Executor接口子接口】中的方法 runnable &amp; callable接口 有返回值 1 定长线程池newFixedThreadPool 可控制线程最大并发数，超出的线程会在队列中等待 123456public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间 阻塞队列是无界的，可以放任意数量的任务 适用于任务量已知，相对耗时的任务 2 可缓存线程池newCachedThreadPool 如果线程池长度超过处理需要，若无空闲线程，则新建线程。超过60秒线程未使用则回收。 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 全部都是救急线程（60s 后可以回收） 救急线程可以无限创建 队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货） 12345678910111213141516public static void main(String[] args) throws InterruptedException &#123; SynchronousQueue&lt;Integer&gt; integers = new SynchronousQueue&lt;&gt;(); new Thread(() -&gt; &#123; try &#123; log.debug(\"putting &#123;&#125; \", 1); integers.put(1); // 要执行完take才会向下运行 log.debug(\"&#123;&#125; putted...\", 1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"t1\").start(); Sleeper.sleep(5); log.debug(\"taking &#123;&#125;\", 1); integers.take(); &#125; 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Main&#123; static class MyTask implements Callable&lt;Integer&gt; &#123; public Integer call() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return 1; &#125; &#125; public static void main(String[] args) throws Exception &#123; ExecutorService service = Executors.newCachedThreadPool(); MyTask mytask = new MyTask(); Future task1 = service.submit(mytask); Thread.sleep(100); System.out.println(service); Future task2 = service.submit(mytask); Thread.sleep(100); System.out.println(service); Thread.sleep(10000); Future task3 = service.submit(mytask); Thread.sleep(100); System.out.println(service); Future task4 = service.submit(mytask); Thread.sleep(100); System.out.println(service); task1.get(); task2.get(); task3.get(); task4.get(); System.out.println(service); Thread.sleep(80000); System.out.println(service); &#125;&#125;/*java.util.concurrent.ThreadPoolExecutor@6d6f6e28[Running, pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 0]java.util.concurrent.ThreadPoolExecutor@6d6f6e28[Running, pool size = 2, active threads = 2, queued tasks = 0, completed tasks = 0]java.util.concurrent.ThreadPoolExecutor@6d6f6e28[Running, pool size = 2, active threads = 1, queued tasks = 0, completed tasks = 2]java.util.concurrent.ThreadPoolExecutor@6d6f6e28[Running, pool size = 2, active threads = 2, queued tasks = 0, completed tasks = 2]java.util.concurrent.ThreadPoolExecutor@6d6f6e28[Running, pool size = 2, active threads = 0, queued tasks = 0, completed tasks = 4]java.util.concurrent.ThreadPoolExecutor@6d6f6e28[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 4]*/ 3 单例线程池newSingleThreadExecutor 保证了线程的顺序，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。 自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作 12345678910111213ExecutorService executorService = Executors.newSingleThreadExecutor(); executorService.execute(()-&gt;&#123; log.debug(\"run 1\"); int i = 1/0; &#125;); executorService.execute(()-&gt;&#123; log.debug(\"run 2\"); &#125;); executorService.execute(()-&gt;&#123; log.debug(\"run 3\"); &#125;); Executors.newFixedThreadPool(1)与此区别 Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改 FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法 Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改 对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改 12345678public static ExecutorService newSingleThreadExecutor() &#123; // 装饰器模式 return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 4 任务调度线程池ScheduledExecutorService 在『任务调度线程池』功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的， 缺点：同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。 12345678910111213141516171819202122232425public static void main(String[] args) throws InterruptedException &#123; Timer timer = new Timer(); TimerTask task1 = new TimerTask() &#123; @Override public void run() &#123; log.debug(\"task 1\"); Sleeper.sleep(2); &#125; &#125;; TimerTask task2 = new TimerTask() &#123; @Override public void run() &#123; log.debug(\"task 2\"); &#125; &#125;; log.debug(\"start...\"); timer.schedule(task1, 1000); timer.schedule(task2, 1000); &#125;// 使用 timer 添加两个任务，希望它们都在 1s 后执行 // 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行11:33:03.832 [main] MultiThread - start...11:33:04.840 [Timer-0] MultiThread - task 111:33:06.844 [Timer-0] MultiThread - task 2 任务调度线程池 1234567891011public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize); &#125; /*public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService*/public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125; 延迟执行 12345678910ScheduledExecutorService service = Executors.newScheduledThreadPool(4);log.debug(\"now\");service.schedule(() -&gt; &#123; log.debug(\"run\");&#125;, 2, TimeUnit.SECONDS);/* 17:15:00.239 [main] MyTest - now 17:15:02.384 [pool-1-thread-1] MyTest - run【隔了2秒】*/ 延时循环执行 123456789101112131415161718192021ScheduledExecutorService service1 = Executors.newScheduledThreadPool(4);service1.scheduleAtFixedRate(()-&gt;&#123; //⭐scheduleAtFixedRate try &#123; log.debug(\"scheduleAtFixedRate run\"); Thread.sleep(1000); //任务运行时间大于间隔时间 导致间隔时间被包含 任务不重叠 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;,0,500, TimeUnit.MILLISECONDS);Sleeper.sleep(10);service1.shutdown();/*17:27:04.370 [pool-1-thread-1] MyTest - scheduleAtFixedRate run17:27:05.381 [pool-1-thread-1] MyTest - scheduleAtFixedRate run17:27:06.382 [pool-1-thread-2] MyTest - scheduleAtFixedRate run17:27:07.382 [pool-1-thread-2] MyTest - scheduleAtFixedRate run17:27:08.383 [pool-1-thread-2] MyTest - scheduleAtFixedRate run17:27:09.384 [pool-1-thread-2] MyTest - scheduleAtFixedRate run【上一个开始执行计时 开始计时总计隔了1秒】*/ 12345678910111213ScheduledExecutorService service2 = Executors.newScheduledThreadPool(1);service2.scheduleWithFixedDelay(()-&gt;&#123; //⭐scheduleWithFixedDelay try &#123; log.debug(\"scheduleWithFixedDelay run\"); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;,0,1000, TimeUnit.MILLISECONDS);/*16:00:52.942 [pool-3-thread-1] MultiThread - scheduleWithFixedDelay run16:00:55.943 [pool-3-thread-1] MultiThread - scheduleWithFixedDelay run【要等上一个执行完 存在延时 开始计时总计隔了3秒】16:00:58.945 [pool-3-thread-2] MultiThread - scheduleWithFixedDelay run*/ 如何让每周四 18:00:00 定时执行任务？1234567891011121314151617181920public static void main(String[] args) &#123; // 获取当前时间 LocalDateTime now = LocalDateTime.now(); System.out.println(now); // 获取周四时间 LocalDateTime time = now.withHour(18).withMinute(0).withSecond(0).withNano(0).with(DayOfWeek.THURSDAY); // 如果 当前时间 &gt; 本周周四，必须找到下周周四 if(now.compareTo(time) &gt; 0) &#123; time = time.plusWeeks(1); &#125; System.out.println(time); // initailDelay 代表当前时间和周四的时间差 // period 一周的间隔时间 long initailDelay = Duration.between(now, time).toMillis(); long period = 1000 * 60 * 60 * 24 * 7; ScheduledExecutorService pool = Executors.newScheduledThreadPool(1); pool.scheduleAtFixedRate(() -&gt; &#123; System.out.println(\"running...\"); &#125;, initailDelay, period, TimeUnit.MILLISECONDS); &#125; 5 提交任务12345678910111213141516// 执行任务 void execute(Runnable command);// 提交任务 task，用返回值 Future 获得任务执行结果 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);//【Future使用了保护性暂停模式 线程间通信获取结果】// 提交 tasks 中所有任务 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException;// 提交 tasks 中所有任务，带超时时间 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)throws InterruptedException;// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消 &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)throws InterruptedException, ExecutionException; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ExecutorService pool = Executors.newFixedThreadPool(2); method1(pool); Sleeper.sleep(10); method2(pool); Sleeper.sleep(10); method3(pool); &#125;private static void method1(ExecutorService pool) throws InterruptedException, ExecutionException &#123; Future&lt;String&gt; future = pool.submit(() -&gt; &#123; log.debug(\"running\"); Thread.sleep(1000); return \"ok\"; &#125;); log.debug(\"&#123;&#125;\", future.get()); /* 00:42:15.410 [pool-1-thread-1] MultiThread - running 00:42:16.416 [main] MultiThread - ok */ &#125; private static void method2(ExecutorService pool) throws InterruptedException &#123; List&lt;Future&lt;String&gt;&gt; futures = pool.invokeAll(Arrays.asList( () -&gt; &#123; log.debug(\"begin\"); Thread.sleep(500); return \"2\"; &#125;, () -&gt; &#123; log.debug(\"begin\"); Thread.sleep(2000); return \"3\"; &#125; )); futures.forEach( f -&gt; &#123; try &#123; log.debug(\"&#123;&#125;\", f.get()); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;); /* 00:42:26.425 [pool-1-thread-1] MultiThread - begin 00:42:26.425 [pool-1-thread-2] MultiThread - begin 00:42:28.426 [main] MultiThread - 2【要等时间最长的结果返回】 00:42:28.426 [main] MultiThread - 3 */ &#125; private static void method3(ExecutorService pool) throws InterruptedException, ExecutionException &#123; String result = pool.invokeAny(Arrays.asList( () -&gt; &#123; log.debug(\"begin 1\"); Thread.sleep(1000); log.debug(\"end 1\"); return \"1\"; &#125;, () -&gt; &#123; log.debug(\"begin 2\"); Thread.sleep(500); log.debug(\"end 2\"); return \"2\"; &#125; )); log.debug(\"&#123;&#125;\", result); /* 00:42:38.428 [pool-1-thread-1] MultiThread - begin 2 00:42:38.428 [pool-1-thread-2] MultiThread - begin 1 00:42:38.928 [pool-1-thread-1] MultiThread - end 2 00:42:38.928 [main] MultiThread - 2 */ &#125; 6 关闭线程池shutdown 线程池状态变为 SHUTDOWN 不会接收新任务，但已提交任务会执行完 此方法不会阻塞调用线程的执行 12345678910111213141516void shutdown();public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); advanceRunState(SHUTDOWN); // 修改线程池状态 interruptIdleWorkers(); // 仅会打断空闲线程 onShutdown(); //扩展点ScheduledThreadPoolExecutor &#125; finally &#123; mainLock.unlock(); &#125; // 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会阻塞) tryTerminate();&#125; shutdownNow 线程池状态变为 STOP，不会接收新任务 会将队列中的任务返回 用 interrupt 的方式中断正在执行的任务 1234567891011121314151617List&lt;Runnable&gt; shutdownNow();public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); advanceRunState(STOP);// 修改线程池状态 interruptWorkers();// 打断所有线程 tasks = drainQueue();// 获取队列中剩余任务 &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate();// 尝试终结 所有已经都打断了 肯定被终结 return tasks; &#125; 7 其它方法123456// 不在 RUNNING 状态的线程池，此方法就返回 true boolean isShutdown();// 线程池状态是否是 TERMINATEDboolean isTerminated();// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待 等所有已提交的任务（包括正在跑的和队列中等待的）执行完或者等超时时间到【不好用 不确定等多久 可以用get返回结果阻塞】boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; 8.1.7 正确处理执行任务异常方法1：主动捉异常123456789ExecutorService pool = Executors.newFixedThreadPool(1); pool.submit(() -&gt; &#123; try &#123; log.debug(\"task1\"); int i = 1 / 0; &#125; catch (Exception e) &#123; log.error(\"error:\", e); &#125; &#125;); 方法2：使用 Future 没有异常的就获取结果，有异常就获取异常 1234567ExecutorService pool = Executors.newFixedThreadPool(1); Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123; log.debug(\"task1\"); int i = 1 / 0; return true;&#125;);log.debug(\"result:&#123;&#125;\", f.get()); 8.1.8 Tomcat线程池 LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲 Acceptor 只负责【接收新的 socket 连接】 Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】 一旦可读，封装一个任务对象（socketProcessor）， 提交给 Executor 线程池处理 Executor 线程池中的工作线程最终负责【处理请求】 Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同 如果总线程数达到 maximumPoolSize 这时不会立刻抛 RejectedExecutionException 异常 而是再次尝试将任务放入队列，如果还失败，才抛出RejectedExecutionException 异常 123456789101112131415161718192021222324public void execute(Runnable command, long timeout, TimeUnit unit) &#123; submittedCount.incrementAndGet(); try &#123; super.execute(command); //捕获异常 &#125; catch (RejectedExecutionException rx) &#123; if (super.getQueue() instanceof TaskQueue) &#123; final TaskQueue queue = (TaskQueue)super.getQueue(); try &#123;//再试一次 if (!queue.force(command, timeout, unit)) &#123; submittedCount.decrementAndGet(); throw new RejectedExecutionException(\"Queue capacity is full.\"); &#125; &#125; catch (InterruptedException x) &#123; submittedCount.decrementAndGet(); Thread.interrupted(); throw new RejectedExecutionException(x); &#125; &#125;else &#123; submittedCount.decrementAndGet(); throw rx; &#125; &#125; &#125; 123456789 TaskQueue.java ~~~java public boolean force(Runnable o, long timeout, TimeUnit unit) throws InterruptedException &#123; if ( parent.isShutdown() ) throw new RejectedExecutionException( &quot;Executor not running, can&#39;t force a command into the queue&quot; ); return super.offer(o,timeout,unit); &#x2F;&#x2F;forces the item onto the queue, to be used if the task is rejected &#125; Connector 配置 Executor 线程配置 8.1.9异步模式之工作线程1 定义让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。也可以将其归类为分工模式，它的典型实现 就是线程池，也体现了经典设计模式中的享元模式 2 饥饿现象 固定大小线程池会有饥饿现象 同一类别任务可以使用同一个线程池，多个任务可以采用多个线程池 两个工人是同一个线程池中的两个线程 他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作 客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待 后厨做菜：没啥说的，做就是了 比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好 但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿 1234567891011121314151617181920212223242526272829303132static final List&lt;String&gt; MENU = Arrays.asList(\"地三鲜\", \"宫保鸡丁\", \"辣子鸡丁\", \"烤鸡翅\");static Random RANDOM = new Random();static String cooking() &#123; return MENU.get(RANDOM.nextInt(MENU.size()));&#125;public static void main(String[] args) &#123; // ExecutorService waiterPool = Executors.newFixedThreadPool(1); ExecutorService cookPool = Executors.newFixedThreadPool(2); for (int i = 0; i &lt; 2; i++) &#123; cookPool.execute(() -&gt; &#123; //使用线程池的一个线程⭐ log.debug(\"处理点餐...\"); Sleeper.sleep(1); Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123; //使用线程池的一个线程⭐ log.debug(\"做菜\"); return cooking(); &#125;); try &#123; log.debug(\"上菜: &#123;&#125;\", f.get()); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;); &#125;&#125;/* 17:08:41.339 c.TestDeadLock [pool-1-thread-2] - 处理点餐... 17:08:41.339 c.TestDeadLock [pool-1-thread-1] - 处理点餐... 【饥饿死等】*/ 1234567891011121314151617181920public static void main(String[] args) &#123; ExecutorService waiterPool = Executors.newFixedThreadPool(1); ExecutorService cookPool = Executors.newFixedThreadPool(1); for (int i = 0; i &lt; 3; i++) &#123; waiterPool.execute(() -&gt; &#123; log.debug(\"处理点餐...\"); Sleeper.sleep(1); Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123; log.debug(\"做菜\"); return cooking(); &#125;); try &#123; log.debug(\"上菜: &#123;&#125;\", f.get()); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;); &#125;&#125; 3 创建多少线程池合适 过小会导致程序不能充分地利用系统资源、容易导致饥饿 过大会导致更多的线程上下文切换，占用更多内存 CPU 密集型运算 通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率 +1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 I/O 密集型运算 CPU 不总是处于繁忙状态 当你执行业务计算时，这时候会使用 CPU 资源 当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。 经验公式如下 ：线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间 例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式 4 * 100% * 100% / 50% = 8 例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式 4 * 100% * 100% / 10% = 40 8.1.10 ForkJoinPool1 概念Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型 运算所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计 算，如归并排序、斐波那契数列、都可以用分治思想进行求解Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运 算效率Fork/Join 默认会创建与 cpu 核心数大小相同的线程池 2 使用提交给 Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值），例如下 面定义了一个对 1~n 之间的整数求和的任务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class Main&#123; static int[] nums = new int[10000]; static final int MAX_NUM = 100; static Random r = new Random(); static&#123; for(int i = 0; i&lt; 10000; i++) &#123; nums[i] = r.nextInt(100); &#125; out.println(Arrays.stream(nums).sum()); &#125; //有返回值 static class AddTaskWithReturn extends RecursiveTask&lt;Long&gt; &#123; int start, end; public AddTaskWithReturn(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected Long compute() &#123; if(end - start &lt; MAX_NUM) &#123; long sum = 0; for(int i = start; i&lt; end ;i++) &#123; sum += nums[i]; &#125; return sum; &#125; int middle = (start+end) &gt;&gt; 1; AddTaskWithReturn subTask1 = new AddTaskWithReturn(start, middle); AddTaskWithReturn subTask2 = new AddTaskWithReturn(middle, end); subTask1.fork(); subTask2.fork(); return subTask1.join() + subTask2.join(); &#125; &#125; //无返回值// static class AddTaskWithoutReturn extends RecursiveAction&#123;//// int start, end;//// AddTaskWithoutReturn(int start, int end) &#123;// this.start = start;// this.end = end;// &#125;// @Override// protected void compute() &#123;// if(end - start &lt; MAX_NUM)// &#123;// long sum = 0;// for(int i = start; i&lt; end ;i++) &#123;// sum = sum + nums[i];// &#125;// &#125;// else &#123;// int middle = (start+end) &gt;&gt; 2;// AddTaskWithoutReturn subTask1 = new AddTaskWithoutReturn(start, middle);// AddTaskWithoutReturn subTask2 = new AddTaskWithoutReturn(middle, end);// subTask1.fork();// subTask2.fork();// &#125;// &#125;// &#125; public static void main(String[] args) throws Exception &#123; //无返回值// ForkJoinPool pool = new ForkJoinPool();// AddTaskWithoutReturn task = new AddTaskWithoutReturn(0, nums.length);// pool.execute(task);// task.join(); //有返回值 ForkJoinPool pool = new ForkJoinPool(); AddTaskWithReturn task = new AddTaskWithReturn(0, nums.length); pool.execute(task); Long result = task.join(); System.out.println(result); &#125;&#125;","tags":[{"name":"多线程","slug":"多线程","permalink":"http://goldcarpenter.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"MyBatis","date":"2019-08-17T16:00:00.000Z","path":"2019/08/18/MyBatis_Part3/","text":"7.Mybatis 的动态 SQL 语句7.1.&lt;if&gt;标签的使用 如果需要根据传入的实体类，判断哪些属性不为空，并以此作为查询条件，那么使用&lt;if&gt;&lt;/if&gt; 标签 WHERE 1 =1是防止所有条件都为空时，SQL 语句最后会带有一个 WHERE 关键字而没有条件，不符合 SQL 语法。 &lt;if&gt;&lt;/if&gt;标签中 test 属性是必须的，表示判断的条件。其中有几点需要注意： 如果 test 有多个条件，那么必须使用 and 进行连接，而不能使用 Java 中的 &amp;&amp; 运算符。 test中的参数名称必须与实体类的属性保持一致，也就是和#{参数符号}保持一致。 如果判断条件为字符串，那么除了判断是否为null外，最好也判断一下是否为空字符串&#39;&#39; ，防止 SQL语句将其作为条件查询。 首先定义接口方法 1234567/** * 根据传入的查询条件，进行多条件查询 * * @param user 包含查询的条件，可能包含 username、sex、birthday、address等条件 * @return */List&lt;User&gt; listUsersByCondition(User user); 接着配置映射文件 12345678910111213141516&lt;!-- 根据查询条件进行复合查询 --&gt;&lt;select id=\"listUsersByCondition\" parameterType=\"top.carpenter.pojo.User\" resultType=\"top.carpenter.pojo.User\"&gt; SELECT * FROM user WHERE 1 = 1 &lt;if test=\"username != null and username != ''\"&gt; AND username LIKE CONCAT('%',#&#123;username&#125;,'%') &lt;/if&gt; &lt;if test=\"sex != null and sex != ''\"&gt; AND sex = #&#123;sex&#125; &lt;/if&gt; &lt;if test=\"address != null and address != ''\"&gt; AND address = #&#123;address&#125; &lt;/if&gt; &lt;if test=\"birthday != null\"&gt; AND birthday = #&#123;birthday&#125; &lt;/if&gt;&lt;/select&gt; 测试代码及运行结果 12345678910@Testpublic void testListUsersByCondition() &#123; User user = new User(); // 加入查询条件 user.setUsername(\"王\"); user.setSex(\"男\"); // 查询并展示 List&lt;User&gt; users = mapper.listUsersByCondition(user); users.forEach(System.out::println);&#125; 7.2.&lt;where&gt;标签的使用 该标签可以动态添加 WHERE 关键字，并且剔除掉 SQL 语句中多余的 AND 或者 OR，使用&lt;where&gt;&lt;/where&gt; 进一步优化 SQL 语句。 &lt;where&gt;&lt;/where&gt;标签只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入&lt;where&gt;子句。而且，若语句的开头为 AND 或 OR，&lt;where&gt;&lt;/where&gt;标签也会将它们去除。 1234567891011121314151617&lt;select id=\"listUsersByCondition\" parameterType=\"cn.ykf.pojo.User\" resultType=\"top.carpenter.pojo.User\"&gt; SELECT * FROM user &lt;where&gt; &lt;if test=\"username != null and username != ''\"&gt; AND username LIKE CONCAT('%',#&#123;username&#125;,'%') &lt;/if&gt; &lt;if test=\"sex != null and sex != ''\"&gt; AND sex = #&#123;sex&#125; &lt;/if&gt; &lt;if test=\"address != null and address != ''\"&gt; AND address = #&#123;address&#125; &lt;/if&gt; &lt;if test=\"birthday != null\"&gt; AND birthday = #&#123;birthday&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 为了避免 Mybatis 在动态拼接 SQL 语句的时候发生错误，建议在编写 SQL 语句时不要添加分号 ; 7.3.&lt;set&gt;标签的使用123456789101112131415&lt;update id=\"updateByPrimaryKeySelective\" parameterType=\"top.carpenter.pojo.BlogLink\"&gt; update tb_link &lt;set&gt; &lt;if test=\"linkType != null\"&gt; link_type = #&#123;linkType,jdbcType=TINYINT&#125;, &lt;/if&gt; &lt;if test=\"linkName != null\"&gt; link_name = #&#123;linkName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"linkUrl != null\"&gt; link_url = #&#123;linkUrl,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/set&gt; where link_id = #&#123;linkId,jdbcType=INTEGER&#125; &lt;/update&gt; 7.4. foreach 标签的使用 假如需要根据一个 id 集合，来查询出 id 在该集合中的所有用户，如果使用普通 SQL 语句的话，那么查询语句应该这样写：SELECT * FROM user WHERE id IN(41,42,43); 使用动态 SQL 使用&lt;foreach&gt;&lt;/foreach&gt;遍历集合拼接上id IN(41,42,43)这一串内容 collection： 代表要遍历的集合或数组，这个属性是必须的。如果是遍历数组，那么该值只能为 array open： 代表语句的开始部份 close： 代表语句的结束部份 item： 代表遍历集合时的每个元素，相当于一个临时变量 separator： 代表拼接每个元素之间的分隔符 首先修改 QueryVo 类，增加一个成员变量用于存放 id 集合 123456public class QueryVo implements Serializable &#123; private User user; // 如果还有其他的查询条件，就可以一并封装进来 private List&lt;Integer&gt; ids; //get set function&#125; 接下来添加接口方法，并配置映射文件 1234/** * 根据id集合，查询用户 */List&lt;User&gt; listUsersByIds(QueryVo vo); 1234567891011&lt;!-- 根据id集合查询用户 --&gt;&lt;select id=\"listUsersByIds\" parameterType=\"top.carpenter.pojo.QueryVo\" resultType=\"top.carpenter.pojo.User\"&gt; SELECT * FROM user &lt;where&gt; &lt;if test=\"ids != null and ids.size &gt; 0\"&gt; &lt;foreach collection=\"ids\" open=\"AND id IN (\" close=\")\" item=\"id\" separator=\",\"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象传递给 foreach 作为集合参数。 当使用可迭代对象或者数组时，index 是当前迭代的次数，item 的值是本次迭代获取的元素。 当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。 注意：SQL 语句中的参数符号 #{id} 应该与 item=”id” 保持一致，也就是说，item 属性如果把临时变量声明为 uid 的话，那么使用时就必须写成 #{uid} 7.5.定义 SQL 片段 我们可以把SELECT * FROM user定义为 SQL 片段，以供复用，减少工作量。 首先在映射文件中定义代码片段 1234&lt;!-- 定义代码片段 --&gt;&lt;sql id=\"defaultSql\"&gt; SELECT * FROM user&lt;/sql&gt; 在需要的地方引用该片段 123456789101112&lt;!-- 根据id集合查询用户 --&gt;&lt;select id=\"listUsersByIds\" parameterType=\"top.carpenter.pojo.QueryVo\" resultMap=\"userMap\"&gt; &lt;!-- 引用代码片段 --&gt; &lt;include refid=\"defaultSql\"&gt;&lt;/include&gt; &lt;where&gt; &lt;if test=\"ids != null and ids.size &gt; 0\"&gt; &lt;foreach collection=\"ids\" open=\"AND id IN (\" close=\")\" item=\"id\" separator=\",\"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 8.Mybatis 多表查询 表之间的关系共有以下几种 一对一 ： 人和身份证就是一对一的关系。一个人只能有一个身份证号，而一个身份证号只能属于一个人。 多对一（一对多）：学生和班级就是多对一（一对多）的关系。一个班级有多个学生，而一个学生只属于一个班级。 多对多 ： 学生和任课老师就是多对多的关系。一个学生可以有多个任课老师，而一个任课老师可以有多个学生。 8.1.环境搭建 现在以用户和账户为例子，一个用户可以有多个账户，一个账户只能属于一个用户。 数据库表： 123456789101112131415161718192021222324# 创建用户表DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL auto_increment, `username` varchar(32) NOT NULL COMMENT '用户名称', `birthday` datetime default NULL COMMENT '生日', `sex` char(1) default NULL COMMENT '性别', `address` varchar(256) default NULL COMMENT '地址', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;# 导入用户数据insert into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (41,'老王','2018-02-27 17:47:08','男','北京'),(42,'小二王','2018-03-02 15:09:37','女','北京金燕龙'),(43,'小二王','2018-03-04 11:34:34','女','北京金燕龙'),(45,'传智播客','2018-03-04 12:04:06','男','北京金燕龙'),(46,'老王','2018-03-07 17:37:26','男','北京'),(48,'小马宝莉','2018-03-08 11:44:00','女','北京修正');# 创建账户表，外键为uid，关联用户表的idDROP TABLE IF EXISTS `account`;CREATE TABLE `account` ( `id` int(11) NOT NULL COMMENT '编号', `uid` int(11) default NULL COMMENT '用户编号', `money` double default NULL COMMENT '金额', PRIMARY KEY (`id`), KEY `FK_Reference_8` (`uid`), CONSTRAINT `FK_Reference_8` FOREIGN KEY (`uid`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;# 导入账户数据insert into `account`(`id`,`uid`,`money`) values (1,46,1000),(2,45,1000),(3,46,2000); 添加账户实体类 Account 1234567public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; // set get function&#125; 添加账户实体类对应的 Mapper 接口 AccountMapper 以及映射文件 AccountMapper.xml 123456public interface IAccountDao &#123; /** * 查询所有账户，带有用户信息 */ List&lt;Account&gt; listAllAcounts();&#125; 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"top.carpenter.dao.IAccountDao\"&gt; &lt;!-- 配置查询所有账户 --&gt; &lt;select id=\"listAllAccounts\" resultType=\"top.carpenter.pojo.Account\"&gt; SELECT * FROM account &lt;/select&gt;&lt;/mapper&gt; 记得在 Mybatis 配置文件中 加入新的映射文件：&lt;mapper resource=&quot;AccountMapper.xml&quot;/&gt; 直接配置整个包：&lt;package name=&quot;top.carperter.dao&quot;/&gt; 测试一下查询账户 12345678public class AccountMapperTest &#123; @Test public void testListAllAccounts() &#123; // 5. 使用代理对象执行查询 List&lt;Account&gt; accounts = mapper.listAllAccounts(); accounts.forEach(System.out::println); &#125;&#125; 虽然可以查询出账户信息，但是这个结果并没有和用户产生关联，而我们想要的效果是查询出账户信息的同时，把所属用户信息也一并展示。那么我们该如何修改呢？ 8.2.多表查询之【一对一】 首先编写 SQL 语句，如果想要达到上述效果，那么 SQL 语句可以这样写 1SELECT U.*, a.id AS aid, a.uid, a.money from account a, user u WHERE a.uid = u.id; 为了可以接收这条语句的查询结果，对账户实体类 Account 进行修改，为其增加成员变量 User 来接收查询出的用户信息（从表实体应该包含一个主表实体的对象引用） 12345678public class Account implements Serializable &#123; // 其他成员不展示... /** * 账户对应的用户信息,从表实体应该包含一个主表实体的对象引用 */ private User user; // 其他setter()/getter()不展示... &#125; 因为此时账户实体类 Account 已经发生了变化，所以我们应该在映射文件定义用于封装带有 User 信息的 Account 的映射集合resultMap 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"top.carpenter.dao.IAccountDao\"&gt; &lt;!-- 定义可以封装带有User的Account的 resultMap --&gt; &lt;resultMap id=\"AccountWithUserMap\" type=\"top.carpenter.pojo.Account\"&gt; &lt;id property=\"id\" column=\"aid\"/&gt; &lt;!--***注意aid 与SQL相同**--&gt; &lt;result property=\"uid\" column=\"uid\"/&gt; &lt;result property=\"money\" column=\"money\"/&gt; &lt;!-- 关联 User 对象 --&gt; &lt;association property=\"user\" javaType=\"top.carpenter.pojo.User\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"username\" column=\"username\"/&gt; &lt;result property=\"sex\" column=\"sex\"/&gt; &lt;result property=\"birthday\" column=\"birthday\"/&gt; &lt;result property=\"address\" column=\"address\"/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- 配置查询所有账户，带有用户信息 --&gt; &lt;select id=\"listAllAccounts\" resultMap=\"AccountWithUserMap\"&gt; SELECT U.*, a.id AS aid, a.uid, a.money from account a, user u WHERE a.uid = u.id &lt;/select&gt;&lt;/mapper&gt; 注意： &lt;association&gt;&lt;/association&gt;用于一对一映射，其中的 property 属性表示要关联的属性，javaType 表示待关联的实体类的全限定类名。 因为 SQL 语句中为 account 表的 id 字段起了别名 aid ，所以在定义 resultMap 的时候，记得主字段写 column=”aid”，而不是 column=”id”。 此处重新运行测试代码，可以发现查询的账户已经带有了用户信息 8.3.多表查询之【一对多】 假如需要查询用户的时候，如果用户拥有账户，那么也要把账户信息展示出来。那么又该如何实现？ 首先SQL语句如何编写，由于有的用户并没有账户，所以如果采用内连接的方式查询（也就是上面的查询方式），那么会把没有账户的用户筛选掉，像下面这样： 因此，我们应该采用外连接的方式，使得没有账户的用户也可以查询出来： 1SELECT u.*, a.id AS aid, a.uid, a.money FROM user u LEFT OUTER JOIN account a ON u.id = a.uid; 为了可以接收这条语句的查询结果，那么我们应该对用户实体类 User 进行修改，为其增加成员变量 accounts 来接收查询出的账户信息（主表实体应该包含从表实体的集合引用） 12345678public class User implements Serializable &#123; // 其他成员省略不展示... /** * 一对多关系映射：主表实体应该包含从表实体的集合引用 */ private List&lt;Account&gt; accounts; // 其他setter()/getter()省略不展示... &#125; 修改映射文件 1234567891011121314151617181920&lt;mapper namespace=\"top.carpenter.dao.IUserDao\"&gt; &lt;!-- 配置 resultMap ，完成实体类与数据库表的映射 --&gt; &lt;resultMap id=\"UserWithAccountsMap\" type=\"top.carpenter.pojo.User\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"username\" column=\"username\"/&gt; &lt;result property=\"sex\" column=\"sex\"/&gt; &lt;result property=\"birthday\" column=\"birthday\"/&gt; &lt;result property=\"address\" column=\"address\"/&gt; &lt;!-- 配置user对象中accounts集合的映射 --&gt; &lt;collection property=\"accounts\" ofType=\"top.carpenter.pojo.Account\"&gt; &lt;id property=\"id\" column=\"aid\"/&gt; &lt;result property=\"uid\" column=\"uid\"/&gt; &lt;result property=\"money\" column=\"money\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 配置查询所有用户，并且带有账户信息 --&gt; &lt;select id=\"listAllUsers\" resultMap=\"UserWithAccountsMap\"&gt; SELECT u.*, a.id AS aid, a.uid, a.money FROM user u LEFT OUTER JOIN account a ON u.id = a.uid; &lt;/select&gt;&lt;/mapper&gt; &lt;collection &gt;&lt;/collection&gt;用于一对多映射，其中的 property 属性表示要关联的集合，ofType表示集合中的实体类的全限定类名 测试代码及运行结果如下 123456@Testpublic void testListAllUsers() &#123; // 5. 使用代理对象执行查询 List&lt;User&gt; users = accountDao.listAllUsers(); users.forEach(System.out::println);&#125; 8.4.环境搭建 现在以用户和角色为例子，一个用户可以有多个角色，一个角色可以赋予多个用户。 需求： 查询用户的时候可以把用户所拥有的角色信息展示出来。 查询角色的时候可以把角色所赋予的用户信息展示出来。 先搭建相关环境，由于是多对多关系，所以需要借助第三张表，导入所需数据库表： 1234567891011121314151617181920212223# 创建角色表DROP TABLE IF EXISTS `role`;CREATE TABLE `role` ( `id` int(11) NOT NULL COMMENT '编号', `role_name` varchar(30) default NULL COMMENT '角色名称', `role_desc` varchar(60) default NULL COMMENT '角色描述', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;# 添加角色数据insert into `role`(`ID`,`ROLE_NAME`,`ROLE_DESC`) values (1,'院长','管理整个学院'),(2,'总裁','管理整个公司'),(3,'校长','管理整个学校');# 创建用户角色表，也就是中间表# uid 和 rid是复合主键，同时也是外键DROP TABLE IF EXISTS `user_role`;CREATE TABLE `user_role` ( `uid` int(11) NOT NULL COMMENT '用户编号', `rid` int(11) NOT NULL COMMENT '角色编号', PRIMARY KEY (`uid`,`rid`), KEY `FK_Reference_10` (`rid`), CONSTRAINT `FK_Reference_10` FOREIGN KEY (`rid`) REFERENCES `role` (`id`), CONSTRAINT `FK_Reference_9` FOREIGN KEY (`uid`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;# 添加用户角色数据insert into `user_role`(`uid`,`rid`) values (41,1),(45,1),(41,2); 8.5.多表查询之【多对多】8.5.1.查询用户并展示角色 修改用户实体类 User ，并添加角色实体类 Role，为了能体现出多对多的关系，两个实体类都必须包含对方的一个集合引用（多对多关系其实看成是双向的一对多关系） 123456789101112131415161718public class User implements Serializable &#123; /** * 多对多关系映射：包含对方的集合引用 */ private List&lt;Role&gt; roles; // get set 方法 &#125;public class Role implements Serializable &#123; private Integer roleId; private String roleName; private String roleDesc; /** * 多对多关系映射：持有对方集合引用 */ private List&lt;User&gt; users; // get set 方法&#125; 编写 SQL 语句在查询用户的时候可以把用户所拥有的角色信息展示出来，为了确保所有用户（无论是否具有角色）都可以被查询出来，应该使用左连接 123SELECT u.*, r.id as rid, r.role_name, r.role_desc FROM user u LEFT OUTER JOIN user_role ur ON u.id = ur.uid LEFT OUTER JOIN role r ON ur.rid = r.id; 编写接口层和映射文件 12/**查询所有用户信息，包含用户所拥有的角色信息 */List&lt;User&gt; listUsersWithRoles(); 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"top.carpenter.dao.IUserDao\"&gt; &lt;resultMap id=\"UserWithRolesMap\" type=\"top.carpenter.pojo.User\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"username\" column=\"username\"/&gt; &lt;result property=\"sex\" column=\"sex\"/&gt; &lt;result property=\"birthday\" column=\"birthday\"/&gt; &lt;result property=\"address\" column=\"address\"/&gt; &lt;!-- 配置user对象中roles集合的映射 --&gt; &lt;collection property=\"roles\" ofType=\"top.carpenter.pojo.Role\"&gt; &lt;id property=\"roleId\" column=\"rid\"/&gt; &lt;result property=\"roleName\" column=\"role_name\"/&gt; &lt;result property=\"roleDesc\" column=\"role_desc\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询所有用户，并且带有角色信息 --&gt; &lt;select id=\"listUsersWithRoles\" resultMap=\"UserWithRolesMap\"&gt; SELECT u.*, r.id as rid, r.role_name, r.role_desc FROM user u LEFT OUTER JOIN user_role ur ON u.id = ur.uid LEFT OUTER JOIN role r ON ur.rid = r.id &lt;/select&gt;&lt;/mapper&gt; 测试代码和运行结果如下 12345678/** * 测试查询带有角色的用户信息 */@Testpublic void testListUsersWithRoles()&#123; List&lt;User&gt; users = userDao.listUsersWithRoles(); users.forEach(System.out::println);&#125; 8.5.2.查询角色并展示用户123SELECT u.*, r.id as rid, r.role_name, r.role_desc FROM role r LEFT OUTER JOIN user_role ur ON r.id = ur.rid LEFT OUTER JOIN user u ON ur.uid = u.id; 接口层代码及映射文件如下 1234public interface IRoleDao &#123; /**查询所有角色，带有用户信息*/ List&lt;Role&gt; listAllRoles();&#125; 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"top.carpenter.dao.IRoleDao\"&gt; &lt;resultMap id=\"RoleWithUsersMap\" type=\"top.carpenter.pojo.Role\"&gt; &lt;id property=\"roleId\" column=\"rid\"/&gt; &lt;result property=\"roleName\" column=\"role_name\"/&gt; &lt;result property=\"roleDesc\" column=\"role_desc\"/&gt; &lt;!-- 配置role对象中users集合的映射 --&gt; &lt;collection property=\"users\" ofType=\"top.carpenter.pojo.User\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"username\" column=\"username\"/&gt; &lt;result property=\"sex\" column=\"sex\"/&gt; &lt;result property=\"birthday\" column=\"birthday\"/&gt; &lt;result property=\"address\" column=\"address\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询所有角色，并且带有用户信息 --&gt; &lt;select id=\"listAllRoles\" resultMap=\"RoleWithUsersMap\"&gt; SELECT u.*, r.id as rid, r.role_name, r.role_desc FROM role r LEFT OUTER JOIN user_role ur ON r.id = ur.rid LEFT OUTER JOIN user u ON ur.uid = u.id &lt;/select&gt;&lt;/mapper&gt; 9.Mybatis 中的延迟加载9.1 延迟加载和立即加载 假如此时我们有 1 个用户，该用户拥有 100 个账户，那么问题来了： 当我们查询该用户的时候，要不要把关联的账户也一起查询出来？ 当我们查询某个账户的时候，要不要把关联的用户一起查询出来？ 答案很简单。在查询用户的时候，用户所拥有的账户信息应该是需要使用的时候才去查询，不然每次查询该用户的时候，都要查询他拥有的账户，那么开销无疑是比较大的；而在查询账户的时候，由于每个账户对应一个用户，所以应该让用户信息随账户信息一并查询出来，否则别人不知道该账户属于谁。 延迟加载 延迟加载就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据，延迟加载也称懒加载。 在一对多或多对多的表关系中，通常情况下我们都是采用延迟加载。 立即加载 立即加载就是不管是否需要数据，只要一进行查询，就会把相关联的数据一并查询出来。 在多对一或一对一的表关系中，通常情况下我们都是采用立即加载 9.2.一对一实现延迟加载 实现以下需求： 如果不需要使用用户信息的话，那么只查询账户信息；只有当需要使用用户信息时，才去关联查询 首先在 Mybatis 的配置文件中开启延迟加载 12345 &lt;!-- 开启延迟加载 --&gt;&lt;settings&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt;&lt;/settings&gt; 账户映射文件 AccountMapper.xml 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"top.carpenter.dao.IAccountDao\"&gt; &lt;!-- 定义可以封装带有User的Account的 resultMap --&gt; &lt;resultMap id=\"AccountWithUserMap\" type=\"top.carpenter.pojo.Account\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"uid\" column=\"uid\"/&gt; &lt;result property=\"money\" column=\"money\"/&gt; &lt;!-- 关联 User 对象 --&gt; &lt;association property=\"user\" javaType=\"user\" select=\"top.carpenter.dao.IUserDao.findById\" column=\"uid\"&gt;&lt;/association&gt; &lt;/resultMap&gt; &lt;!-- 配置查询所有账户，延迟加载用户信息 --&gt; &lt;select id=\"findAll\" resultMap=\"AccountWithUserMap\"&gt; select * from account &lt;/select&gt; &lt;select id=\"getAccountByUid\" parameterType=\"int\" resultType=\"top.carpenter.pojo.Account\"&gt; SELECT * FROM account WHERE uid = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; &lt;association&gt;&lt;/association&gt; 标签中的 select 属性表示我们要调用的映射语句的 ID，它会从 column 属性指定的列中检索数据，作为参数传递给目标 select 语句。 column 属性指定传递给我们要调用的映射语句的参数。 top.carpenter.dao.IUserDao.findById 的映射文件如下 123456&lt;mapper namespace=\"top.carpenter.dao.IUserDao\"&gt; &lt;!-- 查询单个用户 --&gt; &lt;select id=\"findById\" parameterType=\"int\" resultType=\"user\"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 不会把所有的账户信息连同用户信息一并查询出来。而是打印Account 对象，其中调用了 User 对象，才会进行查询。 123456 @Test public void TestAccount() &#123; List&lt;Account&gt; all = accountDao.findAll();// all.forEach(System.out::println); &#125; 9.3 一对多实现立即加载 实现以下需求： 当查询用户信息时使用延迟加载。也就是说，如果不需要使用账户信息的话，那么只查询用户信息；只有当需要使用账户信息时，才去关联查询 还是一样先修改 账户 的映射文件，不同的是现在是使用 &lt;collection&gt;&lt;/collection&gt; 进行延迟加载 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"top.carpenter.dao.IUserDao\"&gt; &lt;!-- 配置 resultMap ，完成实体类与数据库表的映射 --&gt; &lt;resultMap id=\"UserWithAccountsMap\" type=\"top.carpenter.pojo.User\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"username\" column=\"username\"/&gt; &lt;result property=\"sex\" column=\"sex\"/&gt; &lt;result property=\"birthday\" column=\"birthday\"/&gt; &lt;result property=\"address\" column=\"address\"/&gt; &lt;!-- 配置user对象中accounts集合的映射 --&gt; &lt;collection property=\"accounts\" ofType=\"Account\" select=\"top.carpenter.dao.IAccountDao.getAccountByUid\" column=\"id\"&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 配置查询所有用户，延迟加载账户信息 --&gt; &lt;select id=\"findAll\" resultMap=\"UserWithAccountsMap\"&gt; select * from user &lt;/select&gt; &lt;select id=\"findById\" parameterType=\"int\" resultType=\"user\"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 在账户实体类对应的接口层及配置文件中添加对应的方法 1234/** * 根据用户id查询账户 */Account getAccountByUid(Integer uid); 123456&lt;mapper namespace=\"top.carpenter.dao.IAccountDao\"&gt; &lt;!-- 根据用户id查询账户 --&gt; &lt;select id=\"getAccountByUid\" parameterType=\"int\" resultType=\"top.carpenter.pojo.Account\"&gt; SELECT * FROM account WHERE uid = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 运行结果 123456 @Test public void TestUser() &#123; List&lt;User&gt; all = userDao.findAll();// all.forEach(System.out::println); &#125; 10.Mybatis 中的缓存 什么是缓存？ 缓存就是存在于内存中的临时数据。 为什么要使用缓存？ 为了减少和数据库交互的次数，提高执行效率。 适用于缓存的数据 经常查询并且不经常改变的数据。 数据的正确与否对最终结果影响不大的。 不适用于缓存的数据 经常改变的数据。 数据的正确与否对最终结果影响很大的。例如：商品的库存、银行的汇率、股市的牌价等。 10.1Mybatis 的一级缓存 一级缓存是 SqlSession 级别的缓存，只要 SqlSession 没有 flush 或 close，它就会存在。 Mybatis 默认就是使用一次缓存的，不需要配置。 一级缓存中存放的是对象。（一级缓存其实就是 Map 结构，直接存放对象） 当调用 SqlSession 的修改、添加、删除、commit()、close()、clearCache() 等方法时，就会清空一级缓存。 一级缓存流程如下图 第一次发起查询用户 id 为 1 的用户信息，Mybatis 会先去找缓存中是否有 id 为 1 的用户信息，如果没有，从数据库查询用户信息。 得到用户信息，将用户信息存储到一级缓存中。 如果 sqlSession 去执行 commit 操作（执行插入、更新、删除），那么 Mybatis 就会清空 SqlSession 中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 第二次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，缓存中有，直接从缓存中获取用户信息。 12345System.out.println(\"=======================================\");List&lt;User&gt; all = userDao.findAll();System.out.println(\"=======================================\");List&lt;User&gt; all1 = userDao.findAll();System.out.println(all == all1); 10.2.Mybatis 的二级缓存 二级缓存是 Mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 SQL 语句，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。 当我们使用二级缓存的时候，所缓存的类一定要实现 java.io.Serializable 接口，这样才可以使用序列化的方式来保存对象。 由于是序列化保存对象，所以二级缓存中存放的是数据，而不是整个对象。 二级缓存流程如下图 当 sqlSession1 去查询用户信息的时候，Mybatis 会将查询数据存储到二级缓存中。 如果 sqlSession3 去执行相同 Mapper 映射下的 SQL 语句，并且执行 commit 提交，那么 Mybatis 将会清空该 Mapper 映射下的二级缓存区域的数据。 sqlSession2 去查询与 sqlSession1 相同的用户信息，Mybatis 首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据。 如果想使用 Mybatis 的二级缓存，那么应该做以下配置 让Mybatis框架支持二级缓存(在SqlMapConfig. xml中配置) 1234&lt;settings&gt; &lt;!-- 开启缓存 --&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt; 让当前的映射文件支持二级缓存(在IUserDao. xml中配置) 1234&lt;mapper namespace=\"top.carpenter.dao.IUserDao\"&gt; &lt;!-- 使用缓存 --&gt; &lt;cache/&gt;&lt;/mapper&gt; 让当前的操作支持二级缓存（针对每次查询都需要最新数据的操作，要设置成 useCache=”false”，禁用二级缓存） 123&lt;select id=\"listAllUsers\" resultMap=\"UserWithAccountsMap\" useCache=\"true\"&gt; SELECT * FROM user&lt;/select&gt; 1234567891011121314151617System.out.println(\"====================================\");SqlSession session = factory.openSession();IUserDao userDao = session.getMapper(IUserDao.class);List&lt;User&gt; all = userDao.findAll();session.close();System.out.println();System.out.println(\"====================================\");SqlSession session1 = factory.openSession();IUserDao userDao1 = session1.getMapper(IUserDao.class);List&lt;User&gt; all1 = userDao1.findAll();System.out.println();System.out.println(\"====================================\");System.out.println(all == all1);session1.close(); 11.Mybatis 中的注解开发 在 Mybatis 的注解开发中，常用的注解如下表所示： 注解 作用 @Intsert 实现新增 @Update 实现更新 @Delete 实现删除 @Select 实现查询 @Results 实现结果集封装 @ResultMap 实现引用 @Results 定义的封装 @One 实现一对一结果集封装 @Many 实现一对多结果集封装 @SelectProvider 实现动态 SQL 映射 @CacheNamespace 实现注解二级缓存的使用 11.1.Mybatis 使用注解实现单表 CURD 用户实体类接口层 IUserDao代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public interface IUserDao &#123; /** * 查询所有用户 */ @Select(\"SELECT * FROM user\") List&lt;User&gt; listAllUsers(); /** * 添加用户 * @return 成功返回1，失败返回0 */ @Insert(\"INSERT INTO user(username,birthday,sex,address) VALUES(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)\") @SelectKey(keyProperty = \"id\", keyColumn = \"id\", statement = \"SELECT LAST_INSERT_ID()\", resultType = Integer.class, before = false) int saveUser(User user); /** * 根据id删除用户 * @return 成功返回1，失败返回0 */ @Delete(\"DELETE FROM user WHERE id = #&#123;id&#125;\") int removeUserById(Integer userId); /** * 修改用户 * @return 成功返回1，失败返回0 */ @Update(\"UPDATE user SET username = #&#123;username&#125;, birthday = #&#123;birthday&#125;, sex = #&#123;sex&#125;, address = #&#123;address&#125; WHERE id = #&#123;id&#125;\") int updateUser(User user); /** * 根据id查询单个用户 * @return */ @Select(\"SELECT * FROM user WHERE id = #&#123;id&#125;\") User getUserById(Integer userId); /** * 根据姓名模糊查询多个用户 * @return */ @Select(\"SELECT * FROM user WHERE username LIKE CONCAT('%',#&#123;username&#125;,'%')\") List&lt;User&gt; listUsersByName(String username); /** * 查询用户总数 * @return */ @Select(\"SELECT COUNT(id) FROM user\") int countUser();&#125; 如果此时实体类的属性与数据库表列名不一致，那么我们应该使用@Results、@Result、@ResultMap 等注解 @Results 注解：定义映射结果集【等价xml标签 &lt;resultMap&gt;&lt;/resultMap&gt;】 id属性为唯一标识。 value属性用于接收 @Result[]注解类型的数组。 @Result 注解：定义映射关系【等价xml标签 &lt;id/&gt; &lt;result/&gt;】 id属性指定主键 property属性指定实体类的属性名 column属性指定数据库表中对应的列 @ResultMap 注解：引用 @Results 定义的映射结果集，避免了重复定义映射结果集。 1234567891011121314151617181920public interface IUserDao&#123; /** * 查询所有用户 * User类中已经将属性修改 此时与数据库无法对于 * @return */ @Select(\"SELECT * FROM user\") @Results(id = \"UserMap\",value = &#123; @Result(id = true,property = \"userId\",column = \"id\"), @Result(property = \"userName\",column = \"username\"), @Result(property = \"userBirthday\",column = \"birthday\"), @Result(property = \"userSex\",column = \"sex\"), @Result(property = \"userAddress\",column = \"address\"), &#125;) List&lt;User&gt; listAllUsers(); @Insert(\"INSERT INTO user(username,birthday,sex,address) VALUES(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)\") @ResultMap(\"UserMap\") // **** int saveUser(User user); 11.2.Mybatis 使用注解实现多对一（一对一） 账户实体类和用户实体类与xml配置相同 @One注解：在注解中用来指定子查询返回单一对象【等价xml标签&lt;association&gt;&lt;/association&gt;】 select属性指定用于查询的接口方法 fetchType属性用于指定立即加载或延迟加载 FetchType.EAGER FetchType.LAZY 在包含@one注解的@Result中，column属性用于指定将要作为参数进行查询的数据库表列。 123456789101112131415public interface IAccountDao &#123; /** * 查询所有账户，并查询所属用户，采用立即加载 * * @return */ @Select(\"SELECT * FROM account\") @Results(id = \"AccountMap\", value = &#123; @Result(id = true, property = \"id\", column = \"id\"), @Result(property = \"uid\", column = \"uid\"), @Result(property = \"user\", column = \"uid\", one = @One(select = \"top.carpenter.dao.IUserDao.getUserById\", fetchType = FetchType.EAGER)) &#125;) List&lt;Account&gt; listAllAccounts();&#125; 1234public interface IUserDao &#123; @Select(\"SELECT * FROM user WHERE id = #&#123;id&#125;\") User getUserById(Integer userId);&#125; 11.3.Mybatis 使用注解实现一对多 为用户实体类添加包含账户实体类的集合引用 @Many 注解相当于标签 &lt;collection&gt;&lt;/collection&gt;，是多表查询的关键，在注解中用来指定子查询返回对象集合。 其中，select 属性指定用于查询的接口方法，fetchType 属性用于指定立即加载或延迟加载，分别对应 FetchType.EAGER 和 FetchType.LAZY 在包含 @Many 注解的 @Result 中，column 属性用于指定将要作为参数进行查询的数据库表列。 1234567891011121314151617public interface IUserDao &#123; /** * 查询所有用户，并且查询拥有账户，采用延迟加载 * * @return */ @Select(\"SELECT * FROM user\") @Results(id = \"UserMap\", value = &#123; @Result(id = true, property = \"userId\", column = \"id\"), @Result(property = \"userName\", column = \"username\"), @Result(property = \"userBirthday\", column = \"birthday\"), @Result(property = \"userSex\", column = \"sex\"), @Result(property = \"userAddress\", column = \"address\"), @Result(property = \"accounts\", column = \"id\", many = @Many(select = \"top.carpenter.dao.IAccountDao.getAccountByUid\", fetchType = FetchType.LAZY)) &#125;) List&lt;User&gt; listAllUsers(); 12345678910public interface IAccountDao &#123; /** * 根据用户id查询账户列表 * * @param uid * @return */ @Select(\"SELECT * FROM account WHERE uid = #&#123;uid&#125;\") List&lt;Account&gt; listAccountsByUid(Integer uid);&#125; 11.4.Mybatis 使用注解实现二级缓存 如果使用注解时想开启二级缓存，那么首先应该在 Mybatis 配置文件中开启全局配置 1234&lt;settings&gt; &lt;!-- 开启缓存 --&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt; 在持久层接口中使用注解即可 1234@CacheNamespace(blocking = true)public interface IUserDao &#123; // .....&#125;","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://goldcarpenter.github.io/tags/MyBatis/"}]},{"title":"多线程编程","date":"2019-08-14T16:00:00.000Z","path":"2019/08/15/多线程_Part8/","text":"7. 共享模型之不可变 对象内有成员变量处于共享代码中，但是其不可改变，依然是线程安全的 7.1 日期转换的问题问题提出下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的 12345678910SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; try &#123; log.debug(\"&#123;&#125;\", sdf.parse(\"1951-04-21\")); &#125; catch (Exception e) &#123; log.error(\"&#123;&#125;\", e); &#125; &#125;).start();&#125; 很大几率出现java.lang.NumberFormatException 或者出现不正确的日期解析结果 解决思路 - 同步锁这样虽能解决问题，但带来的是性能上的损失，并不算很好： 123456789101112SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; synchronized (sdf) &#123; try &#123; log.debug(\"&#123;&#125;\", sdf.parse(\"1951-04-21\")); &#125; catch (Exception e) &#123; log.error(\"&#123;&#125;\", e); &#125; &#125; &#125;).start();&#125; 解决思路 - 不可变对象【另一种避免竞争的方式】如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改啊！这样的对象在 Java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类： 1234567DateTimeFormatter stf = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; TemporalAccessor parse = stf.parse(\"1951-04-21\"); log.debug(\"&#123;&#125;\", parse); &#125;).start();&#125; 7.2 不可变设计 （String 类为例）另一个大家更为熟悉的 String 类也是不可变的，以它为例，说明一下不可变设计的要素 12345678public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0 //... 7.2.1 使用 final 发现类中所有属性都是 final 属性用 final 修饰保证了该属性是只读的，不能修改 类用 final 修饰保证了该类中的方法不能被覆盖 防止子类无意间破坏不可变性 针对数组采用复制新的数组的方式【对于数组 final关键字仅仅对引用地址有效】 1234567final int[] arr = new int[10];System.out.println(arr);arr[0] = 0; // 依然可以修改arr[3] = 3;int[] ints = new int[3];// arr = ints; ✖System.out.println(ints); 7.2.2 保护性拷贝 使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例： 12345678910public String substring(int beginIndex) &#123; //有效性判断... return (beginIndex == 0) ? this : new String(value, beginIndex, subLen); &#125; public String(char value[], int offset, int count) &#123; //有效性判断... this.value = Arrays.copyOfRange(value, offset, offset+count); &#125; 构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive copy）】 数组创建——保证了不与传入的数组对象指向同一引用 123public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length);&#125; 7.2.3 享元模式 原因：保护性拷贝导致对象创建频繁，对象个数较多 目的：当需要重用数量有限的同一类对象 2.1 包装类 在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的 valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象： 1234567public static Long valueOf(long l) &#123; final int offset = 128; if (l &gt;= -128 &amp;&amp; l &lt;= 127) &#123; // will cache return LongCache.cache[(int)l + offset]; &#125; return new Long(l);&#125; Byte, Short, Long 缓存的范围都是 -128~127 Character 缓存的范围是 0~127 Integer的默认范围是 -128~127 最小值不能变但最大值可以通过调整虚拟机参数 -Djava.lang.Integer.IntegerCache.high 来改变 Boolean 缓存了 TRUE 和 FALSE 2.2 String 串池2.3 BigDecimal BigInteger2.4[实例]自定义数据库连接池仅使用乐观锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; public static void main(String[] args) &#123; Pool pool = new Pool(2); for (int i = 0; i &lt; 5; i++) &#123; new Thread(() -&gt; &#123; Connection conn = pool.borrow(); try &#123; Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; pool.free(conn); &#125;).start(); &#125; &#125;&#125;@Slf4j(topic = \"c.Pool\")class Pool &#123; // 1. 连接池大小 private final int poolSize; // 2. 连接对象数组 private Connection[] connections; // 3. 连接状态数组 0 表示空闲， 1 表示繁忙 private AtomicIntegerArray states; // 4. 构造方法初始化 public Pool(int poolSize) &#123; this.poolSize = poolSize; this.connections = new Connection[poolSize]; this.states = new AtomicIntegerArray(new int[poolSize]); for (int i = 0; i &lt; poolSize; i++) &#123; connections[i] = new MyConnection(\"连接\" + (i+1)); &#125; &#125; // 5. 借连接 public Connection borrow() &#123; while(true) &#123; for (int i = 0; i &lt; poolSize; i++) &#123; // 获取空闲连接 if(states.get(i) == 0) &#123; if (states.compareAndSet(i, 0, 1)) &#123; log.debug(\"borrow &#123;&#125;\", connections[i]); return connections[i]; &#125; &#125; &#125; // 优化：如果没有空闲连接，当前线程进入等待 synchronized配合cas防止CPU长时间空转 可以打开注释/* synchronized (this) &#123; try &#123; log.debug(\"wait...\"); this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;*/ &#125; // 6. 归还连接 public void free(Connection conn) &#123; for (int i = 0; i &lt; poolSize; i++) &#123; if (connections[i] == conn) &#123; states.set(i, 0); /*synchronized (this) &#123; log.debug(\"free &#123;&#125;\", conn); this.notifyAll(); &#125;*/ break; &#125; &#125; &#125;&#125; 仅使用悲观锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Slf4j(topic = \"c.Pool\")class Pool &#123; // 1. 连接池大小 private final int poolSize; // 2. 连接对象数组 private Connection[] connections; // 3. 连接状态数组 0 表示空闲， 1 表示繁忙 private int[] states; // 4. 构造方法初始化 public Pool(int poolSize) &#123; this.poolSize = poolSize; this.connections = new Connection[poolSize]; this.states = new int[poolSize]; for (int i = 0; i &lt; poolSize; i++) &#123; connections[i] = new MockConnection(\"连接\" + (i+1)); &#125; &#125; // 5. 借连接 public Connection borrow() &#123; Connection connection = null; synchronized (states) &#123; while (connection==null) &#123; for (int i = 0; i &lt; poolSize; i++) &#123; // 获取空闲连接 if(states[i] == 0) &#123; states[i]=1; connection = connections[i]; log.debug(\"borrow &#123;&#125;\", connection); return connection; &#125; &#125; try &#123; log.debug(\"wait...\"); states.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return connection; &#125; // 6. 归还连接 public void free(Connection conn) &#123; for (int i = 0; i &lt; poolSize; i++) &#123; if (connections[i] == conn) &#123; states[i] = 0; synchronized (states) &#123; log.debug(\"free &#123;&#125;\", conn); states.notifyAll(); &#125; break; &#125; &#125; &#125;&#125; 7.3 无状态 在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这种没有任何成员变量的类是线程安全的 因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】","tags":[{"name":"多线程","slug":"多线程","permalink":"http://goldcarpenter.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"多线程编程","date":"2019-08-12T15:14:22.000Z","path":"2019/08/12/多线程_Part7/","text":"6共享模型之无锁6.1CAS引入 案例引入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MultiThread &#123; public static void main(String[] args) &#123; Account account = new Account(10000); ArrayList&lt;Thread&gt; threads = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 1000; i++) &#123; threads.add(new Thread(()-&gt;&#123; account.withdraw(10); &#125;)); &#125; threads.forEach(Thread::start); threads.forEach(t -&gt; &#123; try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); System.out.println(account.getMoney()); &#125;&#125;class Account&#123; private AtomicInteger money; public Account(int money) &#123; this.money = new AtomicInteger(money); //⭐原子整数类 &#125; public Integer getMoney() &#123; return money.get(); &#125; public void withdraw(Integer amount) &#123; /*while(true) &#123; // 获取余额的最新值 int prev = balance.get(); // 要修改的余额 int next = prev - amount; // 真正修改 if(balance.compareAndSet(prev, next)) &#123; break; &#125; &#125;*/ money.getAndAdd(-1 * amount); &#125;&#125; CAS原理前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？ 123456789101112public void withdraw(Integer amount) &#123; while(true) &#123; int 旧值 = balance.get(); // 从主存读取到工作内存 int 新值 = 旧值 - amount; // 真正修改 if(balance.compareAndSet(旧值, 新值)) &#123; break; &#125; /*compareAndSet 正是做这个检查， 在 set 前，先比较 旧值 与当前值 ①不一致了，新值 作废，返回 false表示失败 比如，别的线程已经做了减法，当前值已经被减成了 990 那么本线程的这次 990 就作废了，进入 while 下次循环重试 ②一致，以 新值 设置为新值，返回 true 表示成功 */ 其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。 其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。 在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。 volatile 可以用来修饰成员变量和静态成员变量，可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。 CAS 底层必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果 CAS 的特点 结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。 CAS 体现的是无锁并发、无阻塞并发 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响 乐观锁 &amp; 悲观锁 CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再 重试呗。 synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想 改，我改完了解开锁，你们才有机会。 6.2 原子操作类原子整数 J.U.C (java.util.concurrent) 中提供了原子操作类，可以提供线程安全的操作，例如: AtomicInteger.AtomicBoolean，AtomicLong等，它们底层就是采用CAS技术+ volatile实现的。 123456789101112131415161718192021222324252627282930 AtomicInteger i = new AtomicInteger(5); i.incrementAndGet(); // ++i 1 i.getAndIncrement(); // i++ 2 i.getAndAdd(5); // 2 , 7 i.addAndGet(5); // 12, 12*/// 读取到 设置值// i.updateAndGet(value -&gt; value * 10);//函数式接口 i.updateAndGet(new IntUnaryOperator() &#123; @Override public int applyAsInt(int operand) &#123; int newValue = operand * 8; return newValue; &#125; &#125;);/* public final int updateAndGet(IntUnaryOperator updateFunction) &#123; int prev, next; do &#123; prev = get(); next = updateFunction.applyAsInt(prev); &#125; while (!compareAndSet(prev, next)); return next; &#125;*/ i.getAndAccumulate(10, (p, x) -&gt; p + x) 原子引用 AtomicReference AtomicMarkableReference AtomicStampedReference ABA 问题及解决12345678910111213141516171819202122 static AtomicReference&lt;String&gt; ref = new AtomicReference&lt;&gt;(\"A\"); public static void main(String[] args) &#123; String pre = ref.get(); other(); Sleeper.sleep(1); log.debug(\"change A-&gt;C &#123;&#125;\", ref.compareAndSet(pre, \"C\")); &#125; private static void other() &#123; new Thread(() -&gt; &#123; log.debug(\"change A-&gt;B &#123;&#125;\", ref.compareAndSet(ref.get(), \"B\")); &#125;, \"t1\").start(); Sleeper.sleep(0.5); new Thread(() -&gt; &#123; log.debug(\"change B-&gt;A &#123;&#125;\", ref.compareAndSet(ref.get(), \"A\")); &#125;, \"t2\").start(); &#125;/*23:49:13.277 [t1] MultiThread - change A-&gt;B true23:49:13.778 [t2] MultiThread - change B-&gt;A true23:49:14.779 [main] MultiThread - change A-&gt;B true*/ 主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程 希望：只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号 AtomicStampedReference 12345678910111213141516171819202122232425262728static AtomicStampedReference&lt;String&gt; ref = new AtomicStampedReference&lt;&gt;(\"A\",0);public static void main(String[] args) &#123; String pre = ref.getReference(); int stamp = ref.getStamp(); other(); Sleeper.sleep(1); log.debug(\"change A-&gt;C &#123;&#125;\", ref.compareAndSet(pre, \"C\",stamp,stamp+1));&#125;private static void other() &#123; new Thread(() -&gt; &#123; log.debug(\"change A-&gt;B &#123;&#125;\", ref.compareAndSet(ref.getReference(), \"B\", ref.getStamp(), ref.getStamp() + 1)); log.debug(\"更新版本为 &#123;&#125;\", ref.getStamp()); &#125;, \"t1\").start(); Sleeper.sleep(0.5); new Thread(() -&gt; &#123; log.debug(\"change B-&gt;A &#123;&#125;\", ref.compareAndSet(ref.getReference(), \"A\", ref.getStamp(), ref.getStamp() + 1)); log.debug(\"更新版本为 &#123;&#125;\", ref.getStamp()); &#125;, \"t2\").start();&#125;/* 23:53:52.695 [t1] MultiThread - change A-&gt;B true 23:53:52.702 [t1] MultiThread - 更新版本为 1 23:53:53.148 [t2] MultiThread - change B-&gt;A true 23:53:53.148 [t2] MultiThread - 更新版本为 2 23:53:54.165 [main] MultiThread - change A-&gt;B false */ AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt; C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了 AtomicMarkableReference 如果修改引用对象内容，而不是引用地址，则原子引用就会失效 原子数组 AtomicIntegerArray AtomicLongArray AtomicReferenceArray 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static void main(String[] args) &#123; demo( ()-&gt;new int[10], (array)-&gt;array.length, (array, index) -&gt; array[index]++, array-&gt; System.out.println(Arrays.toString(array)) ); demo( ()-&gt; new AtomicIntegerArray(10), //创建原子数组 (array) -&gt; array.length(), (array, index) -&gt; array.getAndIncrement(index), // 数组元素自增 array -&gt; System.out.println(array) );&#125;/** 参数1，提供数组、可以是线程不安全数组或线程安全数组 参数2，获取数组长度的方法 参数3，自增方法，回传 array, index 参数4，打印数组的方法**/// supplier 提供者 无中生有 ()-&gt;结果// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;private static &lt;T&gt; void demo( Supplier&lt;T&gt; arraySupplier, Function&lt;T, Integer&gt; lengthFun, BiConsumer&lt;T, Integer&gt; putConsumer, Consumer&lt;T&gt; printConsumer ) &#123; List&lt;Thread&gt; ts = new ArrayList&lt;&gt;(); T array = arraySupplier.get(); // 获取被操作的数组 Integer length = lengthFun.apply(array); for (int i = 0; i &lt; length; i++) &#123; // 每个线程对数组作 10000 次操作 ts.add(new Thread(() -&gt; &#123; for (int j = 0; j &lt; 10000; j++) &#123; putConsumer.accept(array, j%length); //数组每一个元素+1 10个线程每个1000次 &#125; &#125;)); &#125; ts.forEach(t -&gt; t.start()); // 启动所有线程 ts.forEach(t -&gt; &#123; try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); // 等所有线程结束 printConsumer.accept(array); // 打印数组&#125;//[9820, 9840, 9800, 9821, 9814, 9820, 9836, 9801, 9813, 9807]//[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000] 字段更新器 利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常 AtomicReferenceFieldUpdater // 域字段 12345678910111213141516public class Test40 &#123; public static void main(String[] args) &#123; Student stu = new Student(); AtomicReferenceFieldUpdater updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, \"name\"); System.out.println(updater.compareAndSet(stu, null, \"张三\"));//true System.out.println(stu);//Student&#123;name='张三'&#125; &#125;&#125;class Student &#123; volatile String name; //*****&#125; AtomicIntegerFieldUpdater //字段为整形 AtomicLongFieldUpdater //字段为长整形 原子累加器 对数字进行累加操作，比AtomicInteger的累加操作性能高很多 LongAdder LongAccumulator 累加器性能比较 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; demo( () -&gt; new AtomicLong(0), AtomicLong::getAndIncrement ); &#125; for (int i = 0; i &lt; 5; i++) &#123; demo( LongAdder::new, LongAdder::increment ); &#125; &#125; /* () -&gt; 结果 提供累加器对象 (参数) -&gt; 执行累加操作 */ private static &lt;T&gt; void demo(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action) &#123; T adder = adderSupplier.get(); List&lt;Thread&gt; ts = new ArrayList&lt;&gt;(); // 4 个线程，每个累加 50 万 for (int i = 0; i &lt; 4; i++) &#123; ts.add(new Thread(() -&gt; &#123; for (int j = 0; j &lt; 500000; j++) &#123; action.accept(adder); &#125; &#125;)); &#125; long start = System.nanoTime(); ts.forEach(Thread::start); ts.forEach(t -&gt; &#123; try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); long end = System.nanoTime(); System.out.println(adder + \" cost:\" + (end - start) / 1000_000); &#125;/*2000000 cost:292000000 cost:5 *///有很高的性能提升 性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。 LongAdder原理见单独插页UnSafe类概述 CAS底层依赖于 Unsafe 类来直接调用操作系统底层的CAS指令 Unsafe 对象提供了非常底层的，操作内存、线程的方法【CAS park unpark AtomicInteger中incrementAndGet…】，Unsafe 对象不能直接调用，只能通过反射获得 是线程安全的，Unsafe字面为不建议使用的意思，过于底层 UnSafe CAS操作方法123456789101112131415161718192021222324252627public class TestUnsafe &#123; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123; //Unsafe 对象不能直接调用，只能通过反射获得 Field theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\"); theUnsafe.setAccessible(true); Unsafe unsafe = (Unsafe) theUnsafe.get(null); System.out.println(unsafe); // 1. 获取域的偏移地址 long idOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(\"id\")); long nameOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField(\"name\")); Teacher t = new Teacher(); // 2. 执行 cas 操作 unsafe.compareAndSwapInt(t, idOffset, 0, 1); unsafe.compareAndSwapObject(t, nameOffset, null, \"张三\"); // 3. 验证 System.out.println(t); &#125;&#125;@Dataclass Teacher &#123; volatile int id; volatile String name;&#125; UnSafe 操作内存方法 不在本专题内 自定义原子整数类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; public static void main(String[] args)&#123; &#125;&#125;class MyAtomicInteger&#123; private volatile int value; private static final long valueOffset; private static final Unsafe UNSAFE; static &#123; UNSAFE = UnsafeAccessor.getUnsafe(); try &#123; valueOffset = UNSAFE.objectFieldOffset(MyAtomicInteger.class.getDeclaredField(\"value\")); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; public int getValue() &#123; return value; &#125; public void decrement(int amount) &#123; while(true) &#123; int prev = this.value; int next = prev - amount; if (UNSAFE.compareAndSwapInt(this, valueOffset, prev, next)) &#123; break; &#125; &#125; &#125; public MyAtomicInteger(int value) &#123; this.value = value; &#125;&#125;//工具类 方便获取Unsafe对象class UnsafeAccessor &#123; private static final Unsafe unsafe; static &#123; try &#123; Field theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\"); theUnsafe.setAccessible(true); unsafe = (Unsafe) theUnsafe.get(null); &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; throw new Error(e); &#125; &#125; public static Unsafe getUnsafe() &#123; return unsafe; &#125;&#125;","tags":[{"name":"多线程","slug":"多线程","permalink":"http://goldcarpenter.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"多线程编程","date":"2019-07-29T15:14:22.000Z","path":"2019/07/29/多线程_Part6/","text":"5共享模型之内存5.1 Java内存模型【JMM】 JMM即Java Memory Model,它定义了 主存：所有线程共享的数据，成员变量，静态成员变量 工作内存：每个线程所私有的数据，如局部变量 底层对应着CPU寄存器、缓存、硬件内存、CPU指令优化等。 JMM体现在以下几个方面 原子性——保证指令不会受到线程上下文切换的影响 可见性——保证指令不会受cpu缓存的影响 有序性——保证指令不会受cpu指令并行优化的影响 JMM 定义了一套在多线程读写共享数据时(成员变量、数组)时,对数据的可见性、有序性、原子性的规则和保障 5.2 可见性5.2.1 问题引入 run是存在于堆内存中的main对象中，当匿名线程开始运行的时候会把run从内存中读到线程的工作区，在运行中直接使用这个copy，并不会每次都去去读堆内存，这样，当主线程修改run值之后，线程感知不到，所以不会停止运行。 1234567891011static boolean run = true;public static void main(String[] args) &#123; Thread t = new Thread(()-&gt;&#123; while(run)&#123; // .... &#125; &#125;); t.start(); Sleeper.sleep(1); run = false; //线程t不会如预想的停下来&#125; 5.2.2 分析 初始状态， t 线程刚开始从主内存读取了static 的run 的值到工作内存。 因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会优化将 run 的值缓存至自己工作内存（CPU缓存）中的高速缓存中， 减少对主存中 run 的访问，提高效率 1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是旧值 5.2.3 问题解决方法一：volatile保证线程的可见性 在volatile修饰成员变量和静态成员变量后，将可以避免线程从自己的工作缓存中查找变量的值，会强制所有线程都去主内存中去读值 A B线程都用到一个变量，java默认是A线程中保留一份copy，如果线程B参数修改了变量，则A线程未必知道。 功能：使一个变量在多个线程之间可见，不存在一致性问题【在各个线程的工作内存中，volatile变量可能存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题】 方法二：synchronized关键字123456789101112131415161718192021222324public class MultiThread &#123; //锁对象 final static Object Lock = new Object(); static boolean run = true; public static void main(String[] args) throws InterruptedException &#123; Thread t = new Thread(()-&gt;&#123; while(true) &#123; /*synchronized (Lock) &#123;*/ // 新增*** if (!run) &#123; break; &#125; /*&#125; */ // 新增*** &#125; &#125;); t.start(); Sleeper.sleep(1); log.debug(\"停止t\"); /*synchronized (Lock) &#123;*/ run = false; //线程t会停下来 /*&#125;*/ &#125;&#125; 5.2.4可见性 vs 原子性 前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见，不能保证原子性，仅用在一个写线程，多个读线程的情况： 上例从字节码理解是这样的： 123456getstatic &#x2F;&#x2F; 线程 t 获取 run truegetstatic &#x2F;&#x2F; 线程 t 获取 run truegetstatic &#x2F;&#x2F; 线程 t 获取 run truegetstatic &#x2F;&#x2F; 线程 t 获取 run trueputstatic &#x2F;&#x2F; 线程 main 修改 run 为 false， 仅此一次getstatic &#x2F;&#x2F; 线程 t 获取 run false 比较一下之前线程安全时举的例子：两个线程一个 i++ 一个 i– ，只能保证看到最新值，不能解决指令交错 1234567891011&#x2F;&#x2F; 假设i的初始值为0 getstatic i &#x2F;&#x2F; 线程2 获取静态变量i的值 线程内i&#x3D;0getstatic i &#x2F;&#x2F; 线程1 获取静态变量i的值 线程内i&#x3D;0iconst_1 &#x2F;&#x2F; 线程1-准备常量1iadd &#x2F;&#x2F; 线程1-自增 线程内i&#x3D;1 【在操作数栈完成+1】putstatic i &#x2F;&#x2F; 线程1-将修改后的值存入静态变量i 静态变量i&#x3D;1iconst_1 &#x2F;&#x2F; 线程2-准备常量1isub &#x2F;&#x2F; 线程2-自减 线程内i&#x3D;-1putstatic i &#x2F;&#x2F; 线程2-将修改后的值存入静态变量i 静态变量i&#x3D;-1 synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 synchronized 是属于重量级操作，性能相对更低 实例 堆/栈是Java内存结构的术语 工作内存/主存是在JMM中的术语 补充：java内存模式​ Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。此处的变量与Java编程时所说的变量不一样，指包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享。 ​ Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（可以与前面将的处理器的高速缓存类比），线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如上图所示。 Q: Volatile线程不安全Q: volatile &amp; synchronized 区别1234567891011121314151617181920212223242526272829303132class Main&#123; /*volatile*/ int count = 0; void increase() &#123; for(int i = 0; i&lt; 10000; i++) count++; &#125; public static void main (String[] args) throws InterruptedException &#123; int count = 0; for(int i = 0; i &lt; 100; i++) &#123; Main main = new Main(); for(int j = 0; j &lt; 15; j++) &#123; new Thread(main::increase).start(); &#125; System.out.println(Thread.activeCount()); while(Thread.activeCount() &gt; 2) &#123; Thread.yield(); &#125; count += main.count; &#125; System.out.println(count/15); &#125;&#125;/*此程序目的在于测试结果&lt;1000000[在加入synchronized后,正常并发]附带证明：加入volatile比不加入volatile结果更小 getfield获取的是旧值*/ javap反编译分析！ 1234567//increase方法在class文件中由4条字节码指令组成//.....getfieldiconst_1iaddputfield//..... 当getfield指令把count的值取到操作数栈顶的时候，volatile关键字保证了count的值是正确的，但当执行iconst_1,iadd这些指令时，其他线程可能已经把count的值加大了，而在操作栈顶的值就变成了过期数据，所以putfield指令执行将较小的count同步回主内存中。【此处一条字节码指令，不意味着这条指令就是一个原子操作】 同步模式之Balking Balking（犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回 优化两终止模式(多线程1.md) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); myThread.start(); myThread.start(); myThread.start(); Sleeper.sleep(3); myThread.start(); myThread.stop(); &#125;&#125;@Slf4jclass MyThread &#123; private Thread mythread; private volatile boolean stop = false; private volatile boolean starting = false; void start() &#123; /*⭐⭐Balking 模式代码*/ synchronized (this) //保证多行语句的同步 需要synchronize &#123; if(starting) &#123; log.debug(\"has started\"); return; &#125; starting = true; &#125; /*⭐⭐Balking 模式代码*/ mythread = new Thread(()-&gt;&#123; while (!stop) &#123; log.debug(\"monitor\"); Thread.sleep(1000); &#125; starting = false; &#125;); mythread.start(); &#125; void stop() &#123; log.debug(\"stop\"); stop = true; mythread.interrupt(); &#125;&#125; 5.3有序性5.3.1有序性理解JVM会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码 12345static int i;static int j;// 在某个线程内执行如下赋值操作i = ...; j = ...; 可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时 123456既可以是i = ...; j = ...;也可以是j = ...; i = ...; 5.3.2CPU指令重排序优化现代 CPU 支持多级指令流水线，例如支持在一个时钟周期同时执行【干五类活】取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回的处理器，就可以称之为五级指令流水线。本质上，流水线技术并不能缩短单条指令执行的时间，但它变相提高了指令的吞吐率。 因为对第一个时钟周期EX，不会影响对第二个时钟周期ID 在不改变程序结果的前提下，这些指令的各个阶段可以通过重排序和组合来实现指令级并行 5.3.3Java级指令重排序 JIT 编译器在运行时的一些优化 123456789101112131415 int num = 0; /*volatile 避免指令重排序*/ boolean ready = false;// 线程1执行此方法 public void actor1(I_Result r) &#123; if(ready) &#123; r.r1 = num + num; &#125; else &#123; r.r1 = 1; &#125; &#125;// 线程2执行此方法 public void actor2(I_Result r) &#123; num = 2; //这两行指令 ready = true; //交换位置 出现0 &#125; 实例2 多线程下「指令重排」会影响正确性，例如著名的double-checked locking模式实现单例 1234567891011121314151617public final class Singleton &#123; private Singleton() &#123; &#125; private /*volatile 避免指令重排序*/ static Singleton INSTANCE = null; public static Singleton getInstance() &#123; //实例没创建，才会进入内部的synchronized代码块 if (INSTANCE == null) &#123; synchronized (Singleton.class) &#123; //synchronized会重排序，但 synchronized 范围内结果是保证有序性的 //也许有其它线程已经创建实例，所以再判断一次 if (INSTANCE == null) &#123; INSTANCE = new Singleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 以上的实现特点是: 懒惰实例化 首次使用getInstance()才使用synchronized加锁，后续使用时无需加锁 但在多线程环境下，上面的代码是有问题的，INSTANCE = new Singleton()对应的字节码为 12340: new #2 // class cn/itcast/jvm/t4/Singleton3: dup // 【操作数栈顶复制Singleton对象引用】4: invokespecial #3 // Method \"&lt;init&gt;\":()V 【构造方法】7: putstatic #4 // Field INSTANCE:Lcn/itcast/jvm/t4/Singleton;【赋值】 其中4 7两步的顺序不是固定的，也许jvm会优化为:先将引用地址赋值给INSTANCE后，再执行构造方法，如果两个线程tI, t2按如下时间序列执行: 123456时间1 t1 线程执行到INSTANCE = new Singleton();时间2 t1 线程分配空间，为Singleton对象生成了引用地址 (0处)时间3 t1 线程将引用地址赋值给INSTANCE, 这时INSTANCE就!= null了 (7处)时间4 t2 线程进入getInstance()方法,发现INSTANCE != null (synchronized块外) ，直接返回INSTANCE时间5 t1 线程执行Singleton的构造方法(4处) 这时t1还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么t2拿到的是将是一个未初始化完毕的单例 5.4 volatile 原理 volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence） 对 volatile 变量的写指令后会加入写屏障 对 volatile 变量的读指令前会加入读屏障 1保证可见性 写屏障（sfence）保证在该屏障之前所有的，对共享变量的改动，都同步到主存当中 12345public void actor2(I_Result r) &#123; num = 2; ready = true; // ready 是 volatile 赋值带写屏障 // 写屏障&#125; 读屏障（lfence）保证在该屏障之后所有的，对共享变量的读取，加载的是主存中最新数据 123456789public void actor1(I_Result r) &#123; // 读屏障 // ready 是 volatile 读取值带读屏障 if(ready) &#123; r.r1 = num + num; &#125; else &#123; r.r1 = 1; &#125;&#125; 2保证有序性 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后 123456public void actor2(I_Result r) &#123; num = 2; ready = true; // ready 是 volatile 赋值带写屏障 // 写屏障 // 不会出现✖ num = 2; &#125; 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前 123456789public void actor1(I_Result r) &#123; // 读屏障 // ready 是 volatile 读取值带读屏障 if(ready) &#123; r.r1 = num + num; &#125; else &#123; r.r1 = 1; &#125;&#125; volatile可以阻止重排序，synchronized会重排序，但synchronized范围内结果是保证有序性的 3不保证原子性无 4.双检查锁中volatile问题寻找问题1234567891011121314151617final class Singleton&#123; private /*volatile*/ static Singleton singleton = null; public static Singleton getInstance() &#123; if (singleton == null)//getstatic在synchronized的作用范围外，可能导致指令重排 &#123; synchronized (Singleton.class) &#123; if (singleton ==null) singleton = new Singleton(); &#125; &#125; return singleton; &#125;&#125; 123456789101112131415161718192021220: getstatic #2 &#x2F;&#x2F; Field INSTANCE:Lcn&#x2F;itcast&#x2F;n5&#x2F;Singleton;3: ifnonnull 376: ldc #3 &#x2F;&#x2F; class cn&#x2F;itcast&#x2F;n5&#x2F;Singleton8: dup9: astore_010: monitorenter 11: getstatic #2 &#x2F;&#x2F; Field INSTANCE:Lcn&#x2F;itcast&#x2F;n5&#x2F;Singleton;14: ifnonnull 2717: new #3 &#x2F;&#x2F; class cn&#x2F;itcast&#x2F;n5&#x2F;Singleton20: dup21: invokespecial #4 &#x2F;&#x2F; Method &quot;&lt;init&gt;&quot;:()V24: putstatic #2 &#x2F;&#x2F; Field INSTANCE:Lcn&#x2F;itcast&#x2F;n5&#x2F;Singleton;27: aload_0 28: monitorexit 29: goto 3732: astore_1 33: aload_0 34: monitorexit 35: aload_1 36: athrow 37: getstatic #2 &#x2F;&#x2F; Field INSTANCE:Lcn&#x2F;itcast&#x2F;n5&#x2F;Singleton;40: areturn 其中【划重点】 17 表示创建对象，将对象引用入栈 // new Singleton 20 表示复制一份对象引用 // 引用地址 21 表示利用一个对象引用，调用构造方法 24 表示利用一个对象引用，赋值给 static INSTANCE jvm 可能优化为：先执行 24，再执行 21。【synchronized会重排序，但synchronized范围内结果是保证有序性的】： 问题： t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例 问题所在：第一个 if (singleton == null) 使用了 singleton变量，getstatic是在同步块之外 问题解决 字节码上看不出来 volatile 指令的效果 第0行读屏障会确保指令重排序时，不会将读屏障之后的代码【21 24】排在读屏障之前 第24行写屏障会确保指令重排序时，不会将写屏障之前的代码【21】排在写屏障之后 即使这种情况，getstatic会get到null，进入synchronized处理逻辑 5 happens-before规则 happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结 抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见 0单线程happen-before原则 在同一个线程中，书写在前面的操作happen-before后面的操作。 1synchronized可以保证可见性 线程对m解锁之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见 12345678910111213141516static int x; static Object m = new Object(); public static void main(String[] args)&#123; new Thread(()-&gt;&#123; synchronized(m) &#123; x=10; &#125; &#125;,\"t1\").start(); new Thread(()-&gt;&#123; synchronized(m) &#123; System.out.println(x); &#125; &#125;,\"t2\").start(); &#125; 2volatile 可以保证可见性 线程对 volatile 变量的写，对接下来其它线程对该变量的读可见 12345678910volatile static int x; public static void main(String[] args)&#123; new Thread(()-&gt;&#123; x=10; &#125;,\"t1\").start(); new Thread(()-&gt;&#123; System.out.println(x); &#125;,\"t2\").start(); &#125; 3线程启动的happen-before原则 线程 start 前对变量的写，对该线程开始后对该变量的读可见【线程还没启动】 12345678static int x; public static void main(String[] args)&#123; x = 10; new Thread(()-&gt;&#123; System.out.println(x); &#125;,\"t2\").start(); &#125; 4线程终结的happen-before原则 线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待 它结束）【线程结束了数据无误】 1234567891011static int x; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; x = 10; &#125;, \"t1\"); t1.start(); t1.join(); System.out.println(x); &#125; 5线程中断的happen-before原则 线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted） 1234567891011121314151617181920212223static int x; public static void main(String[] args) &#123; Thread t2 = new Thread(()-&gt;&#123; while(true) &#123; if(Thread.currentThread().isInterrupted()) &#123; System.out.println(x); break; &#125; &#125; &#125;,\"t2\"); t2.start(); new Thread(()-&gt;&#123; Thread.sleep(2000); x=10; t2.interrupt(); &#125;,\"t1\").start(); while(!t2.isInterrupted()) &#123; Thread.yield(); &#125; System.out.println(x); &#125; 6对象创建的happen-before原则 对变量默认值（0，false，null）的写，对其它线程对该变量的读可见 7happen-before的传递性原则 具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排 12345678910111213volatile static int x; static int y; public static void main(String[] args) &#123; new Thread(()-&gt;&#123; y = 10; x = 20; &#125;,\"t1\").start(); new Thread(()-&gt;&#123; //x=20对t2可见，同时y=10也对t2可见 System.out.println(x); System.out.println(y); &#125;, \"t2\"). start(); &#125; 单例模式细究饿汉式：类加载就会导致该单实例对象被创建懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建 123456789101112131415161718// 问题1：为什么加 final // 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例 public final class Singleton implements Serializable &#123; // 问题3：为什么设置为私有? 是否能防止反射创建新的实例? private Singleton() &#123;&#125; // 问题4：这样初始化是否能保证单例对象创建时的线程安全? private static final Singleton INSTANCE = new Singleton(); // 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public public static Singleton getInstance() &#123; return INSTANCE; &#125; //问题2 反序列化发现此函数则直接返回 //public Object readResolve() &#123; // return INSTANCE; //&#125;&#125; 问题1：防止子类不适当覆盖父类方法，破坏单例 问题3：不能。通过构造器对象可以暴力反射 问题4：保证。类的静态成员变量初始化操作在类初始化阶段完成，由JVM保证线程安全 可以实现懒加载 泛型支持等。。 枚举细究 问题1：枚举单例是如何限制实例个数的 问题2：枚举单例在创建时是否有并发问题 问题3：枚举单例能否被反射破坏单例 问题4：枚举单例能否被反序列化破坏单例 问题5：枚举单例属于懒汉式还是饿汉式 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做 123enum Singleton &#123; INSTANCE;&#125; 待细化 5.5final 原理 理解了 volatile 原理，再对比 final 的实现就比较简单了 123public class TestFinal &#123; final int a = 20;&#125; 字节码 12345670: aload_0 1: invokespecial #1 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V 4: aload_0 5: bipush7: putfield #2 &#x2F;&#x2F; Field a:I&lt;-- 写屏障 10: return 发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况","tags":[{"name":"多线程","slug":"多线程","permalink":"http://goldcarpenter.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java虚拟机","date":"2019-07-23T13:37:15.000Z","path":"2019/07/23/JVM_Part4/","text":"5.类加载器5.1类加载机制 JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。 由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。 类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。 加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。 最后JVM对类进行初始化 如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类 如果类中存在初始化语句，就依次执行这些初始化语句。 类的加载是由类加载器完成的 根加载器（BootStrap） 扩展加载器（Extension） 系统加载器（System） 用户自定义类加载器（java.lang.ClassLoader的子类） 从Java 2（JDK 1.2）开始，类加载过程采取了委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。 5.2类的加载 &amp; 连接 &amp; 初试化 在Java代码中，类型的加载、连接与初始化过程都是在程序运行期间完成的 5.2.1加载 加载：查找并加载类的二进制数据 类加载器并不需要等到某个类被“首次主动使用”时再加载它 JVM规范允许类加载器在预料到某个类将在被使用时预先加载它，如果预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类是报告错误，否则类加载器就不会报告错误 将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象，用来封装类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口 将类的字节码载入方法区中，内部采用C++的instanceKlass描述java类，它的重要field有: _java_mirror——java的类镜像，例如对String来说，就是String.class，作用是把klass暴露给java使用 _super ——父类 _fields——成员变量 _methods——方法 _constants——常量池 _class_loader——类加载器 _vtable——虚方法表 _itable——接口方法表 对象、类的元数据（InstanceKlass）、类的Java镜像关系 每个Java对象的对象头里，_klass字段会指向一个VM内部用来记录类的元数据用的InstanceKlass对象； InsanceKlass里有个_java_mirror字段，指向该类所对应的Java镜像——java.lang.Class实例。 HotSpot VM会给Class对象注入一个隐藏字段“klass”，用于指回到其对应的InstanceKlass对象。 klass与mirror之间就有双向引用，可以来回导航。 这个模型里，java.lang.Class实例并不负责记录真正的类元数据，而只是对VM内部的InstanceKlass对象的一个包装供Java的反射访问用。 如果这个类还有父类没有加载，先加载父类 加载和链接可能是交替运行的 instanceKlass 这样的[元数据]是存储在方法区(1.8 后的元空间内)，但_java_mirror是存储在堆中 可以通过HSDB工具查看 符号引用 VS 直接引用 符号引用（Symbolic References）： 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。 直接引用 直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针） 相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量） 一个能间接定位到目标的句柄 直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。 5.2.2连接 验证：确保被加载的类的正确性 准备：为类的静态变量分配内存 ，并将其初试化为默认值 static变量在JDK 6存储于instanceKlass末尾，从JDK 7开始，存储于_java_mirror末尾 static变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成 如果static变量是final的基本类型 &amp; 字符串常量，那么编译阶段值就确定了（常量池中），赋值在准备阶段完成 如果static变量是final的引用类型，那么需要等待类初始化之后，赋值会在初始化阶段完成 解析：把类中的符号引用转换为直接引用 有些符号引用是在类解析阶段就会转换为直接引用，这种转换叫做静态解析，存在4种情形： 静态方法 父类方法 构造方法 私有方法(无法被重写) 以上4类方法称作非虚方法，他们是在类加载阶段就可以将符号引用转换为直接引用的 另外一些符号引用则是在每次运行期转换为直接引用，这种转换叫做动态链接，这体现为Java的多态性 123456789101112131415 /** *解析的含义 */ public class Load2 &#123; public static void main(String[] args) throws ClassNotFoundException, IOException &#123; //①loadClass 方法 仅仅加载 不会导致类的解析和初始化 ClassLoader classloader = Load2.class.getClassLoader(); Class&lt;?&gt; C = classloader.loadClass(\"cn.itcast.jvm.t3.load.C\"); //②new会导致类的解析和初始化 new C(); System.in.read(); &#125;class C &#123; D d=new D();&#125; ①loadClass 方法不会导致类的解析和初始化 ②new会导致类的解析和初始化 5.2.3（类）初始化（类）初试化：初始化即调用&lt;clinit&gt;()V ，为类的静态变量赋予正确的初始值，虚拟机会保证这个类的【构造方法】的线程安全 如果类还没有加载和连接，则先进行加载和连接 如果类存在直接父类，并且父类还没有被初试化，先初始化直接父类 在初始化一个类时 ，并不会先初始化它所实现的接口 12345678910111213141516public class Load9 &#123; public static void main(String[] args) &#123; System.out.println(MyChild5.b); &#125;&#125;interface MyParent5 &#123; //接口会被加载，不会被初始化 public static Thread thread = new Thread( ) &#123; &#123; System.out.println(\"MyParent5发生初始化\") ; &#125; &#125;;&#125;class MyChild5 implements MyParent5 &#123; public static int b = 5;&#125;//5 在初始化一个接口时，并不会先初始化它的父接口 123456789101112131415interface MyParent5 &#123; public static Thread thread = new Thread( ) &#123; &#123; System.out.println(\"MyParent5发生初始化\") ; &#125; &#125;;&#125;interface MyChild5 extends MyParent5 &#123; public static Thread thread = new Thread( ) &#123; &#123; System.out.println(\"MyChild5发生初始化\") ; &#125; &#125;;&#125;//MyChild5发生初始化 一个父接口不会因为它的子接口或者实现类的初始化而初始化（可能加载）。只有当程序主动使用特定接口的静态对象变量时，才会导致给接口的初始化 如果类中存在初试化语句，那就依次执行这些初试化语句【与&lt;cinit&gt;()V方法小结联系】 初始化发生时机：所有的Java虚拟机实现必须在每个类或接口被Java程序首次主动使用时初试化 对象使用执行顺序 类初始化clinit 父类静态属性/静态代码块 子类静态属性/静态代码块 对象实例化init 父类的普通属性/普通代码块 父类的构造函数 子类的普通属性/普通代码块 子类的构造函数 5.2.4初始化发生时机【主动使用情况】 概括得说，类初始化是【懒惰的】，除去以下情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化 Java虚拟机启动时被标名为启动类的类 main方法所在的类，总会被首先初始化 访问访问某个类或接口的静态变量，或者为给静态变量赋值 调用类或接口的静态方法 一个子类要初始化需要先初始化父类 子类访问父类的静态变量，只会触发父类的初始化 Class.forName反射 new创建类的实例 不会导致类初始化的情况【值得注意的】 访问类的static final静态常量(基本类型和字符串)不会触发初始化 123456789101112131415161718192021public class Load9 &#123; public static void main(String[] args) &#123; System.out.println(My.i); System.out.println(My.num); &#125;&#125;//将常量存放到了Load9的常量池中，之后Load9与My就没有任何关系了// 甚至在运行期 可以删除My.class都不会有影响class My&#123; public static final String i = \"str\"; public static final int num = 1;&#125;/* 0 getstatic #2 &lt;java/lang/System.out&gt; 3 ldc #4 &lt;str&gt; 5 invokevirtual #5 &lt;java/io/PrintStream.println&gt; 8 getstatic #2 &lt;java/lang/System.out&gt;11 iconst_112 invokevirtual #6 &lt;java/io/PrintStream.println&gt;15 return*/ 访问类对象不会触发初始化【加载阶段在内存中已经有了】 创建该类的数组不会触发初始化 12345678910// 数组类的class对象不是由类加载器加载/创建的 其类型是由JVM在运行期动态生成的，`[L....`这种形式。// 对于数组实例来说，getClassLoader会得到其元素类型getClassLoader的结果// 动态生成的类型，其父类型就是object.Student[] students = new Student[1];System.out.println(students.getClass());//class [Ltop.carpenter.Student;System.out.println(students.getClass().getSuperclass());//class java.lang.ObjectStudent[][] studentss = new Student[1][1] ;System.out.println(studentss.getClass()); //class [[Ltop.carpenter.Student;System.out.println(studentss.getClass().getSuperclass());//class java.lang.Object 类加载器的loadClass方法 Class.forName的参数2为false时 实例验证 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package top.carpenter;/** * 判断是否初始化的方法：是否执行了静态代码块中的print方法 */class A &#123; static int a = 0; static &#123; System.out.println(\"a init\"); &#125;&#125;class B extends A &#123; final static double b = 5.0; static boolean c = false; static &#123; System. out. println(\"b init\"); &#125;&#125;public class Load3 &#123; static &#123; System.out.println(\"main init\"); &#125; public static void main(String[] args) throws ClassNotFoundException &#123; // final静态常量不会触发初始化 System.out.println(B.b); // 类对象.class不会触发初始化 System.out.println(B.class); // 创建该类的数组不会触发初始化 System.out.println(new B[0]); // 不会初始化类B,但会加载B 和 A ClassLoader cl = Thread.currentThread().getContextClassLoader(); cl.loadClass(\"top.carpenter.B\"); // 不会初始化类B 但会加载B 和 A ClassLoader c2 = Thread.currentThread().getContextClassLoader(); Class.forName(\"top.carpenter.B\", false, c2); // 1.首次访问这个类的静态变量或静态方法时 System.out.println(A.a); // 2.子类初始化,如果父类还没初始化,会引发 System.out.println(B.c); // 3.子类访问父类静态变量,只触发父类初始化 System.out.println(B.a); // 4.会初始化类B,并先初始化类A Class.forName(\"cn.itcast.jvm.t3.1oad.B\"); &#125;&#125; 5.2.5.案例分析 准备 与 初始化 阶段对比 12345678910111213141516171819202122232425public class Load9 &#123; public static void main(String[] args) &#123; Singleton singleton = Singleton.getInstance(); System.out.println(\"counter1:\"+ Singleton.counter1); //counter1:2 System.out.println(\"counter2:\"+ Singleton.counter2); //counter2:0 &#125;&#125;class Singleton &#123; // 准备阶段将会开辟静态变量内存空间 counter1 = 0 singleton = null counter2 = 0 // 初始化阶段将会对静态变量开始赋值 public static int counter1 = 1; private static Singleton singleton = new Singleton(); private Singleton() &#123; counter1++; counter2++; //准备阶段的重要意义 System.out.println(counter1); // 2 System.out.println(counter2); // 1 &#125; public static int counter2 = 0; public static Singleton getInstance() &#123; return singleton; &#125;&#125; 单例模式初始化 123456789101112131415161718192021222324252627282930313233package top.carpenter;public class Load9 &#123; public static void main(String[] args) &#123; System.out.println(Singleton.getInstance()); //Singleton init //lazy holder init //Singleton construct //top.carpenter.Singleton@4b67cf4d &#125;&#125;class Singleton &#123; static &#123; System.out.println(\"Singleton init\"); &#125; &#123; System.out.println(\"Singleton construct\"); &#125; private Singleton() &#123;&#125; private static class LazyHolder &#123; static &#123; System.out.println(\"lazy holder init\"); &#125; private static final Singleton SINGLETON = new Singleton();//如果交换未知则结果交换未知 &#125; // 不调用此方法 就不会LazyHolder.SINGLETON 也就不引发内部类LazyHolder的（加载 链接）初始化 public static Singleton getInstance() &#123; return LazyHolder.SINGLETON; &#125;&#125; 5.4Java虚拟机结束生命周期 System.exit()方法 程序正常执行结束 程序在执行过程中遇到异常或错误而终止 由于OS出现错误导致Java虚拟机进程终止 5.5类加载器分类 名称 类型 加载哪的类 bootstrap classloader 启动类加载器 JAVA_HOME/jre/lib/rt.jar sun.misc.Launcher$ExtClassLoader 扩展类加载器 JAVA_HOME/jre/lib/ext sun.misc.Launcher$AppClassLoader 系统类加载器 CLASSPATH【我们写的类/以及第三方的类】 5.5.1启动类/根类加载器 内建于JVM中的启动类加载器会加载java.lang.ClassLoader以及其他的Java平台类，当JVM启动时，一块特殊的机器码会运行，它会加载扩展类加载器与系统加载器，这个特殊的机器码叫做启动类加载器(Bootstrap) 启动类加载器是特定于平台的机器指令，它负责开启整个加载过程 所有类加载器（除了启动类加载器）都被实现为java类。不过，总归要有一个组件来加载第一个java类加载器，从而让整个加载过程能够顺利进行下去，加载第一个纯Java类加载器就是启动类加载器的职责，负责开启整个加载过程。 启动类加载器还会负责加载提供JRE（&lt;JAVA_HOME&gt;\\jre\\lib）正常运行所需要的基本组件，这包括java.util与java.lang包中的类等等，系统变量sum.boot.class.path指定的目录下的类库 启动类加载器打印的结果为null 12ClassLoader c1 = Object.class.getClassLoader();// c1 == null 5.5.2扩展类加载器 扩展类加载器是由原SUN公司实现的sun.misc.Launcher$ExtClassLoader类，它是由java语言编写 父加载器是根类加载器 负责加载&lt;JAVA_HOME&gt;\\jre\\lib\\ext目录下的类库/系统变量java.ext.dirs指定的目录下的类库 5.5.3系统类加载器 系统类加载器也称之为应用类加载器，纯java类，是原SUN公司实现的sun.misc.Launcher$AppClassLoader 父加载器是扩展类加载器 负责从CLASSPATH【我们写的类】或者系统属性java.class.path所指定的目录中加载类 是用户自定义的类加载器的默认父加载器。一般情况下，该类加载器是程序中默认的类加载器，可以通过ClassLoader.getSystemClassLoader()直接获得 5.5.4自定义类加载器 自类加载器 为了加载网络上的类，因为这会让class在网络中传输，为了安全，那么class一定是需要加密的，所以需要自定义的类加载器来加载（自定义的类加载器需要做解密工作） 加载非classpath随意路径中的类文件 都是通过接口来使用实现，希望解耦时，常用在框架设计 这些类希望予以隔离，不同应用的同名类都可以加载,不冲突,常见于tomcat容器 需要继承ClassLoader抽象类，然后重写它的findClass()方法 1234567891011121314151617181920212223public class Load9 &#123; public static void main(String[] args) throws SQLException, ClassNotFoundException &#123; MyClassLoader myClassLoader = new MyClassLoader(); System.out.println(myClassLoader.loadClass(\"T\")) &#125;&#125;class MyClassLoader extends ClassLoader &#123; // name就是类名称 @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; String path = \"F:\\\\StudyDemo\\\\multiThread\\\\target\\\\test-classes\\\\\" + name + \".class\"; try &#123; ByteArrayOutputStream os = new ByteArrayOutputStream(); Files.copy(Paths.get(path), os); //得到字节数组 byte[] bytes = os.toByteArray(); // byte[] -&gt; *.class return defineClass(name, bytes, 0, bytes.length); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new ClassNotFoundException(\"类文件末找到\", e); &#125; &#125;&#125; 5.6线程上下文类加载器 当高层提供了统的接口让低层去实现，同时又要在高层加载(或实例化)低层的类时，就必须要通过线程上下文类加载器来帮助高层的ClassLoader 如果-个类由类加载器A加载，那么这个类的依赖类也是由相同的类加载器加载的(如果该依赖类之前没有被加载过的话)，ContextClassLoader的作用就是为了破坏了双亲委托模型，它使得java类加载器变得更加灵活。 在Java中存在着很多的服务提供者接口SPI（Service Provider Interface）,是Java提供的一套被第三方实现或者扩展的API，这些接口一般由第三方提供实现，常见的SPI有JDBC、JNDI等 这些SPI的接口（比如JDBC中的java.sql.Driver）属于核心类库，一般存在rt.jar包中，由根类加载器加载。 第三方实现的代码一般作为依赖jar包存放在classpath路径下，由于SPI接口中的代码需要加载具体的第三方实现类并调用其相关方法，SPI的接口类是由根类加载器加载的，根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。BootStrap类加载器还要去加载jar包中的Driver接口的实现类，Bootstrap类加载器无法直接加载位于classpath下的具体实现类。 当高层提供了统- -的接口让低层去实现，同时又要在高层加载(或实例化) 低层的类时，就必须要通过线程上下文类加载器来帮助高层的ClassLoader找到并加载该类。 由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载SPl的具体实现类。在这种情况下，java提供了线程上下文类加载器用于解决以上问题。 线程上下文类加载器可以通过java.lang.Thread的getContextClassLoader()来获取,或者通过setContextClassLoader(ClassLoader cl)来设置线程的上下文类加载器。 如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器，初始线程的上下文类加载器是系统类加载器(AppClassLoader) ，在线程中运行的代码可以通过此类加载器来加载类或资源。 显然这种加载类的 父ClassLoader可以使用当前线程Thread.currentThread().getContextClassLoader()所指定的classloader加载的类。这就改变了父classLoader不能使用子classLoader或是其他没有直接父子关系的ClassLoader加载的类的情况，即改变了双亲委托模型。 线程上下文类加载器使用的通用写法 12345678ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); try &#123; Thread.currentThread().setContextClassLoader(TargetClassLoader); //其他执行事件 doSomthing();&#125; finally &#123; Thread.currentThread().setContextClassLoader(classLoader);&#125; 5.7JDBC无法使用双亲委托模型 JDBC的Driver接口定义在JDK中，其实现由各个数据库的服务商来提供，比如MySQL驱动包。DriverManager 类中要加载各个实现Driver接口的类，然后进行管理，但是DriverManager位于 $JAVA_HOME中jre/lib/rt.jar 包，由BootStrap类加载器加载，而其Driver接口的实现类是位于服务商提供的 Jar 包，根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。也就是说BootStrap类加载器还要去加载jar包中的Driver接口的实现类。我们知道，BootStrap类加载器默认只负责加载 $JAVA_HOME中jre/lib/rt.jar 里所有的class，所以需要由子类加载器去加载Driver实现，这就破坏了双亲委派模型。 我们在使用JDBC时，都需要加载Driver驱动 12Class.forName(\"com.mysql.jdbc.Driver\"); //①Connection connection = DriverManager.getConnection(\"xxx\", \"xx\", \"xx\");//从注册的驱动加载适合的驱动 不写Class.forName(&quot;com.mysql.jdbc.Driver&quot;)可以让com.mysql.jdbc.Driver正确加载的 ①表示初始化Driver类，对Driver类的主动使用，就会导致Driver的静态代码块执行，那么我们进入到Driver类中，看是否有需要初始化调用的静态代码块。 1234567891011121314151617181920212223public Driver() throws SQLException &#123;&#125;static &#123; try &#123; DriverManager.registerDriver(new Driver()); //Driver静态代码块里向驱动管理器DriverManager注册了驱动② &#125; catch (SQLException var1) &#123; throw new RuntimeException(\"Can't register driver!\"); &#125;&#125;public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException &#123; registerDriver(driver, null);&#125;public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da) throws SQLException &#123; if(driver != null) &#123; registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); //... &#125; 可以看到，存在静态代码块，那么进入到静态代码块中，解析 ② 其实跟解析①一样，主动调用DriverManager类的静态方法，会导致类的初始化，执行 DriverManager中的静态代码块。所以我们需要先看下面的源码： 12345678910private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;(); /** * Load the initial JDBC drivers by checking the System property * jdbc.properties and then use the &#123;@code ServiceLoader&#125; mechanism */ static &#123; loadInitialDrivers();//⭐怎么能正确加载com.mysql.jdbc.Driver呢? println(\"JDBC DriverManager initialized\"); &#125; 打印null，表示它的类加载器是Bootstrap ClassLoader 1System.out.println(DriverManager.class.getClassLoader()); 会到JAVA_ HOME/jre/lib 下搜索类，但JAVA_ HOME/jre/lib 下显然没有mysql-connector-java-5.1.47.jar 包，这样问题来了，在DriverManager的静态代码块中，怎么能正确加载com.mysql.jdbc.Driver呢? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private static void loadInitialDrivers() &#123; String drivers; try &#123; drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() &#123; public String run() &#123; return System.getProperty(\"jdbc.drivers\"); &#125; &#125;); &#125; catch (Exception ex) &#123; drivers = null; &#125; // If the driver is packaged as a Service Provider, load it. // Get all the drivers through the classloader // exposed as a java.sql.Driver.class service. // ServiceLoader.load() replaces the sun.misc.Providers() // 方式一：使用ServiceLoader机制加载驱动，即SPI AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; // ServiceLoader 是由启动类加载器加载 ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);//⭐可以得到待加载类父类是Driver的类，以及使用系统类加载器来负责加载 Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();//创建了一个 LazyIterator对象 try&#123; while(driversIterator.hasNext()) &#123; driversIterator.next(); //⭐利用线程上下文类加载器加载实现类 &#125; &#125; catch(Throwable t) &#123; // Do nothing &#125; return null; &#125; &#125;); println(\"DriverManager.initialize: jdbc.drivers = \" + drivers); // 方式二：使用系统变量方式jdbc.drivers 定义的驱动名加载驱动 if (drivers == null || drivers.equals(\"\")) &#123; return; &#125; String[] driversList = drivers.split(\":\"); println(\"number of Drivers:\" + driversList.length); for (String aDriver : driversList) &#123; try &#123; println(\"DriverManager.Initialize: loading \" + aDriver); //这里的ClassLoader.getSystemClassLoader()就是应用程序类加载器 Class.forName(aDriver, true, ClassLoader.getSystemClassLoader()); &#125; catch (Exception ex) &#123; println(\"DriverManager.Initialize: load failed: \" + ex); &#125; &#125; &#125; 方式一：Service Provider Interface (SPI) 约定如下，在jar包的META-INF/services包下，以接口全限定名名为文件，文件内容是实现类名称 这样就可以使用 12345ServiceLoader&lt;接口类型&gt; allImpls = ServiceLoader.load(接口类型.class);Iterator&lt;接口类型&gt; iter = allImpls.iterator();while(iter .hasNext()) &#123; iter.next();&#125; 来得到实现类，体现的是[面向接口编程+解耦]的思想，在下面一些框架中都运用了此思想: JDBC Servlet初始化器 Spring 容器 Dubbo (对SPI进行了扩展) 123456public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123; //获取线程上下文类加载器：应用类加载器 ClassLoader cl = Thread.currentThread().getContextClassLoader(); // 用应用类加载器加载 return ServiceLoader.load(service, cl);&#125; 线程上下文类加载器是当前线程使用的类加载器，默认就是应用程序类加载器，内部又是由Class.forName调用了线程上下文类加载器完成类加载，LazyIterator.next()方法，该方法最终调用了 LazyIterator.nextService()方法，在该方法中我们可以看到如何将mysql的Driver实现类使用上下文类加载器所加载到内存中。具体代码在ServiceLoader的内部类LazyIterator中: 123456789101112131415161718192021222324252627282930private S nextService() &#123; if (!hasNextService()) throw new NoSuchElementException(); //在遍历的时候获取的当前item的文件内容 String cn = nextName; nextName = null; Class&lt;?&gt; c = null; try &#123; //是否初始化参数为false，表示这里只加载类，不初始化 c = Class.forName(cn, false, loader); &#125; catch (ClassNotFoundException x) &#123; fail(service, \"Provider \" + cn + \" not found\"); &#125; if (!service.isAssignableFrom(c)) &#123; fail(service, \"Provider \" + cn + \" not a subtype\"); &#125; try &#123; //这里才将类初始化，触发mysql Driver类的静态代码块 S p = service.cast(c.newInstance()); providers.put(cn, p); return p; &#125; catch (Throwable x) &#123; fail(service, \"Provider \" + cn + \" could not be instantiated\", x); &#125; throw new Error(); // This cannot happen&#125; 已经使用了SPI方式的ServiceLoader加载方式，不在需要第一步骤的手动加载初始化具体的驱动全类名【使用了Class.forName()将mysql驱动的Driver类加载了】了。 5.8双亲委托模型【ClassLoader】 所有的类加载器（除了根类加载器）都必须继承java.lang.ClassLdader。 它是一个抽象类，主要的方法如下: 5.6.1loadClass 在ClassLoader的源码中，有一个方法loadClass(String name,boolean resolve)，这里就是双亲委托模式的代码实现。 从源码中我们可以观察到它的执行顺序。需要注意的是，只有父类加载器加载不到类时，会调用findClass方法进行类的查找，所以，在定义自己的类加载器时，不要重写loadClass该方法，而应该重写findClass方法。 使用指定的二进制名称来加载类。此方法的默认实现将按以下顺序搜索类 调用findLoadedClass (String)来检查是否已经加载类 在父类加载器上调用loadClass方法。如果父类加载器为null,则使用虚拟机的内置类加载器。 如果委托到双亲顶部【启动类加载器】，都没有加载过 从上之下依次尝试调用findClass (String)方法查找类 如果resolve为true，则调用resolveClass解析Class 12345678910111213141516171819202122232425262728293031323334353637383940protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; // First, 检查该类是否已经被此加载器加载过 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; // 没被加载 if (parent != null) &#123; // 有上级的话，委派上级loadClass（迭代 回到此函数第一行） c = parent.loadClass(name, false); &#125; else &#123; // 如果没有上级了（扩展类加载器） 则使用启动类加载器加载 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; long t1 = System.nanoTime(); // 上一层加载器加载不到类时，调用findClass 方法(每个类加载器自己扩展)来加载 // 此层类加载器尝试加载 如果没有加载到 则爆出ClassNotFoundException 被上数4行代码的catch捕捉 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 5.6.2findClass 在自定义类加载器时，一般我们需要覆盖这个方法，且ClassLoader中给出了一个默认的错误实现 123protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; throw new ClassNotFoundException(name);&#125; 5.6.3defineClass 该方法的用来将byte字节解析成虚拟机能够识别的Class对象 defineClass()方法通常与findClass()方法一起使用 在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法获取要加载类的字节码，然后调用defineClass()方法生成Class对象 5.6.4resolveClass 连接指定的类。类加载器可以使用此方法来连接类 5.7如何创建用户自定义类加载器 扩展java.lang.ClassLoader类 覆盖findClass(String name)方法 在方法中根据指定的类的名字，返回对应的Class对象的引用 使用者调用该类加载器的loadClass方法 实例 1234567891011121314151617181920212223242526272829303132333435package top.carpenter;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.sql.Driver;import java.sql.DriverManager;import java.sql.SQLException;import java.util.Iterator;import java.util.ServiceLoader;public class Load9 &#123; public static void main(String[] args) throws SQLException, ClassNotFoundException &#123; MyClassLoader myClassLoader = new MyClassLoader(); System.out.println(myClassLoader.loadClass(\"T\")); &#125;&#125;class MyClassLoader extends ClassLoader &#123; // name就是类名称 @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; String path = \"F:\\\\StudyDemo\\\\multiThread\\\\target\\\\test-classes\\\\\" + name + \".class\"; try &#123; ByteArrayOutputStream os = new ByteArrayOutputStream(); Files.copy(Paths.get(path), os); //得到字节数组 byte[] bytes = os.toByteArray(); // ⭐byte[] -&gt; *.class return defineClass(name, bytes, 0, bytes.length); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new ClassNotFoundException(\"类文件末找到\", e); &#125; &#125;&#125; 5.7获取ClassLoader的途径 获得当前类的ClassLoader 1class.getClassLoader() 获得当前线程的上下文ClassLoader 1Thread.currentThread().getContextClassLoader() 获得系统的ClassLoader 1ClassLoader.getSystemClassLoader() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// ClassLoader.java &#123; // 用来接收系统类加载器的 private static ClassLoader scl; // sclSet则是一个布尔值，用来判断scl是否为空的 private static boolean sclSet; public static ClassLoader getSystemClassLoader() &#123; initSystemClassLoader(); // 一些安全检查，直接返回系统类加载器scl //... return scl; &#125; private static synchronized void initSystemClassLoader() &#123; //若sclSet为真，则代表系统类加载已经被加载 if (!sclSet) &#123; if (scl != null) throw new IllegalStateException(\"recursive invocation\"); // ⭐ 创建一个Launcher 后文会讲 sun.misc.Launcher l = sun.misc.Launcher.getLauncher(); if (l != null) &#123; Throwable oops = null; // 通过Launcher类，获取系统类加载器 scl = l.getClassLoader(); try &#123; //⭐ 处理用户是否自定义系统类加载器 scl = AccessController.doPrivileged( new SystemClassLoaderAction(scl)); &#125; //.... &#125; sclSet = true; &#125; &#125;&#125;class SystemClassLoaderAction implements PrivilegedExceptionAction&lt;ClassLoader&gt; &#123; private ClassLoader parent; SystemClassLoaderAction(ClassLoader parent) &#123; this.parent = parent; &#125; // AccessController.doPrivileged会运行run方法 public ClassLoader run() throws Exception &#123; //从系统属性中获取key，即用户自定义系统类加载器的二进制名 String cls = System.getProperty(\"java.system.class.loader\"); //若cls为空，则说明用户没有设定此系统属性 返回parent，即传入的系统类加载器 if (cls == null) &#123; &#125; //通过这个自定义类加载器的二进制名，使用系统类加载器去将其加载，并将其初始化 Constructor&lt;?&gt; ctor = Class.forName(cls, true, parent) .getDeclaredConstructor(new Class&lt;?&gt;[] &#123; ClassLoader.class &#125;); //通过反射创建这个自定义类加载器的实例 ClassLoader sys = (ClassLoader) ctor.newInstance( new Object[] &#123; parent &#125;);//解释将自定的类设置为系统类加载器 其父类加载器为应用类加载器 //将线程上下文类加载器设置为这个自定义类加载器 Thread.currentThread().setContextClassLoader(sys); return sys; &#125;&#125;// Launcher.java 反编译代码&#123; //启动类加载器所要加载的jar包的路径 private static String bootClassPath = System.getProperty(\"sun.boot.class.path\"); private ClassLoader loader; //类加载器字段，上文getClassLoader()所获取的一个类加载器就是这个字段 public Launcher() &#123; //声明一个扩展类加载器 这里在构造方法中声明扩展类加载器，而不将其设置为全局变量的原因是，可以直接通过系统类加载器的getParent()来获取扩展类加载器。 Launcher.ExtClassLoader var1; try &#123; //创建一个扩展类加载器 var1 = Launcher.ExtClassLoader.getExtClassLoader(); &#125; catch (IOException var10) &#123; throw new InternalError(\"Could not create extension class loader\", var10); &#125; try &#123; //将内部维护的一个ClassLoader赋值为系统类加载器 this.loader = Launcher.AppClassLoader.getAppClassLoader(var1); &#125; catch (IOException var9) &#123; throw new InternalError(\"Could not create application class loader\", var9); &#125; //设置线程上下文类加载为系统类加载器 Thread.currentThread().setContextClassLoader(this.loader); //... &#125; // 在Launcher的方法中，通过AppClassLoader.getAppClassLoader来获取系统类加载器，其实AppClassloader是Launcher的一个内部类，它的最顶层父类也是ClassLoader public static ClassLoader getAppClassLoader(final ClassLoader var0) throws IOException &#123; //获取系统类加载器要加载的jar包路径以及当前Java程序classPath路径 final String var1 = System.getProperty(\"java.class.path\"); //根据这些路径，创建一个文件数组 final File[] var2 = var1 == null ? new File[0] : Launcher.getClassPath(var1); //访问控制操作和决策 return (ClassLoader)AccessController.doPrivileged(new PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123; public Launcher.AppClassLoader run() &#123; //将文件数组转换成一个URL数组 URL[] var1x = var1 == null ? new URL[0] : Launcher.pathToURLs(var2); //将当前的资源URL数组以及扩展类加载器传入这个内部类的构造方法 return new Launcher.AppClassLoader(var1x, var0); &#125; &#125;); &#125; //最后通过ClassLoader的构造方法，创建出当前的这个类加载器，即系统类加载器，且扩展类加载器被设置为它的父类加载器。 //扩展类加载ExtClassLoader和系统类加载器是差不多的，是Launcher类的一个内部类&#125; 5.8类加载双亲委托模型的好处 可以确保Java核心库的类型安全（双亲委托机制保证了，Java核心类库中的类的加载工作都是由启动类加载器来统一完成的，从而确保了Java应用中使用的都是同一个版本的相互可兼容的Java核心类库） 例如：所有的类都会引用到java.lang.Object类，即在运行期间，java.lang.Object类会被加载到JVM中。如果找个加载过程是由Java应用自己定义的类加载器完成，那么很有可能会在JVM中存在多个版本的，不兼容的，相互不可见的java.lang.Object（命名空间发挥作用） 确保Java核心类库提供的类不会被自定义的类所替代 不同的类加载器可以为相同名称（binary name）的类创建额外的命名空间。相同名称的类可以并存在JVM中，只需要用不同的类加载器加载即可。不同类加载器所加载的类之间是不兼容的，这就相当于在Java虚拟机内部创建了一个又一个相互隔离的Java类空间，这类技术在很多框架中都得到了实际应用。 5.9 命名空间 每个类加载器都有自己的命名空间，命名空间由该类加载器以及所有父类加载器所加载的类组成。 同一个命名空间内的类是相互可见的 子加载器的命名空间包含所有父加载器的命名空间。 因此由子加载器加载的类能看见父加载器加载的类。 例如系统类加载器加载的类能看见根类加载器加载的类。 由父加载器加载的类不能看见子加载器加载的类。 如果两个类加载器之间没有直接或间接的父子关系，那么他们各自加载的类相互不可见 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Main&#123; public static void main(String[] args) throws Exception &#123; // 环境：MyA在自定义目录下 MyB在Class目录下 // 使用自定义类加载器 为应用类加载器的子类加载器 可以加载特定目录下Class文件 MyClassLoader myClassLoader = new MyClassLoader(); myClassLoader.setPath(\"自定义目录\"); Class&lt;?&gt; clazz = myClassLoader.loadClass(\"top.carpenter.MyA\"); //如果注释掉该行，那么并不会实例化MySample对象，即MySample构造方法不会被调用 //因此不会实例化MyCat对象，即没有对MyCat进行主动使用，这里就不会加载MyCat Class Object object = clazz.newInstance(); &#125;&#125;public class MyA &#123; public MyA()&#123; System.out.println( \"MyA is loaded by:\" + this.getClass().getClassLoader()); // 自定义类加载器 new MyB(); System.out.println(\"from MyA:\"+ MyA.class); // 成功 &#125;&#125;public class MyB &#123; public MyB()&#123; // 从自定义类加载器开始双亲委托 使用应用类加载器加载成功 System.out.println( \"MyB is loaded by:\" + this.getClass().getClassLoader()); // ⭐报错：MyB应用类加载器加载的 其命名空间中不存在MyA的Class文件（在其子加载器中命名空间中） System.out.println(\"from MyA:\"+ MyA.class); &#125;&#125;class MyClassLoader extends ClassLoader &#123; // name就是类名称 @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; String path = \"F:\\\\StudyDemo\\\\multiThread\\\\target\\\\top\\\\carpenter\\\\MyA.class\"; try &#123; ByteArrayOutputStream os = new ByteArrayOutputStream(); Files.copy(Paths.get(path), os); //得到字节数组 byte[] bytes = os.toByteArray(); // ⭐byte[] -&gt; *.class return defineClass(name, bytes, 0, bytes.length); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new ClassNotFoundException(\"类文件末找到\", e); &#125; &#125;&#125; 5.10类的卸载 一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期 当类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期 由Java虚拟机自带的类加载器所加载的类（根类加载器、扩展类加载器和系统类加载器）在虚拟机的生命周期中，始终不会被卸载。 Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的。 由用户自定义的类加载器所加载的类是可以被卸载的 5.11 SPI SPI是java内置的一种服务发现机制，一般在框架设计的时候，将问题抽象成接口，至于服务的实现，由不同的厂家来各自实现，按照指定的规范引入哪个厂家的实现jar包，就可以使用该厂家的服务实现，这种现象个人理解跟java的多态很类似。 为什么要使用SPI 假设现在没有使用SPI，存在一个接口，和不同的实现类，然后在使用该接口的时候，需要硬编码的形式使用哪个实现类，例如使用工厂模式+策略模式，根据指定条件硬编码，如果我们新增加一种实现，还是需要修改工厂模式的编码，所以跟业务代码存在耦合。而使用SPI机制，可以将第三方的实现方式作为插件的方式，可插拔方式，可以很大程度的与业务代码进行解耦。但是，这种方式也有缺点，假设配置了多个实现类，不能很好的根据条件的来进行判断筛选，只能针对Iterator遍历获取。 关于策略模式和SPI的几点区别 如果从代码接入的级别来看，策略模式还是在原有项目中进行代码修改，只不过它不会修改原有类中的代码，而是新建了一个类。而 SPI 机制则是不会修改原有项目中的代码，其会新建一个项目，最终以 Jar 包引入的方式代码。 从这一点来看，无论策略模式还是 SPI 机制，他们都是将修改与原来的代码隔离开来，从而避免新增代码对原有代码的影响。但策略模式是类层次上的隔离，而 SPI 机制则是项目框架级别的隔离。 从应用领域来说，策略模式更多应用在业务领域，即业务代码书写以及业务代码重构。而 SPI 机制更多则是用于框架的设计领域，通过 SPI 机制提供的灵活性，让框架拥有良好的插件特性，便于扩展。 从设计思想来看。策略模式和 SPI 机制其思想是类似的，都是通过一定的设计隔离变化的部分，从而让原有部分更加稳定。 从隔离级别来看。策略模式的隔离是类级别的隔离，而 SPI 机制是项目级别的隔离。 从应用领域来看。策略模式更多用在业务代码书写，SPI 机制更多用于框架的设计。 使用介绍或者说约定 服务提供者：接口服务提供者，规则定义者，通俗来说，负责写接口 服务消费者：接口服务实现对象，具体的规则实现。 调用方：具体的业务工程，例如在一个Main方法中使用该接口的所在类所在工程。 定义一个接口 服务消费者所在工程里，在根路径下(针对web项目，可以理解成resources目录下，非web项目，就是src目录下)，创建一个文件夹，即META-INF/services, 然后创建一个文件，文件名就是定义的接口的全类名，文件内容就是当前的服务消费者所在工程里针对该接口的实现类对应的全类名。 调用方使用 java.util.ServiceLoader 类来加载服务消费者。 具体的demo实现 在这个demo中，不管是服务提供者还是消费者，以及调用者都是在不同的工程中，不要全部都放在一个工程里，这样比较符合规范和设计，以及能够比较清楚的理解其中的使用细节。由于是demo，这里就提供一个计算接口，由不同的实现来实现数据的计算，输出结果。 创建服务提供者 12345public interface ICalculationService &#123; Object calc(Object param1, Object param2);&#125; 项目结构如下图：[将该项目打包成jar包] 创建服务消费者A 新建一个工程 spi-impl1,在这里实现了计算接口，使用加法进行数据的运算。**注意：这里还需要引入刚才服务提供者的打包好的jar包，不然找不到需要实现的接口。 123456789import services.ICalculationService;public class CalculationServiceImplB implements ICalculationService &#123; @Override public Object calc(Object o, Object o1) &#123; return (Double)o + (Double)o1; &#125;&#125; 按照约定，创建约定目录以及文件，创建目录 META-INF/services，从上述的服务提供者结构图来看，我们得知接口的全类名是 “services.ICalculationService” , 所以我们需要创建一个文件，名字就是我们的全类名，里面的内容，就是我们刚才的实现类的全类名。 具体的项目结构如下图： 将该工程打包 创建服务消费者B 新建一个工程 spi-impl2,在这里实现了计算接口，使用减法进行数据的运算。再次提醒注意：这里还需要引入刚才服务提供者的打包好的jar包，不然找不到需要实现的接口。 123456public class CalculationServiceImplA implements ICalculationService &#123; @Override public Object calc(Object o, Object o1) &#123; return (Double) o - (Double) o1; &#125;&#125; 按照约定，创建约定目录以及文件 创建目录 META-INF/services，从上述的服务提供者结构图来看，我们得知接口的全类名是 “services.ICalculationService” , 所以我们需要创建一个文件，名字就是我们的全类名，里面的内容，就是我们刚才的实现类的全类名。 具体的项目结构如下图： 将该工程打包 创建调用者 创建一个工程 spi-main, 注意：需要引用上面三个项目的jar包。 123456789101112131415import services.ICalculationService;import java.util.Iterator;import java.util.ServiceLoader;public class Main &#123; public static void main(String[] args) &#123; ServiceLoader&lt;ICalculationService&gt; serviceLoader = ServiceLoader.load(ICalculationService.class); Iterator&lt;ICalculationService&gt; iterator = serviceLoader.iterator(); while(iterator.hasNext())&#123; ICalculationService calculationService = iterator.next(); System.out.println(MessageFormat.format(\"指定类：&#123;0&#125;.calc()执行结果是：&#123;1&#125;\",calculationService.getClass().getName(),calculationService.calc(23.1,15.3))); &#125; &#125;&#125; 执行结果如下： 12指定类：service.impl.CalculationServiceImplA.calc()执行结果是：7.8指定类：service.impl.CalculationServiceImplB.calc()执行结果是：38.4 从结果上看，我们在调用方工程代码中，没有写上一行关于 “CalculationServiceImplA”或者”CalculationServiceImplB”相关服务的硬代码，只要后续新添加一种实现，只需要在编写一个工程，按照SPI约定，打包成jar后，放入到调用者工程中，就能使用了，完全与具体实现解耦。 6.运行时优化 分层编译(TieredCompilation) 1234567891011121314151617 public static void main(String[] args) &#123; for(int i=0;i&lt;200;i++)&#123; long start = System. nanoTime(); for(int j=0;j&lt;1000;j++)&#123; new Object(); // JIT 逃逸分析 Java Hotspot分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存 &#125; long end = System. nanoTime(); System. out. printf(\"%d\\t%d\\n\",i,(end - start)); &#125; &#125;/* 0 66000...82 14400...159 300*/ 原因：JVM将执行状态分成了5个层次: 0层，解释执行(Interpreter) 【字节码加载到虚拟机 解释器将字节码解释为机器码，一个一个执行】 1层，使用C1即时编译器编译执行(不带profiling)【字节码反复使用到一定程度 启用编译器】 2层，使用C1即时编译器编译执行(带基本的profiling) 3层，使用C1即时编译器编译执行(带完全的profiling) 4层，使用C2即时编译器编译执行 profiling是指在运行过程中收集一些程序执行状态的数据， 例如[方法的调用次数]，[循环次数]等 即时编译器(JIT) 与解释器的区别 解释器是将字节码编译为机器码，下次即使遇到相同的字节码，仍会执行重复的编译 即时编译器(JIT) 是将一些字节码编译为机器码存入Code Cache， 下次遇到相同的字节码，无需再字节码编译为机器码，直接执行机器码 解释器是将字节码编译为针对所有平台都通用的机器码 即时编译器(JIT) 会根据平台类型，生成平台特定的机器码 执行效率：Interpreter &lt;C1 &lt; C2 即时编译器(JIT) 总的目标：发现热点代码(hotspot名称的由来) 并优化 6.1逃逸分析 定义：Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术 逃逸分析的 JVM 参数如下： 开启逃逸分析：-XX:+DoEscapeAnalysis【默认启用状态】 关闭逃逸分析：-XX:-DoEscapeAnalysis 显示分析结果：-XX:+PrintEscapeAnalysis 分析精度较高，但是运行时间和内存消耗相对较大 对象的逃逸状态 全局逃逸（GlobalEscape）：一个对象的作用范围逃出了当前方法或者当前线程： 对象是一个静态变量 对象是一个已经发生逃逸的对象 对象作为当前方法的返回值 参数逃逸（ArgEscape）：一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的 没有逃逸：方法中的对象没有发生逃逸 当一个对象没有逃逸时，可以得到以下几个虚拟机的优化 锁消除 我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。 例如 StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作。 锁消除的 JVM 参数如下： 开启锁消除：-XX:+EliminateLocks【锁消除都要建立在逃逸分析的基础上，默认开启的】 关闭锁消除：-XX:-EliminateLocks 标量替换 标量 &amp; 聚合量， 标量：不能被进一步分解的量，比如：基础类型和对象的引用。 聚合量：能被进一步分解的量，比如：对象可以分解成其他聚合量和标量。 标量替换：对象被进一步分解成标量，将其成员变量分解为分散的变量。 如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能。 标量替换的 JVM 参数如下： 开启标量替换：-XX:+EliminateAllocations【建立在逃逸分析的基础上，默认开启的】 关闭标量替换：-XX:-EliminateAllocations 显示标量替换详情：-XX:+PrintEliminateAllocations 栈上分配 当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员，将堆分配转化为栈分配，标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能。 12345678910111213141516class Point&#123; private int x; private int y;&#125;//=====优化前private static void alloc() &#123; Point point = new Point（1,2）; System.out.println(\"point.x=\"+point.x+\"; point.y=\"+point.y);&#125;//=====优化后private static void alloc() &#123; int x = 1; int y = 2; System.out.println(\"point.x=\"+x+\"; point.y=\"+y);&#125; 6.1.2所有的对象和数组都会在堆内存分配空间？ 不一定，随着JIT编译器的发展，在编译期间，如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。 但是这也并不是绝对的。开启逃逸分析之后，也并不是所有User对象都没有在堆上分配。 代码：使用for循环，在代码中创建100万个User对象 12345678910111213141516171819public static void main(String[] args) &#123; long a1 = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000; i++) &#123; alloc(); &#125; // 查看执行时间 long a2 = System.currentTimeMillis(); System.out.println(\"cost \" + (a2 - a1) + \" ms\"); // 为了方便查看堆内存中对象个数，线程sleep try &#123; Thread.sleep(100000); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125;&#125; private static void alloc() &#123; User user = new User();&#125; 在alloc方法中定义了User对象，但是并没有在方法外部引用他。也就是说，这个对象并不会逃逸到alloc外部。经过JIT的逃逸分析之后，就可以对其内存分配进行优化。 如果没有JIT编译器优化，没有逃逸分析技术，正常情况下所有对象都分配到堆内存中。 接下来，我们开启逃逸分析，再来执行下以上代码。 1-Xmx4G -Xms4G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError 在程序打印出 cost XX ms 后，代码运行结束之前，我们使用jmap命令，来查看下当前堆内存中有多少个User对象： 123456789101112131415➜ ~ jps7092858 Launcher2859 StackAllocTest2860 Jps➜ ~ jmap -histo 2859 num #instances #bytes class name---------------------------------------------- 1: 524 101944280 [I 2: 6806 2093136 [B 3: 83619 1337904 StackAllocTest$User 4: 8006 1320872 [C 5: 4188 100512 java.lang.String 6: 581 66304 java.lang.Class 从以上打印结果中可以发现，开启了逃逸分析之后（-XX:+DoEscapeAnalysis），在堆内存中只有8万多个StackAllocTest$User对象。也就是说在经过JIT优化之后，堆内存中分配的对象数量，从100万降到了8万。 6.2方法内联 方法内联：如果发现方法是热点方法，且长度不太长时，会进行内联【把方法内代码拷贝、粘贴到调用者的位置】 1234private static int square(final int i) &#123; return i * i;&#125;System.out.println(square(9)); 方法内联优化 1System.out.println(9 * 9); 还能够进行常量折叠(constant folding)的优化 1System.out.println(81); private static int square(final int i) {return i * i; 6.3字段优化 针对（静态）成员变量读写进行优化 12345678910111213141516171819202122232425262728static int sum = 0;static void doSum(int x)&#123; sum += x;&#125;// 内联后 可以进一步运行时优化 elements 首次读取会缓存起来-&gt; int[] local【机器码指令层次】// 不用访问成员变量 访问局部变量即可@Benchmarkpublic void test1() &#123; for (int i = 0; i &lt; elements.length; i++) &#123; doSum(elements[i]); &#125;&#125;// 手动优化 将成员变量-&gt;本地变量@Benchmarkpublic void test2() &#123; int[] local = this. elements; for (int i = 0; i &lt; 1ocal.length; i++) &#123; doSum(local[i]); &#125;&#125;// 编译时优化@Benchmarkpublic void test3() &#123; for (int element : elements) &#123; dosum(element); &#125;&#125; 6.4反射优化1234567891011public static void foo() &#123; System. out. println(\"foo...\"); &#125; public static void main(String[] args) throws Exception &#123; Method foo = Load9.class.getMethod(\"foo\"); for(int i=0;i&lt;=16;i++)&#123; System.out.printf(\"%d\\t\", i); foo.invoke (null); &#125; System.in.read(); &#125; 过程：foo.invoke前面0~ 15次调用使用的是MethodAccessor的NativeMethodAccessorImpl实现，效率较低。17次以后编译器会生成新的方法访问器。 次数达到一定，反射调用—-&gt;直接调用 4.Java 内存模型（JMM） 与多线程笔记交叉 见多线程3.md 见多线程2.md","tags":[{"name":"JVM","slug":"JVM","permalink":"http://goldcarpenter.github.io/tags/JVM/"}]},{"title":"Java虚拟机","date":"2019-07-18T12:31:14.000Z","path":"2019/07/18/JVM_Part3/","text":"3 类加载与字节码技术3.1.字节码文件结构 详见《深入理解Java虚拟机》 使用javap -verbose命令分析个字节码文件时，将会分析该字节码文件的魔数，版本号、常量池、类信息，类的构造方法、类中的方法信息、类变量与成员变量等信息 4个字节：魔数，固定值0xCAFEBABE 4个字节：版本信息 前两个字节：minor version (次版本号) 后两个字节表：major version (主版本号) 【00 00 00 34, 换算成十进制，表示次版本号为0，主版本号为52。文件的版本号为: 1.8.0】 向下兼容 2个字节：常量池项目数量 【0023 (35) 表示常量池有34项 即常量池数 - 1 (其中0暂时不使用，目的是满足某些常量池索引值的数据在特定情况下需要表达不引用任何个常量池的含义】 不定：常量池数组 一个Java类中定义的很多信息都是由常量池来维护和描述的 将常量池看作是Class文件的资源仓库，比如说Java类中定义的方法与变量信息，都是存储在常量池中。 常量池中主要存储两类 字面量：文本字符串，Java中声明为final的常量值 符号引用：类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符等 常量池是一个数组，数组中不同的元素的类型、结构都是不同的，长度当然也就不同 后续种类进行了增加 常量池数组中每一项常量都是一个表结构，每项的第一个数据都是个u1类型，代表当前常量属于哪种常量类型，JVM在解析常量池时，会根据这个类型来获取元素的具体类型。 2个字节：访问标识 用于标志识别类或者层次的访问信息 2个字节：类索引 2个字节：父类索引 2个字节：接口数量 不定：接口信息 2个字节：字段表长度 字段表用于描述类和接口中声明的变量。这里的字段包含了类级别变量以及实例变量，但是不包括方法内部声明的局部变量 不定：字段表信息 2个字节：方法表长度 不定：方法表信息 2个字节：属性表长度 不定：属性表信息 在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息 Code attribute的作用是保存该方法的结构 max_stack表示这个方法运行的任何时刻所能达到的操作数栈的最大深度 max_locals表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量 code_length表示该方法所包含的字节码的字节数以及具体的指令码，具体字节码即是该方法被调用时，虚拟机所执行的字节码 exception_table, 这里存放的是处理异常的信息，每个exception_table表项由start_pc end_pc handler_pc catch_type组成 start_pc和end_pc表示在code数组中的从start_pc到end_pc处 [start_pc,end.pc) 的指令抛出的异常会由这个表项来处理 handler_pc表示处理异常的代码的开始处 catch_type表示会被处理的异常类型，它指向常量池里的一个异常类。当catch_type为0时，表示处理所有的异常 属性表 LineNumberTable: 这个属性用来表示code数组中的字节码和Java代码行数之间的关系。这个属性可以用来在调试的时候定位代码执行的行数 每个变量/字段都有描述信息，描述信息主要的作用是描述字段的数据类型 对于基本数据类型只使用一个大写字母来表示，B-byte C-char D-double F-float I-int J-long S-short Z-boolean V-void L-对象类型【为了压缩字节码文件的体积】 对象类型则使用字符L对象的全限定名称;来表示 对于数组类型来说，每个维度使用个前置的[来表示， 如int[]被记录为[I，String[][]被记录为[[Ljava/lang/String; 每个方法都有描述信息，描述信息主要的作用是描述方法的参数列表(包括数量、类型与顺序)与返回值 按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在组()之内， 如方法String getRealnamebyIdAndNickname(int id, String name)的描述符的描述符为：(I, Ljava/lang/String;) Ljava/lang/String; 3.2.字节码的执行流程 原始java代码 1234567891011/** *演示字节码指令和操作数栈、常量池的关系 */public class Demo3_1 &#123; public static void main(String[] args) &#123; int a = 10; int b = Short.MAX_VALUE + 1; int c = a+b; System.out.println(c); &#125;&#125; 编译后的字节码文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394F:\\StudyDemo\\multiThread\\target\\classes\\top\\carpenter&gt;javap -verbose Demo3_1.classClassfile /F:/StudyDemo/multiThread/target/classes/top/carpenter/Demo3_1.class Last modified 2020-4-28; size 611 bytes MD5 checksum a7d0991b2d0767b9ea3a2c9199b6adbf Compiled from \"Demo3_1.java\"public class top.carpenter.Demo3_1 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #7.#25 // java/lang/Object.\"&lt;init&gt;\":()V #2 = Class #26 // java/lang/Short #3 = Integer 32768 #4 = Fieldref #27.#28 // java/lang/System.out:Ljava/io/PrintStream; #5 = Methodref #29.#30 // java/io/PrintStream.println:(I)V #6 = Class #31 // top/carpenter/Demo3_1 #7 = Class #32 // java/lang/Object #8 = Utf8 &lt;init&gt; #9 = Utf8 ()V #10 = Utf8 Code #11 = Utf8 LineNumberTable #12 = Utf8 LocalVariableTable #13 = Utf8 this #14 = Utf8 Ltop/carpenter/Demo3_1; #15 = Utf8 main #16 = Utf8 ([Ljava/lang/String;)V #17 = Utf8 args #18 = Utf8 [Ljava/lang/String; #19 = Utf8 a #20 = Utf8 I #21 = Utf8 b #22 = Utf8 c #23 = Utf8 SourceFile #24 = Utf8 Demo3_1.java #25 = NameAndType #8:#9 // \"&lt;init&gt;\":()V #26 = Utf8 java/lang/Short #27 = Class #33 // java/lang/System #28 = NameAndType #34:#35 // out:Ljava/io/PrintStream; #29 = Class #36 // java/io/PrintStream #30 = NameAndType #37:#38 // println:(I)V #31 = Utf8 top/carpenter/Demo3_1 #32 = Utf8 java/lang/Object #33 = Utf8 java/lang/System #34 = Utf8 out #35 = Utf8 Ljava/io/PrintStream; #36 = Utf8 java/io/PrintStream #37 = Utf8 println #38 = Utf8 (I)V&#123; public top.carpenter.Demo3_1(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Ltop/carpenter/Demo3_1; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: bipush 10 2: istore_1 3: ldc #3 // int 32768 5: istore_2 6: iload_1 7: iload_2 8: iadd 9: istore_3 10: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 13: iload_3 14: invokevirtual #5 // Method java/io/PrintStream.println:(I)V 17: return LineNumberTable: line 5: 0 line 6: 3 line 7: 6 line 8: 10 line 9: 17 LocalVariableTable: Start Length Slot Name Signature 0 18 0 args [Ljava/lang/String; 3 15 1 a I 6 12 2 b I 10 8 3 c I&#125;SourceFile: \"Demo3_1.java\" 常量池载入运行时常量池 此时仅仅示意 运行时常量池属于方法区 并且没有列出所有项 方法的字节码会放入方法区 main线程开始运行，分配栈帧内存 bipush 10将一个byte压入操作数栈(长度会补齐4个字节) istore 1将操作数栈顶数据弹出，存入局部变量表的slot 1 ldc #3从常量池加载#3数据到操作数栈 32768 = Short.MAX_VALUE + 1实际是在编译期间计算好的 istore 2 *iload 1 * iload2 iadd istore 3 getstatic #4 iload 3 invokevirtual #5 找到常量池#5项 定位到方法区java/io/PrintStream. println:(I)V方法 生成新的栈帧(分配locals、stack等) 传递参数，执行新栈帧中的字节码 执行完毕,弹出栈帧，清除main操作数栈内容 完成main方法调用，弹出main栈帧，程序结束 3.3.常用字节码指令 详见《深入理解Java虚拟机》 ldc表示将int，float或是String类 型的常量值从常量池中推送至栈顶 bipush表示将单字节 (-128 - 127) 的常量值推送至栈顶 sipush表示将一个短整型常量值(-32768 - 32767)推送至栈顶 iconst_1表示将int类型1推送至栈顶(iconst_m1 - iconst_5) anewarray:表示创建一个引用类型的(如类、接口、数组)数组，并将其引用值压入栈顶 newarray;表示创建一个指定的原始类型(如int、 float. char等)的数组，并将其引用值压入栈顶 3.3.1构造方法&lt;CLINIT&gt;()V方法 编译器会按从上至下的顺序，收集所有static静态代码块和静态成员赋值的代码，合并为一个特殊的方法&lt;cinit&gt;()V 123456789static int a = 10;static &#123; a = 20;&#125;static &#123; a = 30;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667Classfile &#x2F;F:&#x2F;StudyDemo&#x2F;multiThread&#x2F;target&#x2F;classes&#x2F;top&#x2F;carpenter&#x2F;CINIT.class Last modified 2020-4-28; size 371 bytes MD5 checksum 53d1de3bf6512166904597cdfa925778 Compiled from &quot;CINIT.java&quot;public class top.carpenter.CINIT minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 &#x3D; Methodref #4.#17 &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V #2 &#x3D; Fieldref #3.#18 &#x2F;&#x2F; top&#x2F;carpenter&#x2F;CINIT.i:I #3 &#x3D; Class #19 &#x2F;&#x2F; top&#x2F;carpenter&#x2F;CINIT #4 &#x3D; Class #20 &#x2F;&#x2F; java&#x2F;lang&#x2F;Object #5 &#x3D; Utf8 i #6 &#x3D; Utf8 I #7 &#x3D; Utf8 &lt;init&gt; #8 &#x3D; Utf8 ()V #9 &#x3D; Utf8 Code #10 &#x3D; Utf8 LineNumberTable #11 &#x3D; Utf8 LocalVariableTable #12 &#x3D; Utf8 this #13 &#x3D; Utf8 Ltop&#x2F;carpenter&#x2F;CINIT; #14 &#x3D; Utf8 &lt;clinit&gt; #15 &#x3D; Utf8 SourceFile #16 &#x3D; Utf8 CINIT.java #17 &#x3D; NameAndType #7:#8 &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V #18 &#x3D; NameAndType #5:#6 &#x2F;&#x2F; i:I #19 &#x3D; Utf8 top&#x2F;carpenter&#x2F;CINIT #20 &#x3D; Utf8 java&#x2F;lang&#x2F;Object&#123; static int i; descriptor: I flags: ACC_STATIC public top.carpenter.CINIT(); descriptor: ()V flags: ACC_PUBLIC Code: stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1 0: aload_0 1: invokespecial #1 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Ltop&#x2F;carpenter&#x2F;CINIT; static &#123;&#125;; descriptor: ()V flags: ACC_STATIC Code: stack&#x3D;1, locals&#x3D;0, args_size&#x3D;0 0: bipush 10 2: putstatic #2 &#x2F;&#x2F; Field i:I 5: bipush 20 7: putstatic #2 &#x2F;&#x2F; Field i:I 10: bipush 30 12: putstatic #2 &#x2F;&#x2F; Field i:I 15: return LineNumberTable: line 4: 0 line 6: 5 line 9: 10 line 10: 15&#125;SourceFile: &quot;CINIT.java&quot; &lt;clinit&gt;()V方法会在类加载的初始化阶段被调用 &lt;INIT&gt;()V方法 编译器会按从上至下的顺序，收集所有{}代码块和成员变量赋值的代码，形成新的构造方法，但原始构造方法内的代码总是在最后 123456789101112131415161718192021package top.carpenter;public class INIT &#123; private String a = \"s1\"; &#123; b = 20; &#125; private int b = 10; &#123; a = \"s2\"; &#125; public INIT(String a, int b) &#123; this.a = a; this.b = b; &#125; public static void main(String[] args) &#123; INIT d = new INIT(\"s3\", 30); System.out.println(d.a); System.out.println(d.b); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134Classfile &#x2F;F:&#x2F;StudyDemo&#x2F;multiThread&#x2F;target&#x2F;classes&#x2F;top&#x2F;carpenter&#x2F;INIT.class Last modified 2020-4-28; size 799 bytes MD5 checksum 7bb1a6f02baecfedf42f39670549c6d2 Compiled from &quot;INIT.java&quot;public class top.carpenter.INIT minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 &#x3D; Methodref #12.#31 &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V #2 &#x3D; String #32 &#x2F;&#x2F; s1 #3 &#x3D; Fieldref #6.#33 &#x2F;&#x2F; top&#x2F;carpenter&#x2F;INIT.a:Ljava&#x2F;lang&#x2F;String; #4 &#x3D; Fieldref #6.#34 &#x2F;&#x2F; top&#x2F;carpenter&#x2F;INIT.b:I #5 &#x3D; String #35 &#x2F;&#x2F; s2 #6 &#x3D; Class #36 &#x2F;&#x2F; top&#x2F;carpenter&#x2F;INIT #7 &#x3D; String #37 &#x2F;&#x2F; s3 #8 &#x3D; Methodref #6.#38 &#x2F;&#x2F; top&#x2F;carpenter&#x2F;INIT.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;I)V #9 &#x3D; Fieldref #39.#40 &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream; #10 &#x3D; Methodref #41.#42 &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V #11 &#x3D; Methodref #41.#43 &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(I)V #12 &#x3D; Class #44 &#x2F;&#x2F; java&#x2F;lang&#x2F;Object #13 &#x3D; Utf8 a #14 &#x3D; Utf8 Ljava&#x2F;lang&#x2F;String; #15 &#x3D; Utf8 b #16 &#x3D; Utf8 I #17 &#x3D; Utf8 &lt;init&gt; #18 &#x3D; Utf8 (Ljava&#x2F;lang&#x2F;String;I)V #19 &#x3D; Utf8 Code #20 &#x3D; Utf8 LineNumberTable #21 &#x3D; Utf8 LocalVariableTable #22 &#x3D; Utf8 this #23 &#x3D; Utf8 Ltop&#x2F;carpenter&#x2F;INIT; #24 &#x3D; Utf8 main #25 &#x3D; Utf8 ([Ljava&#x2F;lang&#x2F;String;)V #26 &#x3D; Utf8 args #27 &#x3D; Utf8 [Ljava&#x2F;lang&#x2F;String; #28 &#x3D; Utf8 d #29 &#x3D; Utf8 SourceFile #30 &#x3D; Utf8 INIT.java #31 &#x3D; NameAndType #17:#45 &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V #32 &#x3D; Utf8 s1 #33 &#x3D; NameAndType #13:#14 &#x2F;&#x2F; a:Ljava&#x2F;lang&#x2F;String; #34 &#x3D; NameAndType #15:#16 &#x2F;&#x2F; b:I #35 &#x3D; Utf8 s2 #36 &#x3D; Utf8 top&#x2F;carpenter&#x2F;INIT #37 &#x3D; Utf8 s3 #38 &#x3D; NameAndType #17:#18 &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;I)V #39 &#x3D; Class #46 &#x2F;&#x2F; java&#x2F;lang&#x2F;System #40 &#x3D; NameAndType #47:#48 &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream; #41 &#x3D; Class #49 &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream #42 &#x3D; NameAndType #50:#51 &#x2F;&#x2F; println:(Ljava&#x2F;lang&#x2F;String;)V #43 &#x3D; NameAndType #50:#52 &#x2F;&#x2F; println:(I)V #44 &#x3D; Utf8 java&#x2F;lang&#x2F;Object #45 &#x3D; Utf8 ()V #46 &#x3D; Utf8 java&#x2F;lang&#x2F;System #47 &#x3D; Utf8 out #48 &#x3D; Utf8 Ljava&#x2F;io&#x2F;PrintStream; #49 &#x3D; Utf8 java&#x2F;io&#x2F;PrintStream #50 &#x3D; Utf8 println #51 &#x3D; Utf8 (Ljava&#x2F;lang&#x2F;String;)V #52 &#x3D; Utf8 (I)V&#123; public top.carpenter.INIT(java.lang.String, int); descriptor: (Ljava&#x2F;lang&#x2F;String;I)V flags: ACC_PUBLIC Code: stack&#x3D;2, locals&#x3D;3, args_size&#x3D;3 0: aload_0 1: invokespecial #1 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V 4: aload_0 5: ldc #2 &#x2F;&#x2F; String s1 7: putfield #3 &#x2F;&#x2F; Field a:Ljava&#x2F;lang&#x2F;String; 10: aload_0 11: bipush 20 13: putfield #4 &#x2F;&#x2F; Field b:I 16: aload_0 17: bipush 10 19: putfield #4 &#x2F;&#x2F; Field b:I 22: aload_0 23: ldc #5 &#x2F;&#x2F; String s2 25: putfield #3 &#x2F;&#x2F; Field a:Ljava&#x2F;lang&#x2F;String; 28: aload_0 29: aload_1 30: putfield #3 &#x2F;&#x2F; Field a:Ljava&#x2F;lang&#x2F;String; 33: aload_0 34: iload_2 35: putfield #4 &#x2F;&#x2F; Field b:I 38: return LineNumberTable: line 16: 0 line 4: 4 line 7: 10 line 10: 16 line 13: 22 line 17: 28 line 18: 33 line 19: 38 LocalVariableTable: Start Length Slot Name Signature 0 39 0 this Ltop&#x2F;carpenter&#x2F;INIT; 0 39 1 a Ljava&#x2F;lang&#x2F;String; 0 39 2 b I public static void main(java.lang.String[]); descriptor: ([Ljava&#x2F;lang&#x2F;String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack&#x3D;4, locals&#x3D;2, args_size&#x3D;1 0: new #6 &#x2F;&#x2F; class top&#x2F;carpenter&#x2F;INIT 3: dup 4: ldc #7 &#x2F;&#x2F; String s3 6: bipush 30 8: invokespecial #8 &#x2F;&#x2F; Method &quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;I)V 11: astore_1 12: getstatic #9 &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream; 15: aload_1 16: getfield #3 &#x2F;&#x2F; Field a:Ljava&#x2F;lang&#x2F;String; 19: invokevirtual #10 &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V 22: getstatic #9 &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream; 25: aload_1 26: getfield #4 &#x2F;&#x2F; Field b:I 29: invokevirtual #11 &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(I)V 32: return LineNumberTable: line 22: 0 line 23: 12 line 24: 22 line 26: 32 LocalVariableTable: Start Length Slot Name Signature 0 33 0 args [Ljava&#x2F;lang&#x2F;String; 12 21 1 d Ltop&#x2F;carpenter&#x2F;INIT;&#125;SourceFile: &quot;INIT.java&quot; 3.3.2方法调用 对于Java类中的每一个实例方法(非static方法) ，其在编译后所生成的字节码当中，方法参数的数量总是会比源代码中方法参数的数量多一个(this)，位于方法的第一个参数位置处 这样，我们就可以在Java的实例方法中使用this来去访问当前对象的属性以及其他方法。 这个操作是在编译期间完成的，即由javac编译器在编译的时候，将对this的访问转化为对一个普通实例方法参数的访问，接下来在运行期间，由JVM在调用实例方法时，自动向实例方法传入该this参数。所以，在实例方法的局部变量表中，至少会有一个指向当前对象的局部变量。 123456789101112131415161718192021public class Function &#123; //构造方法 public Function() &#123;&#125; //私有方法 private void test1() &#123;&#125; //final方法 private final void test2() &#123;&#125; //public方法 public void test3() &#123;&#125; //静态方法 public static void test4()&#123;&#125; public static void main(String[] args) &#123; Function d = new Function(); d.test1(); d.test2(); d.test3(); d.test4(); Function.test4(); &#125;&#125; 12345678910111213141516171819202122232425public static void main(java.lang.String[]); descriptor: ([Ljava&#x2F;lang&#x2F;String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack&#x3D;2, locals&#x3D;2, args_size&#x3D;1 0: new #2 &#x2F;&#x2F; class top&#x2F;carpenter&#x2F;Function 在堆中分配内存 将引用放入操作数栈 3: dup 将操作数栈 引用对象复制一份【有两个对象引用】 4: invokespecial #3 &#x2F;&#x2F; Method &quot;&lt;init&gt;&quot;:()V 消耗一个对象引用 7: astore_1 将对象引用赋值d 操作数栈消耗空了 8: aload_1 9: invokespecial #4 &#x2F;&#x2F; Method test1:()V 12: aload_1 13: invokespecial #5 &#x2F;&#x2F; Method test2:()V 16: aload_1 17: invokevirtual #6 &#x2F;&#x2F; Method test3:()V &#x2F;&#x2F;public方法 20: aload_1 加入操作数栈 因为对象调用static方法 21: pop 弹出操作数栈 多余了 22: invokestatic #7 &#x2F;&#x2F; Method test4:()V 25: invokestatic #7 &#x2F;&#x2F; Method test4:()V 28: return LocalVariableTable: Start Length Slot Name Signature 0 29 0 args [Ljava&#x2F;lang&#x2F;String; 8 21 1 d Ltop&#x2F;carpenter&#x2F;Function; 方法调用字节码指令存在5种情况 静态绑定：在字节码生成的时候就知道执行的是哪个类哪个方法了 invokespecial 调用自己的私有方法、构造方法(&lt;init&gt;) 以及父类的方法。 invokestatic调用static方法 动态绑定：在运行期确定的 invokeinterface调用接口中的方法，决定到底调用实现该接口的哪个对象的特定方法 方法区的接口方法表的数据结构(interface method table, itable)有关 invokevirtual都属于动态绑定，调用虚方法 方法区的虚方法表的数据结构(virtual method table, vtable)有关 invokedynamic动态调用方法 性能：接口调用，多态调用，直接调用的性能可以显而易见，invokeinterface最慢，invokevitual中，invokespeical最快 3.3.3多态调用-虚拟函数表Vtable 包含该类所有函数自有函数（除了static, final，私有方法）和父类的函数虚拟表。 结构： 1vtableEntry | vtableEntry |vtableEntry... 是以vtableEntry 结构体的数组顺序结构，在每个entry 中保存了所调用的函数的指针 举个例子： 123456789class A &#123; public void A()&#123;&#125; public void A(String a)&#123;&#125;&#125;class B extends A&#123; public void A()&#123;&#125; public void B()&#123;&#125;&#125; 对于B的vtale: 就是 {B.A}{A.A(String)}{B.B} 如何初始化——当类初始化的时候，复制父类的虚拟表， 然后根据自己的顺序替换或者增加虚拟表的内容， 如果overwrite函数,(方法名字，参数签名 完全一样)，也就是替换虚拟表相同顺序的内容 如果overload函数（方法名字，参数签名完全不一样）/或者自己写的函数，顺序添加到虚拟表尾部 特殊的mirandas，该类的实现的接口函数里的方法列表，如果函数名字和参数签名一样的话，认为是同一个，顺序的添加到虚拟表的最后 在链接时 生成虚方法表 当执行invokevirtual指令时，字节码指令的多态查找流程 先通过栈帧中操作数栈顶的对象引用找到对象 分析对象头，找到对象的实际Class Class结构中有虚方法表vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了 查表得到方法的具体地址 执行方法的字节码 3.2.2静态分配1234567891011121314151617181920212223242526public class Load9 &#123; public static void main(String[] args) throws NullPointerException &#123; GradePa gradePa1 = new GradePa(); GradePa gradePa2 = new Father(); GradePa gradePa3 = new Son(); print(gradePa1); //GradePa print(gradePa2); //GradePa print(gradePa3); //GradePa &#125; public static void print(GradePa gradePa) &#123; System.out.println(\"GradePa\"); &#125; public static void print(Father gradePa) &#123; System.out.println(\"Father\"); &#125; public static void print(Son gradePa) &#123; System.out.println(\"Son\"); &#125;&#125;class GradePa&#123;&#125;class Father extends GradePa&#123;&#125;class Son extends Father&#123;&#125; 3.3异常处理3.3.1try-catch 方法表信息中的方法的Code属性多出来一个Exception table的结构，[rom, to)是前闭后开的检测范围，一旦这个范围内的字节码 执行出现异常，则通过type匹配异常类型 如果一致, 进入target所指示行号8行的字节码指令astore_2是将异常对象引用存入局部变量表的slot2位置 12345678910111213package top.carpenter;public class TryCatch &#123; public static void main(String[] args) &#123; int i = 0; try&#123; i = 20; &#125;catch (Exception e) &#123; i =12 ; &#125; &#125;&#125; 1234567891011121314151617public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=3, args_size=1 0: iconst_0 1: istore_1 2: bipush 20 4: istore_1 5: goto 12 8: astore_2 9: bipush 12 11: istore_1 12: return Exception table: from to target type 2 5 8 Class java/lang/Exception 3.3.2finally 可以看到finally中的代码被复制了3份，分别放入try流程，catch 流程以及catch 剩余的异常类型流程 3.3.2.1finally出现了return 由于finally中的ireturn被插入了所有可能的流程，因此返回结果肯定以finally的为准 字节码中第2行，return执行之前要暂存一下 跟上例中的finally相比，发现没有athrow了，这告诉我们：如果在finally中出现了return，会吞掉异常 12345678910111213public static void main(String[] args) &#123; int result = test(); System.out.println(result); //20 &#125; public static int test() &#123; try &#123; //int i = 10/0; 依然返回20 不出现异常 return 10; &#125; finally &#123; return 20; &#125;&#125; 3.3.2.2finally对返回值的影响123456789101112public static void main(String[] args) &#123; int result = test(); System.out.println(result); //10 &#125; public static int test() &#123; int i=10; try &#123; return i; &#125; finally &#123; i=20; &#125; &#125; 3.3.3异常 如果异常采用throws NullPointerException抛出，则不会出现在Code属性表集合中，而是在与Code同级，不属于方法体的内容， 123456789public static void main(String[] args) throws NullPointerException &#123; int i = 0; try&#123; i = 20; &#125;catch (Exception e) &#123; i =12 ; &#125; &#125; 3.4synchronized锁123456public static void main(String[] args) &#123; Object lock = new Object(); synchronized(lock) &#123; System.out.println(\"ok\"); &#125; &#125; 方法级别的synchronized不会在字节码指令中有所体现 会在访问标志中区别 4.编译期处理 所谓的语法糖，其实就是指java编译器把*. java源码编译为*. class字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担 编译器转换的结果直接就是class字节码，以下只是为了便于阅读，给出了几乎等价的java源码方式，并不是编译器还会转换出中间的java源码,切记。 4.1默认构造器4.2自动拆装箱4.3泛型集合存取 Java在编译泛型代码后会执行泛型擦除的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了Object类型来处理: 1234567public class Candy3 &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(10); //实际调用的是List.add(Object e) Integer x = list.get(0); //实际调用的是Object obj = List.get(int index); &#125;&#125; 4.4可变参数123456789public class Candy4 &#123; public static void foo(String... args) &#123; String[] array = args; //直接赋值 System.out.println(array); &#125; public static void main(String[] args) &#123; foo(\"hello\", \"world\"); &#125;&#125; 可变参数String... args其实是一个String[] args，从代码中的赋值语句中就可以看出来 注意：如果调用了foo()则等价代码为foo(new String[]{})， 创建了一个空的数组，而不会传递null进去 4.5foreach循环12345678public class Candy5_1 &#123; public static void main(String[] args) &#123; int[] array = &#123;1, 2, 3, 4, 5&#125;; //数组赋初值的简化写法也是语法糖 for (int e : array) &#123; System.out.println(e); &#125; &#125;&#125; 会被编译器转换为 123456789public class Candy5_1 &#123; public static void main(String[] args) &#123; int[] array = new int[]&#123;1, 2, 3, 4, 5&#125;; for(int i = 0; i &lt; array.length; ++i) &#123; int e = array[i]; System.out.println(e); &#125; &#125;&#125; foreach循环能够配合数组，以及所有实现了Iterable 接口的集合类一起使用， 其中Iterable 用来获取集合的迭代器(Iterator) 4.6switch字符串 从JDK 7开始，通过转换利用原生switch，作用于字符串和枚举类 1234567891011121314public class Candy6_1 &#123; public static void choose(String str) &#123; switch (str) &#123; case \"hello\": &#123; System.out.println(\"h\"); break; &#125; case \"world\": &#123; System.out.println(\"w\"); break; &#125; &#125; &#125;&#125; 注意：switch配合String和枚举使用时，变量不能为null 会被编译器转换为: 执行了两遍switch 第一遍是根据字符串的hashCode【提高效率】和equals【防止hashCode冲突】将字符串的转换为相应byte类型 第二遍才是利用byte执行进行比较 4.7switch枚举类12345678910111213enum Sex &#123; MALE，FEMALE&#125;public class Candy_7 &#123; public static void foo(Sex sex) &#123; switch (sex) &#123; case MALE: &#123;System.out.println(\"男\"); break;&#125; case FEMALE: &#123;System.out.println(\"女\"); break;&#125; &#125; &#125;&#125; 4.8枚举类4.9try-with-resources JDK 7开始新增了对需要关闭的资源处理的特殊语法try-with-resources 12345try(资源变量=创建资源对象)&#123; ...&#125;catch() &#123;&#125; 其中资源对象需要实现AutoCloseable接口，例如InputStream OutputStream Connection Statement``ResultSet等接口都实现了AutoCloseable, 使用try-with-resources可以不用写finally语句块,编译器会帮助生成关闭资源代码 123456789public class Candy_9 &#123; public static void main(String[] args) &#123; try(InputStream is = new FileInputStream(\"d:\\\\1.txt\")) &#123; System.out.println(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 为什么要设计一个addSuppressed(Throwable e) (添加被压制异常) 的方法呢?是为了防止异常信息的丢失(想想try-with-resources生成的fianlly中如果抛出了异常) : 1234567891011121314public class Test6 &#123; public static void main(String[] args) &#123; try (MyResource resource = new MyResource()) &#123; int i = 1/0; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class MyResource implements AutoCloseable &#123; public void close() throws Exception &#123; throw new Exception(\"close 异常\"); &#125;&#125; 输出： 4.10方法重写时的桥接方法 方法重写时对返回值分两种情况 父子类的返回值完全一致 子类返回值可以是父类返回值的子类( 123456789101112class A &#123; public Number m() &#123; return 1; &#125;&#125;class B extends A &#123; @Override //子类m方法的返回值是Integer是父类m方法返回值Number的子类 public Integer m() &#123; return 2; &#125;&#125; 对于子类，java 编译器会做如下处理: 12345678910class B extends A &#123; public Integer m() &#123; return 2; &#125; //此方法才是真正重写了父类public Number m()方法 public synthetic bridge Number m() &#123; //调用public Integer m() return m( ); &#125;&#125; 其中桥接方法比较特殊，仅对java虚拟机可见，并且与原来的public Integer m()没有命名冲突，可以用下面反射代码来验证: 123for (Method m : B.class.getDeclaredMethods()) &#123; System. out. println(m); &#125; 会输出: 12public java.lang.Integer test.candy.B.m()public java.lang.Number test.candy.B.m() 4.11内部类 匿名内部类为例 12345678910public class Candy_11 &#123; public static void main(String[] args) &#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println(\"ok\"); &#125; &#125; &#125;&#125; 转换后代码: 123456789101112//额外生成的类final class Candy11$1 implements Runnable &#123; Candy11$1() &#123; public void run() &#123; System.out.println(\"ok\"); &#125;&#125;public class Candy11 &#123; public static void main(String[] args) &#123; Runnable runnable = new Candy11$1(); &#125;&#125; 引用局部变量的匿名内部类，源代码: 123456789public class Candy11 &#123; public static void test(final int x) &#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println(\"ok:\" + x); &#125;; &#125;&#125; 转换后代码: 123456789101112131415//额外生成的类final class Candy11$1 implements Runnable &#123; int val$x; Candy11$1(int x) &#123; this.val$x = x; &#125; public void run() &#123; System.out.println(\"ok:\" + this.val$x); &#125;&#125;public class Candy11 &#123; public static void test(final int x) &#123; Runnable runnable = new Candy11$1(x); &#125;&#125; 解释了为什么匿名内部类引用局部变量时，局部变量必须是final的 因为在创建Candy11$1对象时，将x的值赋值给了Candy11$1对象的val$x属性，所以x不应该再发生变化了，如果变化,那么valx属性没有机会再跟着一起变化","tags":[{"name":"JVM","slug":"JVM","permalink":"http://goldcarpenter.github.io/tags/JVM/"}]},{"title":"MyBatis","date":"2019-07-14T16:00:00.000Z","path":"2019/07/15/MyBatis_Part2/","text":"3.基于代理Dao的CRUD操作3.1.搭建步骤 创建maven工程 导入坐标 编写必要代码(实体类和持久层接口) 编写SqlMapConfig.xml 编写映射配置文件 编写测试类 3.2.根据ID查询 findById方法 123public interface IUserDao &#123; User findById(Integer id);&#125; 在用户的映射配置文件中配置 resultType属性：用于指定结果集的类型 parameterType属性：用于指定传入参数的类型 sql语句中使用#{}字符：它代表占位符，相当于原来jdbc部分的?，都是用于执行语句时替换实际的数据。具体的数据是由#{}里面的内容决定的 #{}中内容的写法：由于数据类型是基本类型，所以此处可以随意写 123&lt;select id=\"findById\" resultType=\"top.carpenter.pojo.User\" parameterType=\"java.lang.Integer\"&gt; select * from user where id=#&#123;id&#125;;&lt;/select&gt; 3.3.保存操作 saveUser方法 123public IUserDao &#123; void saveUser(User user);&#125; 在用户的映射配置文件中配置 #{}中内容的写法：由于我们保存方法的参数是一个User对象，此处要写User对象中的属性名称。用的是ognl表达式 ognl表达式 它是apache提供的一种表达式语言， 全称是object Graphic Navigation Language对象图导航语言 按照一定的语法格式来获取数据的。语法格式就是使用#{对象.对象}的方式 #{user.username}会先去找user对象，然后在user对象中找到username属性，并调用getUsername()方法把值取出来。但是在parameterType属性上指定了实体类名称top.carpenter.pojo.User，所以可以省略user.直接写username 1234567&lt;insert id=\"saveUser\" parameterType=\"top.carpenter.pojo.User\"&gt; &lt;!-- 配置插入操作后，获取插入数据的id--&gt; &lt;selectKey keyColumn=\"id\" keyProperty=\"id\" resultType=\"java.lang.Integer\" order=\"AFTER\"&gt; select last_insert_id(); &lt;/selectKey&gt; insert into user(username,address,sex,birthday) values(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;); &lt;/insert&gt; 3.4.用户更新 updateUser方法 123public interface IUserDao &#123; void updateUser(User user);&#125; 在用户的映射配置文件中配置 123&lt;update id=\"updateUser\" parameterType=\"top.carpenter.pojo.User\"&gt; update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;&lt;/update&gt; 3.5.用户删除 deleteUser方法 123public interface IUserDao &#123; void deleteUser(Integer id);&#125; 在用户的映射配置文件中配置 123&lt;delete id=\"deleteUser\" parameterType=\"java.lang.Integer\"&gt; delete from user where id=#&#123;id&#125;;&lt;/delete&gt; 3.6.用户模糊查询 findByName方法 123public interface IUserDao &#123; List&lt;User&gt; findByName(String Username);&#125; 在用户的映射配置文件中配置 虽然 UserMapper 中方法的返回值为 List，但是映射文件中 resultType写 User就行。因为如果有多条记录的话，Mybatis 会自动帮我们封装成一个 List 集合。 123&lt;select id=\"findByName\" resultType=\"top.carpenter.pojo.User\" parameterType=\"String\"&gt; select * from user where username like #&#123;username&#125;&lt;/select&gt; 3.7.查询使用聚合函数 findTotal方法 123public interface IUserDao &#123; int findTotal();&#125; 在用户的映射配置文件中配置 123&lt;select id=\"findTotal\" resultType=\"int\"&gt; select count(*) from user;&lt;/select&gt; 3.8.测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package top.carpenter;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import top.carpenter.dao.IUserDao;import top.carpenter.pojo.User;import java.io.IOException;import java.io.InputStream;import java.sql.SQLException;import java.util.Date;import java.util.List;public class MybatisTest &#123; private InputStream in = null; private SqlSession session = null; SqlSessionFactory factory = null; private IUserDao userDao = null; @Before public void Before() throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.创建SqlSessionFactory的构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.使用构建者创建工厂对象sqlSessionFactory factory = builder.build(in); //4.使用SqlSessionFactory生产SqlSession对象 session = factory.openSession(); //5.使用sqlSession创建dao接口的代理对象 userDao = session.getMapper(IUserDao.class); &#125; @Test public void testFindAll() throws IOException, SQLException, ClassNotFoundException &#123; System.out.println(\"testFindAll\"); List&lt;User&gt; users = userDao.findAll(); for (User user : users)&#123; System.out.println(user); &#125; System.out.println(\"testFindAll\"); &#125; @Test public void testDeleteUser() throws IOException, SQLException, ClassNotFoundException &#123; System.out.println(\"testDeleteUser\"); userDao.deleteUser(98); session.commit(); System.out.println(\"testDeleteUser\"); &#125; @Test public void testSaveUser() throws Exception &#123; System.out.println(\"testSaveUser\"); User user = new User(); user.setUsername(\"yyx\"); user.setAddress(\"old address\"); user.setSex(\"男\"); user.setBirthday(new Date()); System.out.println(user); userDao.saveUser(user); System.out.println(user); session.commit(); System.out.println(\"testSaveUser\"); &#125; @Test public void testUpdateUser() throws Exception &#123; System.out.println(\"testUpdateUser\"); User user = userDao.findByName(\"%yyx%\").get(0); user.setAddress(\"new address\"); userDao.updateUser(user); session.commit(); System.out.println(\"testUpdateUser\"); &#125; @Test public void testfindTotal() throws Exception &#123; System.out.println(\"testfindTotal\"); int count = userDao.findTotal(); System.out.println(count); System.out.println(\"testfindTotal\"); &#125; @After public void After() throws IOException &#123; session.close(); in.close(); &#125;&#125; 3.9.MyBatis对比JDBC 数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，使用数据库链接池可解决此问题 解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接 Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码 解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离 向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数对应 解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型 对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便 解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型 4.Mybatis的参数深入4.1.@parameterType参数深入 parameterType属性可以用于给SQL语句传参 属性的取值 基本类型 基本类型可以直接写类型名称，也可以使用包名.类名的方式 引用类型（例如:String类型） String类型可以直接写类型名称，也可以使用java.lang.String的方式 实体类类型（POJO类） 在注册别名之前，只能使用全限定类名 实体类的包装类（Pojo类包含Pojo类） 创建Pojo包装对象 1234public clas QueryVo implementss Seriablizable&#123; private User user; // get set 方法 &#125; IUserDao 123public interface IUserDao &#123; List&lt;User&gt; findByVo(QueryVo vo);&#125; 接口映射配置文件 12345&lt;!--根据用户名称模糊查询，参数变成一个QueryVo对象了--&gt;&lt;select id=\"findByVo\" resultType=\"top.carpenter.pojo.User\"parameterType= \"top.carpenter.pojo.QueryVo\"&gt; select * from user where username like #&#123;user.username&#125;;&lt;/select&gt; 4.2.@resultType参数深入 resultType属性可以指定结果集的类型，它支持基本类型和实体类类型 如果注册过类型别名的，可以直接使用别名。没有注册过的必须使用全限定类名。例如:我们的实体类此时必须是全限定类名 同时，当是实体类名称时，实体类定义的属性名称必须和查询语句中的列名保持一致，否则无法实现封装 实体类属性和数据库表列名不一致 将两个对应相同的username不动，其余修改为成无对应的名称，发现无法封装 方法一：修改映射配置文件 在查询语句中使用别名 123&lt;select id=\"findAll\" resultType=\"top.carpenter.pojo.User\"&gt; select id as userid, username as username , birthday as userbirthday, sex as usersex, address as from user&lt;/select&gt; 方法二：resultMap结果类型 resultMap标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。 在select标签中使用resultMap属性指定引用即可。同时resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询 type属性：指定实体类的全限定类名 id属性：给定一个唯一标识，是给查询select标签引用用的 id标签：用于指定主键字段 result标签：用于指定非主键字段 colunn属性：用于指定数据库列名 property属性：用于指定实体类属性名称 123456789101112&lt;mapper namespace=\"top.carpenter.dao.IUserDao\"&gt; &lt;resultMap id=\"userMap\" type=\"top.carpenter.pojo.User\"&gt; &lt;id column=\"id\" property=\"userid\"/&gt; &lt;result column=\"username\" property=\"username\"/&gt; &lt;result column=\"birthday\" property=\"userbirthday\"/&gt; &lt;result column=\"sex\" property=\"usersex\"/&gt; &lt;result column=\"address\" property=\"useraddress\"/&gt; &lt;/resultMap&gt; &lt;!--配置查询所有--&gt; &lt;select id=\"findAll\" resultMap=\"userMap\"&gt; select * from user &lt;/select&gt; 5.SqlMapConfig.xml中配置文件5.1.配置内容1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=\"mysql\"&gt; &lt;!-- 配置mysql的环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!-- 配置事务的类型--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;mappers&gt;&lt;!-- &lt;mapper resource=\"top/carpenter/dao/IUserDao.xml\"/&gt;--&gt; &lt;mapper class=\"top.carpenter.dao.IUserDao\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 5.2.properties标签 在配置数据库连接的时候，我们可以采用以下几种方式来配置： 采用全局的内部配置 如果需要配置多个数据库环境，那么像 username、password 等属性就可以复用，提高开发效率。 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 全局变量 --&gt; &lt;properties&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/db_mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/properties&gt; &lt;!--配置环境--&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!-- 配置事务类型 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"UserMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 第二种，使用 resources 属性引入外部配置文件（常用） 123456#编写配置文件 jdbcConfig.properties。配置文件名没有限制，但是配置文件一定要放在类路径下# 键为 jdbc.xxx 可以自行修改jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/db_mybatisjdbc.username=rootjdbc.password=123456 12&lt;!-- 引入外部文件 --&gt;&lt;properties resource=\"jdbcConfig.properties\"/&gt; 第三种，使用 url 属性引入外部配置文件 外部文件可以放在任意位置，但是路径写法必须按照 Url 的方式，写起来比较麻烦 12&lt;!-- 引入外部文件 --&gt;&lt;properties url=\"file:///D:/document/.../src/main/resources/jdbcConfig.properties\"/&gt; URL：Uniform Resouce Locator，即统一资源定位符。它可以唯一标识一个资源的位置，由四部分组成：协议、主机、端口、路径。 例如：http://localhost:8080/mybatisserver/demo1，其中 http 为协议, localhost 为主机，8080 为端口号，/mybatisserver/demo1 为uri（路径） URI：Uniform Resource Identifier，即统一资源标识符。它是在应用中可以唯一定位一个资源的。 5.3. typeAliases 标签 之前在编写映射文件的时候，resultType这个属性可以写int、INT等，就是因为 Mybatis 给这些类型起了别名。 如果我们也想给某个实体类指定别名的时候，就可以采用 typeAliases 标签。用法如下： typeAlias子标签：用于配置别名 type属性：用于指定要配置的类的全限定类名（该类只能是某个domain实体类）, alias属性：指定别名。一旦指定了别名，那么别名就不再区分大小写。 123456789&lt;configuration&gt; &lt;!-- 位于&lt;configuration&gt; 标签内--&gt; &lt;!--配置别名--&gt; &lt;typeAliases&gt; &lt;typeAlias type=\"top.carpenter.pojo.User\" alias=\"user\"/&gt; &lt;/typeAliases&gt; &lt;!-- 其他配置省略... --&gt;&lt;/configuration&gt; 当我们有多个实体类需要起别名的时候，那么我们就可以使用package标签。 package标签指定要配置别名的包，当指定之后，该包下的所有实体类都会注册别名，并且别名就是类名，不再区分大小写 1234&lt;typeAliases&gt; &lt;!-- 包下所有实体类起别名 --&gt; &lt;package name=\"top.carpenter.pojo\"/&gt;&lt;/typeAliases&gt; package 标签还可以将某个包内的映射器接口实现全部注册为映射器 1234&lt;!-- 指定映射文件 --&gt;&lt;mappers&gt; &lt;package name=\"top.carpenter.dao\"/&gt;&lt;/mappers&gt; 5.4.SqlMapConfig.xml配置内容和顺序1234567891011121314151617-properties(属性) --property-settings(全局配置参数) -- setting-typeAliases(类型别名) --typeAliase --package-typeHandlers(类型处理器)-objectFactory(对象工厂)-plugins(插件)-environments(环境集合属性对象) --environment(环境子属性对象) ---transactionManager (事务管理) ---dataSource(数据源)-mappers(映射器) --mapper --package 6.Mybatis 连接池简单介绍 在 Mybatis 中，数据源dataSource共有三类，分别是： UNPOOLED： 不使用连接池的数据源。采用传统的javax.sql.DataSource规范中的连接池，Mybatis 中有针对规范的实现 POOLED： 使用连接池的数据源。采用传统的获取连接的方式，虽然也实现Javax.sql.DataSource接口，但是并没有使用池的思想。 JNDI： 使用 JNDI 实现的数据源，采用服务器提供的 JNDI 技术实现，来获取 DataSource 对象，不同的服务器所能拿到的 DataSource 是不一样的。【如果不是 Web 或者 Maven 的war工程，是不能使用 JNDI 的。】 如果想要修改 Mybatis 使用的数据源，那么就可以在 Mybatis 配置文件中修改： 1234567&lt;!-- 配置数据源（连接池） --&gt;&lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/dataSource&gt; 查看POOLED的实现PooledDataSource，可以看出获取连接时采用了池的思想 查看UNPOOLED的实现UnpooledDataSource，可以看出每次获取连接时都会注册驱动并创建新连接","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://goldcarpenter.github.io/tags/MyBatis/"}]},{"title":"Java虚拟机","date":"2019-07-13T14:32:42.000Z","path":"2019/07/13/JVM_Part2/","text":"2.内存管理 / 垃圾回收2.1概述 Java与C语言相比的一个优势是，可以通过自己的JVM自动分配和回收内存空间。垃圾回收机制是由垃圾收集器Garbage Collection来实现的，GC是后台一个低优先级的守护进程。在内存中低到一定限度时才会自动运行，因此垃圾回收的时间是不确定的。 为何要这样设计：因为GC也要消耗CPU等资源，如果GC执行过于频繁会对Java的程序的执行产生较大的影响，因此实行不定期的GC。 与GC有关的是：JVM运行时数据区中的堆（对象实例会存储在这里）和 gabage collector方法。垃圾回收GC只能回收通过new关键字申请的内存（在堆上），但是堆上的内存并不完全是通过new申请分配的。还有一些本地方法，这些内存如果不手动释放，就会导致内存泄露，所以需要在finalize中用本地方法(native method)如free操作等，再使用gc方法。 2.2两次标记要真正宣告一个对象死亡，至少需要经历两次标记过程。 Finalizer线程由JVM自动创建，优先级很低 Finalizer线程不保证等待finalize()方法结束，避免方法中存在死循环或执行缓慢，致使队列中其他对象永久等待，内存回收系统崩溃 finalize()方法运行代价高昂，建议使用try..catch..代替 2.3引用的状态：强软弱虚可达性分析判断对象的引用链是否可达，即对象是否存活与引用有关 JDK1.2以前 reference类型的数据中存储的数值代表的是否是另外块内存的起始地址 只有引用 &amp; 没被引用 两种状态 JDK1.2以后：对引用进行扩充为四种 引用队列 被引用对象被回收前，***Reference对象加入引用队列 强引用 123456789Object obj1 = new Object(); //java.lang.Object@74a14482有一个强引用Object obj2 = obj1; //java.lang.Object@74a14482有两个强引用obj1 = null; System.gc(); System.out.println(obj2); //还有一个强引用 所以没有被GC/*java.lang.Object@74a14482*/ 最常见的普通对象引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用，当一个对象被即使一个强引用对象引用时，标明对象还”活着”，就不会回收 就算是出现了OOM也不会对该对象进行回收，崩盘也不回收 一个普通对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式的将响应的强引用设置为null，则认为可以被GC 内存泄露的主要原因之一 软引用 123456789101112131415161718192021/* * 程序：内存空间够用 保留 */Object o1 = new Object(); //java.lang.Object@74a14482有一个强引用//java.lang.Object@74a14482有一个强引用 + 一个软引用SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(o1);System.out.println(o1);System.out.println(softReference.get());o1 = null; //置空 java.lang.Object@74a14482只剩一个软引用System.gc();System.out.println(o1); // 置空故为nullSystem.out.println(softReference.get()); //内存空间富裕 则保留/*java.lang.Object@74a14482java.lang.Object@74a14482nulljava.lang.Object@74a14482*/ 1234567891011121314151617181920212223242526272829303132/* * 程序：内存空间不够用 * JVM配置：-Xms5m -Xmx5m -XX:+PrintGCDetails * 故意产生大对象【30M】并配置小内存【5M】，倒置OOM，查看软引用的回收情况 */Object o1 = new Object(); //java.lang.Object@74a14482有一个强引用//java.lang.Object@74a14482有一个强引用 + 一个软引用SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(o1);System.out.println(o1);System.out.println(softReference.get());o1 = null; //置空 java.lang.Object@74a14482只剩一个软引用try&#123; // 在总共5M的内存分配 30M强引用 触发垃圾回收 byte[] bytes = new byte[30 * 1024 * 1024];&#125;catch (Throwable e)&#123; e.printStackTrace();&#125;finally &#123; System.out.println(o1); System.out.println(softReference.get());//内存空间不足 被软引用的对象被回收&#125;/*java.lang.Object@74a14482java.lang.Object@74a14482java.lang.OutOfMemoryError: Java heap space at Main.main(test.java:28)nullnull*/ 用来描述还有用但是非必须的对象【可以做内存敏感的高速缓存】 如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存 在系统将要发生OOM异常之前，将会把这些对象范围内的进行二次回收，如果还没有足够内存，抛出OOM异常 应用：读取本地大量图片——分次读影响性能，一次读取容易OOM 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * SoftRefenceCache * @param &lt;K&gt; key的类型. * @param &lt;V&gt; value的类型. */class SoftReferenceCache&lt;K, V&gt; &#123; private final HashMap&lt;K, SoftReference&lt;V&gt;&gt; mCache; public SoftReferenceCache() &#123; mCache = new HashMap&lt;K, SoftReference&lt;V&gt;&gt;(); &#125; /** * 将对象放进缓存中，这个对象可以在GC发生时被回收 * * @param key key的值. * @param value value的值型. */ public void put(K key, V value) &#123; mCache.put(key, new SoftReference&lt;V&gt;(value)); &#125; /** * 从缓存中获取value * @param key * @return 如果找到的话返回value，如果被回收或者压根儿没有就返回null */ public V get(K key) &#123; V value = null; SoftReference&lt;V&gt; reference = mCache.get(key); if (reference != null) &#123; value = reference.get(); &#125; return value; &#125;&#125;class Main&#123; public static void main(String[] args) throws Exception &#123; SoftReferenceCache&lt;Integer, Person&gt; mPersonCache = new SoftReferenceCache&lt;&gt;(); mPersonCache.put(0, new Person(\"Peter\")); mPersonCache.put(1, new Person(\"Jan\")); mPersonCache.put(2, new Person(\"Kees\")); // 去拿Jan Person p = (Person) mPersonCache.get(1); System.out.println(p.name); &#125;&#125; 弱引用 12345678910111213141516Object o1 = new Object(); //java.lang.Object@74a14482有一个强引用//java.lang.Object@74a14482有一个强引用 + 一个弱引用WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;&gt;(o1);System.out.println(o1);System.out.println(weakReference.get());o1 = null; //置空 java.lang.Object@74a14482只剩一个弱引用System.gc();System.out.println(o1); // 置空故为nullSystem.out.println(weakReference.get()); // null 弱引用一定被回收 /*java.lang.Object@74a14482java.lang.Object@74a14482nullnull*/ 垃圾回收器一旦发现了弱引用的对象，不管当前内存空间足够与否，都会回收它的内存 不过由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些弱引用的对象 WeakHashMap 123456789101112WeakHashMap&lt;Integer,String&gt; map = new WeakHashMap&lt;&gt;();Integer value = new Integer(3);String str = new String(\"weakHashMap\");map.put(value, str);System.out.println(map); // &#123;3=weakHashMap&#125;value = null;System.out.println(map); // &#123;3=weakHashMap&#125;System.gc();System.out.println(map); // &#123;&#125;System.out.println(map.size()); // 0 虚引用 12345678910111213141516171819202122232425262728Object o1 = new Object();// 创建引用队列ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;&gt;();//java.lang.Object@74a14482有一个强引用 + 一个虚引用PhantomReference&lt;Object&gt; phantomReference = new PhantomReference&lt;&gt;(o1, referenceQueue);System.out.println(o1);System.out.println(phantomReference.get()); // 不管gc 虚引用永远返回nullSystem.out.println(referenceQueue.poll()); // 没有gc 为nullSystem.out.println(\"=====================\");o1 = null;System.gc();Thread.sleep(500);System.out.println(o1);System.out.println(phantomReference.get()); // 虚引用永远返回nullSystem.out.println(referenceQueue.poll()); // 对象被回收到队列中/*java.lang.Object@74a14482nullnull=====================nullnulljava.lang.ref.PhantomReference@7ea987ac*/ * 一个对象是否有虚引用的存在，完全不会对其生命时间构成影响 * 如果一个对象被虚引用，那么它就和没有引用一样，在任何时候都可能被垃圾回收器回收 * 必须和引用队列（ReferenceQueue）联合使用 * 每次调用get方法，返回值总是null * **虚引用主要用来跟踪对象被垃圾回收的活动**。 * **直接内存使用时，使用到了虚引用**：在直接内存回首时，虚引用对象进入引用队列中，`RefferenceHandler`在队列中寻找到虚引用Cleaner调用Unsafe.freeMemory()方法释放直接内存；释放引用。 ![1587973861026](1587973861026.png) * 目的：允许使用finalize()方法在垃圾收集器将对象从内存中清除出去前做必要的清理工作，可以收到一个系统通知 * 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。2.4垃圾回收算法2.4.1引用计数法 给对象添加一个引用计数器，每当有一个地方引用它则计数器+1，引用失效-1 算法目前没人使用，无法解决循环引用问题 2.4.2可达性分析法 Java中那些不可达的对象就会变成垃圾。 对象之间的引用可以抽象为树结构，通过树根（GC Roots）遍历，搜索走过的链成为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明这个对象为可回收的对象。 可以作为GC Roots的主要有以下几种： 栈帧中的本地变量表所引用的对象 方法区中类静态属性和常量引用的对象 本地方法栈中JNI（Native方法）引用的对象 123456private static GCRootDemo2 t1 = new GCRootDemo1();private final GCRootDemo2 t2 = new GCRootDemo2() ;public void m()&#123; GCRootDemo t3 = new GCRootDemo3();&#125; MAT：eclipse提供的分析Java堆对象的分析工具 实例： 123456789101112131415161718192021222324252627282930313233343536373839//1.改变对象的引用，如置为null或者指向其他对象Object obj1 = new Object();Object obj2 = new Object();obj1 = obj2; //obj1成为垃圾obj1 = obj2 = null ; //obj2成为垃圾//2.引用类型//第2句在内存不足的情况下会将String对象判定为可回收对象//第3句无论什么情况下String对象都会被判定为可回收对象String str = new String(\"hello\");SoftReference&lt;String&gt; sr = new SoftReference&lt;String&gt;(new String(\"java\"));WeakReference&lt;String&gt; wr = new WeakReference&lt;String&gt;(new String(\"world\"));//3.循环每执行完一次，生成的Object对象都会成为可回收的对象for(int i=0;i&lt;10;i++) &#123; Object obj = new Object(); System.out.println(obj.getClass());&#125;//4.类嵌套class A&#123; A a;&#125;A x = new A();//分配了一个空间x.a = new A();//又分配了一个空间x = null;//产生两个垃圾//5.线程中的垃圾class A implements Runnable&#123; void run()&#123; //.... &#125;&#125; //mainA x = new A();x.start();x=null; //线程执行完成后x对象才被认定为垃圾 2.4.2.1Copying（复制）算法【新生代】将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把第一块内存上的空间一次清理掉 优点：不容易出现内存碎片的问题，并且运行高效 缺点 能够使用的内存缩减到原来的一半，太过浪费 效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低 2.4.2.2Mark-Sweep（标记-清除）算法【老年代】 标记阶段的任务是标记出所有需要被回收的对象 清除阶段就是回收被标记的对象所占用的空间 缺点 产生大量不连续的内存碎片。当之后需要为大内存分配空间时，可能导致无法找到足够的内存再次GC 2.4.2.3Mark-Compact（标记-整理）算法【老年代】标记阶段标记出所有需要被回收的对象，但是在完成标记之后不是直接清理可回收对象，而是将存活的对象都移向一端，然后清理掉端边界以外的所有内存（只留下存活对象） 2.4.2.4Generational Collection（分代收集）算法 核心思想是将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在不同代的采取不同的最适合的收集算法。 新生代的特点是每次垃圾回收时都有大量的对象需要被回收 采取复制算法 划分为一块较大的Eden空间和两块较小的Survivor空间（默认比例8：1：1） 每次使用Eden空间和一块Survivor From空间，当进行回收时，将还存活的对象复制到Survivor To空间中，然后清理掉Eden和Survivor From空间 反复循环 当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，对象年龄达到15时（最大寿命是4bit），就会移动到老年代中 大对象会被直接分配到老年代，所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组，比如：byte[] data = new byte[4*1024*1024] Minor GC是新生代Copying算法 触发条件：Eden区满 Minor GC会引发Stp The World，暂停其它用户的线程，等垃圾回收结束,用户线程才恢复运行 老年代的特点是每次垃圾收集时只有少量对象需要被回收 无额外空间对其进行分配担保 标记整理算法 当老年代空间不足，会先尝试触发Minor GC，如果之后空间仍不足，那么触发Full GC, STW的时间更长 Full GC的老年代，采取的标记-整理。Full GC触发条件： 调用System.gc时，系统建议执行Full GC，但是不必然执行 老年代空间不足 方法区空间不足 过Minor GC后进入老年代的平均大小大于老年代的可用内存 2.5垃圾收集器参数设置 -XX:+UseConcMarkSweepGC 使用CMS收集器 XX:+UseParallelGC 使用并行收集器 XX:+UseParallelOldGC 使用并行老年代收集器 垃圾回收统计信息 -XX:+ PrintGC -XX:+ PrintGCDetails 打印GC的细节 -XX: +PrintGCTimeStamps 打印GC操作的时间戳 -Xloggc:filename -XX:ParallelGCThreads=n 设置并行收集器收集时使用的CPU数。并行收集线程数。 -XX:MaxGCPauseMillis=n 设置并行收集最大暂停时间 -XX:GCTimeRatio=n 设置垃圾回收时间占程序运行时间的百分比。公式为1/(1 +n) -XX: +CMSIncrementalMode 设置为增量模式。适用于单CPU情况。 -XX:-DisableExplicitGC 让System.gc()不产生任何作用 -XX:PrintTenuringDistribution 设置每次新生代GC后输出幸存者乐园中对象年龄的分布 -XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold 设置老年代阀值的初始值和最大值 -XX:TargetSurvivorRatio 设置幸存区的目标使用率 2.6典型垃圾回收器【7种】 JVM有两种运行模式Server与Client Client模式 启动速度较快 轻量级的虚拟机 Server模式 启动较慢 采用的是重量级的虚拟机 程序采用了更多的优化 动进入稳定期长期运行之后Server模式的程序运行速度比Client要快很多 总体分类 串行 单线程 堆内存较小，适用于个人电脑 吞吐量优先【程序运行100分钟，垃圾收集时间1分钟，吞吐量就是99%】（运行用户代码时间/(运行用户代码时间+垃圾收集时间)） 多线程 堆内存大，多核cpu 单位时间内STW时间最小 0.2+0.2 = 0.4 响应时间优先 多线程 堆内存大，多核cpu 尽可能STW单次时间减小 0.1+0.1+0.1+0.1+0.1=0.5 2.6.1串行垃圾回收器（Serial【新生代】 &amp; Serial Old【老年代】） 一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程 不适合服务器环境，适合Client模式，需要管理的内存较小，停顿时间可以接受 在单CPU环境下，避免线程交互的开销可以获得最高的单线程垃圾收集效率 12# 开启后使用组合：Serial收集器【新生代 复制算法】 + Serial Old收集器【老年代 标记整理算法】-XX:+UseSerialGC Serial收集器是针对新生代的收集器，采用的是Copying算法 Serial Old【已废弃】收集器是针对老年代的收集器，采用的是Mark-Compact算法 现在主要与CMS配合 2.6.2并行垃圾回收器（ParNew【新生代】） 使用多个线程进行垃圾收集，在垃圾收集时会Stop-The-World暂停其他所有的工作直到收集结束 ew收集器是Serial收集器的多线程版本 12# 开启后： ParNew(新生代) + Serial Old(老年代)【deprecatd】-XX:+UseParNewGC ParNew收集器是针对新生代的收集器，采用的是复制算法 2.6.3并行垃圾回收器（Parallel Scavenge【新生代】） JDK1.8默认收集器，可控制的吞吐量，高吞吐量意味着高效利用CPU的时间，它多用于在后台运算而不需要太多交互的任务 一个新生代的多线程收集器，采用Copying算法 关注重点 -XX:+UseAdaptiveSizePolicy：系统会根据系统运行情况修改新生代大小(-Xmn)以及Eden和Survivor比例(-XX:SurvivorRatio)，晋升老年代对象年龄(-XX:PretenureSizeThreshold)等参数来提供最合适的停顿时间和最大吞吐量。 自适应调节策略 MaxGCPauseMillis：设置回收停顿的最大时间。收集器尽可能将垃圾回收消耗时间保持在这个数值之下，但是并不是把这个数设置越小，垃圾收集就越快。 停顿时间减少是以牺牲吞吐量和新生代空间换来的，系统会将新生代内存降低，来达到每次回收停顿时间缩小，但是这也导致了停顿次数增加，总停顿时间并没有减少，吞吐量减小。 GCTimeRatio：设置一个1-99的整数，1/(1+X)设置垃圾回收时间占总时间的比率（吞吐量），整数设置越大，吞吐量越大 整数设置越大相当于停顿时间减少，系统会减少新生代内存，导致停顿增加，吞吐量减小。 这两个参数不可一味的增加某一个，他们互相制约，寻找一个平衡。 XX:ParallelGCThreads=n：并发线程数 1234# 开启后使用组合： Parallel Scavenge【新生代 复制算法】+ Parallel Old【老年代 标记整理算法】# 开启一个另一个自动开启-XX:+UseParallelGC-XX:+UseParallelOldGC 总结对于不是很了解收集器运作的开发人员来说，ParallelGC是个更好的选择。事先设置好堆大小-Xmx，然后设置MaxGCPauseMillis（重视停顿时间）或者GCTimeRatio（重视吞吐量）；设置完优化目标，剩下的具体参数修改交给系统自己。这也是ParallelGC和ParNew一个重要的区别 2.6.4并行垃圾回收器（Parallel Old【老年代】） Parallel Old是Parallel Scavenge收集器的老年代版本（并行收集器） 使用多线程和Mark-Compact算法 提供在老年代的吞吐量优先的垃圾收集器 123# 开启后使用组合： Parallel Scavenge【新生代】+ Parallel Old【老年代】-XX:+UseParallelGC-XX:+UseParallelOldGC 2.6.5并发垃圾回收期（CMS【老年代】） 以获取最短回收停顿时间为目标的收集器，采用标记-清除算法 只有初始标记和并发标记会发生STW，所以相应时间比较短 适合对响应时间有要求的场景，适合应用在互联网站或者B/S系统的服务器 尤其重视服务器的响应速度，希望系统停顿时间最短。 CMS非常适合堆内存大、CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。 1234# 开启后使用组合： ParNew(年轻代) + CMS(老年代) + Serial Old的收集器组合(CMS出错的后备收集器)-XX:+UseConcMarkSweepGC# 自动将打开-XX:+UseParNewGC 初始标记(CMS initial mark) 【STP】 只是标记一下GC Roots能直接关联的对象，速度很快，仍然需要暂停所有的工作线程 并发标记(CMS concurrent mark)和用户线程一起【耗时】 从第一步标记的对象出发，和用户线程一起工作，不需要暂停工作线程。 主要标记过程，标记全部对象 重新标记(CMS remark) 【STP】 -XX:+ScavengeBeforeFullGC： 为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的对象和新创建的对象的标记，仍然需要暂停所有的工作线程。由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正。 重新标记需要全量扫描整个堆大小（存在年轻代关联老年代的引用,所以需要扫描整个堆） 并发清除(CMS concurrent sweep)和用户线程一起【耗时】 清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。基于标记结果，直接清理对象 缺点： 采用的标记清除算法会导致大量碎片 标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。CMS也提供了参数-XX:CMSFullGCsBeForeCompaction(默认0，即每次都进行内存整理)来指定多少次CMS收集之后，进行一次压缩的Full GC。 无法处理浮动垃圾，由于并发进行，CMS在收集与应用线程会同时会增加对堆内存的占用，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW的方式进行一次GC,从而造成较大停顿时间 并发执行CPU压力大 -XX:ParallelGCThread=n：并行线程数，一般为cpu核心数 -XX:ConcGCThreads=threads：一般设置为n/4，并发垃圾回收线程数。 -XX:CMSInitiatingOccupancyFraction=percent：达到比例就会出发老年代垃圾回收 jdk1.6将这一值从1.5中的68改为92，为了防止频繁的触发老年代垃圾回收； 为什么要设置这一比例？ 因为在并发垃圾清理的同时，其它用户线程也在运行，产生的浮动垃圾CMS当前批次中难以处理，只能留到下次GC；也正是因为如此，所以需要留下空间给用户线程运行所产生的对象使用。 如何设置最好？ 在内存无法满足运行需要时，会出现Concurrent Mode Failure失败，VM会使用Serial Old代替CMS对老年代中垃圾对象进行整理，停顿时间更长，比例设置过高，更加容易触发Concurrent Mode Failure失败，影响性能（Serial Old暂停所有用户线程防止产生更多的对象，同时可以清理内存碎片） 2.6.6G1 设计目标是取代CMS收集器，JDK1.9默认 整体上采用标记整理算法，局部是通过复制算法，不会产生内存碎片。 同时注重吞吐量(Throughput) 和低延迟(Low latency)，默认的暂停目标是200 ms . Stop The World(STW)更可控，G1 在停顿时间上添加了预测机制，用户可以指定期望停顿时间 宏观上看G1之中不再区分年轻代和老年代。把内存划分成多个独立的子区域(Region) G1收集器里面讲整个的内存区都混合在一起了，但其本身依然在小范围内要进行年轻代和老年代的区分，保留了新生代和老年代，但它们不再是物理隔离的，而是一部分Region的集合且不需要Region是连续的，也就是说依然会采用不同的GC方式来处理不同的区域。 G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换 面向服务端应用的收集器，充分利用多CPU、多核环境，尽量缩短STW 核心思想 适合超大堆内存，将整个堆内存区域分成大小相同的子区域(Regjon)， 在JVM启动时会自动设置这些子区域的大小 12345678910111213# 开启G1-XX:+UseG1GC# 指定分区大小(1MB~32MB，且必须是2的幂) 默认将整堆划分为2048个分区# 最大内存为: 32MB * 2048 = 65536MB = 64G内存XX:G1HeapRegionSize=n# 最大GC停顿时间，这是个软目标，JVM将尽可能(但不保证)停顿小于这个时间，Xx:MaxGCPauseMillis=n:# 堆占用了多少的时候就触发GC，默认为45-X:InititingHeapOccupancyPercent=n# 并发Gc使用的线程数-XX:ConcGCThreads=n# 设置作为空闲空间的预留内存百分比，以降低目标空间溢出的风险，默认值是10%-XX:G1 ReservePercent=n G1垃圾回收阶段 Young Collection 会存在STP Young Collection + CM 在Young GC时会进行GC Root的初始标记 老年代占用堆空间比例达到阈值时，进行并发标记（不会STW） ，由下面的JVM参数决定-XX: InitiatingHeapOccupancyPercent=percent (默认45%) Mixed Collection 会对E、S、O进行全面垃圾回收 最终标记(Remark) 会STW 拷贝存活(Evacuation) 会STW 在老年代来讲，会优先回收垃圾较多的区域 XX : MaxGCPauseMillis=ms ​ Young Collection跨代引用 新生代回收的跨代引用(老年代引用新生代)问题 直接在脏卡区遍历GCRoot，减少编译时间 卡表与Remembered Set 在引用变更时通过post -write barrier + dirty card queue concurrent refinement threads更新Remembered Set JDK 8u20字符串去重 优点：节省大量内存 缺点：略微多占用了cpu时间，新生代回收时间略微增加 1-XX: +UseStringDeduplication 12String s1 = new String(\"hello\"); // char[]&#123;'h','e','l','l','o'&#125;String s2 = new String(\"hello\"); // char[]&#123;'h','e','l','l','o'&#125; 将所有新分配的字符串放入一个队列 当新生代回收时，G1并发检查是否有字符串重复 如果它们值一样，让它们引用同一个char[] 与String.intern()不一样 String.intern()关注的是字符串对象，而字符串去重关注的是char[] 在JVM内部，使用了不同的字符串表 2.7G1 &amp; CMS对比 G1 不会产生内存碎片 G1是可以精确控制停顿。收集器是把整个堆(新生代、老生代)划分成多个固定大小的区域，每次根据允许停顿的时间去收集垃圾最多的区域 2.8GC选择 参数 2.9Full GC SerialGC 新生代内存不足发生的垃圾收集- minor gc 老年代内存不足发生的垃圾收集- full gc ParallelGC 新生代内存不足发生的垃圾收集-minor gc 老年代内存不足发生的垃圾收集-full gc CMS 新生代内存不足发生的垃圾收集- minor gc 老年代内存不足 G1 新生代内存不足发生的垃圾收集- minor gc 老年代内存不足 CMS G1老年代内存不足分两种情况 回收速度比新产生的垃圾速度快，不会触发-full gc 暂停时间比较短 回收速度比新产生的垃圾速度慢，触发-full gc CMS可能退化为串行收集 暂停时间比较长 根据GC日志判断是否发生-full gc 2.10重新标记Remark阶段 pre-write barrier+ satb_mark_queue 重新标记阶段解决此问题 对象的引用发生改变，则加入写屏障 写屏障使得C加入到一个队列当中，C变为未处理情况 2.11GC调优 调优跟应用、环境有关，没有放之四海而皆准的法则 查看虚拟机GC运行参数java -XX: +PrintFlagsFinal -version | findstr &quot;GC&quot; 2.11.1调优领域 内存 锁竞争 cpu占用 IO 2.11.2确定目标 根据目标，选择合适的回收器 【吞吐量优先】：ParallelGC 【相应时间优先】：CMS，G1, ZGC【JDK12】 2.11.3最快的GC是不发生GC 查看FullGC前后的内存占用，是否是自己程序的问题 数据是不是太多? resultSet = statement.executeQuery(“select * from 大表 limit n“) 数据表示是否太臃肿 查询属性过多 对象大小 是否存在内存泄漏 使用 软弱引用/Redis 优化 2.11.4新生代调优 新生代的特点 所有的new操作的内存分配非常廉价 伊甸园中每个线程都有TLAB（thread-local allocation buffer），防止线程安全问题 死亡对象的回收代价是零 大部分对象用过即死 Minor GC的时间远远低于Full GC 新生代容量是不是越大越好 较小的话 易发生Minor-GC，Minor-GC的时候会出现STW造成时间增加 较大的话 老年代的内存就会变小，易发生垃圾回收（Full-GC），暂停时间要比新生代的暂停时间更长 新生代的复制算法分为标记和复制两个阶段，复制要花费的时间更多，新生代的对象只有少量的对象能够存活，因此，复制的时间较少，即使新生代有较大的内存，回收的效率依旧不会太高 Oracle建议的新生代内存大小为：占用堆内存的百分之25-百分之50 理性情况：新生代能容纳所有【并发量* (请求-响应)】的数据 幸存区大到能保留 幸存区要能够保留：当前活跃对象和需要晋升的对象 幸存区的晋升阈值设置要合理，阈值太大的话，幸存区的幸存对象会被多次复制，阈值过小的话，晋升后的对象进入老年带后就只有Full-GC的时候才会被清理 升阈值配置得当，让长时间存活对象尽快晋升，防止多次复制浪费性能 -XX: MaxTenuringThreshold=threshold -XX: +PrintTenuringDistribution 2.11.5老年代调优 以CMS为例 因为垃圾处理线程和用户的线程是并发的，当垃圾处理的时候，用户的线程还会产生垃圾（浮动垃圾），如果再次导致内存不足，就会导致并发失败。退化为Serial-old，串行的垃圾回收器，响应时间较长 先尝试不去调优，因为如果未发生Full-GC，则证明老年代的内存正常，可以尝试调优新生代 如果老年代发生了Full-GC，就去观察发生Full-GC的时候老年代的内存占用，将老年代的内存预设调大1/4-1/3 -XX:CMSInitiatingOccupancyFraction=percent【75%-80%】 2.11.6调优案例案例一 现象：FullGC和MinorGC频繁 原因分析：业务高峰期的时候，大量的对象被创建，导致新生代空间不足，MinorGC频繁。对象的晋升阈值也随之降低，导致老年代中生存周期并不是很长的对象晋升，老年代就需要频繁地进行Full-GC 解决方案：尝试增加新生代内存，并增加幸存区晋升的阈值 案例二 现象：请求高峰期发生Full GC，单次暂停时间特别长（CMS） 重新标记的时候要扫描整个堆内存，耗时较多，可以在重新标记以前对新生代先做一次垃圾回收减少对象的数量，可以添加虚拟机参数：-XX:CMSScavengeBeforeRemark 案例三老年代充裕的情况下，发生Full GC（CMS jdk1.7） jdk1.8将元空间作为方法区的实现，jdk1.7将永久代作为方法区的实现，永久代空间的不足也会引起Full GC 2.11.7Java调优工具 javap：专门用于分析Class文件字节码的工具 1234# 查看.class文件内容javap -c xxx.classjavap -verbose xxx.class -p # 显示私有的 jps：查看本机java进程信息 jstack 打印线程栈的信息，制作线程dump文件 jstat 性能监控工具 jconsole 简易的可视化控制台 jmap ：分析Java堆对象 1234# 打印内存映射-heap PID # 制作堆dump文件-dump:format=b,live,file=filename.bin PID jhat：内存分析工具 jvisualvm：功能强大的控制台 垃圾回收后，内存占用依然很高 1.控制台输入jvistualvm，在1处选择对应进程，2处点“dump”。 2.点击“查找”，点击第一条占用内存最大的记录。 3.找到问题所在，list中有过多大对象student，无法被清除。 动态链接 &amp; 静态链接 部分符号引用在类加载阶段(解析)的时候就转化为直接引用，这种转化为静态链接 部分符号引用在运行期间转化为直接引用,这种转化为动态链接 虚/非虚方法 非虚方法：在类加载阶段(解析时期)才会将符号引用解析直接引用的方法被称之为非虚方法 静态方法、私有方法、实例构造器、父类方法,这些只需要在类加载阶段就会确定 解析调用一定是一个静态过程 编译器可知，运行期不可变 虚方法: 在运行期间将符号引用转化为直接引用的方法被称之为虚方法 分派 静态类型:编译期间确定的类型(Ocean) 实际类型:运行期间确定的类型(River) 1234567public class Ocean &#123; public static void main(String[] args) &#123; Ocean river = new River(); &#125;&#125;class River extends Ocean&#123;&#125; 左为静态类型，右为实际类型：Ocean river = new River(); 宗量:方法的接受者（亦即方法的调用者）与方法的参数统称为方法的宗量 静态分派 1234567891011121314151617181920212223242526272829class Ocean &#123;&#125;class River extends Ocean&#123;&#125;class Lake extends Ocean&#123;&#125;/** 静态分派*/ public class StaticDispatch&#123; public void getSize(Ocean waterArea)&#123; System.out.println(\"Ocean is the biggest!\"); &#125; public void getSize(Lake waterArea)&#123; System.out.println(\"Lake is bigger!\"); &#125; public void getSize(River waterArea)&#123; System.out.println(\"River is big...\"); &#125; public static void main(String[] args) &#123; StaticDispatch dispatch = new StaticDispatch(); Ocean river = new River(); Ocean lake = new Lake(); dispatch.getSize(lake); dispatch.getSize(river); &#125;&#125; 控制台输出: 12Ocean is the biggest!Ocean is the biggest! 分析: ①定义了两个静态类型相同而实际类型却不同的变量 ②重载时方法的执行依赖的是形参列表，而形参列表指的却是静态类型 ③静态类型是在类加载(解析时期)就确定下来的 总结:静态分派可以解释重载 动态分派 1234567891011121314151617181920212223242526abstract class Human &#123; abstract void call();&#125;class Father extends Human&#123; @Override void call() &#123; System.out.println(\"I am the Father!\"); &#125;&#125;class Mother extends Human&#123; @Override void call() &#123; System.out.println(\"I am the Mother!\"); &#125;&#125;public class DynamicDispatch &#123; public static void main(String[] args) &#123; Human father = new Father(); Human mother = new Mother(); father.call(); mother.call(); &#125;&#125; 控制台输出: 12I am the Father!I am the Mother! 程序执行过程的机器指令分析如下: 各操作指令解析: 0:在java堆中为变量father分配空间,并将地址压入操作数栈顶3:复制操作数栈顶值.并压入栈顶(此时操作栈上有两个连续相同的father对象地址)4:从操作栈顶弹出一个this的引用(即两个连续father对象地址中靠近栈顶的一个),并调用实例化方法:()v7:将栈顶的仅剩的一个father对象地址存入第二个本地变量表slot(1)中815:重复上面的操作,创建了mother对象并将其地址存入第三个本地变量表slot(2)中16.将第二个本地变量表slot(1)中引用类型数据father地址推送至操作栈顶17:调用虚方法,根据father对象地址查询其call()方法并执行2021:重复上面的操作,根据mother对象地址查询其call()并执行24:结束方法 总结:从上面的invokevirtual可以知道方法call()的符号引用转换是在运行时期完成的,所以可以说动态分派解释了重载 单分派&amp;多分派 单分派是指根据一个宗量就可以知道调用目标(即应该调用哪个方法) 多分派需要根据多个宗量才能确定调用目标 总结: Java中静态分派的方法调用，首先确定调用者的静态类型是什么，然后根据要调用的方法参数的静态类型(声明类型)确定所有重载方法中要调用哪一个，需要根据这两个宗量来编译，所以重写是静态多分派(多个宗量确定) Java中动态分派的方法调用，在运行期间，虚拟机会根据调用者的实际类型调用对应的方法，根据这一个宗量就可以确定要调用的方法,所以重载是动态单分派(一个宗量) 即 Java 语言是一门静态多分派（方法重载）、动态单分派（方法重写）的语言. GC日记解读如何对springboot调优1java - server jvm的各种参数 -jar jar&#x2F;war包名字 重排序在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型： 编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 从Java源代码到最终实际执行的指令序列，会经过下面三种重排序： Q: Java 是否存在内存泄漏?12答：理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存泄露。上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。 194.说一下 jvm 的主要组成部分？及其作用？ 195.说一下 jvm 运行时数据区？ 196.说一下堆栈的区别？ 197.队列和栈是什么？有什么区别？ 198.什么是双亲委派模型？ 199.说一下类加载的执行过程？ 200.怎么判断对象是否可以被回收？ 201.java 中都有哪些引用类型？ 202.说一下 jvm 有哪些垃圾回收算法？ 203.说一下 jvm 有哪些垃圾回收器？ 204.详细介绍一下 CMS 垃圾回收器？ 205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？ 206.简述分代垃圾回收器是怎么工作的？ 207.说一下 jvm 调优的工具？","tags":[{"name":"JVM","slug":"JVM","permalink":"http://goldcarpenter.github.io/tags/JVM/"}]},{"title":"MyBatis","date":"2019-07-09T16:00:00.000Z","path":"2019/07/10/MyBatis_Part1/","text":"1.MyBatis基础1.1.架构概念 架构：我们软件开发中的一套解决方案，不同的框架解决的是不同的问题。 优点：框架封装了很多的细节，使开发者可以使用极简的方式实现功能。大大提高开发效率。 1.2.MyBatis框架 mybatis是一个优秀的基于java的持久层框架，内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 Mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。 采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。 1.3. 入门案例——基于XML SQL准备 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL auto_increment, `username` varchar(32) NOT NULL COMMENT '用户名称', `birthday` datetime default NULL COMMENT '生日', `sex` char(1) default NULL COMMENT '性别', `address` varchar(256) default NULL COMMENT '地址', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (41,'老王','2018-02-27 17:47:08','男','北京'),(42,'小二王','2018-03-02 15:09:37','女','北京金燕龙'),(43,'小二王','2018-03-04 11:34:34','女','北京金燕龙'),(45,'传智播客','2018-03-04 12:04:06','男','北京金燕龙'),(46,'老王','2018-03-07 17:37:26','男','北京'),(48,'小马宝莉','2018-03-08 11:44:00','女','北京修正');DROP TABLE IF EXISTS `account`;CREATE TABLE `account` ( `ID` int(11) NOT NULL COMMENT '编号', `UID` int(11) default NULL COMMENT '用户编号', `MONEY` double default NULL COMMENT '金额', PRIMARY KEY (`ID`), KEY `FK_Reference_8` (`UID`), CONSTRAINT `FK_Reference_8` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `account`(`ID`,`UID`,`MONEY`) values (1,41,1000),(2,45,1000),(3,41,2000);DROP TABLE IF EXISTS `role`;CREATE TABLE `role` ( `ID` int(11) NOT NULL COMMENT '编号', `ROLE_NAME` varchar(30) default NULL COMMENT '角色名称', `ROLE_DESC` varchar(60) default NULL COMMENT '角色描述', PRIMARY KEY (`ID`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `role`(`ID`,`ROLE_NAME`,`ROLE_DESC`) values (1,'院长','管理整个学院'),(2,'总裁','管理整个公司'),(3,'校长','管理整个学校');DROP TABLE IF EXISTS `user_role`;CREATE TABLE `user_role` ( `UID` int(11) NOT NULL COMMENT '用户编号', `RID` int(11) NOT NULL COMMENT '角色编号', PRIMARY KEY (`UID`,`RID`), KEY `FK_Reference_10` (`RID`), CONSTRAINT `FK_Reference_10` FOREIGN KEY (`RID`) REFERENCES `role` (`ID`), CONSTRAINT `FK_Reference_9` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `user_role`(`UID`,`RID`) values (41,1),(45,1),(41,2); pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;top.carpenter&lt;/groupId&gt; &lt;artifactId&gt;carpenter-mybatis&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt;&lt;!-- Mybatis和Spring的整合包 https://mvnrepository.com/artifact/org.mybatis/mybatis-spring &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; IUserDao.java 123456789package top.carpenter.dao;import top.carpenter.pojo.User;import java.util.List;public interface IUserDao &#123; List&lt;User&gt; findAll();&#125; User.java 12345678910111213package top.carpenter.pojo;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; // get set toString方法&#125; Mybatis的主配置文件SqlMapConfig.xml 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=\"mysql\"&gt; &lt;!-- 配置mysql的环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!-- 配置事务的类型--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"top/carpenter/dao/IUserDao.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; IUserDao.xml 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"top.carpenter.dao.IUserDao\"&gt; &lt;!--配置查询所有--&gt; &lt;select id=\"findAll\" resultType=\"top.carpenter.pojo.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; MyBatisTest 1234567891011121314151617181920212223242526272829303132333435363738package top.carpenter;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import top.carpenter.dao.IUserDao;import top.carpenter.pojo.User;import java.io.IOException;import java.io.InputStream;import java.util.List;public class MybatisTest &#123; @Test public void testMybatis() throws IOException &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.创建SqlSessionFactory的构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.使用构建者创建工厂对象sqlSessionFactory SqlSessionFactory factory = builder.build(in); //4.使用SqlSessionFactory生产SqlSession对象 SqlSession session = factory.openSession(); //5.使用sqlSession创建dao接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); //6.使用代理对象执行查询所有方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users)&#123; System.out.println(user); //7.释放资源 session.close(); in.close(); &#125; &#125;&#125; 1.4. 入门案例——基于注解 把IUserDao.xml移除，在dao接口的方法上使用@Select注解，并且指定SQL语句 IUserDao——增加注解 1234public interface IUserDao &#123; @Select(\"select * from user\") List&lt;User&gt; findAll();&#125; 主配置文件 123&lt;mappers&gt; &lt;mapper class=\"top.carpenter.dao.IUserDao\"/&gt;&lt;/mappers&gt; 1.5.Dao层实现类的方式补充 使用Mybatis开发Dao，通常有两个方法，即原始Dao开发方式和Mapper接口代理开发方式。而现在主流的开发方式是接口代理开发方式，这种方式总体上更加简便。 Dao层的实现类可以使用代理Dao的方式实现，不写实现类也可以实现功能，故在工程开发中省略不写 UserDaoImpl 123456789101112131415161718192021222324252627package top.carpenter.dao.impl;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import top.carpenter.dao.IUserDao;import top.carpenter.pojo.User;import java.util.List;public class UserDaoImpl implements IUserDao &#123; private SqlSessionFactory factory; public UserDaoImpl(SqlSessionFactory factory) &#123; this.factory = factory; &#125; public List&lt;User&gt; findAll() &#123; // 1. 使用工厂创建SqlSession对象 SqlSession session = factory.openSession(); // 2. 使用session执行查询所有方法 // #########从配置中拿到SQL语句 使用namespace.id唯一定位### // 解释了IUserDao.xml的namespace属性 List&lt;User&gt; users = session.selectList(\"top.carpenter.dao.IUserDao.findAll\"); session.close(); return users; &#125;&#125; MyBatisTest 123456789101112131415161718192021222324252627282930313233package top.carpenter;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import top.carpenter.dao.impl.UserDaoImpl;import top.carpenter.pojo.User;import java.io.IOException;import java.io.InputStream;import java.util.List;public class MybatisTest &#123; @Test public void testMybatis() throws IOException &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.创建SqlSessionFactory的构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.使用构建者创建工厂对象sqlSessionFactory SqlSessionFactory factory = builder.build(in); //4. 返回Dao实现类 UserDaoImpl userDao = new UserDaoImpl(factory); List&lt;User&gt; users = userDao.findAll(); for (User user : users)&#123; System.out.println(user); //7.释放资源 in.close(); &#125; &#125;&#125; 1.6.注意事项 在IDEA中创建目录的时候，它和包是不一样的 Package包在创建时:top.carpenter.dao是三级结构 Directory目录在创建时: top.carpenter.dao是一级目录 mybatis的映射配置文件位置必须和dao接口的包结构相同 映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名 映射配置文件的操作配置(select)，id属性的取值必须是dao接口的方法名 2.手写MyBatis详细分析2.1.MyBatis设计模式小结 2.2.自定义MyBatis分析 在上图使用代理dao的方式实现增删改查时本质只做了两件事 创建代理对象 在代理对象创建selectList方法 包含了创建Connection信息，可以用于创建Connection对象 包含了SQL语句以及查询返回的封装类，可以创建Dao的被代理对象 读取.xml文件 解析的信息都在selectList方法中所需要 所需要的信息总结为 获得了代理对象 在该方法内部逻辑应为 总图 2.3.自定义MyBatis2.3.1.基于XML的自定义MyBatis testMybatis 123456789101112131415161718192021222324252627282930313233343536373839package top.carpenter;import org.junit.Test;import top.carpenter.mybatis.sqlsession.SqlSessionFactory;import top.carpenter.dao.IUserDao;import top.carpenter.mybatis.io.Resources;import top.carpenter.mybatis.sqlsession.SqlSession;import top.carpenter.mybatis.sqlsession.SqlSessionFactoryBuilder;import top.carpenter.pojo.User;import java.io.IOException;import java.io.InputStream;import java.sql.SQLException;import java.util.List;public class MybatisTest &#123; @Test public void testMybatis() throws IOException, SQLException, ClassNotFoundException &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.创建SqlSessionFactory的构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.使用构建者创建工厂对象sqlSessionFactory SqlSessionFactory factory = builder.build(in); //4.使用SqlSessionFactory生产SqlSession对象 SqlSession session = null; session = factory.openSession(); //5.使用sqlSession创建dao接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); //6.使用代理对象执行查询所有方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users)&#123; System.out.println(user); //7.释放资源 in.close(); &#125; &#125;&#125; SqlMapConfig和IUserDao的&lt;!DOCTYPE..可以删除 XMLConfigBuilder——解析XML文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214package top.carpenter.mybatis.utils;import org.dom4j.Attribute;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.io.SAXReader;import top.carpenter.mybatis.annotations.Select;import top.carpenter.mybatis.cfg.Configuration;import top.carpenter.mybatis.cfg.Mapper;import top.carpenter.mybatis.io.Resources;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 用于解析配置文件 */public class XMLConfigBuilder &#123; /** * 解析主配置文件，把里面的内容填充到DefaultSqlSession所需要的地方 * 使用的技术： * dom4j+xpath */ public static Configuration loadConfiguration(InputStream config)&#123; try&#123; //定义封装连接信息的配置对象（mybatis的配置对象） Configuration cfg = new Configuration(); //1.获取SAXReader对象 SAXReader reader = new SAXReader(); //2.根据字节输入流获取Document对象 Document document = reader.read(config); //3.获取根节点 Element root = document.getRootElement(); //4.使用xpath中选择指定节点的方式，获取所有property节点 List&lt;Element&gt; propertyElements = root.selectNodes(\"//property\"); //5.遍历节点 for(Element propertyElement : propertyElements)&#123; //判断节点是连接数据库的哪部分信息 //取出name属性的值 String name = propertyElement.attributeValue(\"name\"); if(\"driver\".equals(name))&#123; //表示驱动 //获取property标签value属性的值 String driver = propertyElement.attributeValue(\"value\"); cfg.setDriver(driver); &#125; if(\"url\".equals(name))&#123; //表示连接字符串 //获取property标签value属性的值 String url = propertyElement.attributeValue(\"value\"); cfg.setUrl(url); &#125; if(\"username\".equals(name))&#123; //表示用户名 //获取property标签value属性的值 String username = propertyElement.attributeValue(\"value\"); cfg.setUsername(username); &#125; if(\"password\".equals(name))&#123; //表示密码 //获取property标签value属性的值 String password = propertyElement.attributeValue(\"value\"); cfg.setPassword(password); &#125; &#125; //取出mappers中的所有mapper标签，判断他们使用了resource还是class属性 List&lt;Element&gt; mapperElements = root.selectNodes(\"//mappers/mapper\"); //遍历集合 for(Element mapperElement : mapperElements)&#123; //判断mapperElement使用的是哪个属性 Attribute attribute = mapperElement.attribute(\"resource\"); if(attribute != null)&#123; System.out.println(\"使用的是XML\"); //表示有resource属性，用的是XML //取出属性的值 String mapperPath = attribute.getValue();//获取属性的值\"com/itheima/dao/IUserDao.xml\" //把映射配置文件的内容获取出来，封装成一个map Map&lt;String,Mapper&gt; mappers = loadMapperConfiguration(mapperPath); //给configuration中的mappers赋值 cfg.setMappers(mappers); &#125;else&#123; System.out.println(\"使用的是注解\"); //表示没有resource属性，用的是注解 //获取class属性的值 String daoClassPath = mapperElement.attributeValue(\"class\"); //根据daoClassPath获取封装的必要信息 Map&lt;String,Mapper&gt; mappers = loadMapperAnnotation(daoClassPath); //给configuration中的mappers赋值 cfg.setMappers(mappers); &#125; &#125; //返回Configuration return cfg; &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125;finally&#123; try &#123; config.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; /** * 根据传入的参数，解析XML，并且封装到Map中 * @param mapperPath 映射配置文件的位置 * @return map中包含了获取的唯一标识（key是由dao的全限定类名和方法名组成） * 以及执行所需的必要信息（value是一个Mapper对象，里面存放的是执行的SQL语句和要封装的实体类全限定类名） */ private static Map&lt;String,Mapper&gt; loadMapperConfiguration(String mapperPath)throws IOException &#123; InputStream in = null; try&#123; //定义返回值对象 Map&lt;String,Mapper&gt; mappers = new HashMap&lt;String,Mapper&gt;(); //1.根据路径获取字节输入流 in = Resources.getResourceAsStream(mapperPath); //2.根据字节输入流获取Document对象 SAXReader reader = new SAXReader(); Document document = reader.read(in); //3.获取根节点 Element root = document.getRootElement(); //4.获取根节点的namespace属性取值 String namespace = root.attributeValue(\"namespace\");//是组成map中key的部分 //5.获取所有的select节点 List&lt;Element&gt; selectElements = root.selectNodes(\"//select\"); //6.遍历select节点集合 for(Element selectElement : selectElements)&#123; //取出id属性的值 组成map中key的部分 String id = selectElement.attributeValue(\"id\"); //取出resultType属性的值 组成map中value的部分 String resultType = selectElement.attributeValue(\"resultType\"); //取出文本内容 组成map中value的部分 String queryString = selectElement.getText(); //创建Key String key = namespace+\".\"+id; //创建Value Mapper mapper = new Mapper(); mapper.setQueryString(queryString); mapper.setResultType(resultType); //把key和value存入mappers中 mappers.put(key,mapper); &#125; return mappers; &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125;finally&#123; in.close(); &#125; &#125; /** * 根据传入的参数，得到dao中所有被select注解标注的方法。 * 根据方法名称和类名，以及方法上注解value属性的值，组成Mapper的必要信息 * @param daoClassPath * @return */ private static Map&lt;String,Mapper&gt; loadMapperAnnotation(String daoClassPath)throws Exception&#123; //定义返回值对象 Map&lt;String,Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); //1.得到dao接口的字节码对象 Class daoClass = Class.forName(daoClassPath); //2.得到dao接口中的方法数组 Method[] methods = daoClass.getMethods(); //3.遍历Method数组 for(Method method : methods)&#123; //取出每一个方法，判断是否有select注解 boolean isAnnotated = method.isAnnotationPresent(Select.class); if(isAnnotated)&#123; //创建Mapper对象 Mapper mapper = new Mapper(); //取出注解的value属性值 Select selectAnno = method.getAnnotation(Select.class); String queryString = selectAnno.value(); mapper.setQueryString(queryString); //获取当前方法的返回值，还要求必须带有泛型信息 Type type = method.getGenericReturnType();//List&lt;User&gt; //判断type是不是参数化的类型 if(type instanceof ParameterizedType)&#123; //强转 ParameterizedType ptype = (ParameterizedType)type; //得到参数化类型中的实际类型参数 Type[] types = ptype.getActualTypeArguments(); //取出第一个 Class domainClass = (Class)types[0]; //获取domainClass的类名 String resultType = domainClass.getName(); //给Mapper赋值 mapper.setResultType(resultType); &#125; //组装key的信息 //获取方法的名称 String methodName = method.getName(); String className = method.getDeclaringClass().getName(); String key = className+\".\"+methodName; //给map赋值 mappers.put(key,mapper); &#125; &#125; return mappers; &#125;&#125; Resources 123456789101112package top.carpenter.mybatis.io;import java.io.InputStream;/** * 使用类加载器读取配置文件的类 */public class Resources &#123; public static InputStream getResourceAsStream(String filePath)&#123; // 获取相对classes目录的文件 return Resources.class.getClassLoader().getResourceAsStream(filePath); &#125;&#125; SqlSessionFactoryBuilder 12345678910111213141516171819package top.carpenter.mybatis.sqlsession;import top.carpenter.mybatis.cfg.Configuration;import top.carpenter.mybatis.sqlsession.impl.DefaultSqlSessionFactory;import top.carpenter.mybatis.utils.XMLConfigBuilder;import java.io.InputStream;/** * 用于创建一个SqlSessionFactory对象 */public class SqlSessionFactoryBuilder &#123; public SqlSessionFactory build(InputStream xmlfile) &#123; Configuration cfg = XMLConfigBuilder.loadConfiguration(xmlfile); return new DefaultSqlSessionFactory(cfg); &#125;&#125; SqlSessionFactory&amp;DefaultSqlSessionFactory 12345678910111213141516171819202122232425262728293031323334package top.carpenter.mybatis.sqlsession;import java.sql.SQLException;/** * 用于创建SqlSession对象 */public interface SqlSessionFactory &#123; SqlSession openSession() throws SQLException, ClassNotFoundException;&#125;//==============================================package top.carpenter.mybatis.sqlsession.impl;import top.carpenter.mybatis.cfg.Configuration;import top.carpenter.mybatis.sqlsession.SqlSession;import top.carpenter.mybatis.sqlsession.SqlSessionFactory;import java.sql.SQLException;public class DefaultSqlSessionFactory implements SqlSessionFactory &#123; private Configuration cfg; public DefaultSqlSessionFactory(Configuration cfg) &#123; this.cfg = cfg; &#125; public SqlSession openSession() throws SQLException, ClassNotFoundException &#123; return new DefaultSqlSession(this.cfg); &#125;&#125; SqlSession &amp;DefaultSqlSession 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package top.carpenter.mybatis.sqlsession;import java.sql.SQLException;/** * 与数据交互的核心类 * 创建Dao接口的代理对象 */public interface SqlSession &#123; /** * 根据参数创建代理对象 */ &lt;T&gt;T getMapper(Class&lt;T&gt; daoInterfaceClass); /** * 释放资源 */ void close() throws SQLException;&#125;//==============================================package top.carpenter.mybatis.sqlsession.impl;import top.carpenter.mybatis.cfg.Configuration;import top.carpenter.mybatis.sqlsession.SqlSession;import top.carpenter.mybatis.sqlsession.proxy.MapperProxy;import top.carpenter.mybatis.utils.DataSourceUtil;import java.lang.reflect.Proxy;import java.sql.Connection;import java.sql.SQLException;public class DefaultSqlSession implements SqlSession &#123; private Configuration cfg; private Connection conn; public DefaultSqlSession(Configuration cfg) throws SQLException, ClassNotFoundException &#123; this.cfg = cfg; this.conn = DataSourceUtil.getConnection(cfg); &#125; public &lt;T&gt; T getMapper(Class&lt;T&gt; daoInterfaceClass) &#123; return (T) Proxy.newProxyInstance(daoInterfaceClass.getClassLoader(), new Class[]&#123;daoInterfaceClass&#125;, new MapperProxy(cfg.getMappers(),conn)); &#125; public void close() throws SQLException &#123; if(conn != null) this.conn.close(); &#125;&#125; MapperProxy 1234567891011121314151617181920212223242526272829303132333435package top.carpenter.mybatis.sqlsession.proxy;import top.carpenter.mybatis.cfg.Mapper;import top.carpenter.mybatis.utils.Executor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.sql.Connection;import java.util.Map;public class MapperProxy implements InvocationHandler &#123; private Map&lt;String,Mapper&gt; mappers; private Connection conn; public MapperProxy(Map&lt;String, Mapper&gt; mappers,Connection conn) &#123; this.mappers = mappers; this.conn = conn; &#125; /** * 用于对方法进行增强 增强的方法就是findAll */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); String className = method.getDeclaringClass().getName(); String key = className+'.'+methodName; Mapper mapper = mappers.get(key); if(mapper == null) &#123; throw new IllegalArgumentException(); &#125; return new Executor().selectList(mapper,conn); &#125;&#125; Configuration 12345678910111213141516171819202122package top.carpenter.mybatis.cfg;import java.util.HashMap;import java.util.Map;public class Configuration &#123; private String driver; private String url; private String username; private String password; private Map&lt;String, Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); // 特殊 其他get set略 public Map&lt;String, Mapper&gt; getMappers() &#123; return mappers; &#125; public void setMappers(Map&lt;String, Mapper&gt; mappers) &#123; this.mappers.putAll(mappers); &#125; &#125; Mapper 1234567891011package top.carpenter.mybatis.cfg;/** * 用于封装执行的SQL语句和结果类型的全限定类名 */public class Mapper &#123; private String queryString;//封装执行的SQL语句 private String resultType;//结果类型的全限定类名 //get set 方法 &#125; DataSourceUtil 1234567891011121314151617package top.carpenter.mybatis.utils;import top.carpenter.mybatis.cfg.Configuration;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;/** * 用于创建数据源的DataSource */public class DataSourceUtil &#123; public static Connection getConnection(Configuration cfg) throws ClassNotFoundException, SQLException &#123; Class.forName(cfg.getDriver()); return DriverManager.getConnection(cfg.getUrl(),cfg.getUsername(),cfg.getPassword()); &#125;&#125; Executor 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package top.carpenter.mybatis.utils;import top.carpenter.mybatis.cfg.Mapper;import java.beans.PropertyDescriptor;import java.lang.reflect.Method;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.util.ArrayList;import java.util.List;/** * 负责执行SQL语句，并且封装结果集 */public class Executor &#123; public &lt;E&gt; List&lt;E&gt; selectList(Mapper mapper, Connection conn) &#123; PreparedStatement pstm = null; ResultSet rs = null; try &#123; //1.取出mapper中的数据 String queryString = mapper.getQueryString();//select * from user String resultType = mapper.getResultType();//com.itheima.domain.User Class domainClass = Class.forName(resultType); //2.获取PreparedStatement对象 pstm = conn.prepareStatement(queryString); //3.执行SQL语句，获取结果集 rs = pstm.executeQuery(); //4.封装结果集 List&lt;E&gt; list = new ArrayList&lt;E&gt;();//定义返回值 while(rs.next()) &#123; //实例化要封装的实体类对象 E obj = (E)domainClass.newInstance(); //取出结果集的元信息：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); //取出总列数 int columnCount = rsmd.getColumnCount(); //遍历总列数 for (int i = 1; i &lt;= columnCount; i++) &#123; //获取每列的名称，列名的序号是从1开始的 String columnName = rsmd.getColumnName(i); //根据得到列名，获取每列的值 Object columnValue = rs.getObject(columnName); //给obj赋值：使用Java内省机制（借助PropertyDescriptor实现属性的封装） PropertyDescriptor pd = new PropertyDescriptor(columnName,domainClass);//要求：实体类的属性和数据库表的列名保持一种 //获取它的写入方法 Method writeMethod = pd.getWriteMethod(); //把获取的列的值，给对象赋值 writeMethod.invoke(obj,columnValue); &#125; //把赋好值的对象加入到集合中 list.add(obj); &#125; return list; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; release(pstm,rs); &#125; &#125; private void release(PreparedStatement pstm,ResultSet rs)&#123; if(rs != null)&#123; try &#123; rs.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; if(pstm != null)&#123; try &#123; pstm.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 2.3.2.基于注解的自定义MyBatis IUserDao 1234567891011package top.carpenter.dao;import top.carpenter.mybatis.annotations.Select;import top.carpenter.pojo.User;import java.util.List;public interface IUserDao &#123; @Select(\"select * from user\") List&lt;User&gt; findAll();&#125; Select 123456789101112package top.carpenter.mybatis.annotations;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Select &#123; String value();&#125; SqlMapConfig 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=\"mysql\"&gt; &lt;!-- 配置mysql的环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!-- 配置事务的类型--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;mappers&gt;&lt;!-- &lt;mapper resource=\"top/carpenter/dao/IUserDao.xml\"/&gt;--&gt; &lt;mapper class=\"top.carpenter.dao.IUserDao\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.4.总结 通过以上流程我们不难看出,无论是让mybatis帮我们创建代理对象还是直接使用mybatis提供的CRUD方法，其本质都是得到jdbc的Connection对象,执行对应sq|语句,最终封装结果集。只是注解和xml配置文件两种开发模式在传递sql语句和返回值类型的方式上有所差异而已。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://goldcarpenter.github.io/tags/MyBatis/"}]},{"title":"Java虚拟机","date":"2019-07-05T04:39:12.000Z","path":"2019/07/05/JVM_Part1/","text":"Java虚拟机1234567// cmd 查看默认JVM参数java -XX:+PrintCommandLineFlags -version==========================================-XX:InitialHeapSize=131963904 -XX:MaxHeapSize=2111422464 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGCjava version \"1.8.0_221\"Java(TM) SE Runtime Environment (build 1.8.0_221-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode) 常见JVM JVM总体架构 JVM = 类加载器 classloader + 执行引擎 executionengine + 运行时数据区域 runtime data area 首先Java源代码文件被Java编译器编译为字节码文件，然后JVM中的类加载器加载完毕之后，交由JVM执行引擎执行。在整个程序执行过程中，JVM内存会用来存储程序执行期间需要用到的数据和相关信息。 ClassLoader Classloader把硬盘上的class文件加载到JVM中的运行时数据区域，但是它不负责这个类文件能否执行，而这个是执行引擎负责的 执行引擎 执行字节码，或者执行本地方法 1.内存结构 JDK1.7已经把串常量池【运行时常量池的一部分】转移到堆里面了 1.1程序计数器当前线程所执行的字节码(.class)的下一条指令地址指示器，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。 线程私有 如果正在执行的是Java方法——记录正在执行的下一条字节码指令的地址 如果正在执行的是Native方法——空（Undifined） 唯一一个在JVM规范中没有规定任何OutOfMemoryError的情况区域 1.2Java虚拟机栈 每个线程运行时所需要的内存，称为虚拟机栈 线程私有 每个方法在执行的同时都会创建一个栈帧，描述Java方法执行的内存模型 栈帧（Stack Frame） 每个方法在执行时创建一个栈帧（内存结构） 存储局部变量表、操作数栈、动态链接、方法出口等信息。 方法调用到执行完成的过程，对应栈帧在虚拟机中入栈到出栈的过程 局部变量表【最常说的“栈”】 存放了各种基本类型、对象引用和returnAddress类型（指向了一条字节码指令地址） 其中64位长度long 和 double占两个局部变量空间，其他只占一个 空间大小在编译时确定，运行期间不会改变局部变量表的大小 规定的异常情况 线程请求的栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常 如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，就抛出OutOfMemoryError异常 1234567891011121314151617181920212223242526272829//交叉引用，导致数据过多，栈帧过大public class StackOverFlow &#123; public static void main(String[] args) throws JsonProcessingException &#123; Dept dept = new Dept(); dept.setName(\"Market\"); Emp e1 = new Emp(); Emp e2 = new Emp(); e1.setName(\"zx\"); e2.setName(\"hkw\"); e1.setDept(dept); e2.setDept(dept); dept.setEmp(Arrays.asList(e1,e2)); ObjectMapper mapper = new ObjectMapper(); //输出对象的Json字符串 System.out.println(mapper.writeValueAsString(dept)); //&#123;name: 'Market', // emps: [ // &#123;name: 'zx', dept:&#123;name:'Market', emps: [ ....]&#125; &#125;,] &#125; &#125;&#125;class Dept&#123; private String name; private List&lt;Emp&gt; emp;&#125;class Emp&#123; private String name; private Dept dept;&#125; 栈内存空间越大越好么？ 答： 因为物理内存大小是一定的，内存空间越大会导致线程数量减少，栈是由多个栈帧组成，内存增大，只是将可以容纳栈帧的数量增多，除了可以调用更多的方法(递归)，没有其他的作用 假设物理内存500M，栈内存1M-&gt;2M，500-&gt;250个线程同时运行 -Xss设置栈内存大小，一般-Xss=1M。 垃圾回收是否涉及到栈内存？答： 不会涉及。因为虚拟机栈对应着一个线程的执行过程，在执行过程中，活动栈帧不断随着该方法的运行结束而弹出，直到线程执行完成，栈为空，消失。即一个线程执行完毕，线程栈消失。 线程的局部变量是否线程安全？答： 不一定。方法内的局部变量且没有逃离方法的作用访问时，是线程安全的。如果局部变量引用了对象，由于对象存在于堆中，一般其他线程可以访问修改，需要考虑线程安全。 线程诊断 cpu占用过多 定位进程，top找出占用cpu过多的进程PID ps -H -eo pid,tip,%cpu | grep PID 找出该进程下占用过大的线程 TID jstack pid 查看进程中各线程的详细信息，可以看出问题所在。注意：这里TID为十六进制，TID转换为16进制。 运行迟迟没结果 jstack pid 查看进程中各线程的详细信息，拉到最后，发现死锁问题。 1.3本地方法栈与虚拟机栈（执行Java方法服务）相同，本地方法栈为JVM用到的的Native方法服务 protected native 0bject C lonet) throws CloneNotSupportedException; Sun HotSpot直接将虚拟机栈 &amp; 本地方法栈二合一 1.4Java堆（GC堆）所有的对象实例以及数组都在堆上分配 在虚拟机启动时创建 线程共享 堆可细分为新生代和老年代【目的：更好的回收内存】 新生代可细分为Eden空间、From Survivor空间、To Survivor空间 堆中没有实例内存可以分配扩展时，抛出OutOfMemoryError异常 123456789101112131415161718//List对象始终被关联，无法被回收，死循环不断将list规模变大，最终大于堆内存大小，内存溢出。public class Demo1_5 &#123; public static void main(String[] args) &#123; int i=0; try &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); String a = \"hello\"; while (true) &#123; list.add(a); // he1lo, hellohe1lo, hellohellohellohello ... a= a+a; // hellohellohellohello i++; &#125; &#125;catch (Throwable e) &#123; e.printStackTrace(); System.out.println(i); &#125; &#125;&#125; jps 查看系统有哪些进程 查看堆内存使用情况jmap -heap PID 12345678910111213141516171819202122232425262728293031323334353637383940414243444546Attaching to process ID 84956, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.231-b11using thread-local object allocation.Parallel GC with 8 thread(s)Heap Configuration: MinHeapFreeRatio &#x3D; 0 MaxHeapFreeRatio &#x3D; 100 MaxHeapSize &#x3D; 3995074560 (3810.0MB) NewSize &#x3D; 83886080 (80.0MB) MaxNewSize &#x3D; 1331691520 (1270.0MB) OldSize &#x3D; 167772160 (160.0MB) NewRatio &#x3D; 2 SurvivorRatio &#x3D; 8 MetaspaceSize &#x3D; 21807104 (20.796875MB) CompressedClassSpaceSize &#x3D; 1073741824 (1024.0MB) MaxMetaspaceSize &#x3D; 17592186044415 MB G1HeapRegionSize &#x3D; 0 (0.0MB)Heap Usage:PS Young GenerationEden Space: capacity &#x3D; 62914560 (60.0MB) used &#x3D; 57904552 (55.222084045410156MB) free &#x3D; 5010008 (4.777915954589844MB) 92.03680674235027% usedFrom Space: capacity &#x3D; 10485760 (10.0MB) used &#x3D; 0 (0.0MB) free &#x3D; 10485760 (10.0MB) 0.0% usedTo Space: capacity &#x3D; 10485760 (10.0MB) used &#x3D; 0 (0.0MB) free &#x3D; 10485760 (10.0MB) 0.0% usedPS Old Generation capacity &#x3D; 167772160 (160.0MB) used &#x3D; 0 (0.0MB) free &#x3D; 167772160 (160.0MB) 0.0% used3170 interned Strings occupying 260160 bytes. jconsole 图形界面，多功能检测工具，连续监测 1.5方法区（具体实现方式：元空间/永久代） JDK1.6 方法区是堆逻辑划分中的一个区域，对应hotspot jdk6中的永久代，可以说永久代是方法区在hotspot的一个具体实现 图中 常量池—&gt;运行时常量池 永久代空间不足才会触发FullGC的垃圾回收，导致回收效率不高【其中的字符串常量池使用频繁，回收效率不高会导致占用大量的内存】 从jdk7以后方法区就“四分五裂了”，不再是在单一的一个区域内进行存储。 jdk1.7 永久代概念存在，并没完全移除 存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap 永久代只存储类和类加载器的元数据信息 符号引用(Symbols)转移到了native heap 字面量(interned strings)转移到了java heap 类的静态变量(class statics)转移到了java heap JDK1.8 彻底移除了永久代，新增了元空间（Metaspace）的概念 元空间并不在虚拟机中，而是使用本地内存 元空间中也是存储只存储类和类加载器的元数据信息 符号引用(Symbols)转移到了native heap 字面量(interned strings)转移到了java heap 类的静态变量(class statics)转移到了java heap 图中 常量池—&gt;运行时常量池 存储的内容几乎没怎么变化，都是用于存储类信息（类的版本/字段/方法/接口），常量，静态变量，及时编译器编译后的代码等数据，而是在内存限制、垃圾回收等机制上改变较大。 线程共享 对这块区域主要是针对字符串常量池回收 此区域垃圾回收目标：针对字符串常量池的回收【主要】和对类型的卸载 JDK1.7开始已经把字符串常量池转移到堆里面了。 由于使用反射机制的原因，虚拟机很难推测哪个类信息不再使用 使用本地内存（之前是在jvm中），不在虚拟机中，没有设置限制参数时只受物理内存大小限制，即只有占满了操作系统可用内存后才OOM。 123456789101112131415161718192021/** 演示元空间内存溢出java.lang.OutOfMemoryError: Metaspace **/// -XX:MaxMetaspaceSize=8mpublic class Demo1_8 extends ClassLoader &#123;// 可以用来加载类的二进制字节码 public static void main(String[] args) &#123; int i=0 try &#123; Demo1_8 test = new Demo1_8(); for(inti=0;i&lt;10000;i++,j++)&#123; // Classwriter作用是生成类的二进制字节码 ClassWriter CW = new ClassWriter(0); //版本号，public, 类名，包名，父类，接口 CW.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, \"Class\" + i, nu1l, \"java/lang/object\", null); //返回byte[] byte[] code = CW.toByteArray(); // 执行了类的加载 test.defineClass(\"Class\" + i, code, 0, code.length); // Class 对象 &#125; finally &#123; System.out.println(i); &#125; &#125; &#125; 解决了以前永久代的OOM问题，元数据和class对象存在永久代中，容易出现性能问题和内存溢出，毕竟是和老年代共享堆空间【场景：spring mybatis 都可能会通过cglib产生大量的class对象】 java8后，永久代升级为元空间独立后，也降低了老年代GC的复杂度 1.5.1运行时常量池[JDK1.7概念：方法区的一部分] 存放各种字面量（字符串，final的常量池），符号引用（类/接口/全限定类名，字段名称描述符，方法名称描述符…）等，其空间从方法区域（JDK1.7后为堆空间）中分配。 1.5.2常量池 &amp; 运行时常量池 &amp; 字符串池 Class文件常量池（class constant pool）：class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)【就是一张表】，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。 字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。 符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。 类和接口的全限定名 字段名称和描述符 方法名称和描述符 运行时常量池：常量池是*.class文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址 字符串常量池 字符串常量池里的内容是在类加载完成，经过验证，准备阶段之后在string pool中生成字符串对象实例【家养】 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。 Java语言并不要求常量一定只有编译期预置入Class的常量表的内容才能进入方法区常量池，运行期间也可将新内容放入常量池（最典型的String.intern()方法） 当常量池无法在申请到内存时会抛出OutOfMemoryError异常 1.5.3常量池和串池的关系 Class文件常量池中的都会被加载到运行时常量池中，此时字符串都是常量池中的（字面量）符号，尚且未转化为对象【字符串延迟加载】 123456String s1 = \"a\"; //java.lang.string.count = 2361String s2 = \"b\"; //java.lang.string.count = 2362String s3 = \"ab\"; //java.lang.string.count = 2363 运行时，将String字面量符号“a”转化为字符串对象，并在StringTable中寻找“a”，如多没有则添加“a”字符串对象。 StringTable 结构为HashTable，且不能扩容。 ## 1.6直接内存 不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，读写性能高，不受JVM内存回收管理 堆外内存，又称直接内存。这部分内存不由jvm管理和回收的，需要我们手动的回收，分配回收成本较高 堆内内存是属于jvm的，由jvm进行分配和管理，属于”用户态”，而堆外内存是由操作系统管理的，属于”内核态” JDK1.4加入了NIO，引入一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中DirectByteBuffer对象作为这块内存的引用进行操作。因为避免了在Java堆和Native堆中来回复制数据，提高了性能。 当各个内存区域总和大于物理内存限制，抛出OutOfMemoryError异常 12345678910111213public static void main(String[] args) &#123; List&lt;ByteBuffer&gt; list = new ArrayList&lt;&gt;(); int i = 0; try &#123; while(true)&#123; ByteBuffer byteBuffer = ByteBuffer.allocateDirect(100*1024*1024); list.add(byteBuffer); i++; &#125; &#125;finally &#123; System.out.println(i); &#125; &#125; 1.6.1直接内存优点 对于频繁的IO操作，我们需要不断把内存中的对象复制到直接内存。然后由操作系统直接写入磁盘或者读出磁盘。这时候用到直接内存就减少了堆的内外内存来回复制的操作。 我们在运行程序的过程中可能需要新建大量对象，对于一些声明周期比较短的对象，可以采用对象池的方式。但是对于一些生命周期较长的对象来说，不需要频繁调用gc，为了节省gc的开销，直接内存是必备之选。 扩大程序运行的内存，由于jvm申请的内存有限，这时候可以通过堆外内存来扩大内存 1.6.2直接内存使用前和使用后 使用前 因为java无法操作本地文件，在java堆内存中划出java缓冲区； 从用户态转移到内核态，本地方法在系统内存中划出一段系统缓冲区，将磁盘文件分部分缓冲到系统缓冲区中，间接的将系统缓冲区中数据传输到java缓冲区中 内核态转到用户态，调用输出流写入操作，将文件copy到另一个位置，循环copy，直到全部复制完成。 使用后 ByteBuffer.allocateDirect(_size)，在系统内存中分配直接内存 系统方法和java方法都可以访问直接内存； 与不使用直接内存相比，减少了一次从系统缓存区向java缓冲区复制的操作，复制效率成倍上升。 分配和回收原理 使用Unsafe对象实现直接内存的分配回收，回收主要使用的是freeMemory方法 ByteBuffer类内部，使用了Cleaner（虚引用）来检测ByteBuffer对象，一旦对象被回收，就会由ReferenceHandler线程通过Cleaner的clean对象调用freeMenory来释放直接内存。 -XX:+DisableExplicitGC 显式的System.gc()显式的垃圾回收 FULL GC，被禁用 123456789101112131415public class Demo1_26 &#123; static int _1Gb = 1024 * 1024 * 1024; /* * -XX: +DisableExplicitGC 禁用显式的System.gc() */ public static void main(String[] args) throws I0Exception &#123; ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1Gb) ; System.out.println(\"分配完毕...\"); System.in.read(); System.out.println(\"开始释放...\"); byteBuffer = null; System.gc(); //显式的垃圾回收, Fu1l GC 回收新生代和老年代 时间较长 System.in.read(); &#125;&#125; 因为考虑到系统性能，FULL GC时间够长，会严重影响性能。所以涉及到直接内存的使用，释放内存使用Unsafe.freeMemory，不建议使用System.gc()。 1234567891011121314public class Demo1_27 &#123; static int _1Gb = 1024 * 1024 * 1024; public static void main(String[] args) throws IOException &#123; Unsafe unsafe = getUnsafe(); //分配内存 long base = unsafe.allocateMemory(_1Gb); unsafe.setMemory(base,_1Gb, (byte)0); System.in.read(); //释放内存 unsafeJ.freeMemory(base); System.in.read(); &#125; public static Unsafe getUnsafe() &#123;...&#125;&#125; 1.7堆参数设置 以-X开头的都是非标准的（这些参数并不能保证在所有的JVM上都被实现），而且如果在新版本有什么改动也不会发布通知 以-XX开头的都是不稳定的并且不推荐在生产环境中使用。这些参数的改动也不会发布通知。 -XX:+&lt;option&gt;表示开 启option选项 -XX:-&lt;option&gt;， 表示关闭option选项 -XX:&lt;option&gt;=&lt;value&gt;， 表 示将option选项的值设置为value 整个JVM内存大小= 年轻代/新生代+ 老年代 注：元空间（古称：永久代）已从JVM老年代的堆空间中移除 -Xmx2G（memory max） 设置JVM最大可用内存为2G -Xms1G（memory size） 设置JVM初始可用内存为1G -Xmn500M 设置新生代内存为500M。 -XX:ServivorRatio=3 新生代中划分为Eden区，from Survivor区， to Survivor区 默认大小8：1：1，现在调整为3：1：1 -XX:NewRatio=3: 年轻代与年老代比值为1：3 -XX:NewSize 设置新生代大小 XX:MaxNewSize 新生代最大大小 -XX:MaxPermSize=64M【已弃用】 永久代大小为64M -XX:MetaspaceSize 初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值 -XX:MaxMetaspaceSize 元空间大小空间，默认是没有限制的 实例：-Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc","tags":[{"name":"JVM","slug":"JVM","permalink":"http://goldcarpenter.github.io/tags/JVM/"}]},{"title":"多线程编程","date":"2019-04-30T12:11:21.000Z","path":"2019/04/30/多线程_Part5/","text":"7 Park &amp; Unpark LockSupport 类中的方法 暂停当前线程 1LockSupport.park(); 恢复某个线程的运行 1LockSupport.unpark(暂停线程对象) 7.1 Park &amp; Unpark VS Object的wait &amp; notify相比 wait,notify和notifyAll必须配合Object Monitor一起使用，而unpark不必 park &amp; unpark是以线程为单位来[阻塞]和[唤醒]线程，而notify只能随机唤醒一个等待线程,notifyAll是唤醒所有等待线程，就不那么[精确] park &amp; unpark可以先unpark,而wait &amp;notify 不能先notify 1234567891011121314151617181920 public static void main(String[] args) &#123; Thread t1 = new Thread(()-&gt;&#123; log.debug(\"start\"); Sleeper.sleep(3); log.debug(\"park\"); LockSupport.park(); log.debug(\"resume\"); &#125;,\"t1\"); t1.start(); Sleeper.sleep(1); log.debug(\"unpark\"); LockSupport.unpark(t1); &#125;/*22:03:00.801 [t1] MultiThread - start22:03:01.799 [main] MultiThread - unpark22:03:03.810 [t1] MultiThread - park22:03:03.811 [t1] MultiThread - resume*/ 7.2park &amp; unpark 原理 每个线程都有自己的一个Parker对象，底层由C实现的，有三部分组成_counter,_cond和_mutex 线程就像一个旅人，Parker就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter就好比背包中的备用干粮(0 为耗尽，1为充足) 调用park就是要看需不需要停下来歇息 如果备用干粮耗尽， 那么钻进帐篷歇息 如果备用干粮充足，那么不需停留，继续前进 调用unpark,就好比补充干粮 如果这时线程还在帐篷，就唤醒上他继续前进 如果这时线程还在运行，那么下次他调用park时，仅是消耗掉备用干粮，不需停留继续前进 因为背包空间有限，多次调用unpark仅会补充一份备用干粮 调用park方法 当前线程调用Unsafe.park()方法 检查_counter ，本情况为0，这时获得_mutex互斥锁对象 线程进入，_cond条件变量阻塞 设置_counter= 0 调用unpark方法 调用Unsafe.unpark(Thread_0) 方法，设置_counter为1 唤醒_cond条件变量中的Thread_0 Thread_0恢复运行 设置_counter为0 先Unpark 在Park 调用Unsafe.unpark(Thread_0)方法，设置_counter为1 当前线程调用Unsafe.park()方法 检查_counter，本情况为1,这时线程无需阻塞，继续运行 设置_counter为0 8 将锁的粒度细分 好处，是可以增强并发度 坏处，如果一个线程需要同时获得多把锁，就容易发生死锁 8.1 死锁 有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁 t1 线程 获得 A对象 锁，接下来想获取 B对象 的锁 t2 线程 获得 B对象 锁，接下来想获取 A对象 的锁 12345678910111213141516171819202122public static void main(String[] args) &#123; private final Object lock1 = new Object(); private final Object lock2 = new Object(); new Thread(()-&gt; &#123; synchronized (lock1) &#123; Sleeper.sleep(2); synchronized (lock2)&#123;&#125; &#125; &#125;,\"t1\").start(); new Thread(()-&gt; &#123; synchronized (lock2) &#123; Sleeper.sleep(2); synchronized (lock1) &#123;&#125; &#125; &#125;,\"t2\").start();&#125; 定位死锁 使用jps定位进程 id，再用jstack id定位死锁 jconsole 哲学家就餐问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; public static void main(String[] args) &#123; Chopstick c1 = new Chopstick(\"1\"); Chopstick c2 = new Chopstick(\"2\"); Chopstick c3 = new Chopstick(\"3\"); Chopstick c4 = new Chopstick(\"4\"); Chopstick c5 = new Chopstick(\"5\"); new Philosopher(\"苏格拉底\", c1, c2).start(); new Philosopher(\"柏拉图\", c2, c3).start(); new Philosopher(\"亚里士多德\", c3, c4).start(); new Philosopher(\"赫拉克利特\", c4, c5).start(); new Philosopher(\"阿基米德\", c5, c1).start(); &#125;&#125;@Slf4j(topic = \"c.Philosopher\")class Philosopher extends Thread &#123; Chopstick left; Chopstick right; public Philosopher(String name, Chopstick left, Chopstick right) &#123; super(name); this.left = left; this.right = right; &#125; @Override public void run() &#123; while (true) &#123; // 尝试获得左手筷子 synchronized (left) &#123; // 尝试获得右手筷子 synchronized (right) &#123; eat(); &#125; &#125; &#125; &#125; private void eat() &#123; log.debug(\"eating...\"); Sleeper.sleep(0.5); &#125;&#125;class Chopstick &#123; String name; public Chopstick(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"筷子&#123;\" + name + '&#125;'; &#125;&#125; 8.2活锁 活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束 123456789101112131415161718192021static volatile int count = 10;static final Object lock = new Object();public static void main(String[] args) &#123; new Thread(() -&gt; &#123; // 期望减到 0 退出循环 while (count &gt; 0) &#123; sleep(0.2); count--; log.debug(\"count: &#123;&#125;\", count); &#125; &#125;, \"t1\").start(); new Thread(() -&gt; &#123; // 期望超过 20 退出循环 while (count &lt; 20) &#123; sleep(0.2); count++; log.debug(\"count: &#123;&#125;\", count); &#125; &#125;, \"t2\").start();&#125; 8.3 饥饿 一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束 饥饿的情况不易演示，读写锁会涉及饥饿问题 哲学家就餐问题中，如果修改最后一位哲学家的筷子顺序，可以避免死锁，但是可能导致饥饿 9 Lock接口java.util.concurrent.locks.Lock机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。 Lock锁也称同步锁，加锁与释放锁方法化了，如下： public void lock():加同步锁。 public void unlock():释放同步锁。 每个Java对象都可以用作一个实现同步的锁，成为内置锁（Intrinsic Lock）或监视器锁（Monitor Lock） 使用ReentrantLock子类 1public class ReentrantLock implements Lock, java.io.Serializable 相对于synchronizdd它具备如下特点 可中断等待线程的等待 可以设置超时时间 可以设置为公平锁（先到先到） 支持多个条件变量【waitSet】等待 与synchronized一样，都支持可重入 基本语法 123456789private final ReentrantLock lock = new ReentrantLock();public void m()&#123; lock.lock(); try &#123; //保证线程安全的代码 &#125;finally &#123; lock.unlock(); &#125;&#125; 9.1 可重入 可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁 如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住 123456789101112131415161718192021222324252627282930313233public class MultiThread &#123; private static ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) &#123; lock.lock(); try&#123; log.debug(\"enter main\"); m1(); &#125;finally &#123; lock.unlock(); &#125; &#125; public static void m1()&#123; lock.lock(); try&#123; log.debug(\"enter m1\"); m2(); &#125;finally &#123; lock.unlock(); &#125; &#125; public static void m2()&#123; lock.lock(); try&#123; log.debug(\"enter m2\"); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125;/*09:01:19.286 [main] MultiThread - enter main09:01:19.293 [main] MultiThread - enter m109:01:19.293 [main] MultiThread - enter m2*/ 9.2可中断等待线程的等待 在等待锁的过程中，是否可以终止线程等待的过程 synchronized和lock都是不可打断的，别的线程持有了锁头，等待线程就需要一直等待下去。 lock.lockInterruptibly();防止无限制的等待下去 12345678910111213141516171819202122232425262728293031private static ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) &#123; Thread t1 = new Thread(()-&gt; &#123; log.debug(\"try to get lock\"); try &#123; lock.lockInterruptibly(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); log.debug(\"not wait anymore, be interrupted\"); return; // 如果没有获得锁 则结束 &#125; try&#123; log.debug(\"get lock\"); &#125;finally &#123; lock.unlock(); &#125; &#125;,\"t1\"); lock.lock(); t1.start(); Sleeper.sleep(4); t1.interrupt(); lock.unlock(); &#125;/*09:14:48.782 [t1] MultiThread - try to get lockjava.lang.InterruptedException ... at...top.carpenter.MultiThread.lambda$main$0(MultiThread.java:19) at java.lang.Thread.run(Thread.java:748)09:14:52.782 [t1] MultiThread - not wait anymore, be interrupted*/ 9.3锁超时 public boolean tryLock()——立即尝试锁定【不支持打断】 lock.tryLock(2, TimeUnit.SECONDS)——在时间内都在尝试获得锁【支持打断】 12345678910111213141516171819202122232425private static ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) &#123; Thread t1 = new Thread(()-&gt; &#123; try &#123; if(!lock.tryLock(2, TimeUnit.SECONDS)) &#123; log.debug(\"超时，获取不到锁\");return; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); log.debug(\"被打断，获取不到锁\"); return; &#125; try&#123; log.debug(\"获取锁\"); &#125;finally &#123; lock.unlock(); &#125; &#125;,\"t1\"); lock.lock(); t1.start(); Sleeper.sleep(1); lock.unlock(); &#125; 解决哲学家就餐问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; public static void main(String[] args) &#123; Chopstick c1 = new Chopstick(\"1\"); Chopstick c2 = new Chopstick(\"2\"); Chopstick c3 = new Chopstick(\"3\"); Chopstick c4 = new Chopstick(\"4\"); Chopstick c5 = new Chopstick(\"5\"); new Thread(new Philosopher(c1,c2),\"苏格拉底\").start(); new Thread(new Philosopher(c2,c3),\"柏拉图\").start(); new Thread(new Philosopher(c3,c4),\"亚里士多德\").start(); new Thread(new Philosopher(c4,c5),\"赫拉克利特\").start(); new Thread(new Philosopher(c5,c1),\"阿基米德\").start(); &#125;&#125;@Slf4j(topic = \"c.Philosopher\")class Philosopher implements Runnable &#123; Chopstick left; Chopstick right; public Philosopher(Chopstick left, Chopstick right) &#123; this.left = left; this.right = right; &#125; @Override public void run() &#123; while (true) &#123; // 尝试获得左手筷子 if(left.tryLock()) &#123; try &#123; // 尝试获得右手筷子 if(right.tryLock()) &#123; try &#123; eat(); &#125; finally &#123; right.unlock(); &#125; &#125; &#125; finally &#123; left.unlock(); // 释放自己手里的筷子 &#125; &#125; &#125; &#125; private void eat() &#123; log.debug(\"eating...\"); Sleeper.sleep(0.5); &#125;&#125;class Chopstick extends ReentrantLock &#123; String name; public Chopstick(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"筷子&#123;\" + name + '&#125;'; &#125;&#125; 9.4公平锁12private final ReentrantLock lock = new ReentrantLock(false);//非公平锁 entryList中线程随机获得锁【默认】private final ReentrantLock lock = new ReentrantLock(true);//公平锁 按照进入阻塞队列的顺序 公平锁一般没有必要，会降低并发度，后面分析原理时会讲解 9.5支持多个条件变量等待(waitSet) synchronized中也有条件变量，就是我们讲原理时那个waitSet休息室，当条件不满足时进入waitSet等待 ReentrantLock的条件变量比synchronized强大之处在于，它是支持多个条件变量的 synchronized 是那些不满足条件的线程都在一间休息室等消息 ReentrantLock支持多间休息室，有专门门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒 Lock接口方法：Condition的作用是对锁进行更精确的控制【”互斥锁”/”共享锁”捆绑使用】 12private Condition producer = lock.newCondition();private Condition consumer = lock.newCondition(); Condition中的await()方法相当于Object的wait()方法 1producer.await() Condition中的signal()方法相当于Object的notify()方法 1producer.signal() Condition中的signalAll()相当于Object的notifyAll()方法。 1producer.signalAll() 使用流程 await前需要获得锁【与wait用法相同】 await执行后，会释放锁，进入conditionObject等待 await 的线程被唤醒(或打断、或超时)取重新竞争lock锁 竞争lock锁成功后,从await后继续执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import java.util.LinkedList;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class Container&lt;T&gt; &#123; private LinkedList&lt;T&gt; list = new LinkedList&lt;&gt;(); private int count = 0; private final int MAX = 10; Lock lock = new ReentrantLock(); private Condition producer = lock.newCondition(); private Condition consumer = lock.newCondition(); public void put(T e)&#123; lock.lock(); try&#123; while(this.count == MAX) // 注意是while！防止多个同时唤醒 &#123; System.out.println(\"list满了...\"); producer.await(); &#125; System.out.println(\"list加入元素\" + e); this.list.offer(e); this.count++; consumer.signalAll(); &#125;catch (InterruptedException ex) &#123; ex.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void remove() &#123; lock.lock(); try&#123; while(this.list.size() == 0) &#123; System.out.println(\"list空了...\"); consumer.await(); &#125; System.out.println(\"list清除\" + this.list.getFirst()); this.list.poll(); count--; producer.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.lock(); &#125; &#125;&#125;class Consumer implements Runnable&#123; private Container&lt;Integer&gt; container = null; Consumer(Container container) &#123; this.container = container; &#125; @Override public void run() &#123; for(int i =0 ;i &lt; 99 ;i++) &#123; System.out.println(\"希望清除\" + i); container.remove(); &#125; &#125;&#125;class Producer implements Runnable&#123; private Container&lt;Integer&gt; container = null; Producer(Container container) &#123; this.container = container; &#125; @Override public void run() &#123; for(int i = 0; i &lt; 99; i++) &#123; System.out.println(\"希望添加\" + i); container.put(i); &#125; &#125;&#125;class Main&#123; public static void main (String[] args) throws Exception&#123; Container&lt;Integer&gt; container = new Container&lt;Integer&gt;(); new Thread(new Producer(container)).start(); new Thread(new Consumer(container)).start(); &#125;&#125; 9.6 同步模式之顺序控制9.6.1固定运行顺序 例题：必须先 2 后 1 打印 wait notify123456789101112131415161718192021222324252627282930313233@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; static Object lock = new Object(); static boolean t2runned = false; public static void main(String[] args) &#123; Thread t1 = new Thread(()-&gt;&#123; synchronized (lock) &#123; while (!t2runned) &#123; try&#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; log.debug(\"1\"); &#125; &#125;,\"t1\"); Thread t2 = new Thread(()-&gt;&#123; synchronized (lock) &#123; log.debug(\"2\"); t2runned = true; lock.notify(); &#125; &#125;,\"t2\"); t1.start(); t2.start(); &#125;&#125; await signal12345678910111213141516171819202122232425262728293031323334353637383940@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; final static ReentrantLock lock = new ReentrantLock(); static Condition waitSet = lock.newCondition(); static boolean t2runned = false; public static void main(String[] args) &#123; Thread t1 = new Thread(()-&gt;&#123; lock.lock(); try &#123; while (!t2runned) &#123; try&#123; waitSet.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; log.debug(\"1\"); &#125;finally &#123; lock.unlock(); &#125; &#125;,\"t1\"); Thread t2 = new Thread(()-&gt;&#123; lock.lock(); try &#123; log.debug(\"2\"); t2runned = true; waitSet.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125;,\"t2\"); t1.start(); t2.start(); &#125;&#125; park unpark12345678910111213141516@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; public static void main(String[] args) &#123; Thread t1 = new Thread(()-&gt;&#123; LockSupport.park(); log.debug(\"1\"); &#125;,\"t1\"); Thread t2 = new Thread(()-&gt;&#123; log.debug(\"2\"); LockSupport.unpark(t1); &#125;,\"t2\"); t1.start(); t2.start(); &#125;&#125; 9.6.2交替运行 引例：线程 1 输出 1 5 次，线程 2 输出 2 5 次。现在要求输出 1212121212 怎么实现 123456789101112131415161718192021222324252627282930313233343536373839404142static ReentrantLock lock = new ReentrantLock();static Condition condition = lock.newCondition();static Boolean t1Finish = false;public static void main(String[] args) throws InterruptedException &#123; new Thread(()-&gt;&#123; for (int i = 0; i &lt; 5; i++) &#123; lock.lock(); try &#123; while (t1Finish)&#123; condition.await(); &#125; System.out.println(1); t1Finish = true; condition.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;,\"t1\").start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 5; i++) &#123; lock.lock(); try &#123; while (!t1Finish)&#123; condition.await(); &#125; System.out.println(2); t1Finish = false; condition.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;,\"t2\").start();&#125; 线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现 wait12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; public static void main(String[] args) &#123; PrintObject printObject = new PrintObject(1,5); Thread t1 = new Thread(()-&gt;&#123; printObject.print(1,2,String.valueOf('a')); &#125;,\"t1\"); Thread t2 = new Thread(()-&gt;&#123; printObject.print(2,3,String.valueOf('b')); &#125;,\"t2\"); Thread t3 = new Thread(()-&gt;&#123; printObject.print(3,1,String.valueOf('c')); &#125;,\"t3\"); t1.start(); t2.start(); t3.start(); &#125;&#125;@Slf4jclass PrintObject&#123; private int printFlag; private int loopNumber; public PrintObject(int flag, int loopNumber) &#123; this.printFlag = flag; this.loopNumber = loopNumber; &#125; void print(int waitFlag, int nextFlag, String str) &#123; for (int i = 0; i &lt; loopNumber; i++) &#123; synchronized (this) &#123; while (printFlag != waitFlag) &#123; try&#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; log.debug(str); printFlag = nextFlag; this.notifyAll(); &#125; &#125; &#125;&#125; await 上面的模式可以套用，此处使用新的方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; public static void main(String[] args) &#123; PrintObject printObject = new PrintObject(5); Condition condition1 = printObject.newCondition(); Condition condition2 = printObject.newCondition(); Condition condition3 = printObject.newCondition(); Thread t1 = new Thread(()-&gt;&#123; printObject.print(condition1,condition2,String.valueOf('a')); &#125;,\"t1\"); Thread t2 = new Thread(()-&gt;&#123; printObject.print(condition2,condition3,String.valueOf('b')); &#125;,\"t2\"); Thread t3 = new Thread(()-&gt;&#123; printObject.print(condition3,condition1,String.valueOf('c')); &#125;,\"t3\"); t1.start(); t2.start(); t3.start(); Sleeper.sleep(1); printObject.lock(); try &#123; condition1.signal(); &#125;finally &#123; printObject.unlock(); &#125; &#125;&#125;@Slf4jclass PrintObject extends ReentrantLock&#123; private int loopNumber; public PrintObject(int loopNumber) &#123; this.loopNumber = loopNumber; &#125; void print(Condition printCondition, Condition nextCondition, String str) &#123; for (int i = 0; i &lt; loopNumber; i++) &#123; this.lock(); try&#123; try &#123; printCondition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.debug(str); nextCondition.signal(); &#125;finally &#123; this.unlock(); &#125; &#125; &#125;&#125; 没有使用while的虚假唤醒 park12345678910111213141516171819202122232425262728293031323334353637383940@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; static Thread t1; static Thread t2; static Thread t3; public static void main(String[] args) &#123; PrintObject printObject = new PrintObject(5); t1 = new Thread(()-&gt;&#123; printObject.print(t2,\"a\"); &#125;); t2 = new Thread(()-&gt;&#123; printObject.print(t3,\"b\"); &#125;); t3 = new Thread(()-&gt;&#123; printObject.print(t1,\"c\"); &#125;); t1.start(); t2.start(); t3.start(); LockSupport.unpark(t1); &#125;&#125;@Slf4jclass PrintObject extends ReentrantLock&#123; private int loopNumber; public PrintObject(int loopNumber) &#123; this.loopNumber = loopNumber; &#125; void print(Thread t, String str) &#123; for (int i = 0; i &lt; loopNumber; i++) &#123; LockSupport.park(); log.debug(str); LockSupport.unpark(t); &#125; &#125;&#125; 9.7 Synchronized 与 Lock 对比 Lock只有代码块锁 Synchronized有代码块锁和方法锁 Lock是显示锁 手动开启关闭 Synchronized是隐式锁 出了作用域自动释放 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类） Lock可以进行尝试锁定，无论是否锁定方法都将继续执行 123456789101112131415Lock lock = new ReentrantLock();boolean locked = lock.tryLock(5, TimeUnit.SECONDS);try&#123; if(locked) &#123; //... &#125; else &#123; //... &#125;&#125;finally&#123; if(locked) lock.unlock();&#125; 使用顺序【细粒度】 Lock &gt; 方法代码块 &gt; 同步方法","tags":[{"name":"多线程","slug":"多线程","permalink":"http://goldcarpenter.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"MySQL基础","date":"2019-04-28T12:15:35.000Z","path":"2019/04/28/MySQL基础_Part2/","text":"DDL（Data Define Languge）数据定义语言库和表的管理 √ 创建： create 修改： alter 删除： drop 库的管理 创建语法： 1create database [if not exists] 库名; 修改语法： 1RENAME DATABASE 库名 TO 新库名; 删除语法： 1DROP DATABASE IF EXISTS 库名; 表的管理 创建语法： 1234567create table 表名( 列名 列的类型【(长度)】【约束】, 列名 列的类型【(长度)】【约束】, 列名 列的类型【(长度)】【约束】, ... 列名 列的类型【(长度)】【约束】) 修改语法： 1ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】; 1234567891011121314151617181920#①修改列名ALTER TABLE 表名 CHANGE COLUMN 字段名 新字段名 DATETIME;#②修改列的类型或约束ALTER TABLE 表名 MODIFY COLUMN 字段名 TIMESTAMP;#③添加新列ALTER TABLE 表名 ADD COLUMN 字段名 DOUBLE; #④删除列ALTER TABLE 表名 DROP COLUMN 字段名;#⑤修改表名ALTER TABLE 表名 RENAME TO 新表名;#⑥添加列级约束alter table 表名 modify column 字段名 字段类型 新约束;#⑦添加**表级**约束alter table 表名 ADD 【constraint 约束名】 约束类型(字段名) 【外键的引用】; 删除语法： 1DROP TABLE IF EXISTS 表名; 表的复制 仅仅复制表的结构 1CREATE TABLE 表名 LIKE 表名; 复制表的结构+数据 1CREATE TABLE 表名 SELECT * FROM author; 只复制部分数据 1234CREATE TABLE 表名SELECT 字段名,字段名FROM 表名 WHERE ...; 仅仅复制某些字段 1234CREATE TABLE 表名 SELECT 字段名,字段名FROM 表名WHERE 0; 常见数据类型介绍 √ 数值型： 整型分类： tinyint smallint mediumint int/integer bigint 1 2 3 4 8 ① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值③ 如果不设置长度，会有默认的长度，长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！ 小数 float(M,D)【定点小数】 double(M,D)【定点小数】 dec(M，D)【浮点小数】 decimal(M,D)【浮点小数】 M：整数部位+小数部位D：小数部位如果超过范围，则插入临界值 M和D都可以省略如果是decimal，则M默认为10，D默认为0如果是float和double，则会根据插入的数值的精度来决定精度 定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用 字符型： 较短的文本：char、varchar 较长的文本：text、blob（较长的二进制数据） 写法 M的意思 特点 空间的耗费 空间的耗费 char char(M) 最大的字符数 可以省略，默认为1 比较耗费 高 varchar varchar(M) 最大的字符数 不可以省略 比较节省 低 日期型： 字节 范围 时区等的 datetime 8 1000——9999 不影响 timestamp 4 1970-2038 影响 ​ 常见约束 √ 含义：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性 六大约束 NOT NULL：非空，用于保证该字段的值不能为空 DEFAULT:默认，用于保证该字段有默认值 PRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空 UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空 CHECK:检查约束【mysql中不支持】 FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值 在从表添加外键约束，用于引用主表中某列的值 添加约束的时机： 创建表时 未向表中添加数据修改表时 约束的添加分类： 列级约束 表级约束 六大约束语法上都支持，但外键约束没有效果 除了非空、默认，其他的都支持 12345678910111213141516171819202122CREATE TABLE stuinfo( id INT PRIMARY KEY,#主键 stuName VARCHAR(20) NOT NULL UNIQUE,#非空 gender CHAR(1) CHECK(gender='男' OR gender ='女'),#检查 seat INT UNIQUE,#唯一 age INT DEFAULT 18,#默认约束 majorId INT REFERENCES major(id)#外键【没有效果】);DROP TABLE IF EXISTS stuinfo;CREATE TABLE stuinfo( id INT, stuname VARCHAR(20), gender CHAR(1), seat INT, age INT, majorid INT, CONSTRAINT pk PRIMARY KEY(id),#主键 CONSTRAINT uq UNIQUE(seat),#唯一键 CONSTRAINT ck CHECK(gender ='男' OR gender = '女'),#检查 CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键); 外键： 要求在从表级约束设置外键关系 从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求 主表的关联列必须是一个key（一般是主键或唯一键） 插入数据时，先插入主表，再插入从表 删除数据时，先删除从表，再删除主表 主键和唯一对比： 保证唯一性 是否允许为空 一个表中可以有多少个 是否允许组合 主键 √ × 至多有1个 √，但不推荐 唯一 √ √ 可以有多个 √，但不推荐 1234567891011121314151617181920212223242526272829303132333435363738#1.添加非空约束ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NOT NULL;#2.添加默认约束ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;#3.添加主键#①列级约束ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;#②表级约束ALTER TABLE stuinfo ADD PRIMARY KEY(id);#4.添加唯一#①列级约束ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;#②表级约束ALTER TABLE stuinfo ADD UNIQUE(seat);#5.添加外键ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); #三、修改表时删除约束#1.删除非空约束ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;#2.删除默认约束ALTER TABLE stuinfo MODIFY COLUMN age INT ;#3.删除主键ALTER TABLE stuinfo DROP PRIMARY KEY;#4.删除唯一ALTER TABLE stuinfo DROP INDEX seat;#5.删除外键ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;SHOW INDEX FROM stuinfo; 标识列 自增长列含义：可以不用手动的插入值，系统提供默认的序列值 特点： 标识列必须和主键搭配吗？不一定，但要求是一个key 一个表可以有几个标识列？至多一个！ 标识列的类型只能是数值型 标识列可以通过SET auto_increment_increment=3;设置步长 可以通过手动插入值，设置起始值 TCL（Transaction Control Language）事务控制语言事务和事务处理 特性【一元持久隔离 ACID】 原子性：一个事务不可再分割，要么都执行要么都不执行 一致性：一个事务执行会使数据从一个一致状态切换到另外一个一致状态 隔离性：一个事务的执行不受其他并发操作事务的干扰 持久性：一个事务一旦提交，则会永久的改变数据库的数据 事务的隔离级别 脏读 不可重复读 幻读 read uncommitted √ √ √ read committed × √ √ repeatable read × × √ serializable × × × √：出现 ×：不出现 mysql中默认第三个隔离级别 repeatable read 关键语句 1234567891011set autocommit=0; set session autocommit=0;set @@session.autocommit=0; start transaction;commit;rollback;savepoint 断点commit to 断点rollback to 断点 视图的讲解√ 视图和表的区别： 使用 占用物理空间 视图 增删改查，只是一般不能增删改 不占用，仅仅保存sql逻辑 表 增删改查 占用 视图的好处 sql语句提高重用性，效率高 和表实现了分离，隐藏原表提高了安全性 创建语法： 123CREATE VIEW 视图名AS查询语句; 视图的修改 方式一 123create or replace view 视图名as查询语句; 12345CREATE OR REPLACE VIEW myv3ASSELECT AVG(salary),job_idFROM employeesGROUP BY job_id; 方式二 123alter view 视图名as 查询语句; 123ALTER VIEW myv3ASSELECT * FROM employees; 删除视图 1drop view 视图名,视图名,...; 查看视图 123DESC myv3;SHOW CREATE VIEW myv3; 具备以下特点的视图不允许更新 ①包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all 12345CREATE OR REPLACE VIEW myv1ASSELECT MAX(salary) m,department_idFROM employeesGROUP BY department_id; ②常量视图 12CREATE OR REPLACE VIEW myv2AS SELECT 'john' NAME; ③Select中包含子查询 123CREATE OR REPLACE VIEW myv3ASSELECT department_id,(SELECT MAX(salary) FROM employees) 最高工资 FROM departments; ④join 123456CREATE OR REPLACE VIEW myv4ASSELECT last_name,department_nameFROM employees eJOIN departments dON e.department_id = d.department_id; ⑤from一个不能更新的视图 123CREATE OR REPLACE VIEW myv5ASSELECT * FROM myv3; ⑥where子句的子查询引用了from子句中的表 123456789CREATE OR REPLACE VIEW myv6ASSELECT last_name,email,salaryFROM employeesWHERE employee_id IN( SELECT manager_id FROM employees WHERE manager_id IS NOT NULL); 变量 分类 系统变量 自定义变量 全局变量 用户变量 会画变量 局部变量 系统变量 变量由系统定义，不是用户定义，属于服务器层面 注意： 全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别 语法 查看所有系统变量 1SHOW GLOBAL|【session】variables; 查看满足条件的部分系统变量 1SHOW GLOBAL|【session】 variables like '%char%'; 查看指定的系统变量的值【@@不能少 session.可省略】 1select @@[GLOBAL|session].系统变量名; 123SELECT @@global.autocommit;SELECT @@autocommit;SELECT @@session.tx_isolation; 为某个系统变量赋值【 session.可省略】 1234# 方式一：set GLOBAL|session 系统变量名=值;# 方式二：set @@[GLOBAL|session].系统变量名=值; 1234SET @@global.autocommit=0;SET GLOBAL autocommit=0;SET @@session.tx_isolation='read-uncommitted';SET SESSION tx_isolation='read-committed'; 作用域范围 作用域 全局变量 针对于所有会话（连接）有效，但不能跨重启 会画变量 针对于当前会话（连接）有效 在MYSQL启动的时候由服务器自动将它们初始化为默认值，这些默认值可以通过更改my.ini这个文件来更改。 会话变量 在每次建立一个新的连接的时候，由MYSQL来初始化。MYSQL会将当前所有全局变量的值复制一份。来做为会话变量。 自定义变量 作用域 定义位置 语法 用户变量 当前会话 会话的任何地方 加@符号，不用指定类型 局部变量 定义它的BEGIN END中 BEGIN END的第一句话 一般不用加@,需要指定类型 123456789101112#用户变量SET @m=1;SET @n=1;SET @sum=@m+@n;SELECT @sum;#局部变量DECLARE m INT DEFAULT 1;DECLARE n INT DEFAULT 1;DECLARE SUM INT;SET SUM=m+n;SELECT SUM; 用户变量【以@符号】 声明并初始化： SET @变量名=值; SET @变量名:=值; SELECT @变量名:=值; 赋值： 一般用于赋简单的值 123SET @变量名=值;SET @变量名:=值;SELECT @变量名:=值; 一般用于赋表 中的字段值 1SELECT 字段 INTO @变量名 FROM 表; 使用： 1select @变量名; 局部变量【一般不用加@】 声明 1declare 变量名 类型 【default 值】; 赋值 方式一：一般用于赋简单的值 123SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值; 一般用于赋表 中的字段值 1SELECT 字段名或表达式 INTO 变量 FROM 表; 使用： 1select 变量名 存储过程 含义：一组预先编译好的SQL语句的集合，理解成批处理语句 创建语法 12345CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)BEGIN sql语句1; sql语句2;END $ 参数模式： in：该参数可以作为输入，也就是该参数需要调用方传入值 out：该参数可以作为输出，也就是该参数可以作为返回值 inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值 如果存储过程体仅仅只有一句话，begin end可以省略 存储过程体中的每条sql语句的结尾要求必须加分号 存储过程的结尾可以使用 delimiter 重新设置 语法 1delimiter 结束标记 1delimiter $ 调用语法 1CALL 存储过程名(实参列表); 删除存储过程 1drop procedure 存储过程名; 查看存储过程的信息 12DESC myp2; 错误SHOW CREATE PROCEDURE myp2; 12345678910111213141516#案例2 ：创建存储过程实现，用户是否登录成功CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))BEGIN DECLARE result INT DEFAULT 0;#声明并初始化 SELECT COUNT(*) INTO result#赋值 FROM admin WHERE admin.username = username AND admin.password = PASSWORD; SELECT IF(result&gt;0,'成功','失败');#使用END $#调用CALL myp3('张飞','8888')$ 123456789101112#3.创建out 模式参数的存储过程#根据输入的女神名，返回对应的男神名CREATE PROCEDURE myp6(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))BEGIN SELECT bo.boyname INTO boyname FROM boys bo RIGHT JOIN beauty b ON b.boyfriend_id = bo.id WHERE b.name=beautyName ; END $ 1234567891011121314#4.创建带inout模式参数的存储过程#传入a和b两个值，最终a和b都翻倍并返回CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)BEGIN SET a=a*2; SET b=b*2;END $#调用SET @m=10$SET @n=20$CALL myp8(@m,@n)$SELECT @m,@n$ 函数 语法： 1234CREATE FUNCTION 函数名(参数名 参数类型) RETURNS 返回类型BEGIN 函数体END 函数体：肯定会有return语句，如果没有会报错 如果return语句没有放在函数体的最后也不报错，但不建议 函数体中仅有一句话，则可以省略begin end 使用 delimiter语句设置结束标记 调用语法 1SELECT 函数名(参数列表) 查看函数 1SHOW CREATE FUNCTION myf3; 删除函数 1DROP FUNCTION myf3; 123456789101112131415161718192021222324252627# 案例：返回公司的员工个数CREATE FUNCTION myf1() RETURNS INTBEGIN DECLARE c INT DEFAULT 0;#定义局部变量 SELECT COUNT(*) INTO c#赋值 FROM employees; RETURN c; END $SELECT myf1()$#根据员工名，返回它的工资CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLEBEGIN SET @sal=0;#定义用户变量 SELECT salary INTO @sal #赋值 FROM employees WHERE last_name = empName; RETURN @sal;END $SELECT myf2('k_ing') $ 函数和存储过程的区别 关键字 调用语法 返回值 应用场景 函数 FUNCTION SELECT 函数() 只能是一个 一般用于查询结果 存储过程 PROCEDURE CALL 存储过程() 可以有0个或多个 一般用于更新 流程控制结构 if函数语法 1if(条件，值1，值2) 可以用在任何位置 case语句语法： 类似于switch 123456case 表达式when 值1 then 结果1或语句1(如果是语句，需要加分号) when 值2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要） 情况二：类似于多重if 123456case when 条件1 then 结果1或语句1(如果是语句，需要加分号) when 条件2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要） 可以用在任何位置 if elseif语句语法： 12345if 情况1 then 语句1;elseif 情况2 then 语句2;...else 语句n;end if; 只能用在begin end中！！！！！！！！！！！！！！！ 应用场合 if函数 简单双分支 case结构 等值判断的多分支 if结构 区间判断的多分支 ​ 循环语法： WHILE 123【标签：】WHILE 循环条件 DO 循环体END WHILE 【标签】; loop:可以用来模拟简单的死循环 123【标签:】loop 循环体;end loop 【标签】; repeat 1234【标签：】repeat 循环体;until 结束循环的条件end repeat 【标签】; 只能放在BEGIN END里面 如果要搭配leave跳转语句，需要使用标签，否则可以不用标签 leave类似于java中的break语句，跳出所在循环！！！ 循环控制 iterate类似于 continue，继续，结束本次循环，继续下一次 leave 类似于 break，跳出，结束当前所在的循环 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#1.没有添加循环控制语句#案例：批量插入，根据次数插入到admin表中多条记录DROP PROCEDURE pro_while1$CREATE PROCEDURE pro_while1(IN insertCount INT)BEGIN DECLARE i INT DEFAULT 1; WHILE i&lt;=insertCount DO INSERT INTO admin(username,`password`) VALUES(CONCAT('Rose',i),'666'); SET i=i+1; END WHILE; END $CALL pro_while1(100)$#2.添加leave语句#案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止TRUNCATE TABLE admin$DROP PROCEDURE test_while1$CREATE PROCEDURE test_while1(IN insertCount INT)BEGIN DECLARE i INT DEFAULT 1; a:WHILE i&lt;=insertCount DO INSERT INTO admin(username,`password`) VALUES(CONCAT('xiaohua',i),'0000'); IF i&gt;=20 THEN LEAVE a; END IF; SET i=i+1; END WHILE a;END $CALL test_while1(100)$#3.添加iterate语句#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次TRUNCATE TABLE admin$DROP PROCEDURE test_while1$CREATE PROCEDURE test_while1(IN insertCount INT)BEGIN DECLARE i INT DEFAULT 0; a:WHILE i&lt;=insertCount DO SET i=i+1; IF MOD(i,2)!=0 THEN ITERATE a; END IF; INSERT INTO admin(username,`password`) VALUES(CONCAT('xiaohua',i),'0000'); END WHILE a;END $CALL test_while1(100)$","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://goldcarpenter.github.io/tags/MySQL/"}]},{"title":"多线程编程","date":"2019-04-21T12:11:21.000Z","path":"2019/04/21/多线程_Part4/","text":"5 Monitor 概念 Java 对象头 = Java对象 - Java对象体 Java HotSpot虚拟机中，每个对象都有对象头，保存哈希码、分代年龄等，当加锁时，这些信息就根据情况被替换为标记位、线程锁记录指针、重量级锁指针、线程ID等内容 Klass Word指向这个对象的Class类 以 32 位虚拟机为例 普通对象 数组对象 其中 Mark Word 结构为 锁关系引入 老王 - JVM 小南 - 线程 小女 - 线程 房间 - 对象 房间门上 - 防盗锁 - Monitor 房间门上 - 小南书包 - 轻量级锁 房间门上 - 刻上小南大名 - 偏向锁 批量重刻名 - 一个类的偏向锁撤销到达 20 阈值 不能刻名字 - 批量撤销该类对象的偏向锁，设置该类不可偏向 小南要使用房间保证计算不被其它人干扰（原子性），最初，他用的是防盗锁，当上下文切换时，锁住门。这样， 即使他离开了，别人也进不了门，他的工作就是安全的。但是，很多情况下没人跟他来竞争房间的使用权。小女是要用房间，但使用的时间上是错开的，小南白天用，小女晚上用。每次上锁太麻烦了，有没有更简单的办法呢？小南和小女商量了一下，约定不锁门了，而是谁用房间，谁把自己的书包挂在门口，但他们的书包样式都一样，因此每次进门前得翻翻书包，看课本是谁的，如果是自己的，那么就可以进门，这样省的上锁解锁了。万一书包不是自己的，那么就在门外等，并通知对方下次用锁门的方式。后来，小女回老家了，很长一段时间都不会用这个房间。小南每次还是挂书包，翻书包，虽然比锁门省事了，但仍然觉得麻烦。于是，小南干脆在门上刻上了自己的名字：【小南专属房间，其它人勿用】，下次来用房间时，只要名字还在，那么说明没人打扰，还是可以安全地使用房间。如果这期间有其它人要用这个房间，那么由使用者将小南刻的名字擦掉，升级为挂书包的方式。同学们都放假回老家了，小南就膨胀了，在 20个房间刻上了自己的名字，想进哪个进哪个。后来他自己放假回老家了，这时小女回来了（她也要用这些房间），结果就是得一个个地擦掉小南刻的名字，升级为挂书包的方式。老王觉得这成本有点高，提出了一种批量重刻名的方法，他让小女不用挂书包了，可以直接在门上刻上自己的名字后来，刻名的现象越来越频繁，老王受不了了：算了，这些房间都不能刻名了，只能挂书包 Monitor(锁) Monitor被翻译为监视器或管程，由操作系统提供，成本比较高 每个Java对象都可以关联一个 Monitor对象，如果使用synchronized给对象上锁(重量级)之后，该对象头的Mark Word中就被设置指向Monitor对象的指针 Monitor结构如下 刚开始Monitor中Owner为null 当Thread-2执行synchronized(obj)就会将Monitor的所有者Owner置为Thread-2，Monitor中只能有一个 Owner=Thread-2上锁的过程中，如果Thread-3, Thread-4, Thread-5也来执行synchronized(obj), 就会进入EntryList中BLOCKED Thread-2执行完同步代码块的内容，然后唤醒EntryList中等待的线程来竞争锁，竞争的时候是非公平的 图中WaitSet中的Thread-? Thread-?是之前获得过锁，但条件不满足进入WAITING状态的线程，后面讲wait-notify时会分析 注意: synchronized 必须是进入同一个对象的monitor才有上述的效果 不加synchronized的对象不会关联监视器，不遵从以上规则 原理之synchronized12345678static final Object lock = new Object();static int counter = 0;public static void main(String[] args) &#123; synchronized (lock) &#123; counter++ ; &#125;&#125; 对应的字节码为javap -c XXX.Class 123456789101112131415161718192021222324public static void main(java.lang.String[]); Code: 0: getstatic #2 // Field lock:Ljava/lang/Object; //拿到lock 作为锁对象 3: dup // 赋值一份 4: astore_1 // 将锁的引用存入slot 1 5: monitorenter // ⭐ 将lock对象MarkWord 置为 Monitor 指针 // 6-10:++操作 6: getstatic #3 // Field counter:I 9: iconst_1 10: iadd 11: putstatic #3 // Field counter:I 14: aload_1 // 拿到slot 1中的临时变量 即lock引用 15: monitorexit // 根据lock找到monitor 将lock对象MarkWord重置[把hashCode 分带年龄等放回来] 唤醒EntryList 16: goto 24 // 退出 19: astore_2 // e -&gt; slot 2 20: aload_1 // 拿到slot 1中的临时变量 即lock引用 21: monitorexit // 同上 22: aload_2 // e &lt;- slot 23: athrow // 抛出异常 24: return Exception table: from to target type 6 16 19 any 19 22 19 any 方法级别的 synchronized 不会在字节码指令中有所体现 synchronized优化：轻量级锁——前提：线程访问对象时间错开 不再使用Monitor锁，而是使用线程栈帧中的锁记录充当轻量级锁 轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。 如果有竞争力，轻量级锁会升级为重量级锁 轻量级锁对使用者是透明的，即语法仍然是 synchronized，如果失败，升级为重量级锁 假设有两个方法同步块，利用同一个对象加锁 123456789101112static final Object obj = new Object();public static void method1() &#123; synchronized( obj ) &#123; // 同步块 A method2(); &#125;&#125;public static void method2() &#123; synchronized( obj ) &#123; // 同步块 B &#125;&#125; 线程的栈帧中创建锁记录（Lock Record）对象【JVM层面】，每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word 让锁记录中Object reference指向锁对象，并尝试用 cas 替换 Object 的Mark Word，将Mark Word的值存入锁记录【MarkWord上01表示无锁状态 锁记录中地址为00轻量级锁】 如果cas替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下 如果 cas 失败，有两种情况 如果是其它线程已经持有了该 Object 的轻量级锁，对象头的状态码不是01，这时表明有竞争，其他线程已经持有了这个锁对象，进入锁膨胀过程 如果是自己执行了 synchronized 锁重入，那么新的栈帧中再添加一条 Lock Record【Lock Record是栈结构本身也可重入 解锁时将元素弹出】作为重入的计数 当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一 当退出synchronized代码块（解锁时）锁记录的值不为 null，这时使用 cas 将Mark Word的值恢复给对象头 成功，则解锁成功 失败，说明轻量级锁进行了锁膨胀已经升级为重量级锁，进入重量级锁解锁流程 线程1 对象Mark Word 线程2 访问同步块A把Mark Word复制到线程1的锁记录 01 (无锁) - CAS修改Mark Word为线程1锁记录地址 01 (无锁) - 成功(加锁) 00 (轻量锁) 线程1锁记录地址 - 执行同步块A 00 (轻量锁) 线程1锁记录地址 - 访问同步块B把Mark Word复制到线程1的锁记录 00(轻量锁) 线程1锁记录地址 - CAS修改Mark Word为线程1锁记录地址 00(轻量锁) 线程1锁记录地址 - 失败(发现是自己的锁) 00(轻量锁) 线程1锁记录地址 - 锁重入 00(轻量锁) 线程1锁记录地址 - 执行同步块B 00(轻量锁) 线程1锁记录地址 - 同步块B执行完毕 00(轻量锁) 线程1锁记录地址 - 同步块A执行完毕 00(轻量锁) 线程1锁记录地址 - 成功(解锁) 01 (无锁) - - 01 (无锁) 访问同步块A把Mark Word复制到线程2的锁记录 - 01 (无锁) CAS修改Mark Word为线程2锁记录地址 - 00(轻量锁) 线程2锁记录地址 成功（加锁） … … … 锁膨胀 如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。 Thread-0 已经对该对象加了轻量级锁，当 Thread-1 进行轻量级加锁时 这时Thread-1加轻量级锁失败，状态码已经不是01无锁状态，进入锁膨胀流程 即为 Object 对象申请 Monitor 锁，Thread-1需要进入Monitor锁进行阻塞等待，让 Object 指向重量级锁地址，状态码为10 然后自己进入 Monitor 的 EntryList中BLOCKED 当 Thread-0 退出同步块解锁时，因为对象头中MarkWord已经改变为重量级锁地址和10，使用 cas 将 Mark Word 的值恢复给对象头，失败。 这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程 线程1 对象Mark 线程2 访问同步块A把Mark Word复制到线程1的锁记录 01 (无锁) - CAS修改Mark Word为线程1锁记录地址 01 (无锁) - 成功（加锁） 00(轻量锁) 线程1锁记录地址 - 执行同步块 00(轻量锁) 线程1锁记录地址 - 执行同步块 00(轻量锁) 线程1锁记录地址 访问同步块把Mark Word复制到线程2 执行同步块 00(轻量锁) 线程1锁记录地址 CAS修改Mark为线程2锁记录地址 执行同步块 00(轻量锁) 线程1锁记录地址 失败(发现别人已经占了锁) 执行同步块 00(轻量锁) 线程1锁记录地址 CAS修改Mark为重量锁 执行同步块 10 (重量锁)重量锁指针 阻塞中 执行完毕 10 (重量锁)重量锁指针 阻塞中 失败(解锁) 10 (重量锁)重量锁指针 阻塞中 释放重量锁，唤起阻塞线程竞争 10 (重量锁) 阻塞中 - 10 (重量锁) 竞争重量锁 - 10 (重量锁) 成功（加锁） - … … synchronized优化：自旋优化——前提：重量级锁竞争的时候 重量级锁竞争的时候，还可以使用自旋来进行优化，查询Owner不为null，避免直接进入EntryList中进行阻塞（发生上下文切换），如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 自旋重试成功的情况 线程 1 （core 1 上） 对象 Mark 线程 2 （core 2 上） - 10（重量锁） - 访问同步块，获取 monitor 10（重量锁）重量锁指针 - 成功（加锁） 10（重量锁）重量锁指针 - 执行同步块 10（重量锁）重量锁指针 - 执行同步块 10（重量锁）重量锁指针 访问同步块，获取 monitor 执行同步块 10（重量锁）重量锁指针 自旋重试 执行完毕 10（重量锁）重量锁指针 自旋重试 成功（解锁） 01(无锁) 自旋重试 - 10（重量锁）重量锁指针 成功（加锁） - 10（重量锁）重量锁指针 执行同步块 - … … 自旋重试失败的情况 线程 1 （core 1 上） 对象 Mark 线程 2 （core 2 上） - 10（重量锁） - 访问同步块，获取 monitor 10（重量锁）重量锁指针 - 成功（加锁） 10（重量锁）重量锁指针 - 执行同步块 10（重量锁）重量锁指针 - 执行同步块 10（重量锁）重量锁指针 访问同步块，获取 monitor 执行同步块 10（重量锁）重量锁指针 自旋重试 执行同步块 10（重量锁）重量锁指针 自旋重试 执行同步块 10（重量锁）重量锁指针 自旋重试 执行同步块 10（重量锁）重量锁指针 进入EntryList阻塞 … … … 自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋 总之，比较智能。 Java 7 之后不能控制是否开启自旋功能 synchronized优化：偏向锁——前提：线程访问对象错开 缺点：轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作【尝试用 cas 替换 Object 的Mark Word】。 Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程ID设置到对象的Mark Word头，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS[每次都生成锁记录，将对象头尝试改为锁记录地址，检测是否会失败]。以后只要不发生竞争，这个对象就归该线程所有 撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停(STW) 访问对象的hashCode也会撤销偏向锁 如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程T1的对象仍有机会重新偏向T2,重偏向会重置对象的Thread ID 撤销偏向和重偏向都是批量进行的，以类为单位 如果撤销偏向到达某个阈值,整个类的所有对象都会变为不可偏向的 可以主动使用-XX:-UseBiasedLocking禁用偏向锁 例如 12345678910111213141516171819static final Object obj = new Object(); public static void m1() &#123; synchronized( obj ) &#123; // 同步块 A m2(); &#125;&#125;public static void m2() &#123; synchronized( obj ) &#123; // 同步块 B m3(); &#125;&#125;public static void m3() &#123; synchronized( obj ) &#123; // 同步块 C &#125;&#125; 将进行三次锁重入——轻量级锁 优化为偏向锁 偏向状态 一个对象创建时： 如果开启了偏向锁（默认开启），那么对象创建后，对象头中markword值为 0x05即最后 3 位为 101，这时它的thread、epoch、age都为0 偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加VM参数XX:BiasedLockingStartupDelay=0来禁用延迟 如果没有开启偏向锁，那么对象创建后，markword值为0x01即最后 3 位为 001，这时它的hashcode age都为 0，第一次用到hashcode 时才会赋值 加锁过程中打印锁对象头信息 12345678910111213141516171819202122 public static void main(String[] args) throws InterruptedException &#123; Dog d = new Dog(); // d.hashCode(); 撤销对象可偏向状态，取消偏向锁 有禁用偏向锁的效果 log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) &#123; log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); &#125; log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); &#125;//加VM参数`XX:BiasedLockingStartupDelay=0`来禁用偏向锁延迟//没有注释行============================/* 第一行结果【synchronized 前】：对象生成时结尾直接为101[偏向锁]，而不是001[正常无锁]，前面都是0相同第二行结果【synchronized 中】：线程ID与Java中getId返回的结果不一致，ID是OS的唯一标识与Java中不是一一对应第三行结果【synchronized 后】：偏向锁的特性，d对象就给主线程使用，d从属于主线程，MarkWork头中一直存储着主线程ID，除非其他线程使用该对象或其他可能是才会改变 解锁后仍然存储于对象头中*///注释行============================/* 第一行结果【synchronized 前】：是001[正常无锁] d.hashCode(); 撤销偏向锁 因为偏向锁MarkWord没地方存hashCode 正常无锁前面数字为hashCode 轻量级锁存在于锁记录中 重量级锁存在于monitor中第二行结果【synchronized 中】：轻量级锁00第三行结果【synchronized 后】：是001[正常无锁]*/ 没有注释行============================ 注释行============================ 添加VM参数-XX:-UseBiasedLocking禁用偏向锁后，直接应用轻量级锁 偏向锁适用冲突很少的情况，只有自己使用对象加锁 如果场景为多线程 经常竞争锁对象 应该添加此参数 12345/* 第一行结果【synchronized 前】：正常锁的状态001，不是之前101偏向锁第二行结果【synchronized 中】：成为轻量级锁00 前面的62位轻量级锁锁记录的地址指针，见偏向状态表格第三行结果【synchronized 后】：正常未加锁的状态001*/ 撤销对象偏向状态 - 调用对象 hashCode 调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销【hashCode要找到地方存啊 Normal状态有地方存】 轻量级锁会在锁记录中记录 hashCode【不怕没地方存】 重量级锁会在 Monitor 中记录 hashCode【不怕没地方存】 撤销对象偏向状态 - 其它线程使用对象 当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁，解锁后为正常Normal态【注意两个线程要交错开，一个线程解开锁对象，另一个线程再加锁（所以测试代码加了wait notify，下面代码其实就是写个两个线程，线程内执行的程序同上例），否则就是重量级锁】 123456789101112131415161718192021222324252627282930313233343536373839Dog d = new Dog(); Thread t1 = new Thread(() -&gt; &#123; log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) &#123; log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); &#125; log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (TestBiased.class) &#123; TestBiased.class.notify(); &#125; // 如果不用 wait/notify // 使用 join 必须打开下面的注释 // 因为：t1 线程不能结束，否则底层线程可能被 jvm 重用作为 t2 线程，底层线程 id 是一样的 /*try &#123; System.in.read(); &#125; catch (IOException e) &#123; e.printStackTrace();&#125;*/&#125;, \"t1\");t1.start();Thread t2 = new Thread(() -&gt; &#123; synchronized (TestBiased.class) &#123; TestBiased.class.wait();//try块略 &#125; log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) &#123; log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); &#125; log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true));&#125;, \"t2\"); t2.start();/* 第一行结果【synchronized 前】：101偏向锁第二行结果【synchronized 中】：对象头 前面数字为线程ID + 101偏向锁第三行结果【synchronized 后】：线程ID 依然保留在MarkWord中第四行结果【synchronized 前】：没加锁前 没变第五行结果【synchronized 中】：进入00 轻量级锁状态 前面数字为线程栈帧中锁记录的指针第六行结果【synchronized 后】：解锁后 成为001 偏向状态被撤销*/ 撤销对象偏向状态 - 调用 wait/notify wait/notify只有重量级锁才有，将偏向锁/轻量级锁，升级为重量级锁，解锁后为正常Normal态 12345678//synchronized前 偏向锁[t1] - 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101//synchronized中 线程ID+偏向锁[t1] - 00000000 00000000 00000000 00000000 00011111 10110011 11111000 00000101 //t1 进入wati状态[t2] - notify//synchronized中 010 重量级锁[t1] - 00000000 00000000 00000000 00000000 00011100 11010100 00001101 11001010 批量重偏向 如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象 的 Thread ID 当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程，不再撤销 1234567891011121314151617181920212223242526272829303132333435 Vector&lt;Dog&gt; list = new Vector&lt;&gt;(); Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 30; i++) &#123; Dog d = new Dog(); list.add(d); // 30个锁对象进行测试 synchronized (d) &#123; // 所有状态都是 t1线程ID + 偏向锁101 log.debug(i + ClassLayout.parseInstance(d).toPrintableSimple(true)); &#125; &#125; synchronized (list) &#123; list.notify(); &#125; &#125;, \"t1\"); t1.start(); Thread t2 = new Thread(() -&gt;&#123; synchronized (list) &#123; list.wait();// try 块略 &#125; log.debug(\"===============&gt; \"); for (int i = 0; i &lt; 30; i++) &#123; Dog d = list.get(i); /*线程t1 线程t1 ID + 偏向锁101*/ log.debug(i + ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) &#123;// 前19个 【t2线程要使用锁对象】偏向锁升级成轻量级锁 62位轻量级锁锁记录的地址指针+轻量级锁00// 第20个开始 【t2线程要使用锁对象 咋老是t2 不升级了 统统一次偏向t2吧】线程t2 ID + 偏向锁101 log.debug(i + ClassLayout.parseInstance(d).toPrintableSimple(true)); &#125; //前19个： 【解锁后】00...00+01 偏向状态被撤销 //第20个开始 线程t2 ID + 偏向锁101 log.debug(i + ClassLayout.parseInstance(d).toPrintableSimple(true)); &#125; &#125;, \"t2\"); t2.start(); 批量撤销 当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，这个类新建的对象也是不可偏向的1234567891011121314151617181920212223242526272829303132333435363738394041static Thread t1,t2,t3;private static void test4() throws InterruptedException &#123; Vector&lt;Dog&gt; list = new Vector&lt;&gt;(); int loopNumber = 39; t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; loopNumber; i++) &#123; Dog d = new Dog(); list.add(d); synchronized (d) &#123; // 添加偏向锁 所有状态都是 t1线程ID + 偏向锁101 &#125; &#125; LockSupport.unpark(t2); &#125;, \"t1\"); t1.start(); t2 = new Thread(() -&gt; &#123; LockSupport.park(); for (int i = 0; i &lt; loopNumber; i++) &#123; Dog d = list.get(i); /*线程t1 线程t1 ID + 偏向锁101*/ synchronized (d) &#123; // 0-18个升级为轻量级锁 19-38批量重偏向 &#125; //前19个： 【解锁后】00...00+01 偏向状态被撤销【+20个】 //第20个开始 线程t2 ID + 偏向锁101 &#125; LockSupport.unpark(t3); &#125;, \"t2\"); t2.start(); t3 = new Thread(() -&gt; &#123; LockSupport.park(); for (int i = 0; i &lt; loopNumber; i++) &#123; Dog d = list.get(i); synchronized (d) &#123; // 0-18个【加】轻量级锁 19-38【升级】为轻量级锁 解锁后撤销偏向锁为Normal【+19个】 &#125; &#125; &#125;, \"t3\"); t3.start(); t3.join(); log.debug(ClassLayout.parseInstance(new Dog()).toPrintableSimple(true));// 生成对象对Normal状态&#125; 其他优化1.减少上锁时间 同步代码块中尽量短 2.减少锁的粒度 将一个锁拆分为多个锁提高并发度，例如: ConcurrentHashMap LongAdder分为base和cells两部分。没有并发争用的时候或者是cells 数组正在初始化的时候，会使用CAS来累加值到base,有并发争用，会初始化cells数组，数组有多少个cell,就允许有多少线程并行修改,最后将数组中每个cell累加，再加上base就是最终的值 LinkedBlockingQueue 入队和出队使用不同的锁，相对于LinkedBlockingArray只有一 个锁效率要高 3.锁粗化 多次循环进入同步块不如同步块内多次循环 另外JVM可能会做如下优化，把多次append的加锁操作粗化为一次(因为都是对同一个对象加锁，没必要重入多次) 1new StringBuffer().append(\"a\").append(\"b\").append(\"c\"); 4.锁消除 JIT即时编译器会对Java字节码进行进一步优化 分析局部变量不会逃离此方法 对象不会共享 即不需要加锁 123456789101112public class MyBenchmark &#123; static int x = 0; public void a() throws Exception &#123; x++; &#125; public void b() throws Exception &#123; Object o = new Object(); synchronized (o) &#123; x++; &#125; &#125;&#125; 5.读写分离CopyOnWriteArrayListConyOnWriteSet 6 wait/notify原理 Owner线程发现条件不满足，调用wait方法，即可进入WaitSet变为 WAITING状态 BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 BLOCKED 线程会在 Owner 线程释放锁时唤醒 WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争 6.1常用方法 均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则抛出异常【synchronized关键字捆绑使用】 12// 方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到 notify 为止wait() 12// 有时限的等待, 到 n 毫秒后结束等待，或是被 notifywait(long timeout) 12//唤醒一个处于等待状态的线程notify() 12// 唤醒同一个对象上所有调用wait()方法的线程，优先级搞得优先调度notifyAll() sleep(long n) 和 wait(long n) 的区别 sleep是Thread静态方法，而wait是Object的成员方法 sleep不需要强制和synchronized配合使用，但wait需要和synchronized一起用 sleep在睡眠的同时，不会释放对象锁的，但wait在等待的时候会释放对象锁 它们运行状态状态TIMED_WAITING 123456789101112131415161718192021222324 //建议使用final 不然synchronized可能引用的不同对象 static final Object Lock = new Object(); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; synchronized (Lock) &#123; log.debug(\"获得锁\"); try &#123; Thread.sleep(2000); //Lock.wait(2000); 替换效果更好 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, \"t1\").start(); Sleeper.sleep(1); synchronized (Lock) &#123; log.debug(\"获得锁\"); &#125; &#125;/*16:53:18.627 [t1] MultiThread - 获得锁16:53:20.631 [main] MultiThread - 获得锁【等了2秒】*/ 6.2基本语法12345678910111213synchronized(lock)&#123; while(条件不成立) //避免虚假唤醒 notifyAll唤醒了多个条件 不是所需要的 &#123; lock.wait(); &#125; // 干活&#125;// 另一个线程synchronized(lock)&#123; lock.notifyAll();&#125; 6.3同步模式之保护性暂停模式即 Guarded Suspension，线程间消息传递 有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject 如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者） JDK 中，join 的实现、Future 的实现，采用的就是此模式 因为要等待另一方的结果，因此归类到同步模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Slf4j(topic = \"MultiThread\")public abstract class MultiThread &#123; public static void main(String[] args) &#123; GuardObject guardObject = new GuardObject(); //一个线程传入 一个线程获取 new Thread(()-&gt;&#123; log.debug(\"下载超大文档\"); Sleeper.sleep(1); Object bigFile = new Object(); log.debug(\"线程传递文档\"); guardObject.complete(bigFile); &#125;,\"t1\").start(); new Thread(()-&gt;&#123; log.debug(\"等待超大文档\"); Object result = guardObject.getResponse(); log.debug(\"线程接受文档\"); System.out.println(result); &#125;,\"t2\").start(); &#125;&#125;class GuardObject&#123; private Object response; public Object getResponse() &#123; synchronized (this) &#123; while(response == null) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; return response; &#125; &#125; public void complete(Object response) &#123; synchronized (this) &#123; this.response = response; this.notifyAll(); &#125; &#125;&#125;//17:37:23.565 [t1] MultiThread - 下载超大文档//17:37:23.565 [t2] MultiThread - 等待超大文档//17:37:24.571 [t1] MultiThread - 线程传递文档//17:37:24.571 [t2] MultiThread - 线程接受文档 增加超时停止功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; public static void main(String[] args) &#123; GuardObject guardObject = new GuardObject(); // 结果使用线程 new Thread(()-&gt; &#123; log.debug(\"t1 start\"); //线程间消息传递:取出****** Object response = guardObject.getResponse(1000); log.debug(\"t1 get response\"); &#125;,\"t1\").start(); new Thread(()-&gt;&#123; // 模拟下载 log.debug(\"t2 start download\"); Sleeper.sleep(3); //线程间消息传递:传入****** guardObject.complete(new Object(\"我是下载内容\")); log.debug(\"t2 finish download\"); //优点 此时可以干其他事情 join方法不行 &#125;,\"t2\").start(); &#125;&#125;class GuardObject&#123; private Object response; public Object getResponse(long timeout) &#123; synchronized(this) &#123; long begin = System.currentTimeMillis(); long passTime = 0; *** while (response == null) &#123; long waitTime = timeout - passTime; //***避免虚假唤醒情况 莫名的被唤醒了 if(waitTime &lt;= 0) break; try &#123; this.wait(waitTime); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; passTime = System.currentTimeMillis() - begin; &#125; return response; &#125; &#125; public void complete(Object response) &#123; synchronized (this) &#123; this.response = response; this.notify(); &#125; &#125;&#125; 之前使用join交互线程间的结果，具有一定缺点 join方法必须等待线程完成，再通知另一个线程。保护性暂停模式可以在下载线程中完成后立即通知另一个线程 等待的结果变量必须是全局的。保护性暂停模式变量都是局部的 6.4Join方法原理【保护性暂停应用】 线程间传递的是：检测线程是否结束的boolean join与保护性暂停中的get方法很像，另一个线程没有传递过来对象【线程是否结束信号】就等着 1234567891011121314151617181920212223242526272829public final void join() throws InterruptedException &#123; join(0);&#125;public final synchronized void join(long millis) throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException(\"timeout value is negative\"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; // join与保护性暂停中的get方法很像，线程间传递的是：检测线程是否结束的boolean while (isAlive()) &#123; // 线程结束了么 long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125; &#125; 保护性暂停模式-邮递员传递信息给居民【类RPC框架】 图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右侧的t1 t3 t5就好比邮递员 如果需要在多个类之间使用GuardedObject对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类， 这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; 30; i++) &#123; new People().start(); &#125; Sleeper.sleep(1); for (Integer id : Mailboxes.getIds()) &#123; new Postman(id, \"内容\" + id).start(); &#125; &#125;&#125;@Slf4j(topic = \"c.People\")class People extends Thread&#123; @Override public void run() &#123; // 收信 GuardedObject guardedObject = Mailboxes.createGuardedObject(); log.debug(\"开始收信 id:&#123;&#125;\", guardedObject.getId()); Object mail = guardedObject.get(5000); log.debug(\"收到信 id:&#123;&#125;, 内容:&#123;&#125;\", guardedObject.getId(), mail); &#125;&#125;@Slf4j(topic = \"c.Postman\")class Postman extends Thread &#123; private int id; private String mail; public Postman(int id, String mail) &#123; this.id = id; this.mail = mail; &#125; @Override public void run() &#123; GuardedObject guardedObject = Mailboxes.getGuardedObject(id); log.debug(\"送信 id:&#123;&#125;, 内容:&#123;&#125;\", id, mail); guardedObject.complete(mail); &#125;&#125;// 解耦类 类中内容具有通用性 此处类名为此业务相关class Mailboxes &#123; private static Map&lt;Integer, GuardedObject&gt; boxes = new Hashtable&lt;&gt;();//可以使用并发包 private static int id = 1; // 产生唯一 id private static synchronized int generateId() &#123; return id++; &#125; public static synchronized GuardedObject getGuardedObject(int id) &#123; return boxes.remove(id); &#125; public static GuardedObject createGuardedObject() &#123; //没有同步 GuardedObject go = new GuardedObject(generateId()); boxes.put(go.getId(), go); return go; &#125; public static synchronized Set&lt;Integer&gt; getIds() &#123; //没有同步 return boxes.keySet(); &#125;&#125;// 增加超时效果class GuardedObject &#123; // 标识 Guarded Object private int id; public GuardedObject(int id) &#123; this.id = id; &#125; // 结果 private Object response; // 获取结果 // timeout 表示要等待多久 2000 public Object get(long timeout) &#123; synchronized (this) &#123; // 开始时间 15:00:00 long begin = System.currentTimeMillis(); // 经历的时间 long passedTime = 0; while (response == null) &#123; // 这一轮循环应该等待的时间 long waitTime = timeout - passedTime; // 经历的时间超过了最大等待时间时，退出循环 if (timeout - passedTime &lt;= 0) &#123; break; &#125; try &#123; this.wait(waitTime); // 虚假唤醒 15:00:01 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 求得经历时间 passedTime = System.currentTimeMillis() - begin; // 15:00:02 1s &#125; return response; &#125; &#125; // 产生结果 public void complete(Object response) &#123; synchronized (this) &#123; // 给结果成员变量赋值 this.response = response; this.notifyAll(); &#125; &#125;&#125; 6.5异步模式之消费者生产者模式 线程间消息传递，与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应 消费队列可以用来平衡生产和消费的线程资源 生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据 消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据 JDK 中各种阻塞队列，采用的就是这种模式 程序: 生产者消费者 synchronized版本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; public static void main(String[] args) throws InterruptedException &#123; Container messageQueue = new Container&lt;&gt;(); new Thread(new Producer(messageQueue)).start(); new Thread(new Consumer(messageQueue)).start(); &#125;&#125;class Container&lt;T&gt; &#123; private LinkedList&lt;T&gt; list = new LinkedList&lt;&gt;(); private int count = 0; private final int MAX = 10; public synchronized void put(T e) &#123; while(this.count == MAX) // 注意是while！防止多个同时唤醒 &#123; System.out.println(\"list满了...\"); try &#123; this.wait(); &#125; catch (InterruptedException ex) &#123; ex.printStackTrace(); &#125; &#125; System.out.println(\"list加入元素\" + e); this.list.offer(e); this.count++; this.notify(); &#125; public synchronized void remove() &#123; while(this.list.size() == 0) &#123; System.out.println(\"list空了...\"); try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"list清除\" + this.list.getFirst()); this.list.poll(); // 从头取 从尾放 count--; this.notify(); &#125;&#125;class Consumer implements Runnable&#123; private Container&lt;Integer&gt; container = null; Consumer(Container container) &#123; this.container = container; &#125; @Override public void run() &#123; for(int i =0 ;i &lt; 99 ;i++) &#123; System.out.println(\"list希望清除\" + i); container.remove(); &#125; &#125;&#125;class Producer implements Runnable&#123; private Container&lt;Integer&gt; container = null; Producer(Container container) &#123; this.container = container; &#125; @Override public void run() &#123; for(int i = 0; i &lt; 99; i++) &#123; System.out.println(\"list希望添加\" + i); container.put(i); &#125; &#125;&#125;","tags":[{"name":"多线程","slug":"多线程","permalink":"http://goldcarpenter.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"查看接口或类的继承关系","date":"2019-04-13T16:00:00.000Z","path":"2019/04/14/IDEA查看接口或类的继承关系/","text":"打开想要查看的接口或者类文件，使用快捷键CTRL+H调出Hierarchy窗口 比如，想要查看Exception的类继承关系，首先定位到这个文件，然后调出Hierarchy窗口。 该窗口上面的一排工具栏如下：![Snipaste_2019-10-15_10-22-26.png]006edVQGgy1g7yo8fy7pyj30hr017q2t.jpg)分别是： 查看完整的类（接口）阶层结构 查看父类或者父接口 查看子类 是否按照字母排序 当前操作搜索的范围【重点】 刷新 是否同步打开相应的类或者接口【即鼠标选中某个接口或类，编辑器自动打开】 扩展块或者隐藏块 固定窗口 导出所有的结构到文本文件中 退出 如果用多了idea就会发现，很多的操作都会有scope和字母排序以及隐藏块、扩展块，比如project结构面板，diff面板，搜索面板，favorite面板，以及diagram面板等等 设定搜索范围 我们可以自己设定搜索范围，这样idea就会在指定范围内搜索相应的父类或者子类。这样可以提高搜索范围，快速找到我们需要的继承结构。因为在大部分情况下，项目结构都是相对复杂的，很容易匹配到几十个甚至上百个类。 首先，idea里面有这些默认的搜索范围可供我们选择，其中 production:我们编写的代码【常用】 Test:我们编写的所有的测试类 All:就是1+2 This Class:当前类 JRE:这个范围是我自定义的，限定搜索范围为JRE提供的包 我们可以通过configure选项，来自定义搜索范围。 这样，选中该搜索范围之后，只会展示相应的类了。","tags":[{"name":"IEDA","slug":"IEDA","permalink":"http://goldcarpenter.github.io/tags/IEDA/"}]},{"title":"多线程编程","date":"2019-04-13T12:11:21.000Z","path":"2019/04/13/多线程_Part3/","text":"4并发之共享模型-管程1共享数据带来的问题1.1问题复现123456789101112131415161718static int count = 0;public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 5000; i++) &#123; count++; &#125; &#125;, \"t1\"); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 5000; i++) &#123; count--; &#125; &#125;, \"t2\"); t1.start(); t2.start(); t1.join(); t2.join();&#125; 1.2问题分析 以上的结果可能是正数、负数、零。因为 Java 中对静态变量的自增，自减并不是原子操作，要彻底理解，必须从字节码来进行分析 例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令： 1234getstatic i &#x2F;&#x2F; 获取静态变量i的值 iconst_1 &#x2F;&#x2F; 准备常量1 iadd &#x2F;&#x2F; 自增putstatic i &#x2F;&#x2F; 将修改后的值存入静态变量i 而对应 i– 也是类似： 1234getstatic i &#x2F;&#x2F; 获取静态变量i的值 iconst_1 &#x2F;&#x2F; 准备常量1 isub &#x2F;&#x2F; 自增putstatic i &#x2F;&#x2F; 将修改后的值存入静态变量i Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换： 但多线程下这 8 行代码可能交错运行 1.3临界区 Critical Section 在多个线程对共享资源读写操作时发生指令交错，就会出现问题 一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区 12345678910static void increment() // 临界区 &#123; counter++; &#125;static void decrement()// 临界区 &#123; counter--; &#125; 1.4竞态条件 Race Condition 多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件 1.5解决方案 为了避免临界区的竞态条件发生，有多种手段可以达到目的。 阻塞式的解决方案：synchronized，Lock 非阻塞式的解决方案：原子变量 本次使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换 2线程互斥 互斥：避免临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码 同步：由于线程执行的先后顺序不同、需要一个线程等待其它线程运行到某个点 问题解决 12345678910111213141516171819202122232425static Object lock = new Object();static int count = 0;public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(() -&gt; &#123; synchronized(lock)&#123; for (int i = 0; i &lt; 5000; i++) &#123; count++; &#125; &#125; &#125;, \"t1\"); Thread t2 = new Thread(() -&gt; &#123; synchronized(lock)&#123; for (int i = 0; i &lt; 5000; i++) &#123; count--; &#125; &#125; &#125;, \"t2\"); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(count);&#125; 优化更加面向对象 12345678910111213141516171819202122232425262728293031323334353637383940public class MultiThread &#123; public static void main(String[] args) throws Exception &#123; Count count = new Count(); Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 5000; i++) &#123; count.increment(); &#125; &#125;, \"t1\"); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 5000; i++) &#123; count.decrement(); &#125; &#125;, \"t2\"); t1.start(); t2.start(); t1.join(); t2.join(); log.debug(\"&#123;&#125;\", count.getCounter()); &#125;&#125;class Count &#123; private int counter = 0; // 锁定当前对象，不是锁定代码 效果同下 public void increment() &#123; synchronized(this) &#123; counter++; &#125; &#125; // 相同写法 public synchronized void decrement() &#123; counter--; &#125; public synchronized int getCounter() &#123;// 保证获取到共享变量的值 return counter; &#125;&#125; 2.1不存在this对象，锁定.class123456789101112public static void function()&#123; synchronized (Main.class) // 不存在this对象，锁定.class &#123; count--; System.out.println(Thread.currentThread().getName()); &#125;&#125;public synchronized static void function()&#123; // 不存在this对象，锁定.class count--; System.out.println(Thread.currentThread().getName());&#125; 2.2非同步方法与同步方法同时运行123456789101112131415161718192021222324252627282930313233343536373839import java.sql.Time;import java.util.concurrent.TimeUnit;class Main &#123; // 同步方法 synchronized void function1() &#123; System.out.println(Thread.currentThread().getName()+\"start\"); try&#123; TimeUnit.SECONDS.sleep(1); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"end\"); &#125; // 非同步方法 void function2() &#123; System.out.println(Thread.currentThread().getName()+\"start\"); try&#123; TimeUnit.SECONDS.sleep(1); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"end\"); &#125; public static void main(String []argv) throws Exception &#123; Main main = new Main(); new Thread(main::function1).start(); new Thread(main::function2).start(); &#125;&#125;/*Thread-0start[同时]Thread-1start[同时]Thread-1endThread-0end*/ 2.3对业务写方法加锁，读方法不加锁 容易产生脏读问题 12345678910111213141516171819202122232425262728293031323334353637import java.util.concurrent.TimeUnit;class Main &#123; String name; double balance; // 写方法加了锁 public synchronized void set(String name,double balance) &#123; this.name = name; // 模拟业务代码start try &#123; Thread.sleep(2000); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; // 模拟业务代码end this.balance = balance; &#125; // 读方法不加锁 public double getBalance() &#123; return balance; &#125; public static void main(String []argv) throws InterruptedException &#123; Main main = new Main(); new Thread(()-&gt;main.set(\"yyx\",23)).start(); TimeUnit.SECONDS.sleep(1); //写方法中业务代码还没执行完就读 System.out.println(main.getBalance()); //0.0 TimeUnit.SECONDS.sleep(2); //写方法中业务代码执行完 System.out.println(main.getBalance()); //23.0 &#125;&#125; 2.4 synchronized是可重入锁 一个同步方法可以调用另外一个同步方法 1234567891011121314151617181920212223242526class Main &#123; synchronized void m() &#123; System.out.println(\"m start\"); n(); System.out.println(\"m end\"); &#125; synchronized void n() &#123; System.out.println(\"n start\"); System.out.println(\"n end\"); &#125; public static void main(String []argv) throws InterruptedException &#123; Main main = new Main(); new Thread(main::m).start(); &#125;&#125;/*m startn startn endm end*/ 2.5子类调用父夹的同步方法1234567891011121314151617181920212223242526272829class Main &#123; synchronized void m() &#123; System.out.println(\"Father start\"); System.out.println(\"Father end\"); &#125; public static void main(String []argv) throws InterruptedException &#123; Main main = new Child(); new Thread(main::m).start(); &#125;&#125;class Child extends Main&#123; @Override synchronized void m() &#123; System.out.println(\"Child start\"); // 子类调用父类的同步方法 super.m(); System.out.println(\"Child end\"); &#125;&#125;/*Child startFather startFather endChild end*/ 程序执行出现异常，默认情况锁会被释放 在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。 比如，在一个web app处理过程中，多个servlet线程共同访问同一个资源，这时如果异常处理不合适，在第一个线程中抛出异常，其他线程就会进入同步代码区，有可能会访问到异常产生时的数据。因此要非常小心的处理同步业务逻辑中的异常 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.sql.Time;import java.util.concurrent.TimeUnit;class Main &#123; int num = 0; synchronized public void function() &#123; while(true) &#123; num++; System.out.println(Thread.currentThread().getName() + \" \" + num); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if(num == 5) num = num/0; &#125; &#125; public static void main(String []argv) throws InterruptedException &#123; Main main = new Main(); new Thread(main::function).start(); new Thread(main::function).start(); &#125;&#125;/*Thread-0 1Thread-0 2Thread-0 3Thread-0 4Thread-0 5Thread-1 6Exception in thread \"Thread-0\" java.lang.ArithmeticException: / by zero at Main.function(test.java:19) at java.lang.Thread.run(Thread.java:748)Thread-1 7Thread-1 8Thread-1 9Thread-1 10*/ 3线程同步同步就是协同步调，按预定的先后次序进行运行。如：你说完，我再说。这里的同步千万不要理解成那个同时进行，应是指协同、协助、互相配合。线程同步是指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序（即所谓的同步）也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的！ 线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。 线程互斥可以看成是一种特殊的线程同步。 Q: 多个线程访问同一个资源时需要考虑哪些情况及问题 考虑线程安全性问题，一定要使用同步操作 同步代码块：synchronized(锁定对象){代码} 同步方法：public synchronized void 方法名称(){代码} 过多的同步操作可能带来死锁问题，导致程序进入停滞 4 变量的线程安全问题原因：使用多个线程访问同一个资源且对资源有写的操作 线程安全：如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，且其他变量的值也符合预期，则线程安全。 4.1局部变量的线程安全分析4.1.1局部变量是线程安全的 局部变量线程安全分析 1234public static void test1() &#123; int i = 10; i++;&#125; 每个线程调用 test1() 方法时局部变量 i，i会在每个线程的栈帧内存中被创建多份，因此不存在共享 4.1.2局部变量引用的对象则未必线程安全 如果该对象没有逃离方法的作用访问，它是线程安全的 如果该对象逃离方法的作用范围【例如：子类重写方法】，需要考虑线程安全 见4.2.2 4.2成员变量和静态变量的线程安全分析 如果它们没有被多个线程共享，则线程安全 如果它们被多个线程共享了，根据它们的属性【状态】是否能够改变： 如果只有读操作，则线程安全 如果有读写操作，则这段代码是临界区，需要考虑线程安全 4.2.1成员变量线程安全分析 成员变量线程安全分析 1234567891011121314151617181920212223242526272829@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; public static void main(String[] args) &#123; ThreadUnsafe test = new ThreadUnsafe(); for (int i = 0; i &lt; 2; i++) &#123; new Thread(() -&gt; test.method1(), \"Thread\" + i).start(); &#125; &#125;&#125;@Slf4j(topic = \"ThreadUnsafe\")class ThreadUnsafe &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();//成员变量 public final void method1() &#123; for (int i = 0; i &lt; 200; i++) &#123; method2(); method3(); &#125; &#125; private void method2() &#123; list.add(\"1\"); &#125; private void method3() &#123; list.remove(0); &#125;&#125;//Exception in thread \"Thread1\" java.lang.IndexOutOfBoundsException: Index: 0, Size: 0 将 list 修改为局部变量 1234567891011121314151617class ThreadSafe &#123; public final void method1() &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();//就是下移一行 for (int i = 0; i &lt; 200; i++) &#123; method2(list); method3(list); &#125; &#125; private void method2(ArrayList&lt;String&gt; list) &#123; list.add(\"1\"); &#125; private void method3(ArrayList&lt;String&gt; list) &#123; list.remove(0); &#125;&#125; list 是局部变量，每个线程调用时会创建其不同实例，没有共享 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象 4.2.2局部变量线程安全分析 如果把method2和method3的方法修改为public 情况1：有其它线程调用method2和method3——【不会有问题，传入的都是独立的参数】 情况2：为ThreadUnSafe类添加子类，子类覆盖method2或method3方法【有问题】 1234567891011121314151617181920212223242526272829303132333435363738@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; public static void main(String[] args) &#123; //创建子类 ThreadUnsafeSubClass test = new ThreadUnsafeSubClass(); for (int i = 0; i &lt; 200; i++) &#123; new Thread(() -&gt; test.method1(), \"Thread\" + i).start(); &#125; &#125;&#125;@Slf4j(topic = \"ThreadUnsafe\")class ThreadUnsafe &#123; public /*final*/ void method1() &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 200; i++) &#123; method2(list); method3(list); &#125; &#125; public void method2(ArrayList&lt;String&gt; list) &#123; list.add(\"1\"); &#125; public void method3(ArrayList&lt;String&gt; list) &#123; list.remove(0); &#125;&#125;//重写了父类method3方法，开启新的线程，在新线程中可以对list做很多不可控操作class ThreadUnsafeSubClass extends ThreadUnsafe&#123; @Override public void method3 (ArrayList&lt;String&gt; list) &#123; new Thread(() -&gt; &#123; list.remove(0); &#125;). start(); &#125;&#125; 方法中的private或final提供【安全】的意义所在，体会开闭原则中的【闭】 案例二：其中 foo 的行为是不确定的，可能导致不安全的发生，被称之为外星方法【同上例子】 123456789101112abstract class Test &#123; public void bar() &#123; //是否安全 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); foo(sdf); &#125; public abstract foo(SimpleDateFormat sdf); public static void main(String[] args) &#123; new Test().bar(); &#125;&#125; 1234567891011public void foo(SimpleDateFormat sdf) &#123; String dateStr = \"1999-10-11 00:00:00\"; for (int i = 0; i &lt; 20; i++) &#123; new Thread(() -&gt; &#123; try &#123; sdf.parse(dateStr); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125; 4.3常见线程安全类 这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。 它们的每个方法是原子的，但注意它们多个方法的组合不是原子的 String ——其内部的状态不可以改变，因此方法都是线程安全 【包装类】 ——其内部的状态不可以改变，因此方法都是线程安全 StringBuffer Random Vector【List实现】 Hashtable【Map实现】 java.util.concurrent包下的类 实例分析1 Servlet运行在Tomcat环境下，仅有一个实例对象，会被Tomcat多个线程共享使用，因此成员变量可能存在共享问题 123456789101112131415public class MyServlet extends HttpServlet &#123; // 不安全 不是线程安全Map Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); // 安全 String S1 = \"...\"; // 安全 final String S2 = \"...\"; // 不安全 D1多个线程可以同时修改 Date D1 = new Date(); // 不安全 D2引用值不会变 但其内部属性依然可以修改 final Date D2 = new Date(); public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; // 使用上述变量 &#125;&#125; 实例分析212345678910111213141516public class MyServlet extends HttpServlet &#123; // 不安全 MyServlet的成员变量 内部属性count存在多线程同时修改线程安全问题 private UserService userService = new UserServiceImpl(); public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; userService.update(...); &#125;&#125;public class UserServiceImpl implements UserService &#123; // 记录调用次数 可变成员变量 private int count = 0; public void update() &#123; // ... 本质临界区 count++; &#125; &#125; 实例分析3 Spring的AOP中默认是单例模式 1234567891011121314151617@Aspect@Component public class MyAspect &#123; // 不安全 成员变量被共享 private long start = 0L; @Before(\"execution(* *(..))\") public void before() &#123; start = System.nanoTime(); &#125; @After(\"execution(* *(..))\") public void after() &#123; long end = System.nanoTime(); System.out.println(\"cost time:\" + (end-start)); &#125; &#125; 实例分析4 Web三层模型 12345678910111213141516171819202122232425262728293031323334353637383940public class MyServlet extends HttpServlet &#123; // 方式一：安全 【与不可变类具有一曲同工之妙】 private UserService userService = new UserServiceImpl(); public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; userService.update(...); &#125; &#125;public class UserServiceImpl implements UserService &#123; // 方式一：安全 userDao没有成员变量 即使多个线程访问 没有可修改的属性【与不可变类具有一曲同工之妙】 // 方式二：Connection一个线程还在使用 另一个线程将其关闭了 private UserDao userDao = new UserDaoImpl(); public void update() &#123; userDao.update(); &#125; &#125;// 方式一public class UserDaoImpl implements UserDao &#123; public void update() &#123; String sql = \"update user set password = ? where username = ?\"; // 安全 这里是局部变量 try (Connection conn = DriverManager.getConnection(\"\",\"\",\"\"))&#123; // ... &#125; catch (Exception e) &#123; // ... &#125; &#125; &#125;//方式二public class UserDaoImpl implements UserDao &#123; // 不安全 成员变量 Connection一个线程还在使用 另一个线程将其关闭了 private Connection conn= null; public void update() throws SQLException &#123; String sql = \"update user set password = ? where username = ?\"; conn = DriverManager.getConnection(\"\",\"\",\"\"); // ... conn.close(); &#125; &#125; 实例分析5123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; public static void main(String[] args) throws InterruptedException &#123; Account a = new Account(1000); Account b = new Account(1000); Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 1000; i++) &#123; a.transfer(b, randomAmount()); &#125; &#125;, \"t1\"); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 1000; i++) &#123; b.transfer(a, randomAmount()); &#125; &#125;, \"t2\"); t1.start(); t2.start(); t1.join(); t2.join(); // 查看转账2000次后的总金额 log.debug(\"total:&#123;&#125;\", (a.getMoney() + b.getMoney())); &#125; // Random 为线程安全 static Random random = new Random(); // 随机 1~100 public static int randomAmount() &#123; return random.nextInt(100) + 1; &#125;&#125;// 账户class Account &#123; private int money; public Account(int money) &#123; this.money = money; &#125; // get set 方法略 // 转账 public void transfer(Account target, int amount) &#123; //synchronized(this) &#123; 无法实现效果 锁的不是一个对象 //synchronized(Account.Class) &#123; 实现效果 但效率存在问题 全球只能一个人在转账 if (this.money &gt;= amount) &#123; this.setMoney(this.getMoney() - amount); target.setMoney(target.getMoney() + amount); &#125; //&#125; &#125;&#125;","tags":[{"name":"多线程","slug":"多线程","permalink":"http://goldcarpenter.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"MySQL基础","date":"2019-04-10T15:35:21.000Z","path":"2019/04/10/MySQL基础_DQL/","text":"基础 登录： 1mysql 【-h主机名 -P端口号 】-u用户名 -p密码 退出： 1exit或ctrl+C MySQL的语法规范 不区分大小写,但建议关键字大写，表名、列名小写 注释 123单行注释：#注释文字单行注释：-- 注释文字多行注释：&#x2F;* 注释文字 *&#x2F; DQL（Data Query Language）数据查询语言★基础查询★ 语法： 1select 查询列表 from 表名;特点： 特点： ①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在 ② 查询的可以是常量值、表达式、字段、函数 1234567#查询常量值SELECT 100;SELECT 'john';#查询表达式SELECT 100%98;#查询函数SELECT VERSION(); mysql中的+号——仅仅只有一个功能：运算符 select 100+90;两个操作数都为数值型，则做加法运算 select &#39;123&#39;+90;只要其中一方为字符型，试图将字符型数值转换成数值型如果转换成功，则继续做加法运算 select &#39;john&#39;+90; 如果转换失败，则将字符型数值转换成0 select null+10; 只要其中一方为null，则结果肯定为null 条件查询★ 语法： 123select 要查询的字段|表达式|常量值|函数from 表where 条件; 条件运算符： 123&gt;= &lt;= =&lt;&gt; [常用] != [不常用] 逻辑运算符： 123and[常用] (&amp;&amp;)[不常用]or[常用] (||)[不常用]not[常用] (!)[不常用] 模糊查询 1234567891011121314151617181920like 一般和通配符搭配使用 通配符： % 任意多个字符,包含0个字符 _ 任意单个字符between small and big ①两个临界值不要调换顺序 ②包含临界值 in ①in列表的值类型必须一致或兼容 ②in列表中不支持通配符 is nullis not null ①=或&lt;&gt;不能用于判断null值 ②is null或is not null 可以判断null值 ③IS NULL:仅仅可以判断NULL值，可读性较高，建议使用 &lt;=&gt; :既可以判断NULL值，又可以判断普通的数值，可读性较低 排序查询 ★ 语法： 1234select 查询列表from 表名【where 筛选条件】order by 排序的字段|表达式|函数|别名 【asc|desc】; 特点： asc代表的是升序，可以省略 desc代表的是降序 order by子句可以支持 单个字段、别名、表达式、函数、多个字段 1234567891011121314151617181920212223#按表达式排序#案例：查询员工信息 按年薪降序SELECT *,salary*12*(1+IFNULL(commission_pct,0))FROM employeesORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;#按别名排序#案例：查询员工信息 按年薪升序SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪FROM employeesORDER BY 年薪 ASC;#按函数排序#案例：查询员工名，并且按名字的长度降序SELECT LENGTH(last_name),last_name FROM employeesORDER BY LENGTH(last_name) DESC;#按多个字段排序#案例：查询员工信息，要求先按工资降序，再按employee_id升序SELECT *FROM employeesORDER BY salary DESC,employee_id ASC; order by子句在查询语句的最后面，除了limit子句 常见函数★函数调用：select 函数名(实参列表) 【from 表】; 单行函数 字符函数 concat拼接 1SELECT CONCAT(last_name,'_',first_name) 姓名 FROM employees; length获取字节个数 1SELECT LENGTH('张三丰hahaha'); substr截取子串【SQL语法：索引从1开始】 1234#截取从指定索引处后面所有字符SELECT SUBSTR('李莫愁爱上了陆展元',7) out_put;#截取从指定索引处指定字符长度的字符SELECT SUBSTR('李莫愁爱上了陆展元',1,3) out_put; upper转换成大写 lower转换成小写 12SELECT UPPER('john');SELECT LOWER('joHn'); trim去前后指定的空格和字符 ltrim去左边空格 rtrim去右边空格 12SELECT LENGTH(TRIM(' 张翠山 ')) AS out_put;SELECT TRIM('aa' FROM 'aaaaa张aaaaaaaaa翠山aaaaaa') AS out_put; replace替换【全部替换】 1SELECT REPLACE('周芷若周芷若周芷若周芷若张无忌爱上了周芷若','周芷若','赵敏') AS out_put; lpad左填充 1SELECT LPAD('殷素素',2,'*') AS out_put; rpad右填充 1SELECT RPAD('殷素素',12,'ab') AS out_put; instr返回子串第一次出现的索引 1SELECT INSTR('杨不殷六侠悔爱上了殷六侠','殷八侠') AS out_put; 数学函数 round四舍五入 12SELECT ROUND(-1.55);SELECT ROUND(1.567,2); floor向下取整 1SELECT FLOOR(-9.99); ceil向上取整 1SELECT CEIL(-1.02); rand随机数 1SELECT RAND(); mod取余【简单背诵：结果与被除数 符号相同】 12345/*mod(a,b) ： a-a/b*bmod(-10,-3):-10- (-10)/(-3)*（-3）=-1*/SELECT MOD(10,-3); truncate截断 1SELECT TRUNCATE(1.69999,1); 日期函数 now当前系统日期+时间 1SELECT NOW(); curdate当前系统日期，不包含时间 1SELECT CURDATE(); curtime当前时间，不包含日期 1SELECT CURTIME(); str_to_date将字符转换成日期 123SELECT STR_TO_DATE('1998-3-2','%Y-%c-%d') AS out_put;#查询入职日期为1992-4-3的员工信息SELECT * FROM employees WHERE hiredate = '1992-4-3'; date_format将日期转换成字符 1SELECT DATE_FORMAT(NOW(),'%y年%m月%d日') AS out_put; 指定的部分，年、月、日、小时、分钟、秒 123456SELECT YEAR('1998-1-1');SELECT DAY(NOW())SELECT MONTH(NOW());SELECT HOUR(NOW())SELECT MINUTE(NOW())SELECT SECOND(NOW()) 流程控制函数 if 处理双分支 12SELECT IF(10&lt;5,'大','小');SELECT last_name,commission_pct,IF(commission_pct IS NULL,'没奖金','有奖金') 备注 FROM employees; case语句 处理多分支 处理等值判断 123456789101112131415161718192021222324252627282930#case函数的使用一： switch case 的效果/*mysql中case 要判断的字段或表达式when 常量1 then 要显示的值1或语句1;when 常量2 then 要显示的值2或语句2;...else 要显示的值n或语句n;end*//*案例：查询员工的工资，要求部门号=30，显示的工资为1.1倍部门号=40，显示的工资为1.2倍部门号=50，显示的工资为1.3倍其他部门，显示的工资为原工资*/SELECT salary 原始工资,department_id,CASE department_idWHEN 30 THEN salary*1.1WHEN 40 THEN salary*1.2WHEN 50 THEN salary*1.3ELSE salaryEND AS 新工资FROM employees; 情况2：处理条件判断 12345678910111213141516171819202122232425#case 函数的使用二：类似于 多重if/*mysql中：case when 条件1 then 要显示的值1或语句1when 条件2 then 要显示的值2或语句2。。。else 要显示的值n或语句nend*/#案例：查询员工的工资的情况如果工资&gt;20000,显示A级别如果工资&gt;15000,显示B级别如果工资&gt;10000，显示C级别否则，显示D级别SELECT salary,CASE WHEN salary&gt;20000 THEN 'A'WHEN salary&gt;15000 THEN 'B'WHEN salary&gt;10000 THEN 'C'ELSE 'D'END AS 工资级别FROM employees; 分组函数★ 功能：做统计使用，又称为统计函数、聚合函数、组函数\\ sum求和 max最大值 min最小值 avg平均值 count计数 特点： 分组函数都忽略null值，除了count(*) sum和avg一般用于处理数值型 max、min、count可以处理任何数据类型 都可以搭配distinct使用，用于统计去重后的结果 count的参数可以支持： 字段、*、常量值，一般放1建议使用 count(*) MYISAM存储引擎下 ，COUNT(*)的效率高 INNODB存储引擎下，COUNT(*)和COUNT(1)的效率差不多，比COUNT(字段)要高一些 分组查询★ 语法： 12345select 查询列表from 表【where 筛选条件】group by 分组的字段【order by 排序的字段】; 特点： 和分组函数一同查询的字段必须是group by后出现的字段 筛选分为两类 针对的表 位置 连接的关键字 分组前筛选 原始表 group by前 where 分组后筛选 group by后的结果集 group by后 having 分组可以按多个字段分组，字段之间用逗号隔开 1234SELECT MIN(salary),job_id,department_idFROM employeesGROUP BY department_id,job_idORDER BY MIN(salary) DESC; 一般来讲，能用分组前筛选的，尽量使用分组前筛选，提高效率 连接查询★ 按年代分类： sql92标准 仅仅支持内连接 sql99标准【推荐】 支持内连接 支持外连接（左外和右外） 支持交叉连接 按功能分类： 内连接：* 等值连接 * 非等值连接 * 自连接 外连接： * 左外连接 * 右外连接 * 全外连接 交叉连接 sql92标准 等值连接 ① 多表等值连接的结果为多表的交集部分 ②n表连接，至少需要n-1个连接条件 ③ 多表的顺序没有要求 ④一般需要为表起别名，如果为表起了别名，则查询的字段就不能使用原来的表名去限定 ⑤可以搭配前面介绍的所有子句使用，比如排序、分组、筛选 123456SELECT last_name,department_name,cityFROM employees e,departments d,locations lWHERE e.`department_id`=d.`department_id`AND d.`location_id`=l.`location_id`AND city LIKE 's%'ORDER BY department_name DESC; 非等值连接 1234SELECT salary,grade_levelFROM employees e,job_grades gWHERE salary BETWEEN g.`lowest_sal` AND g.`highest_sal`AND g.`grade_level`='A'; 自连接 1234#案例：查询 员工名和上级的名称 SELECT e.employee_id,e.last_name,m.employee_id,m.last_name FROM employees e,employees m WHERE e.`manager_id`=m.`employee_id`; sql99语法 语法： 12345678select 字段，...from 表1【inner|left outer|right outer|cross】join 表2 on 连接条件【inner|left outer|right outer|cross】join 表3 on 连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】 分类： 123456内连接（★） inner外连接 左外(★) left 【outer】 右外(★) right 【outer】 全外 full【outer】交叉连接 cross 内连接 ①添加排序、分组、筛选 ②inner可以省略 ③ 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读 ④inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集 外连接：用于查询一个表中有，另一个表没有的记录 外连接的查询结果为主表中的所有记录 如果从表中有和它匹配的，则显示匹配的值 如果从表中没有和它匹配的，则显示null 外连接查询结果=内连接结果+主表中有而从表没有的记录 左外连接，left join左边的是主表 右外连接，right join右边的是主表 左外和右外交换两个表的顺序，可以实现同样的效果 全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的 交叉连接 123SELECT b.*,bo.*FROM beauty bCROSS JOIN boys bo; 子查询√ 含义 一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询 在外面的查询语句，称为主查询或外查询 特点 子查询都放在小括号内 按结果集的行列数不同： 标量子查询（结果集只有一行一列） 列子查询（结果集只有一列多行） 行子查询（结果集有一行多列/多列多行） 表子查询（结果集一般为多行多列） 子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧 select后面：仅仅支持标量子查询 from后面：支持表子查询 where或having后面：★ **标量子查询（单行） √** **列子查询 （多行） √** 行子查询[不常用] exists后面（相关子查询） **表子查询** 子查询优先于主查询执行，主查询使用了子查询的执行结果 子查询根据查询结果的行数不同分为以下两类： ① 单行子查询 结果集只有一行 一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= 非法使用子查询的情况： a、子查询的结果为一组值 b、子查询的结果为空 ② 多行子查询 结果集有多行 一般搭配多行操作符使用：any、all、in、not in in： 属于子查询结果中的任意一个就行 any和all往往可以用其他查询代替 where或having后面 标量子查询，一般搭配着单行操作符使用&gt; &lt; &gt;= &lt;= = &lt;&gt; 1234567#返回公司工资最少的员工的last_name,job_id和salarySELECT last_name,job_id,salaryFROM employeesWHERE salary=( SELECT MIN(salary) FROM employees); 列子查询，一般搭配着多行操作符使用in、any/some[不常用]、all[不常用] 123456789101112131415161718#返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工的员工号、姓名、job_id 以及salarySELECT last_name,employee_id,job_id,salaryFROM employeesWHERE salary&lt;ALL( SELECT DISTINCT salary FROM employees WHERE job_id &#x3D; &#39;IT_PROG&#39;) AND job_id&lt;&gt;&#39;IT_PROG&#39;;#等价SELECT last_name,employee_id,job_id,salaryFROM employeesWHERE salary&lt;( SELECT MIN( salary) FROM employees WHERE job_id &#x3D; &#39;IT_PROG&#39;) AND job_id&lt;&gt;&#39;IT_PROG&#39;; select后面 仅仅支持标量子查询 1234567#案例：查询每个部门的员工个数SELECT d.*,( SELECT COUNT(*) FROM employees e WHERE e.department_id = d.`department_id`) 个数FROM departments d; from后面 将子查询结果充当一张表，要求必须起别名 123456789#查询每个部门的平均工资的工资等级SELECT ag_dep.*,g.`grade_level`FROM ( SELECT AVG(salary) ag,department_id FROM employees GROUP BY department_id) ag_depINNER JOIN job_grades gON ag_dep.ag BETWEEN lowest_sal AND highest_sal; exists后面（相关子查询） 语法： 123exists(完整的查询语句)结果：1或0 123456789101112131415161718#查询有员工的部门名#inSELECT department_nameFROM departments dWHERE d.`department_id` IN( SELECT department_id FROM employees)#existsSELECT department_nameFROM departments dWHERE EXISTS( SELECT * FROM employees e WHERE d.`department_id`=e.`department_id`); 分页查询★ 应用场景： 1实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句 语法： 12345678910select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【offset,】size; offset要显示条目的起始索引（起始索引从0开始） size 要显示的条目个数 特点 起始条目索引从0开始 limit子句放在查询语句的最后 union联合查询√ 要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时 union联合合并：将多条查询语句的结果合并成一个结果 语法 12345678select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】 特点：★ 要求多条查询语句的查询列数是一致的！ 要求多条查询语句的查询的每一列的类型和顺序最好一致 union关键字默认去重，如果使用union all 可以包含重复项 DML(Data Manipulate Language)数据操作语言★插入语句 语法： 1insert into 表名(列名,...) values(值1,...); 特点 字段类型和值类型一致或兼容，而且一一对应 可以为空的字段，可以不用插入值，或用null填充 不可以为空的字段，必须插入值 字段个数和值的个数必须一致 字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致 修改语句 修改单表语法： 1update 表名 set 字段=新值,字段=新值 【where 条件】 修改多表语法： 123456789101112# sql92语法：update 表1 别名,表2 别名set 列=值, 列=值,...where 连接条件and 筛选条件;# sql99语法：update 表1 别名inner|left|right join 表2 别名on 连接条件set 列=值, 列=值,...where 筛选条件; 删除语句 删除单表语法： 1delete from 表名 where 筛选条件 修改多表语法： 123456789101112131415方式一：delete# sql92语法：delete 表1的别名,表2的别名from 表1 别名,表2 别名where 连接条件and 筛选条件;# sql99语法：delete 表1的别名,表2的别名from 表1 别名inner|left|right join 表2 别名 on 连接条件where 筛选条件;方式二：truncate语法：truncate table 表名; delete pk truncate【面试题★】 12345671.delete 可以加where条件，truncate不能加2.truncate删除，效率高一丢丢3.假如要删除的表中有自增长列， 如果用delete删除后，再插入数据，自增长列的值从断点开始， 而truncate删除后，再插入数据，自增长列的值从1开始。4.truncate删除没有返回值，delete删除有返回值5.truncate删除不能回滚，delete删除可以回滚.","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://goldcarpenter.github.io/tags/MySQL/"}]},{"title":"多线程编程","date":"2019-04-05T13:21:21.000Z","path":"2019/04/05/多线程_Part2/","text":"Runnable接口实质 静态代理 12345678910111213141516171819202122232425262728293031323334353637public class StaticProxy &#123; public static void main(String[] args)&#123; //创建真实角色 //创建代理角色+真实角色的引用 //执行任务 //new Thread(new A()).start(); new WeddingCompany(new You()).marry(); &#125;&#125;//接口interface Marry&#123; public abstract void marry();&#125;//真实角色class You implements Marry&#123; public void marry()&#123; System.out.println(\"you and me marry\"); &#125;&#125;//代理角色class WeddingCompany implements Marry&#123; private Marry you; public WeddingCompany(Marry you)&#123; this.you=you; &#125; private void before()&#123; System.out.println(\"买房买车\"); &#125; private void after()&#123; System.out.println(\"生孩子！\"); &#125; public void marry()&#123; before(); you.marry(); after(); &#125;&#125; 为什么启动线程不直接使用run()方法 直接调用run方法会在当前线程调用run方法，多线程需要依托底层的操作系统的支持，必须使用start方法，由新的线程调用run方法 123456789 public synchronized void start() &#123; if (threadStatus != 0)//重复调用start方法 抛出异常 throw new IllegalThreadStateException();//... start0(); //... &#125; private native void start0(); 守护线程Daemon &amp; 用户线程User 用户线程 JVM必须保证用户线程执行完毕 守护线程 JVM中所有的线程都是守护线程的时候，就可以退出了 垃圾回收线程，内存监控线程 任何线程都可以是守护线程Daemon或用户线程User Tomcat中的Acceptor和Poller线程都是守护线程，所以Tomcat接收到 shutdown命令后，不会等待它们处理完当前请求 123//设置为守护/用户线程Thread a = new Thread(new B(), \"A\");a.setDaemon(true); //默认为false 用户线程 ThreadLocal线程局部变量 相同的一段代码多个线程来执行，每个线程使用的数据只与当前线程有关 ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。 方法 123456// 返回当前线程所对应的线程局部变量public T get()// 设置当前线程的线程局部变量的值public void set(T value) //将当前线程局部变量的值删除 显式调用该方法清除线程的局部变量并不是必须的操作 但它可以加快内存回收的速度public void remove() 实例 123456789101112131415161718192021222324252627class Main&#123; //用一个静态的变量来记录ThreadLocal对象,方法在任何地方法直接调用 private static ThreadLocal&lt;String&gt; local = new ThreadLocal&lt;&gt;(); public static void main(String[] args) &#123; local.set(\"yyx\"); new Thread(() -&gt; &#123; //在线程的任意地方设置变量 local.set(\"你\"); method(); &#125;).start(); new Thread(() -&gt; &#123; local.set(\"好\"); method(); &#125;).start(); method(); &#125; private static void method()&#123; //可以在当前线程的任意地方获取变量 System.out.println(local.get()); &#125;&#125;/*你yyx好*/ Q: ThreadLocal &amp; 线程同步机制 都是为了解决多线程中相同变量的访问冲突问题 思路不同【抢篮球&amp;一人发一个篮球】： 同步机制【仅提供一份变量，让不同的线程排队访问】：通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大 ThreadLocal【一个线程都提供了一份变量，因此可以同时访问而互不影响】：会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal Q:保证++–的原子性使用 子性的，通过底层实现 123456789101112131415161718192021222324252627282930313233343536import java.util.ArrayList;import java.util.concurrent.atomic.AtomicInteger;class Main &#123; AtomicInteger count = new AtomicInteger(0); //private Integer count = 0; void m() &#123; for (int i = 0; i &lt; 1000; i++) &#123; count.incrementAndGet(); &#125; &#125; void n() &#123; for (int i = 0; i &lt; 1000; i++) &#123; //count++; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Main main = new Main(); ArrayList&lt;Thread&gt; threads = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; threads.add(new Thread(main::m)); &#125; threads.forEach(Thread::start); for (Thread thread : threads) &#123; thread.join(); &#125; System.out.println(main.count); // AtomicInteger:10000 // Integer:6239 &#125;&#125; Q: 证明AtomXXX类的多个方法不具备原子性12345678910void m() &#123; for (int i = 0; i &lt; 1000; i++) &#123; if (count.get()&lt;1000) &#123; count.incrementAndGet(); &#125; &#125;&#125;/*1001*/ Q: 改变锁定对象的属性问题 锁定某个对象，如果object的属性发生改变，不影响锁的使用 如果object变成另外一个对象，则锁定对象发生改变 1234567891011121314151617181920212223242526272829303132333435class Main&#123; private Boolean lock = true; public static void main (String[] args) throws Exception &#123; Main main = new Main(); CountDownLatch latch = new CountDownLatch(1); new Thread(()-&gt;&#123; synchronized(main.lock)&#123; System.out.println(\"监视线程 start..\"); // 创建了一个新的对象 修改了锁对象！！！ main.lock = false; try &#123; // synchronzied(tmain.lock)绑定的是旧的Boolean对象 // main.lock.wait();使用的是新的Boolean对象 // 由于新的Boolean对象并没有使用synchronzied进行同步 // 所以系统抛出了IllegalMonitorStateException异常。 main.lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"监视线程2 end..\"); &#125; &#125;).start(); &#125;&#125;/*监视线程 start..Exception in thread \"Thread-0\" java.lang.IllegalMonitorStateException at java.lang.Object.wait(Native Method) at java.lang.Object.wait(Object.java:502) at Main.lambda$main$0(test.java:48) at java.lang.Thread.run(Thread.java:748)*/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class T implements Runnable&#123; public Object o = new Object(); public void run()&#123; System.out.println(Thread.currentThread().getName()+\"lock rob\"); synchronized(this.o) &#123; System.out.println(Thread.currentThread().getName()+\"start...\"); while(true) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+ \"run...\"); &#125; &#125; &#125;&#125;class Main&#123; private Boolean lock = true; public static void main (String[] args) throws Exception &#123; Main main = new Main(); T m = new T(); new Thread(m,\"Thread1\").start(); Thread.sleep(1000); //m.o = new Object(); new Thread(m,\"Thread2\").start(); &#125;&#125;/*注释关闭Thread1lock robThread1start...Thread2lock robThread2start...Thread1run...Thread2run...Thread1run...Thread2run...Thread1run...Thread2run...Thread1run...*//*注释开启Thread1lock robThread1start...Thread1run...Thread2lock robThread1run...Thread1run...Thread1run...Thread1run...Thread1run...*/ Q: 能否使用字符串常量作为锁对象不能，因为有可能在堆上锁定的是同一个变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class T&#123; String str1 = \"String\"; String str2 = \"String\"; void m() throws InterruptedException &#123; System.out.println(\"m()start\"); synchronized(str1) &#123; System.out.println(\"m()抢到了锁~\"); System.out.println(\"m()ing...\"); Thread.sleep(10000); &#125; System.out.println(\"m()释放了锁~\"); System.out.println(\"m()end\"); &#125; void n() throws InterruptedException &#123; System.out.println(\"n()start\"); synchronized(str2) &#123; System.out.println(\"n()抢到了锁~\"); Thread.sleep(1000); System.out.println(\"n()ing...\"); &#125; System.out.println(\"n()释放了锁~\"); System.out.println(\"n()end\"); &#125;&#125;class Main&#123; public static void main (String[] args) throws Exception &#123; T t = new T(); new Thread(() -&gt; &#123; try &#123; t.m(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); Thread.sleep(100); new Thread(() -&gt; &#123; try &#123; t.n(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125;/*m()startm()抢到了锁~m()ing...n()start(..n在等待m释放锁..)m()释放了锁~m()endn()抢到了锁~n()ing...n()释放了锁~n()end*/ Q: 程序：一个线程添加 一个线程监控个数 当个数为5时 提醒并结束 版本1： list前要加volatile才能正确运行 监视线程 循环死等浪费CPU 计数不精准 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Main&#123; volatile private ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public static void main (String[] args) throws Exception &#123; Main main = new Main(); new Thread(()-&gt;&#123; System.out.println(\"计数线程 start..\"); for(int i = 0; i&lt; 10; i++) &#123; main.list.add(new Random().nextInt()); System.out.println(\"add..\"+ i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"计数线程 end..\"); &#125;).start(); new Thread(()-&gt;&#123; System.out.println(\"监视线程 start..\"); while(true)&#123; if(main.list.size() == 5) &#123; break; &#125; &#125; System.out.println(\"监视线程 end..\"); &#125;).start(); &#125;&#125;/*计数线程 start..add..0监视线程 start..add..1add..2add..3add..4监视线程2 end..add..5add..6add..7add..8add..9计数线程 end.*/ =====================================优化============================================== 版本2： wait()&amp;notify() 必需放在synchronized(Object中) 注意需要让监视线程先运行 notify()方法不会释放锁，wait()方法会释放锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Main&#123; volatile private ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public static void main (String[] args) throws Exception &#123; Main main = new Main(); Object object = new Object(); new Thread(()-&gt;&#123; System.out.println(\"监视线程 start..\"); synchronized(object) &#123; while(main.list.size() != 5) &#123; try &#123; object.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 计数线程继续运行 object.notify(); System.out.println(\"监视线程2 end..\"); &#125; &#125;).start(); new Thread(()-&gt;&#123; synchronized(object) &#123; System.out.println(\"计数线程 start..\"); for (int i = 0; i &lt; 10; i++) &#123; main.list.add(new Random().nextInt()); System.out.println(\"add..\" + i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (main.list.size() == 5) &#123; object.notify(); // 必须wait()释放锁 监控线程才能进入 try &#123; object.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; System.out.println(\"计数线程 end..\"); &#125; &#125;).start(); &#125;&#125;/* 监视线程 start..计数线程 start..add..0add..1add..2add..3add..4监视线程2 end..add..5add..6add..7add..8add..9计数线程 end..*/ ====================================优化============================================== 版本3： 使用并发并存工具java.util.concurrent.CountDownLatch 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Main&#123; volatile private ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public static void main (String[] args) throws Exception &#123; Main main = new Main(); CountDownLatch latch = new CountDownLatch(1); new Thread(()-&gt;&#123; System.out.println(\"监视线程 start..\"); if(main.list.size() != 5) &#123; try &#123; latch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 计数线程继续运行 System.out.println(\"监视线程2 end..\"); &#125;).start(); new Thread(()-&gt;&#123; System.out.println(\"计数线程 start..\"); for (int i = 0; i &lt; 10; i++) &#123; main.list.add(new Random().nextInt()); System.out.println(\"add..\" + i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (main.list.size() == 5) &#123; latch.countDown(); &#125; &#125; System.out.println(\"计数线程 end..\"); &#125;).start(); &#125;&#125;/*监视线程 start..计数线程 start..add..0add..1add..2add..3add..4add..5监视线程2 end..add..6add..7add..8add..9计数线程 end..*/ Q: 线程抛出异常会释放锁么12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.sql.Time;import java.util.concurrent.TimeUnit;class Main &#123; int num = 0; synchronized public void function() &#123; while(true) &#123; num++; System.out.println(Thread.currentThread().getName() + \" \" + num); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if(num == 5) num = num/0; &#125; &#125; public static void main(String []argv) throws InterruptedException &#123; Main main = new Main(); new Thread(main::function).start(); new Thread(main::function).start(); &#125;&#125;/*Thread-0 1Thread-0 2Thread-0 3Thread-0 4Thread-0 5Thread-1 6Exception in thread \"Thread-0\" java.lang.ArithmeticException: / by zero at Main.function(test.java:19) at java.lang.Thread.run(Thread.java:748)Thread-1 7Thread-1 8Thread-1 9Thread-1 10*/ Q: 证明AtomXX类比synchronized更高效程序​ PStreamAPI 45.线程池都有哪些状态？ 47.在 java 程序中怎么保证多线程的运行安全？ 48.多线程锁的升级原理是什么？ 51.ThreadLocal 是什么？有哪些使用场景？ 52.说一下 synchronized 底层实现原理？ 53.synchronized 和 volatile 的区别是什么？ 54.synchronized 和 Lock 有什么区别？ 55.synchronized 和 ReentrantLock 区别是什么？ 56.说一下 atomic 的原理？","tags":[{"name":"多线程","slug":"多线程","permalink":"http://goldcarpenter.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"多线程编程","date":"2019-04-01T13:21:21.000Z","path":"2019/04/01/多线程_Part1/","text":"1.进程与线程并发与并行 并发：在单核CPU上，一段时间内宏观上有多个程序同时运行，微观上这些程序是分时的交替运行 并行：指两个或多个事件在多核CPU上同一时刻发生（同时发生）。 在操作系统中，安装并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。 而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上，实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核越多，并行处理的程序越多，能大大的提高电脑运行的效率。 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。 线程与进程 进程：当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程 每个进程都有一个独立的内存空间 一个应用程序可以同时运行多个进程 进程也是程序的一次执行过程，是系统运行程序的基本单位； 系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行 关系：一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 对比 进程拥有共享的资源，如内存空间等，供其内部的线程共享 进程间通信较为复杂 同一台计算机的进程通信称为IPC (Inter- process communication) 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如HTTP 线程通信相对简单，因为它们共享进程的内存，一个例子是多个线程可以访问同一个共享变量 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低 一个程序运行后至少有一个进程，一个进程中可以包含多个线程 线程调度 分时调度 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 2.Java 线程2.1Thread类 构造方法 public Thread() :分配一个新的线程对象。 public Thread(String name) :分配一个指定名字的新的线程对象。 public Thread(Runnable target) :分配一个带有指定目标新的线程对象。 public Thread(Runnable target,String name):分配一个带有指定目标新的线程对象并指定名字。 常用方法： public String getName() :获取当前线程名称。 public void start():导致此线程开始执行; Java虚拟机调用此线程的run方法。 public void run() :此线程要执行的任务在此处定义代码。 public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。 public static Thread currentThread():返回对当前正在执行的线程对象的引用。 方法名 静态 功能说明 注意 start() 启动一个新线程，在新的线程运行 run 方法中的代码 start 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出现 IllegalThreadStateException run() 新线程启动后会调用的方法 如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象，来覆盖默认行为 join() 等待线程运行结束 join(long n) 等待线程运行结束 最多等待 n 毫秒 getId() 获取线程长整型的 id id 唯一 getName() 获取线程名 setName(String) 修改线程名 getPriority() 获取线程优先级 java中规定线程优先级是1~10 的整数 setPriority(int) 修改线程优先级 较大的优先级能提高该线程被 CPU 调度的机率 getState() 获取线程状态 Java 中线程状态是用 6 个枚举表示，分别为： NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED isInterrupted() 判断当前线程是否被打断 不会清除打断标记 isAlive() 线程是否存活（还没有运行完毕） interrupt() 打断线程 ①被打断线程正在阻塞会导致被打断的线程抛出 InterruptedException，并清除打断标记；②被打断线程正在运行，则会设置打断标记 ；③park 的线程被打断，也会设置打断标记 interrupted() ✔ 判断当前线程是否被打断 会清除打断标记 currentThread() ✔ 获取当前正在执 行的线程 sleep(long n) ✔ 让当前执行的线程休眠n毫秒， 休眠时让出 cpu 的时间片给其它线程 yield() ✔ 提示线程调度器让出当前线程对 CPU的使用 主要是为了测试和调试 currentThread() ✔ 获取当前正在执行的线程 2.1.1创建线程 线程start()进入就绪状态，由CPU调度执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778========================================//继承Thread类 class MyThread extends Thread &#123; //定义指定线程名称的构造方法 public MyThread(String name) &#123; //调用父类的String参数的构造方法，指定线程的名称 super(name); &#125; @Override public void run() &#123; // 重写run方法，完成该线程执行的逻辑 &#125; &#125;========================================//实现Runnable接口 class MyThread implements Runnable &#123; @Override public void run() &#123; //.... &#125; &#125; class Main &#123; public static void main (String[] args) &#123; Thread myThread = new Thread(new MyThread()); myThread.start(); &#125; &#125;========================================//实现Callable接口 class A implements Callable&lt;boolean&gt;&#123; // 泛型为返回值类型 @Override public boolean call() throws Exception &#123; //... return false; &#125; &#125; public static void main (String[] args) throws Exception&#123; A a = new A(); A b = new A(); //创建执行服务 ExecutorService ser = Executors.newFixedThreadPool(3); //提交执行 Future&lt;Boolean&gt; submit = ser.submit(a); Future&lt;Boolean&gt; submit1 = ser.submit(b); //获取结果 Boolean result = submit.get(); Boolean result1 = submit1.get(); //关闭服务 ser.shutdownNow(); &#125;========================================//FutureTask能够接收Callable 类型的参数，用来处理有返回结果的情况//public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; //public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;[返回结果]/** 对比Runnable 可以抛出异常 可以有返回值 @FunctionalInterface public interface Callable&lt;V&gt; &#123; V call() throws Exception; &#125;*/ FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; System.out.println(\"start\"); Thread.sleep(1000); System.out.println(\"end\"); return null; &#125; &#125;); Thread t1 = new Thread(task,\"t1\"); t1.start(); task.get(); //阻塞等待线程返回结果 System.out.println(\"阻塞等待结果\"); 实现Runnable接口比继承Thread类的优势 避免了单继承的局限 适合多个相同代码线程处理同一资源 增强了程序的扩展性，降低程序的耦合性。将实现Runnable接口的方式，把用来设置线程任务【实现类中,重写了run方法】和开启新线程【创建Thread类对象,调用start方法】进行了分离 用Runnable更容易与线程池等高级API配合 run方法原理 1234567891011121314//Thread.java&#123; // 成员方法 private Runnable target; //FutureTask接收Callable本质：FutureTask是Runnalble的子类 构造方法传入的Runnable对象赋值给成员变量 FutureTask自己重写了run方法 调用call方法 //实现Runnable接口本质：构造方法传入的Runnable对象赋值给成员变量 调用成员变量run方法 //继承Thread类：子类重写run方法 @Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125;&#125; 实现Callable接口比实现Runnable接口的优势 Runnable接口中run()方法无法返回操作结果，java.util.concurrent.Callable接口可以指定泛型返回类型 Callable的run方法可以抛出异常 2.1.2线程休眠 存在异常InterruptedException sleep时间到达后进入线程的就绪状态 每个对象都有一个锁，sleep不会释放锁 interrupt()方法打断时会清除打断标记 java.util.concurrent.TimeUnit.SECONDS.sleep(i);代替 Thread 的 sleep 来获得更好的可读性 1Thread.sleep(1000); 小应用——防止CPU占用100%12345678910111213141516/* 在没有利用cpu来计算时，不要让while(true)空转浪费cpu,这时可以使用yield或sleep来让出cpu的使用权给其他程序 可以用wait或条件变量达到类似的效果 不同的是，后两种都需要加锁，并且需要相应的唤醒操作，一般适用于要进行同步的场景 sleep适用于无需锁同步的场景*/public static void main(String[] args) &#123; while(true)&#123; try &#123; Thread.sleep(50); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 2.1.3线程礼让 将线程从运行状态转换为就绪状态，重新竞争，存在礼让失败的可能 12345678910111213141516171819202122 class B implements Runnable &#123; @Override public void run() &#123; System.out.println(\"start\" + Thread.currentThread().getName()); Thread.yield(); System.out.println(\"end\" + Thread.currentThread().getName()); &#125; &#125; class Main &#123; public static void main (String[] args) throws Exception&#123; new Thread(new B(),\"A\").start(); new Thread(new B(),\"B\").start(); &#125; &#125;/*startAstartBendBendA*/ sleep 与 yieldsleep 调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞） 其它线程可以使用interrupt方法打断正在睡眠的线程，这时 sleep 方法会抛出InterruptedException，并清除打断标记； 1234567891011121314151617181920212223242526 public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread( \"t1\") &#123; @Override public void run() &#123; log.debug(\"enter sleep...\"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e)&#123; log.debug(\"wake up...\"); log.debug(String.valueOf(Thread.currentThread().isInterrupted()));// 打断标记为0 e.printStackTrace(); &#125; &#125; &#125;; t1.start(); Thread.sleep(1000); log.debug(\"interrupt...\"); t1.interrupt();&#125;/*18:18:55.377 [t1] MultiThread - enter sleep...18:18:56.374 [main] MultiThread - interrupt...18:18:56.374 [t1] MultiThread - wake up...falsejava.lang.InterruptedException: sleep interrupted*/ 睡眠结束后的线程未必会立刻得到执行，不一定立刻获取让出的CPU使用权 建议用TimeUnit.SECONDS.sleep();的 sleep 代替 Thread 的 sleep 来获得更好的可读性 yield 调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程 具体的实现依赖于操作系统的任务调度器【没有礼让出去】 2.1.4合并线程 等待此线程执行完后，再执行其他线程 1234567891011121314151617static int r = 0; public static void main(String[] args) throws InterruptedException &#123; test1(); &#125;private static void test1() throws InterruptedException &#123; log.debug(\"开始\"); Thread t1 = new Thread(() -&gt; &#123; log.debug(\"开始\"); sleep(1); //1s log.debug(\"结束\"); r = 10; &#125;); t1.start(); // t1.join(); log.debug(\"结果为:&#123;&#125;\", r); log.debug(\"结束\");&#125; 前 后 2.1.5线程打断打断阻塞状态的线程 sleep，wait，join方法都会让线程进入阻塞状态，打断的线程, 会清空打断状态为【false】（已经有了异常捕获过程了） 123456789public static void main(String[] args) &#123; Thread t1 = new Thread(() -&gt; &#123;log.debug(\"s1eep...\"); sleep(5);&#125;,\"t1\"); t1.start(); Thread.sleep(1000); Log.debug(\"interrupt\"); t1.interrupt(); Log.debug(\"打断标记:&#123;&#125;\", t1.isInterrupted()); &#125; 123456789101112131415161718192021final static Object Lock = new Object();static boolean run = false;public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; synchronized (Lock)&#123; log.debug(\"wait...\"); try &#123; Lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); log.debug(\"打断标记:&#123;&#125;\", Thread.currentThread().isInterrupted()); &#125; &#125; &#125;,\"t1\"); t1.start(); Sleeper.sleep(1); log.debug(\"interrupt\"); t1.interrupt();&#125; 打断正常运行的线程 打断正常运行的线程，线程知道有其他线程想打断我，不会影响线程的正常运行过程，不会清空打断状态 线程不会被强制的停止，可以完成一定的善后工作再退出 12345678910111213141516 public static void main(String[] args) &#123; Thread t2 = new Thread(()-&gt;&#123; while(true) &#123; Thread current = Thread.currentThread(); boolean interrupted = current.isInterrupted();//获取打断标记查看是否被打断 if(interrupted) &#123; log.debug(\"打断状态: &#123;&#125;\", interrupted); break; &#125; &#125; &#125;, \"t2\"); t2.start(); sleep(0.5); t2.interrupt(); &#125;//20:57:37.964 [t2] c.TestInterrupt - 打断状态: true 打断 park 线程 打断 park 线程，不会清空打断状态 如果打断标记已经是 true, 则 park 会失效 12345678910111213public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; log.debug(\"park...\"); LockSupport.park();// ① log.debug(\"unpark...\"); log.debug(\"打断状态：&#123;&#125;\",Thread.currentThread().interrupted()); //不会清空打断状态 LockSupport.park(); // park 会失效 log.debug(\"unpark\"); &#125;, \"t1\"); t1.start(); sleep(0.5); //t1.interrupt(); 没有此行①之后的线程不执行了 &#125; 2.1.6停止线程 当run方法完成后线程终止 【不推荐】使用stop方法，destroy方法 在一个线程 T1 中如何“优雅”终止线程 T2？这里的【优雅】指的是给 T2 一个料理后事的机会。 两阶段终止模式 优雅（给与线程了解后事的机会）地停止某个(例如：监视记录)线程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MultiThread &#123; public static void main(String[] args) throws Exception &#123; MonitorThread monitorThread = new MonitorThread(); System.out.println(Thread.currentThread().getName()+\"开始监控\"); monitorThread.start(); Thread.sleep(5000); System.out.println(Thread.currentThread().getName()+\"停止监控\"); monitorThread.stop(); &#125;&#125;class MonitorThread&#123; private Thread monitor; /*private volatile boolean stop = false;*/ //启动监控线程 public void start() &#123; monitor = new Thread(() -&gt; &#123; while (true) &#123; Thread current = Thread.currentThread(); /*优化替代if (stop) &#123; */ if (current.isInterrupted()) &#123; //是否被打断 System.out.println(Thread.currentThread().getName()+\"料理后事\"); break; &#125; try &#123; Thread.sleep(1000); System.out.println(Thread.currentThread().getName()+\"执行监控记录\"); &#125; catch (InterruptedException e) &#123; //如果因为sleep出现异常后，会清除打断标记 //需要重置打断标记 current.interrupt();/*优化不要此行*/ &#125; &#125; &#125;, \"monitor\"); monitor.start(); &#125; //停止监控线程 public void stop() &#123; /*优化添加 stop = true; */ monitor.interrupt(); &#125;&#125;/*main开始监控monitor执行监控记录monitor执行监控记录monitor执行监控记录monitor执行监控记录monitor执行监控记录main停止监控monitor料理后事*/ 2.1.7不推荐的方法 还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁 stop方法会真正的杀死线程 如果锁住了共享资源 那么当杀死后就没有机会释放锁 其他线程永远无法获取到锁 2.2查看进程线程的方法 Windows 查看所有进程 1tasklist java 查看所有Java进程 1jps 查看某个 Java 进程（PID）的所有线程状态 1jstack [PID] 2.3操作系统线程状态 【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联 【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行 【运行状态】指获取了 CPU 时间片运行中的状态 当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换 【阻塞状态】 如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】 等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】 与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们 【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态 2.4Java中定义的线程状态 依据：Thread.State枚举分为六种状态 NEW：创建Java线程对象，但是没有与OS线程相关联 RUNNABLE：JVM中执行的线程，【包括运行线程，就绪线程和阻塞线程（阻塞IO相关API）】 Object.notify()方法【竞锁成功】 Object.notifyAll()方法【竞锁成功】 thread.interruput方法【竞锁成功】 LockSupport.unpark(“thread”)方法 阻塞IO操作 WAITING：无限期等待状态，等待被其他线程显示调用【Java API 层面对阻塞状态细分】 没有设置Timeout参数的Object.wait()方法 没有设置Timeout参数的Thread.join()方法 LockSupport.park()方法 TIMED_WAITING：限期等待状态，一定时间后系统自动唤醒【Java API 层面对阻塞状态细分】 Thread.sleep() 设置Timeout参数的Object.wait()方法 设置Timeout参数的Thread.join()方法 设置Timeout参数的LockSupport.parkNanos()方法 设置Timeout参数的LockSupport.parkUntil()方法 BLOCKED：阻塞状态，线程等待获取一个排他锁，即线程等待进入同步区【Java API 层面对阻塞状态细分】 Object.notify()方法【竞锁失败】 Object.notifyAll()方法【竞锁失败】 thread.interruput()方法【竞锁失败】 TERMINATED：线程执行完成 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import lombok.extern.slf4j.Slf4j;import org.slf4j.Logger;import org.slf4j.LoggerFactory;@Slf4j(topic = \"MultiThread\")public class MultiThread &#123; public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(\"t1\") &#123; @Override public void run() &#123; log.debug(\"running...\"); &#125; &#125;; Thread t2 = new Thread(\"t2\") &#123; @Override public void run() &#123; while(true) &#123; // runnable &#125; &#125; &#125;; t2.start(); Thread t3 = new Thread(\"t3\") &#123; @Override public void run() &#123; log.debug(\"running...\"); &#125; &#125;; t3.start(); Thread t4 = new Thread(\"t4\") &#123; @Override public void run() &#123; synchronized (MultiThread.class) &#123; try &#123; Thread.sleep(1000000); // timed_waiting &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; t4.start(); Thread t5 = new Thread(\"t5\") &#123; @Override public void run() &#123; try &#123; t2.join(); // waiting &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; t5.start(); Thread t6 = new Thread(\"t6\") &#123; @Override public void run() &#123; synchronized (MultiThread.class) &#123; // blocked try &#123; Thread.sleep(1000000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; t6.start(); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.debug(\"t1 state &#123;&#125;\", t1.getState()); log.debug(\"t2 state &#123;&#125;\", t2.getState()); log.debug(\"t3 state &#123;&#125;\", t3.getState()); log.debug(\"t4 state &#123;&#125;\", t4.getState()); log.debug(\"t5 state &#123;&#125;\", t5.getState()); log.debug(\"t6 state &#123;&#125;\", t6.getState()); System.in.read(); &#125;&#125;/*23:34:25 [t3] MultiThread - running...23:34:25 [main] MultiThread - t1 state NEW23:34:25 [main] MultiThread - t2 state RUNNABLE23:34:25 [main] MultiThread - t3 state TERMINATED23:34:25 [main] MultiThread - t4 state TIMED_WAITING23:34:25 [main] MultiThread - t5 state WAITING23:34:25 [main] MultiThread - t6 state BLOCKED*/ 2.5线程运行原理 Java Virtual Machine Stacks（Java 虚拟机栈） 每个线程启动后，虚拟机就会为线程分配一块栈内存。 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 12345678910111213141516public class Demo &#123; public static void main(String[] args) &#123; method1(10); &#125; private static void method1(int x) &#123; int y = x + 1; Object m = method2(); System.out.println(m); &#125; private static Object method2() &#123; Object n = new Object(); return n; &#125;&#125; 进行类加载 启动main线程 分配栈帧内存，调用method1方法 开始方法调用 x=10 程序计数器读取下一行代码，执行 程序计数器读取下一行代码 准备好栈帧 执行method2方法 mothed2执行结束，结果返回给调用者，释放内存 继续执行下一行代码 执行结束，返回结果，释放栈帧内存 主方法也没有方法了，运行结束 2.6线程上下文切换（Thread Context Switch） 因为以下一些原因导致cpu不再执行当前的线程，转而执行另一个线程的代码 线程的 cpu 时间片用完 垃圾回收 有更高优先级的线程需要运行 线程自己调用了sleep、yield、wait、join、park、synchronized、lock 等方法 当Context Switch发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态。其中，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm指令的执行地址，是线程私有的 当前线程的状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等 Context Switch 频繁发生会影响性能 灰色区域都要保存下来 2.7线程优先级 优先级低仅代表获得调度的概率低 设置优先级应该在start()方法前 默认的优先级为5【MIN_PRIORITY = 1 MAX_PRIORITY = 10】 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用 123456789101112131415161718class B implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; System.out.print(\".\"); &#125; &#125;&#125;class Main&#123; public static void main (String[] args) throws Exception&#123; Thread a = new Thread(new B(), \"A\"); a.setPriority(9); a.start(); System.out.println(a.getPriority()); &#125;&#125;","tags":[{"name":"多线程","slug":"多线程","permalink":"http://goldcarpenter.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"JavaIO","date":"2019-03-12T16:00:00.000Z","path":"2019/03/13/javaIO_Part3/","text":"JavaIO6.IO异常的处理6.1JDK7前处理之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用try...catch...finally 代码块，处理异常部分，代码使用演示： 1234567891011121314151617181920public static void main(String[] args) &#123; // 声明变量 FileWriter fw = null; try &#123; //创建流对象 fw = new FileWriter(\"fw.txt\"); // 写出数据 fw.write(\"掘金木匠\"); //掘金木匠 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fw != null) &#123; ****** fw.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 6.2JDK7的处理 可以使用JDK7优化后的try-with-resource 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。 类必须是实现java.io.Closeable 接口 格式： 12345try (创建流对象语句，如果多个,使用';'隔开) &#123; // 读写数据&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 代码使用演示： 123456789public static void main(String[] args) &#123; // 创建流对象 try (FileWriter fw = new FileWriter(\"fw.txt\"); ) &#123; // 写出数据 fw.write(\"掘金木匠\"); //掘金木匠 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 6.3JDK9的改进 JDK9中try-with-resource 的改进，对于引入对象的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。 改进前格式： 123456789// 被final修饰的对象final Resource resource1 = new Resource(\"resource1\");// 普通对象Resource resource2 = new Resource(\"resource2\");// 引入方式：创建新的变量保存try (Resource r1 = resource1; Resource r2 = resource2) &#123; // 使用对象&#125; 改进后格式： 123456789// 被final修饰的对象final Resource resource1 = new Resource(\"resource1\");// 普通对象Resource resource2 = new Resource(\"resource2\");// 引入方式：直接引入try (resource1; resource2) &#123; // 使用对象&#125; 改进后，代码使用演示： 1234567891011121314151617public static void main(String[] args) throws IOException &#123; // 创建流对象 final FileReader fr = new FileReader(\"in.txt\"); FileWriter fw = new FileWriter(\"out.txt\"); // 引入到try中 try (fr; fw) &#123; // 定义变量 int b; // 读取数据 while ((b = fr.read())!=-1) &#123; // 写出数据 fw.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 7.属性集7.1 概述 java.util.Properties 继承于Hashtable【已经被HashMap LinkedHashMap替代】 ，来表示一个持久的属性集，可保存流中数据或从流中加载。 Properties集合是一个唯一和IO流相结合的集合 使用键值结构存储数据，每个键及其对应值都是一个字符串。 该类也被许多Java类使用，比如获取系统属性时，System.getProperties 方法就是返回一个Properties对象。 7.2 Properties类7.2.1构造方法 public Properties() :创建一个空的属性列表。 7.2.2基本的存储方法 public Object setProperty(String key, String value) ： 保存一对属性。 public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。 public Set&lt;String&gt; stringPropertyNames() ：所有键的名称的集合。 1234567891011121314151617181920212223242526272829 public static void main(String[] args) throws FileNotFoundException &#123; // 创建属性集对象 Properties properties = new Properties(); // 添加键值对元素 properties.setProperty(\"filename\", \"a.txt\"); properties.setProperty(\"length\", \"209385038\"); properties.setProperty(\"location\", \"D:\\\\a.txt\"); // 打印属性集对象 System.out.println(properties); // 通过键,获取属性值 System.out.println(properties.getProperty(\"filename\")); System.out.println(properties.getProperty(\"length\")); System.out.println(properties.getProperty(\"location\")); // 遍历属性集,获取所有键的集合 Set&lt;String&gt; strings = properties.stringPropertyNames(); // 打印键值对 for (String key : strings ) &#123; System.out.println(key+\" -- \"+properties.getProperty(key)); &#125; &#125;输出结果：&#123;filename=a.txt, length=209385038, location=D:\\a.txt&#125;a.txt209385038D:\\a.txtfilename -- a.txtlength -- 209385038location -- D:\\a.txt 7.2.3与流相关的方法 public void store(OutputStream out, String comments)：把集合临时数据持久化写入到硬盘中存储 public void store(Writer writer, String comments)：把集合临时数据持久化写入到硬盘中存储 12345Outputstream out : 字节输出流,不能写入中文Writer writer : 字符输出流,可以写中文String comments : 注释,用来解释说明保存的文件是做什么用的 不能使用中文，会产生乱码,默认是Unicode编码 一般使用&quot; &quot;空字符串 123456789public static void main(String[] args) throws IOException &#123; Properties properties = new Properties(); // 添加键值对元素 properties.setProperty(\"name\", \"掘金木匠\"); properties.setProperty(\"age\", \"23\"); properties.setProperty(\"location\", \"成都\"); properties.store(new FileWriter(\"1.txt\"),\"info\"); &#125; 代码生成文件： 12345#info#Fri Jan 31 19:19:57 CST 2020location&#x3D;成都age&#x3D;23name&#x3D;掘金木匠 public void load(InputStream inStream)： 从字节输入流中读取键值对，不能读取含有中文的键值对。 public void load(Reader reader)：字符输入流，能读取含有中文的键值对 文本数据格式 存储键值对的文件中，键与值默认的连接符号可以使用=空格(其他符号) 存储键值对的文件中，可以使用#进行注释，被注释的键值对不会再被读取 存储键值对的文件中，键与值默认都是字符串，不用再加引号 12345#info#Fri Jan 31 19:19:57 CST 2020location&#x3D;成都age&#x3D;23name&#x3D;掘金木匠 加载代码演示： 123456789101112131415 public static void main(String[] args) throws FileNotFoundException &#123; // 创建属性集对象 Properties pro = new Properties(); // 加载文本中信息到属性集 pro.load(new FileReader(\"1.txt\")); // 遍历集合并打印 Set&lt;String&gt; strings = pro.stringPropertyNames(); for (String key : strings ) &#123; System.out.println(key+\" -- \"+pro.getProperty(key)); &#125; &#125;输出结果：location -- 成都age -- 23name -- 掘金木匠 8.缓冲流 一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等。 这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，相当于是对基本流对象的一种增强。 8.1 概述 缓冲流，也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。 8.2 字节缓冲流【BufferedInputStream】8.2.1构造方法 public BufferedInputStream(InputStream in) ：创建一个新的缓冲输入流。 public BufferedInputStream(InputStream in, int size)：创建具有指定缓冲区大小的缓冲输入流。 12InputStream in : 字节输入流，可以传递FileInputStream，缓冲流会给FileInputStream增加一个缓冲区，提高FileInputStream的读取效率int size : 指定缓冲流内部缓冲区的大小,不指定默认 public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。 public BufferedOutputStream(OutputStream out, int size)： 创建具有指定缓冲区大小的缓冲输出流。 构造举例，代码如下： 1234// 创建字节缓冲输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"bis.txt\"));// 创建字节缓冲输出流BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"bos.txt\")); 8.2.2效率测试查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。 基本流，代码如下： 12345678910111213141516171819202122 public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( FileInputStream fis = new FileInputStream(\"jdk9.exe\"); FileOutputStream fos = new FileOutputStream(\"copy.exe\") )&#123; // 读写数据 int b; while ((b = fis.read()) != -1) &#123; fos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\"普通流复制时间:\"+(end - start)+\" 毫秒\"); &#125;十几分钟过去了... 缓冲流，代码如下： 12345678910111213141516171819202122 public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"jdk9.exe\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copy.exe\")); )&#123; // 读写数据 int b; while ((b = bis.read()) != -1) &#123; bos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\"缓冲流复制时间:\"+(end - start)+\" 毫秒\"); &#125;缓冲流复制时间:8016 毫秒 如何更快呢？ 使用数组的方式，代码如下： 12345678910111213141516171819202122 public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"jdk9.exe\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copy.exe\")); )&#123; // 读写数据 int len; byte[] bytes = new byte[8*1024]; while ((len = bis.read(bytes)) != -1) &#123; bos.write(bytes, 0 , len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\"缓冲流使用数组复制时间:\"+(end - start)+\" 毫秒\"); &#125;缓冲流使用数组复制时间:666 毫秒 8.3 字符缓冲流【BufferedReader】8.3.1构造方法 public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 public BufferedReader(Reader in, int sz) ：创建一个使用给定大小输出缓冲区的缓冲字符输入流。 public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。 public Bufferedwriter(writer out, int sz)：创建一个使用给定大小输出缓冲区的缓冲字符输出流。 12Writer out ： 字符输出流，可以传递Filewriter,缓冲流会给Filewriter增加一个缓冲区,提高Filewriter的写入效率int sz ： 指定缓冲区的大小,不写默认大小 构造举例，代码如下： 1234// 创建字符缓冲输入流BufferedReader br = new BufferedReader(new FileReader(\"br.txt\"));// 创建字符缓冲输出流BufferedWriter bw = new BufferedWriter(new FileWriter(\"bw.txt\")); 8.3.2特有方法字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。 BufferedReader：public String readLine(): 读一行文字，包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回null BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 readLine方法演示，代码如下： 12345678910111213 public static void main(String[] args) throws IOException &#123; // 创建流对象 BufferedReader br = new BufferedReader(new FileReader(\"in.txt\"));// 定义字符串,保存读取的一行文字 String line = null; // 循环读取,读取到最后返回null while ((line = br.readLine())!=null) &#123; System.out.print(line); System.out.println(\"------\"); &#125;// 释放资源 br.close(); &#125; newLine方法演示，代码如下： 12345678910111213141516171819 public static void main(String[] args) throws IOException &#123; // 创建流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(\"out.txt\")); // 写出数据 bw.write(\"掘金\"); // 写出换行 bw.newLine(); bw.write(\"木\"); bw.newLine(); bw.write(\"匠\"); bw.newLine(); // 释放资源 bw.close(); &#125;输出效果:掘金木匠 8.4练习:文本排序请将文本信息恢复顺序。 1234567893.侍中、侍郎郭攸之、费祎、董允等。8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能,2.宫中府中，俱为一体，陟罚臧否，不宜异同。1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。9.今当远离，临表涕零，不知所言。6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。7.先帝知臣谨慎，故临崩寄臣以大事也。5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。 案例实现12345678910111213141516171819202122232425262728293031323334public class BufferedTest &#123; public static void main(String[] args) throws IOException &#123; // 创建map集合,保存文本数据,键为序号,值为文字 HashMap&lt;String, String&gt; lineMap = new HashMap&lt;&gt;(); // 创建流对象 BufferedReader br = new BufferedReader(new FileReader(\"in.txt\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"out.txt\")); // 读取数据 String line = null; while ((line = br.readLine())!=null) &#123; // 解析文本 String[] split = line.split(\"\\\\.\"); // 保存到集合 lineMap.put(split[0],split[1]); &#125; // 释放资源 br.close(); // 遍历map集合 for (int i = 1; i &lt;= lineMap.size(); i++) &#123; String key = String.valueOf(i); // 获取map中文本 String value = lineMap.get(key); // 写出拼接文本 bw.write(key+\".\"+value); // 写出换行 bw.newLine(); &#125; // 释放资源 bw.close(); &#125;&#125; 9.转换流9.1 字符编码和字符集9.1.1字符编码计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。 按照某种规则，将字符存储到计算机中，称为编码 。 将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。 编码:字符(能看懂的)–字节(看不懂的) 解码:字节(看不懂的)–&gt;字符(能看懂的) 字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。 编码表:生活中文字和计算机中二进制的对应规则 9.1.2字符集 字符集 Charset：是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。 计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。 可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。 ASCII字符集 ： ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。 ISO-8859-1字符集： 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。 ISO-8859-1使用单字节编码，兼容ASCII编码。 GBxxx字符集： GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 ： Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。UTF-8 是 Unicode 的实现方式之一 UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 以汉字严为例，演示如何实现 UTF-8 编码。 严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。 9.2 编码引出的问题在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。 123456789101112public class ReaderDemo &#123; public static void main(String[] args) throws IOException &#123; FileReader fileReader = new FileReader(\"E:\\\\File_GBK.txt\"); int read; while ((read = fileReader.read()) != -1) &#123; System.out.print((char)read); &#125; fileReader.close(); &#125;&#125;输出结果：��� 那么如何读取GBK编码的文件呢？ 9.3InputStreamReader类转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 9.3.1构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12InputStreamReader isr = new InputStreamReader(new FileInputStream(\"in.txt\"));InputStreamReader isr2 = new InputStreamReader(new FileInputStream(\"in.txt\") , \"GBK\"); 9.3.2指定编码读取123456789101112131415161718192021 public static void main(String[] args) throws IOException &#123; // 定义文件路径,文件为gbk编码 String FileName = \"E:\\\\file_gbk.txt\"; // 创建流对象,默认UTF8编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName)); // 创建流对象,指定GBK编码 InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , \"GBK\");// 定义变量,保存字符 int read; // 使用默认编码字符流读取,乱码 while ((read = isr.read()) != -1) &#123; System.out.print((char)read); // ��Һ� &#125; isr.close(); // 使用指定编码字符流读取,正常解析 while ((read = isr2.read()) != -1) &#123; System.out.print((char)read);// 大家好 &#125; isr2.close(); &#125; 9.4OutputStreamWriter类转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 9.4.1构造方法 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(\"out.txt\"));OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(\"out.txt\") , \"GBK\"); 9.4.2指定编码写出1234567891011121314151617 public static void main(String[] args) throws IOException &#123; // 定义文件路径 String FileName = \"E:\\\\out.txt\"; // 创建流对象,默认UTF8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName)); // 写出数据 osw.write(\"你好\"); // 保存为6个字节 osw.close(); // 定义文件路径String FileName2 = \"E:\\\\out2.txt\"; // 创建流对象,指定GBK编码 OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),\"GBK\"); // 写出数据 osw2.write(\"你好\");// 保存为4个字节 osw2.close(); &#125; 9.4.2转换流理解图解转换流是字节与字符间的桥梁！ 9.5 练习：转换文件编码将GBK编码的文本文件，转换为UTF-8编码的文本文件。 123456789101112131415161718192021222324 public static void main(String[] args) &#123; // 1.定义文件路径 String srcFile = \"file_gbk.txt\"; String destFile = \"file_utf8.txt\"; // 2.创建流对象 // 2.1 转换输入流,指定GBK编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile) , \"GBK\"); // 2.2 转换输出流,默认utf8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(destFile)); // 3.读写数据 // 3.1 定义数组 char[] cbuf = new char[1024]; // 3.2 定义长度 int len; // 3.3 循环读取 while ((len = isr.read(cbuf))!=-1) &#123; // 循环写出 osw.write(cbuf,0,len); &#125; // 4.释放资源 osw.close(); isr.close(); &#125;&#125; 10.序列化10.1 概述Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。看图理解序列化： 10.2 ObjectOutputStream类java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件，实现对象的持久存储。 10.2.1构造方法 public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。 构造举例，代码如下： 12FileOutputStream fileOut = new FileOutputStream(\"1.txt\");ObjectOutputStream out = new ObjectOutputStream(fileOut); 10.2.1序列化操作 一个对象要想序列化，必须满足两个条件: 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。 12345678public class Employee implements java.io.Serializable &#123; public String name; public String address; public transient int age; // transient瞬态修饰成员,不会被序列化 public void addressCheck() &#123; System.out.println(\"Address check : \" + name + \" -- \" + address); &#125;&#125; 写出对象方法 public final void writeObject(Object obj) : 将指定的对象写出。 12345678910111213141516171819202122public class SerializeDemo&#123; public static void main(String [] args) &#123; Employee e = new Employee(); e.name = \"zhangsan\"; e.address = \"beiqinglu\"; e.age = 20; try &#123; // 创建序列化流对象 ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"employee.txt\")); // 写出对象 out.writeObject(e); // 释放资源 out.close(); fileOut.close(); System.out.println(\"Serialized data is saved\"); // 姓名，地址被序列化，年龄没有被序列化。 &#125; catch(IOException i) &#123; i.printStackTrace(); &#125; &#125;&#125;输出结果：Serialized data is saved 10.3ObjectInputStream类ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 10.3.1构造方法 public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。 10.3.2反序列化操作1如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法： public final Object readObject () : 读取一个对象。 1234567891011121314151617181920212223242526public static void main(String [] args) &#123; Employee e = null; try &#123; // 创建反序列化流 FileInputStream fileIn = new FileInputStream(\"employee.txt\"); ObjectInputStream in = new ObjectInputStream(fileIn); // 读取一个对象 e = (Employee) in.readObject(); // 释放资源 in.close(); fileIn.close(); &#125;catch(IOException i) &#123; // 捕获其他异常 i.printStackTrace(); return; &#125;catch(ClassNotFoundException c) &#123; // 捕获类找不到异常 System.out.println(\"Employee class not found\"); c.printStackTrace(); return; &#125; // 无异常,直接打印输出 System.out.println(\"Name: \" + e.name); // zhangsan System.out.println(\"Address: \" + e.address); // beiqinglu System.out.println(\"age: \" + e.age); // 0 &#125; 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。 10.3.3反序列化操作2另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下： 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法 Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。 123456789101112public class Employee implements java.io.Serializable &#123; // 加入序列版本号 private static final long serialVersionUID = 1L; public String name; public String address; // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值. public int eid; public void addressCheck() &#123; System.out.println(\"Address check : \" + name + \" -- \" + address); &#125;&#125; 10.4 练习：序列化集合 将存有多个自定义对象的集合序列化操作，保存到list.txt文件中。 反序列化list.txt ，并遍历集合，打印对象信息。 案例分析 把若干学生对象 ，保存到集合中。 把集合序列化。 反序列化读取时，只需要读取一次，转换为集合类型。 遍历集合，可以打印所有的学生信息 案例实现12345678910111213141516171819202122232425262728293031323334public class SerTest &#123; public static void main(String[] args) throws Exception &#123; // 创建 学生对象 Student student = new Student(\"老王\", \"laow\"); Student student2 = new Student(\"老张\", \"laoz\"); Student student3 = new Student(\"老李\", \"laol\"); ArrayList&lt;Student&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(student); arrayList.add(student2); arrayList.add(student3); // 序列化操作 // serializ(arrayList); // 反序列化 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"list.txt\")); // 读取对象,强转为ArrayList类型 ArrayList&lt;Student&gt; list = (ArrayList&lt;Student&gt;)ois.readObject(); for (int i = 0; i &lt; list.size(); i++ )&#123; Student s = list.get(i); System.out.println(s.getName()+\"--\"+ s.getPwd()); &#125; &#125; private static void serializ(ArrayList&lt;Student&gt; arrayList) throws Exception &#123; // 创建 序列化流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"list.txt\")); // 写出对象 oos.writeObject(arrayList); // 释放资源 oos.close(); &#125;&#125; 11.打印流11.1 概述平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。 11.2 PrintStream类 PrintStream为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。 PrintStream特点: 只负责数据的输出，不负责数据的读取 与其他输出流不同，PrintStream 永远不会抛出IOException 有特有的方法, print, println void print (任意类型的值) void println(任意类型的值并换行) 11.2.1构造方法 public PrintStream(String fileName)： 使用指定的文件名创建一个新的打印流。 PrintStream(File file)： 输出的目的地是一个文件 PrintStream(OutputStream out) ： 输出的目的地是一个字节输出流 1PrintStream ps = new PrintStream(\"ps.txt\")； 11.2.2改变打印流向 System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以改变输出语句的目的地(打印流的流向)输出语句 static void setOut(PrintStream out)：重新分配“标准”输出流。 123456789101112 public static void main(String[] args) throws IOException &#123;// 调用系统的打印流,控制台直接输出97 System.out.println(97); // 创建打印流,指定文件的名称 PrintStream ps = new PrintStream(\"ps.txt\"); // 设置系统的打印流流向,输出到ps.txt System.setOut(ps); // 调用系统的打印流,ps.txt中输出97 System.out.println(97); &#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://goldcarpenter.github.io/tags/Java/"},{"name":"IO","slug":"IO","permalink":"http://goldcarpenter.github.io/tags/IO/"}]},{"title":"JavaIO","date":"2019-03-01T16:00:00.000Z","path":"2019/03/02/javaIO_Part2/","text":"JavaIO3.字节流3.1字节输出流【OutputStream】java.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) ：从指定的字节数组写入len字节，从偏移量off开始输出到此输出流。 public abstract void write(int b) ：将一个字节写入指定的字节输出流。 close方法，当完成流的操作时，必须调用此方法，释放系统资源。 3.2FileOutputStream类java.io.FileOutputStream类是文件输出流，用于将数据写出到文件。 3.2.1构造方法 public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。 1234构造方法1.创建一个FileOutputStream对象2.会根据构造方法中传递的文件&#x2F;文件路径,创建一个空的文件3.会把FileOutputStream对象指向创建好的文件 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。 构造举例，代码如下： 12345678public static void main(String[] args) throws FileNotFoundException &#123; // 使用File对象创建流对象 File file = new File(\"a.txt\"); FileOutputStream fos = new FileOutputStream(file); // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"b.txt\");&#125; 2.2.2写出字节数据 写入数据的原理(内存→硬盘)java程序→JVM(java虚拟机)→OS (操作系统)→OS调用写数据的方法→把数据写入到文件中 字节输出流的使用步骤(重点) 创建一个FileOutputstream对象，构造方法中传递写入数据的目的地 调用FileOutputStream对象中的方法write，把数据写入到文件中 释放资源 写出字节：write(int b) 方法，每次可以写出一个字节数据 12345678910111213141516171819public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"); // 写出数据 fos.write(97); // 写出第1个字节 fos.write(98); // 写出第2个字节 fos.write(99); // 写出第3个字节 // 关闭资源 fos.close(); &#125;&#125;输出结果：abc结果解释 任意的文本编辑器(记事本,notepad++...)在打开文件的时候都会查询编码表把字节转换为字符表示0-127:查询ASCII表---97--&gt;a其他值:查询系统默认码表(中文系统GBK：两个字节一个中文) 写出字节数组：write(byte[] b)，每次可以写出数组中的数据 123456789101112 public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"); // 字符串转换为字节数组 byte[] b = \"掘金木匠\".getBytes(); // 写出字节数组数据 fos.write(b); // 关闭资源 fos.close(); &#125;输出结果：掘金木匠 写出指定长度字节数组：write(byte[] b, int off, int len) ,每次写出从off索引开始，len个字节 123456789101112 public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"); // 字符串转换为字节数组 byte[] b = \"abcde\".getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b,2,2); // 关闭资源 fos.close(); &#125;输出结果：cd 2.2.3数据追加续写 public FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。 这两个构造方法，参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了 123456789101112 public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"，true); // 字符串转换为字节数组 byte[] b = \"abcde\".getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b); // 关闭资源 fos.close(); &#125;文件操作前：cd文件操作后：cdabcde 2.2.4写出换行 回车符\\r和换行符\\n ： 回车符：回到一行的开头（return） 换行符：下一行（newline） OS Windows系统里，每行结尾是 回车+换行 ，即\\r\\n Unix系统里，每行结尾只有 换行 ，即\\n 12345678910111213141516171819202122 public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"); // 定义字节数组 byte[] words = &#123;97,98,99,100,101&#125;; // 遍历数组 for (int i = 0; i &lt; words.length; i++) &#123; // 写出一个字节 fos.write(words[i]); // 写出一个换行, 换行符号转成数组写出 fos.write(\"\\r\\n\".getBytes()); &#125; // 关闭资源 fos.close(); &#125;输出结果：abcde 3.3字节输入流【InputStream】java.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。 public abstract int read()： 从输入流读取数据的下一个字节。 public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组b中 。 close方法，当完成流的操作时，必须调用此方法，释放系统资源。 3.4FileInputStream类java.io.FileInputStream类是文件输入流，从文件中读取字节。 3.4.1构造方法 FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 123构造方法的作用:1.会创建一个FileInputStream对象2.会把FileInputStream对象指定构造方法中要读取的文件 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 构造举例，代码如下： 12345678public static void main(String[] args) throws FileNotFoundException &#123; // 使用File对象创建流对象 File file = new File(\"a.txt\"); FileInputStream fos = new FileInputStream(file); // 使用文件名称创建流对象 FileInputStream fos = new FileInputStream(\"b.txt\");&#125; 3.4.2读取字节数据 读取数据的原理(硬盘–&gt;内存) java程序→JVM→OS→OS读取数据的方法→读取文件 字节输入流的使用步骤(重点) 创建FileInputstream对象，构造方法中绑定要读取的数据源 使用FileInputStream对象中的方法read，读取文件 释放资源 读取字节：read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回-1，代码使用演示： 123456789101112131415161718 public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream(\"read.txt\"); // 定义变量，保存数据 int b ； // 循环读取 while ((b = fis.read())!=-1) &#123; System.out.println((char)b); &#125; // 关闭资源 fis.close(); &#125;输出结果：abcde 虽然读取了一个字节，但是会自动提升为int类型。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 使用字节数组读取：read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1 1234567891011121314151617181920 public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream(\"read.txt\"); // 文件中为abcde // 定义变量，作为有效个数 int len ； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while ((len= fis.read(b))!=-1) &#123; // 每次读取后,把数组变成字符串打印 System.out.println(new String(b)); &#125; // 关闭资源 fis.close(); &#125;输出结果：abcded 错误数据d，是由于最后一次读取时，只读取一个字节e，数组中，上次读取的数据没有被完全替换，所以要通过len ，获取有效的字节，代码使用演示： 1234567891011121314151617181920 public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream(\"read.txt\"); // 文件中为abcde // 定义变量，作为有效个数 int len ； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) &#123; // 每次读取后,把数组的有效字节部分，变成字符串打印 System.out.println(new String(b,0, len));// len 每次读取的有效字节个数 &#125; // 关闭资源 fis.close(); &#125;输出结果：abcde 使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。 3.5 图片复制复制图片文件，代码使用演示： 123456789101112131415161718192021222324public class Copy &#123; public static void main(String[] args) throws IOException &#123; // 1.创建流对象 // 1.1 指定数据源 FileInputStream fis = new FileInputStream(\"D:\\\\test.jpg\"); // 1.2 指定目的地 FileOutputStream fos = new FileOutputStream(\"test_copy.jpg\"); // 2.读写数据 // 2.1 定义数组 byte[] b = new byte[1024]; // 2.2 定义长度 int len; // 2.3 循环读取 while ((len = fis.read(b))!=-1) &#123; // 2.4 写出数据 fos.write(b, 0 , len); &#125; // 3.关闭资源 fos.close(); fis.close(); &#125;&#125; 流的关闭原则：先开后关，后开先关。 4.字符流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 4.1字符输入流【Reader】java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。 public void close() ：关闭此流并释放与此流相关联的任何系统资源。 public int read()： 从输入流读取一个字符。 public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。 4.2FileReader类java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。 idea中UTF-8 字节缓冲区：一个字节数组，用来临时存储字节数据。 4.2.1构造方法 FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。 123FileReader构造方法的作用:1.创建一个FileReader对象2.会把FileReader对象指向要读取的文件 当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 构造举例，代码如下： 12345678public static void main(String[] args) throws FileNotFoundException &#123; // 使用File对象创建流对象 File file = new File(\"a.txt\"); FileReader fr = new FileReader(file); // 使用文件名称创建流对象 FileReader fr = new FileReader(\"b.txt\");&#125; 4.2.2读取字符数据 读取字符：read方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回-1，循环读取，代码使用演示： 1234567891011121314151617 public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader(\"read.txt\"); // 定义变量，保存数据 int b ； // 循环读取 while ((b = fr.read())!=-1) &#123; System.out.println((char)b); &#125; // 关闭资源 fr.close(); &#125;输出结果：掘金木匠 虽然读取了一个字符，但是会自动提升为int类型。 Unicode是一种字符集(charset)，用四个字节就能囊括世界上所有的文字集合。 UTF-8是一种编码方式(encoding)，是Unicode的一种表现方式。 使用字符数组读取：read(char[] cbuf)，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回-1 ，代码使用演示： 1234567891011121314151617181920 public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader(\"read.txt\"); // 定义变量，保存有效字符个数 int len ； // 定义字符数组，作为装字符数据的容器 char[] cbuf = new char[2]; // 循环读取 while ((len = fr.read(cbuf))!=-1) &#123; System.out.println(new String(cbuf,0,len)); &#125; // 关闭资源 fr.close(); &#125;输出结果：掘金木匠么么哒 4.3 字符输出流【Writer】java.io.Writer抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。 void write(int c) 写入单个字符。 void write(char[] cbuf)写入字符数组。 abstract void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 void write(String str)写入字符串。 void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。 void flush()刷新该流的缓冲。 void close() 关闭此流，但要先刷新它。 4.4 FileWriter类java.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 4.4.1构造方法 FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。 FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。 构造举例，代码如下： 12345678public static void main(String[] args) throws IOException &#123; // 使用File对象创建流对象 File file = new File(\"a.txt\"); FileWriter fw = new FileWriter(file); // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"b.txt\");&#125; 4.4.2基本写出数据 字符输出流的使用步骤(重点) 创建Filewriter对象,构造方法中绑定要写入数据的目的地 使用FileWriter中的方法write ,把数据写入到内存缓冲区中(字符转换为字节的过程) 使用Filewriter中的方法flush,把内存缓冲区中的数据，刷新到文件中 释放资源(会先把内存缓冲区中的数据刷新到文件中) 写出字符：write(int b) 方法，每次可以写出一个字符数据，代码使用演示： 123456789101112131415161718 public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"fw.txt\"); // 写出数据 fw.write(97); // 写出第1个字符 fw.write('b'); // 写出第2个字符 fw.write('C'); // 写出第3个字符 fw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。 /* 【注意】关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。 */ // fw.close(); &#125;输出结果：abC田 虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。 未调用close/flush方法，数据只是保存到了缓冲区，并未写出到文件中。 4.4.3关闭和刷新因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush 方法了。 flush ：刷新缓冲区，流对象可以继续使用。 close：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 代码使用演示： 123456789101112131415public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"fw.txt\"); // 写出数据，通过flush fw.write('刷'); // 写出第1个字符 fw.flush(); fw.write('新'); // 继续写出第2个字符，写出成功 fw.flush(); // 写出数据，通过close fw.write('关'); // 写出第1个字符 fw.close(); fw.write('闭'); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed fw.close();&#125; 即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。 4.4.4写出其他数据 写出字符数组 ：write(char[] cbuf) 和 write(char[] cbuf, int off, int len) ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示： 123456789101112131415 public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"fw.txt\"); // 字符串转换为字节数组 char[] chars = \"掘金木匠\".toCharArray(); // 写出字符数组 fw.write(chars); // 掘金木匠 // 写出从索引2开始，2个字节。索引2是'木'，两个字节，也就是'木匠'。 fw.write(b,2,2); // 程序 // 关闭资源 fos.close(); &#125; 写出字符串：write(String str) 和 write(String str, int off, int len) ，每次可以写出字符串中的数据，更为方便，代码使用演示： 123456789101112131415 public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"fw.txt\"); // 字符串 String msg = \"掘金木匠\"; // 写出字符数组 fw.write(msg); //掘金木匠 // 写出从索引2开始，2个字节。索引2是'木'，两个字节，也就是'木匠'。 fw.write(msg,2,2); // 程序 // 关闭资源 fos.close(); &#125; 续写和换行：操作类似于FileOutputStream。 123456789101112131415 public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象，可以续写数据 FileWriter fw = new FileWriter(\"fw.txt\"，true); // 写出字符串 fw.write(\"掘金\"); // 写出换行 fw.write(\"\\r\\n\"); // 写出字符串 fw.write(\"木匠\"); // 关闭资源 fw.close(); &#125;输出结果:掘金木匠 字符流，只能操作文本文件，不能操作图片，视频等非文本文件 当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流 5.字节流 VS 字符流 字节流可以处理所有类型数据，如：MP3，AVI 视频文件，图片 字符流只能处理字符数据。只要是处理纯文本数据，就要优先考虑使用字符流，除此之外都用字节流。 字节流在操作的时候本身是不会用到缓冲区（内存）的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的 字节流在操作文件时，即使不关闭资源（close方法），文件也能输出，但是如果字符流不使用close方法的话，则不会输出任何内容，说明字符流用的是缓冲区，并且可以使用flush方法强制进行刷新缓冲区，这时才能在不close的情况下输出内容","tags":[{"name":"Java","slug":"Java","permalink":"http://goldcarpenter.github.io/tags/Java/"},{"name":"IO","slug":"IO","permalink":"http://goldcarpenter.github.io/tags/IO/"}]},{"title":"JavaIO","date":"2019-02-19T16:00:00.000Z","path":"2019/02/20/javaIO_Part1/","text":"1.File类1.1 概述 java.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作 File类是一个与系统无关的类，任何的操作系统都可以使用这个类中的方法 1.2静态成员变量 static String pathSeparator：与系统有关的路径分隔符，为了方便，它被表示为一个字符串。 static char pathSeparatorChar：与系统有关的路径分隔符。 static string separator：与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。 static char separatorChar：与系统有关的默认名称分隔符。 1.3 构造方法 public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的File实例。 public File(String parent, String child) ：拼接 父路径名字符串和子路径名字符串创建新的 File实例。 public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例。 构造举例，代码如下： 无论该路径下是否存在文件或者目录，都不影响File对象的创建。 路径可以是以文件结尾，也可以是以文件夹结尾 路径可以是相对路径,也可以是绝对路径 路径可以是存在，也可以是不存在 创建File对象，只是把字符串路径封装为File对象，不考虑路径的真假情况 1.4 常用方法1.4.1获取功能的方法 public String getAbsolutePath() ：返回此File的绝对路径名字符串。 public String getPath() ：将此File转换为绝对/相对路径名字符串，toString调用此方法实现。 public String getName() ：返回由此File表示的文件或目录的名称。 public long length() ：返回由此File表示的文件的大小，字节单位。 API中说明：length()——表示文件的大小。但是File对象表示目录，则返回值0。 1.4.2绝对路径和相对路径 绝对路径：从盘符开始的路径，这是一个完整的路径。 相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。 1234567891011121314public class FilePath &#123; public static void main(String[] args) &#123; // D盘下的bbb.java文件 File f = new File(\"D:\\\\bbb.java\"); System.out.println(f.getAbsolutePath()); // 项目下的bbb.java文件 File f2 = new File(\"bbb.java\"); System.out.println(f2.getAbsolutePath()); &#125;&#125;输出结果：D:\\bbb.javaD:\\idea_project_test4\\bbb.java 1.4.3判断功能的方法 public boolean exists() ：此File表示的文件或目录是否实际存在。 public boolean isDirectory() ：此File表示的是否为目录。 public boolean isFile() ：此File表示的是否为文件。 isFile() &amp; isDirectory() 使用前提，路径必须是存在的，否则都返回false 1.4.4创建删除功能的方法 public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 只能创建文件，不能创建文件夹 创建文件的路径必须存在，否则会抛出异常 文件存在，不会创建，返回false public boolean delete() ：删除由此File表示的文件或目录。 如果此File表示目录，文件夹中有内容，不会删除返回false，目录必须为空才能删除 构造方法中路径不存在，返回false 直接在硬盘删除文件/文件夹，不走回收站，删除要谨慎 public boolean mkdir() 【不常用】：创建由此File表示的单级目录。 文件夹存在，不会创建，返回false 构造方法中给出的路径不存在，返回false public boolean mkdirs() 【常用】：创建由此File表示的目录，包括任何必需但不存在的父目录。 既可以创建单级文件夹，也可以创建多级文件夹 1.5目录的遍历 public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 12345678910111213141516public class FileFor &#123; public static void main(String[] args) &#123; File dir = new File(\"d:\\\\java_code\"); //获取当前目录下的文件以及文件夹的名称。 String[] names = dir.list(); for(String name : names)&#123; System.out.println(name); &#125; //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息 File[] files = dir.listFiles(); for (File file : files) &#123; System.out.println(file); &#125; &#125;&#125; 调用遍历方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。 可以遍历到隐藏的文件夹 1.6文件过滤器实现 java.io.FileFilter是一个接口，File过滤器。 该接口的对象可以传递给File类listFiles(FileFilter) 作为参数， 接口中只有一个方法。 boolean accept(File pathname) ：测试pathname是否应该包含在当前File目录中，符合则返回true。 分析： 接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。 accept方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则： 要么是.java文件。 要么是目录，用于继续遍历。 通过过滤器的作用，listFiles(FileFilter)返回的数组元素中，子文件对象都是符合条件的，可以直接打印。 代码实现： 123456789101112131415161718192021222324public class DiGuiDemo4 &#123; public static void main(String[] args) &#123; File dir = new File(\"D:\\\\aaa\"); printDir2(dir); &#125; public static void printDir2(File dir) &#123; // 匿名内部类方式,创建过滤器子类对象 File[] files = dir.listFiles(new FileFilter() &#123; @Override public boolean accept(File pathname) &#123; return pathname.getName().endsWith(\".java\")||pathname.isDirectory(); &#125; &#125;); // 循环打印 for (File file : files) &#123; if (file.isFile()) &#123; System.out.println(\"文件名:\" + file.getAbsolutePath()); &#125; else &#123; printDir2(file); &#125; &#125; &#125;&#125; 1.7文件过滤器实现Lambda优化分析：FileFilter是只有一个方法的接口，因此可以用lambda表达式简写。 lambda格式： 1()-&gt;&#123; &#125; 代码实现： 123456789101112131415public static void printDir3(File dir) &#123; // lambda的改写 File[] files = dir.listFiles(f -&gt;&#123; return f.getName().endsWith(\".java\") || f.isDirectory(); &#125;); // 循环打印 for (File file : files) &#123; if (file.isFile()) &#123; System.out.println(\"文件名:\" + file.getAbsolutePath()); &#125; else &#123; printDir3(file); &#125; &#125;&#125; 2.IO流2.1IO的分类根据数据的流向分为：输入流和输出流。 输入流 ：把数据从其他设备上读取到内存中的流。 输出流 ：把数据从内存 中写出到其他设备上的流。 格局数据的类型分为：字节流和字符流。 字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 2.2顶级父类 输入流 输出流 字节流 字节输入流InputStream 字节输出流OutputStream 字符流 字符输入流Reader 字符输出流Writer","tags":[{"name":"Java","slug":"Java","permalink":"http://goldcarpenter.github.io/tags/Java/"},{"name":"IO","slug":"IO","permalink":"http://goldcarpenter.github.io/tags/IO/"}]},{"title":"hexo博客绑定自定义域名","date":"2019-02-18T11:40:20.000Z","path":"2019/02/18/hexo博客绑定域名/","text":"1.准备 一个已经备案的阿里云域名（国内备案可太麻烦了） 一般域名实名认证通过后2-3天，才会恢复解析 2.前置知识 修改阿里云域名解析 主机记录 &amp; 记录值 &amp; 记录类型 主机记录【设置子域名】：指创建子域名时所添加域名前缀 主机记录 说明 www 解析后的域名为www.aliyun.com @ 直接解析主域名 aliyun.com ***** 泛解析，匹配其他所有域名 *.aliyun.com mail 将域名解析为mail.aliyun.com，通常用于解析邮箱服务器 二级域名 如：abc.aliyun.com，填写abc 三级域名 a.www.example.com，填写a.www 手机网站 如：m.aliyun.com，填写m 记录值是指需要将子域名指向哪个解析地址 可以输入服务器IP地址，也可以输入域名 记录类型 A记录：最普通常见的域名解析，是把某一主机名解析到服务器IP 主机记录 类型 记录值 www A 192.168.0.1 CNAME记录：是主机名到主机名的映射 主机记录 类型 记录值 @ CNAME othername.com AAAA：用来指定主机名（或域名）对应的IPv6地址。A记录对应的是IPV4地址 url转发：可以转发到某一个目录下，甚至某一个文件上。 url转发和cname的主要区别：CNAME记录是不可以转发到某一个目录下，甚至某一个文件上 3.配置阿里云域名解析 无论是A记录、CNAME、URL转发在实际使用时是全部可以设置多条记录的 为了之后项目域名保留，博客使用二级域名scu.yangyuxin.top 使用在线域名解析发现原域名对应多个IP，可能做了负载均衡，故记录类型没有使用A类型 记录类型 主机记录 记录值 CNAME scu 博客原域名 获取博客IP地址方法 cmd窗口中ping 博客原goldcarpenter.github.io 网页在线域名解析服务获取 在本地博客..\\source中新建CNAME文件，注意无拓展名，内容输入scu.yangyuxin.top【新域名】 使用git shell 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 如此 在github的博客仓库中就会设置自定义域名，已经修改，无需再次修改 大功告成","tags":[{"name":"hexo","slug":"hexo","permalink":"http://goldcarpenter.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://goldcarpenter.github.io/tags/github/"}]},{"title":"Java内部类","date":"2019-02-12T04:53:21.000Z","path":"2019/02/12/内部类/","text":"内部类 分类 成员内部类 局部内部类(包含匿名内部类) 1.成员内部类 定义格式： 12345修饰符 class 外部类名称&#123; 修饰符 class 内部类名称&#123; //... &#125;&#125; 案例 123456789101112131415161718public class Body &#123; //外部类 private String name; Body(String name) &#123; this.name = name; &#125; //外部类的方法——外部类用内部类，需要内部类对象 public void alive() &#123; new Heart().beat(); &#125; //成员内部类 public class Heart &#123; public void beat() &#123; //内部类用外部类，随意访问 System.out.println(name + \"心脏跳动! \"); &#125; &#125;&#125; 1.1如何使用成员内部类 间接方式：在外部类的方法当中，使用内部类。然后只是调用外部类的方法 123Body body = new Body(\"掘金木匠\");// 在外部类的方法当中，使用内部类body.alive(); 直接方式：公式：[外部类名称.内部类名称对象名= new外部类名称().new内部类名称();] 12Body.Heart heart = new Body(\"掘金木匠\").new Heart();heart.beat(); 1.2内部类同名变量 如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名 12345678910111213public class Outer &#123; int num = 10; //外部类的成员变量 public class Inner /*extends object*/ &#123; int num = 20; //内部类的成员变量 public void methodInner() &#123; int num = 30; //内部类方法的局部变量 System.out.println(num); //局部变量，就近原则 System.out.println(this.num); //内部类的成员变量 System.out.println(Outer.this.num); //外部类的成员变量 &#125; &#125;&#125; 2.局部内部类 如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。 局部：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。 定义格式: 1234567修饰符 class 外部类名称&#123; 修饰符 返回值类型 外部类方法名称(参数列表) &#123; class 局部内部类名称&#123; // &#125; &#125;&#125; 案例 123456789101112public class Outer &#123; public void method0uter()&#123; class Inner &#123; //局部内部类 int num = 10; public void methodInner() &#123; System.out.println(num); // 10 &#125; &#125; Inner inner = new Inner(); inner.methodInner(); &#125;&#125; 2.1 局部内部类final问题 局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是有效final的 原因 new出来的对象在堆内存当中。 局部变量是跟着方法走的，在栈内存当中。 方法运行结束之后，立刻出栈，局部变量就会立刻消失。 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。 局部变量与局部内部类的对象的生命周期不同； 为解决这一问题，Java把局部内部类要访问的局部变量重新拷贝了一份，并把备份放在内部类的常量池中，这样不论方法有没有执行结束，拷贝都是存在的，就不会再出现访问不存在的变量的错误了。 123456789101112public class MyOuter &#123; public void method0uter() &#123; // ⭐从Java 8开始，只要局部变量事实不变，那么final关键字可以省略。 final int num = 10; //所在方法的局部变量// num = 130; × class MyInner&#123; public void methodInner() &#123; System.out.println(num); &#125; &#125; &#125;&#125; 局部内部类访问的是方法体的参数呢？ Java采取的方法是，默认为局部内部类的构造方法传入该参数作为构造方法的参数，然后用该参数来初始化内部类中拷贝的变量a。 上面通过拷贝一份局部变量来解决生命周期不同的问题，如果方法体和局部内部类都改变了a的值会怎么样呢？ Java规定局部内部类可访问的局部变量必须为final的，即内部类不能改变要访问的局部变量的值，这样就不会出现数据不同步的问题了。 3 匿名内部类【局部内部类特例】 如果接口的实现类/父类的子类只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用匿名内部类 定义格式 123接口名称 对象名 = new 接口名称() &#123; // 覆盖重写所有抽象方法&#125;; 案例 1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; ArrayList&lt;String&gt; col = new ArrayList&lt;&gt;(); Collections.addAll(col,\"a\",\"b\",\"c\"); //============================================== // 局部内部类 class ConsumerImpl implements Consumer&lt;String&gt; &#123; @Override public void accept(String s) &#123; System.out.println(s); &#125; &#125; ConsumerImpl consumer = new ConsumerImpl(); col.stream().forEach(consumer); //============================================== // 匿名内部类 col.stream().forEach(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) &#123; System.out.println(s); &#125; &#125;); //============================================== // lambda表达式 col.stream().forEach(s -&gt; System.out.println(s)); //============================================== // 方法引用 col.stream().forEach(System.out::println); &#125; 3.1 匿名对象 创建对象时，只有创建对象的语句，却没有把对象地址赋值给某个变量 虽然是创建对象的简化写法，但是应用场景非常有限。 语法格式： 1new 类名(参数列表)； 应用场景 创建匿名对象直接调用方法，没有变量名 12new Scanner(System.in).nextInt();new Scanner(System.in).nextInt(); 匿名对象可以作为方法的参数和返回值 作为参数 123456789101112class Test &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = new Scanner(System.in); input(sc); //匿名对象作为方法接收的参数 input(new Scanner(System.in)); &#125; public static void input(Scanner sc)&#123; System.out.println(sc); &#125;&#125; 作为返回值 12345678910111213class Test2 &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = getScanner(); &#125; public static Scanner getScanner()&#123; //普通方式 //Scanner sc = new Scanner(System.in); //return sc; //匿名对象作为方法返回值 return new Scanner(System.in); &#125; &#125; 3.2匿名内部类 VS 匿名对象 匿名内部类，在【创建对象】的时候，只能使用唯一一次；如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了。 匿名对象，在【调用方法】的时候，只能调用唯一一次；如果希望同一个对象，调用多次方法，那么必须给对象起个名字。 匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】 强调：匿名内部类和匿名对象不是一回事 4.类的权限修饰符 类的权限修饰符：public &gt; protected &gt; (default) &gt; private 定义一个类的时候，权限修饰符规则 外部类：public / (default) 成员内部类：public / protected / (default) / private 局部内部类：什么都不能写 5.编译后.Class文件 外部类保存为：外部类.class 内部类保存为：外部类$内部类.class 6.访问权限 内部类用外部类，随意访问 外部类用内部类，需要内部类对象 12345678910111213141516171819public class Body &#123; //外部类 private String name; Body(String name) &#123; this.name = name; &#125; //外部类的方法——外部类用内部类，需要内部类对象 public void alive() &#123; new Heart().beat(); &#125; //成员内部类 public class Heart &#123; public void beat() &#123; //内部类用外部类，随意访问 System.out.println(name + \"心脏跳动! \"); &#125; &#125;&#125;","tags":[{"name":"内部类","slug":"内部类","permalink":"http://goldcarpenter.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"}]},{"title":"注解总结","date":"2019-01-23T12:57:35.000Z","path":"2019/01/23/注解/","text":"注解定义 注解(Annotation)，又称元数据。一种代码级别的说明。 它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。 它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 作用分类 编写文档：通过代码里标识的注解生成文档【生成文档doc文档】cmd--javadoc MyJava.java 12345678910&#x2F;** * @author goldcarpenter * @project carpenteredis * @create 2020-02-04 11:46 *&#x2F; &#x2F;** * 方法功能 * @param selectionKey *&#x2F; 代码分析：通过代码里标识的注解对代码进行分析【使用反射】 编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【例如@Override @FunctionalInterface】 JDK中预定义的一些注解 @Override：检测被该注解标注的方法是否是继承自父类(接口)的 @Deprecated：该注解标注的内容,表示已过时 @SuppressWarnings：压制警告 一般传递参数all–@SuppressWarnings(&quot;all&quot;) 自定义注解 格式 123public @interface [MyAnno]&#123; 属性列表&#125; 本质：是一个接口，该接口默认继承Annotation接口 123public interface MyAnno extends java.lang.annotation.Annotation &#123;&#125; 属性：接口中的抽象方法 12345@interface MyAnno&#123; public abstract String[] value(); public abstract String name(); public abstract int age() default 18; [public abstract 本质接口可省略]&#125; 属性要求: 属性的返回值类型有下列取值 基本数据类型【没有包装类】 String 枚举 注解 以上类型的数组 【没有 void 和 自定义类对象】 定义了属性，在使用时需要给属性赋值 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。 12@MyAnno(value &#x3D; &#123;&quot;str1&quot;, &quot;str2&quot;&#125;, name&#x3D;&quot;yyx&quot;)public void MyFun()&#123;&#125; 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}省略 元注解 定义:用于描述注解的注解 @Target：描述注解能够作用的位置 TYPE：可以作用于类上 METHOD：可以作用于方法上 FIELD：可以作用于成员变量上 @Retention：描述注解被保留的阶段 @Retention(RetentionPolicy.RUNTIME)：注解会保留到class字节码文件中，并被JVM读取到 @Retention(RetentionPolicy.Class)：注解会保留到class字节码文件中 @Retention(RetentionPolicy.Source)：当前被描述的注解，仅保留到源码 @Documented：描述注解是否被抽取到api文档中 @Inherited：描述注解是否被子类继承 在程序解析注解 要获取类 方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation对象，除此之外没有别的获取注解对象的方法 获取注解中定义的属性值 获取注解定义的位置的对象(Class对象 Method对象 Field对象) 获取指定的注解MyAnno myAnno = 对象.getAnnotation(Class) 12345678//其实就是在内存中生成了一个该注解接口的子类实现对象public class MyAnnoImpl implements MyAnno&#123; public String className()&#123; return '注解属性值' &#125; public string methodName()&#123; return '注解属性值'; &#125; 调用注解中的抽象方法获取配置的属性值myAnno.methodName()","tags":[{"name":"注解","slug":"注解","permalink":"http://goldcarpenter.github.io/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"Github无法登陆","date":"2018-12-15T16:00:00.000Z","path":"2018/12/16/GithububNologin/","text":"问题 最初在使用git时出现报错，如下 123456$ git push -u origin masterssh: Could not resolve hostname github.com: Temporary failure in name resolutionfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 登陆github.com，报告404 ping github.com，超时 解决 需要在host文件里做些修改 1C:\\Windows\\System32\\drivers\\etc Win10操作系统，先给自己最高权限【右键-属性-安全-编辑】 在host文件追加内容 12345678192.30.253.113 github.com192.30.252.131 github.com185.31.16.185 github.global.ssl.fastly.net74.125.237.1 dl-ssl.google.com173.194.127.200 groups.google.com192.30.252.131 github.com185.31.16.185 github.global.ssl.fastly.net74.125.128.95 ajax.googleapis.com ping github.com，成功 登陆github.com，成功 将host文件权限恢复","tags":[{"name":"hexo","slug":"hexo","permalink":"http://goldcarpenter.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://goldcarpenter.github.io/tags/github/"}]},{"title":"Java异常体系总结","date":"2018-11-29T12:13:52.000Z","path":"2018/11/29/Java异常/","text":"异常1.Throwable异常体系 异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception 平常所说的异常指java.lang.Exception Error错误 Error：严重错误Error，无法通过处理的错误，只能事先避免。 123456789/*Error:错误 OutOfMemoryError: Java heap space 内存溢出的错误,创建的数组太大了,超出了给JVM分配的内存*/int[] arr = new int[1024*1024*1024];//必须修改代码,创建的数组小一点int[] arr = new int[1024*1024];System.out.println(\"后续代码\"); Exception异常 Exception：表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。 Throwable中的常用方法 public void printStackTrace()：打印异常的详细信息。包含了异常的类型，异常的原因，还包括异常出现的位置，在开发和调试阶段，都得使用printStackTrace。 public String getMessage()：获取发生异常的原因。提示给用户的时候,就提示错误原因。 2.异常分类 我们平常说的异常就是指Exception 异常(Exception)的分类：根据在编译时期还是运行时期检查异常细分 编译时期异常 编译时期异常：checked异常。在编译时期就会检查，如果没有处理异常，则编译失败。(如日期格式化异常) 12345678SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");//用来格式化日期Date date = null;try &#123; date = sdf.parse(\"1999-0909\");//把字符串格式的日期,解析为Date格式的日期&#125; catch (ParseException e) &#123; e.printStackTrace();&#125;System.out.println(date); 运行时期异常 运行时期异常：runtime异常。在运行时期检查异常，在编译时期，运行异常不会编译器检测(不报错)。(如数学异常) 12345678910//RuntimeException:运行期异常,java程序运行过程中出现的问题int[] arr = &#123;1,2,3&#125;;//System.out.println(arr[0]);try &#123; //可能会出现异常的代码 System.out.println(arr[3]);&#125;catch(Exception e)&#123; //异常的处理逻辑 System.out.println(e);&#125; 3.异常的产生过程解析图解异常产生的过程 4.异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws 抛出异常throw 在编写程序时，程序出现问题的情况出现时需要使用抛出异常的方式来告诉调用者。 throw用在方法内，程序出现问题时用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 创建一个异常对象，封装一些提示信息(信息可以自己编写)。 通过关键字throw将这个异常对象传递到调用者处。 使用格式： 1throw new 异常类名(参数); 例如： 12throw new NullPointerException(\"要访问的arr数组不存在\");throw new ArrayIndexOutOfBoundsException(\"该索引在数组中不存在，已超出范围\"); 注意事项: throw关键字必须写在方法的内部 throw关键字后边new的对象必须是Exception或者Exception的子类对象 throw关键字抛出指定的异常对象，我们就必须处理这个异常对象 throw关键字后边创建的是RuntimeException或者是RuntimeException的子类对象，可以不处理，默认交给JVM处理(打印异常对象,中断程序) throw关键字后边创建的是编译异常(写代码的时候报错)，我们就必须处理这个异常，要么throws,要么try...catch 1234567891011121314151617181920212223242526272829/* 以后(工作中)我们首先必须对方法传递过来的参数进行合法性校验 如果参数不合法,那么我们就必须使用抛出异常的方式,告知方法的调用者,传递的参数有问题 注意: NullPointerException是一个运行期异常,我们不用处理,默认交给JVM处理 ArrayIndexOutOfBoundsException是一个运行期异常,我们不用处理,默认交给JVM处理 */ public static int getElement(int[] arr,int index)&#123; /* 我们可以对传递过来的参数数组,进行合法性校验 如果数组arr的值是null 那么我们就抛出空指针异常,告知方法的调用者\"传递的数组的值是null\" */ if(arr == null)&#123; throw new NullPointerException(\"传递的数组的值是null\"); &#125; /* 我们可以对传递过来的参数index进行合法性校验 如果index的范围不在数组的索引范围内 那么我们就抛出数组索引越界异常,告知方法的调用者\"传递的索引超出了数组的使用范围\" */ if(index&lt;0 || index&gt;arr.length-1)&#123; throw new ArrayIndexOutOfBoundsException(\"传递的索引超出了数组的使用范围\"); &#125; int ele = arr[index]; return ele; &#125; Objects非空判断 类Objects曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。 public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象不是null。 查看源码发现这里对为null的进行了抛出异常操作： 1234567891011//对传递过来的参数进行合法性判断,判断是否为nullpublic static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125;public static &lt;T&gt; T requireNonNull(T obj, String message) &#123; if (obj == null) throw new NullPointerException(message); return obj;&#125; 12Objects.requireNonNull(obj);Objects.requireNonNull(obj,\"传递的对象的值是null\"); 异常处理的第一种方式：声明异常throws 交给别人处理 声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理，那么必须通过throws进行声明，让调用者去处理。 关键字throws运用于方法声明之上，用于表示当前方法不处理异常，而是提醒该方法的调用者来处理异常(抛出异常). 声明异常格式： 1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125; 声明异常的代码演示： 12345678910111213public class ThrowsDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; read(\"a.txt\"); &#125; // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; 注意: throws关键字必须写在方法声明处 throws关键字后边声明的异常必须是Exception或者是Exception的子类 方法内部如果抛出了多个异常对象,那么throws后边必须也声明多个异常 如果抛出的多个异常对象有子父类关系，那么直接声明父类异常即可 调用了一个声明抛出异常的方法，我们就必须的处理声明的异常 要么继续使用throws声明抛出，交给方法的调用者处理，最终交给JVM 要么try…catch自己处理异常 异常处理的第二种方式：捕获异常try…catch 自己处理 try-catch的方式就是捕获异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。* 捕获异常语法如下： 12345678try&#123; 可能产生异常的代码&#125;catch(定义一个异常的变量,用来接收try中抛出的异常对象)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;...catch(异常类名 变量名)&#123;&#125; try：该代码块中编写可能产生异常的代码。 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 1234567891011121314151617181920public class TryCatchDemo &#123; public static void main(String[] args) &#123; try &#123;// 当产生异常时，必须有处理方式。要么捕获，要么声明。 read(\"b.txt\"); &#125; catch (FileNotFoundException e) &#123; //try中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); &#125; System.out.println(\"over\"); &#125; /* * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; finally 代码块 finally一般用于资源释放(资源回收),无论程序是否出现异常,最后都要资源释放(IO) finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 1234567891011121314151617181920212223public class TryCatchDemo4 &#123; public static void main(String[] args) &#123; try &#123; read(\"a.txt\"); &#125; catch (FileNotFoundException e) &#123; //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); &#125; finally &#123; System.out.println(\"不管程序怎样，这里都将会被执行。\"); &#125; System.out.println(\"over\"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; 当只有在try或者catch中调用退出JVM的相关方法，此时finally才不会执行，否则finally永远会执行。 异常注意事项 一般我们是使用一次捕获多次处理方式，格式如下： 123456789try&#123; 编写可能会出现异常的代码&#125;catch(异常类型A e)&#123; 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;catch(异常类型B e)&#123; 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果finally有return语句，会永远返回finally中的结果，应该避免该情况 123456789101112131415161718public static void main(String[] args) &#123; int a = getA(); System.out.println(a); //100 &#125; //定义一个方法,返回变量a的值 public static int getA()&#123; int a = 10; try&#123; return a; &#125;catch (Exception e)&#123; System.out.println(e); &#125;finally &#123; //一定会执行的代码 a = 100; return a; &#125; &#125; 子父类的异常 如果父类抛出了多个异常，子类重写父类方法时，抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出 父类异常时什么样，子类异常就什么样 1234567891011121314151617181920212223242526272829public class Fu &#123; public void show01() throws NullPointerException,ClassCastException&#123;&#125; public void show02() throws IndexOutOfBoundsException&#123;&#125; public void show03() throws IndexOutOfBoundsException&#123;&#125; public void show04() throws Exception &#123;&#125;&#125;class Zi extends Fu&#123; //子类重写父类方法时,抛出和父类相同的异常 public void show01() throws NullPointerException,ClassCastException&#123;&#125; //子类重写父类方法时,抛出父类异常的子类 public void show02() throws ArrayIndexOutOfBoundsException&#123;&#125; //子类重写父类方法时,不抛出异常 public void show03() &#123;&#125; /* 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。 */ //public void show04() throws Exception&#123;&#125; × //此时子类产生该异常，只能捕获处理，不能声明抛出 public void show04() &#123; try &#123; throw new Exception(\"编译期异常\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5.自定义异常概述 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类. 自定义一个业务逻辑异常: RegisterException。一个注册异常类。 异常类如何定义: 自定义一个编译期异常：自定义类 并继承于java.lang.Exception。 自定义一个运行时期的异常类：自定义类 并继承于java.lang.RuntimeException。 自定义异常的练习要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 首先定义一个登陆异常类RegisterException： 12345678910111213141516// 业务逻辑异常public class RegisterException extends Exception &#123; /** * 空参构造 */ public RegisterException() &#123; &#125; /** * * @param message 表示异常提示 */ public RegisterException(String message) &#123; super(message); &#125;&#125; 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。 123456789101112131415161718192021222324252627public class Demo &#123; // 模拟数据库中已存在账号 private static String[] names = &#123;\"bill\",\"hill\",\"jill\"&#125;; public static void main(String[] args) &#123; //调用方法 try&#123; // 可能出现异常的代码 checkUsername(\"nill\"); System.out.println(\"注册成功\");//如果没有异常就是注册成功 &#125;catch(RegisterException e)&#123; //处理异常 e.printStackTrace(); &#125; &#125; //判断当前注册账号是否存在 //因为是编译期异常，又想调用者去处理 所以声明该异常 public static boolean checkUsername(String uname) throws LoginException&#123; for (String name : names) &#123; if(name.equals(uname))&#123;//如果名字在这里面 就抛出登陆异常 throw new RegisterException(\"亲\"+name+\"已经被注册了！\"); &#125; &#125; return true; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://goldcarpenter.github.io/tags/Java/"}]},{"title":"【博客搭建】使用hexo与github搭建个人博客系统（一）","date":"2018-10-27T14:19:02.000Z","path":"2018/10/27/配置hexo与github/","text":"1.软件准备 软件准备 注册Github账户(略) 安装node.js软件(略) 安装Git软件(略) 建议安装Typora(编辑博文使用，略) 创建github page仓库 在Github中创建goldcarpenter.github.io(goldcarpenter为github用户名)的仓库 未来博客网站访问地址就是https://goldcarpenter.github.io 了 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟 配置SSH key 使用SSH key（公钥私钥）验证登录可以简化我们的登录过程，避免输入账户密码 12ssh-keygen -t rsa -C &quot;youremail@qq.com&quot;提示信息——连续3次回车 在C盘的用户当前用户目录下找到.ssh\\id_rsa.pub，将公钥内容使用软件打开拷贝至setting -&gt; SSH and GPG keys -&gt; New SSH key 将刚复制的内容粘贴到key那里，title填你的计算机名称，保存。 测试SSH key 1ssh -T git@github.com # 注意邮箱地址不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： 1Hi goldcarpenter! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 如果你是首次使用git，git shell中配置 12345你的github用户名$ git config --global user.name &quot;goldcarpenter&quot;填写你的github注册邮箱$ git config --global user.email &quot;xxx@qq.com&quot; 2.搭建hexo博客系统2.1.前言 hexo简介 Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 hexo原理 由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容 hexo将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github 注意事项 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，为避免不必要的问题，使用的命令建议全部使用git bash来执行 hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2类_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下管理各个主题的_config.yml； 2.2.本地hexo使用 安装hexo 1$ npm install -g hexo 创建博客本地存放文件夹 在电脑的某个地方新建一个文件夹，作为存放代码的地方。我的是F:\\Project\\Hexo_Repo 12$ cd [目标目录]$ hexo init 12345678910├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json #npm 依赖等 12$ hexo g # 生成相关页面$ hexo s # 启动本地hexo预览服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github的 hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到hexo写了一篇名为 Hello World 的文章内容 修改主题 官方主题中有很多优秀的主题，本文使用主题为BlueLake 12$ cd [目标目录]$ git clone https:&#x2F;&#x2F;github.com&#x2F;chaooo&#x2F;hexo-theme-BlueLake.git themes&#x2F;BlueLake 下载后的主题放在themes目录中 BlueLake是基于jade和stylus写的，所以需要安装hexo-renderer-jade和hexo-renderer-stylus来渲染 12$ npm install hexo-renderer-jade@0.3.0 --save$ npm install hexo-renderer-stylus --save 修改_config.yml中的theme: landscape改为theme: BlueLake 12$ hexo clean$ hexo g 更新主题 今后若主题添加了新功能正是需要的，可以直接git pull来更新主题 12cd themes&#x2F;BlueLakegit pull 2.3.hexo上传Github 上传之前 一定要记得先把你以前所有代码pull下来（虽然github有版本管理，但备份一下总是好的） 因为从hexo提交代码时会把你以前的所有代码都删掉 上传前配置准备 安装插件 1$ npm install hexo-deployer-git --save 配置_config.yml中有关deploy的部分 1234deploy: type: git repository: git@github.com:goldcarpenter&#x2F;goldcarpenter.github.io.git branch: master 上传 1hexo d 2.4.写博客 定位到我们的hexo根目录 1hexo new &#39;配置hexo与github&#39; hexo会帮我们在_posts下生成相关配置hexo与github.md文件 需要打开这个文件就可以开始写博客了 12345title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面 如何让博文列表不显示全部内容 默认情况下，生成的博文目录会显示全部的文章内容，在合适的位置加上&lt;!--more--&gt;即可设置文章摘要的长度 2.5.博客系统优化 根_config.yml配置 _config.yml详细说明 参数 描述 title 网站标题 显示在网站头部 subtitle 网站副标题 显示在网站头部 description 网站描述 加入网站源码的meta标签中 主要用于SEO keywords 网站的关键词。使用半角逗号 , 分隔多个关键词。 author 您的名字 网站底部的Copyright处有所显示 language 简体中文（zh-CN）繁体中文（zh-TW）英语（en） 1234567title: 掘金木匠subtitle: 不玩金融的软件工程师不是好的吃货description: JJMJ&#39;s blog.keywords: Java, Spring, MyBatis, 后端author: 掘金木匠language: zh-CNtimezone: &#39;&#39; 主题_config.yml设置 主题默认是展示四个菜单，即主页home，归档archive，关于about，订阅RSS；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。 12345678910111213menu: - page: home directory: . icon: fa-home - page: archive directory: archives&#x2F; icon: fa-archive - page: about directory: about&#x2F; icon: fa-user #- page: rss # directory: atom.xml # icon: fa-rss 每个页面底部的footer中联系博主的三个图标分别是邮箱，微博主页链接地址，GitHUb个人页链接地址，直接使用主题_config.yml中about页面的配置，若不需要about页面，只需要如下配置就好： 1234about: email: ## 个人邮箱 weibo_url: ## 微博主页链接地址 github_url: ## github主页链接地址 添加about页 此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面 1$ hexo new page &#39;about&#39; 1234567about: photo_url: ## 头像的链接地址 email: ## 个人邮箱 weibo_url: ## 微博主页链接地址 weibo_name: ## 微博用户名 github_url: ## github主页链接地址 github_name: ## github用户名 当然也可以自定义重新布局about页面，只需要修改layout/page.jade模板就好 安装 RSS(订阅) 和 sitemap(网站地图) 插件 123$ npm install hexo-generator-feed --save$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 添加主题_config.yml配置 1234567891011121314Plugins: hexo-generator-feed hexo-generator-sitemap hexo-generator-baidu-sitemapfeed: type: atom path: atom.xml limit: 20sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 添加本地搜索 默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件hexo-generator-json-content来创建JSON数据文件 1$ npm install hexo-generator-json-content@2.2.0 --save 然后在根_config.yml添加配置： 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 最后在主题_config.yml添加配置： 1local_search: true 修改站点图标 站点图标存放在主题的Source目录下，已经默认准备了两张图片。您也可以自己设计站点LOGO。 需要准备一张ico格式并命名为favicon.ico 将其放入hexo目录的source文件夹，建议大小：32px X 32px。 首页添加文章置顶 在根目录下打开命令行窗口安装： 12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 然后在需要置顶的文章的Front-matter中加上top: true即可。 123456---title: BlueLake博客主题的详细配置tags: [hexo,BlueLake]categories: hexo博客折腾top: true--- 其他配置 show_category_count——是否显示分类下的文章数。 widgets_on_small_screens——是否在小屏显示侧边栏，若true,则侧边栏挂件将显示在底部。 12show_category_count: true widgets_on_small_screens: true 保留CNAME、README.md等文件 一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的： 由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。 3.Q&amp;A 博客中的图片无法显示问题 Hexo下的_config.yml里的post_asset_folder，把这个选项从false改成true Hexo目录下打开Git Brsh，执行一个下载上传图片插件的命令npm install hexo-asset-image --save 图片所在文件夹为文件同名的文件夹 .md中的图片仅仅保留图片名 4.常用hexo命令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate &#x3D;&#x3D; hexo g #生成静态页面至public目录hexo server &#x3D;&#x3D; hexo s #开启预览访问端口（默认端口4000）hexo deploy &#x3D;&#x3D; hexo d #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 5.鸣谢12原文作者: 郑超(Charles·Zheng)原文链接: http:&#x2F;&#x2F;chaoo.oschina.io&#x2F;2016&#x2F;12&#x2F;29&#x2F;BlueLake博客主题的详细配置.html","tags":[{"name":"hexo","slug":"hexo","permalink":"http://goldcarpenter.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://goldcarpenter.github.io/tags/github/"}]}]