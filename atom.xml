<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>掘金木匠</title>
  
  <subtitle>懂金融的软件工程师一定是一个合格的吃货</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://goldcarpenter.github.io/"/>
  <updated>2020-06-17T07:24:10.991Z</updated>
  <id>http://goldcarpenter.github.io/</id>
  
  <author>
    <name>掘金木匠</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis</title>
    <link href="http://goldcarpenter.github.io/2020/04/17/Redis_Part3/"/>
    <id>http://goldcarpenter.github.io/2020/04/17/Redis_Part3/</id>
    <published>2020-04-16T16:00:00.000Z</published>
    <updated>2020-06-17T07:24:10.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7高级数据类型"><a href="#7高级数据类型" class="headerlink" title="7高级数据类型"></a>7高级数据类型</h1><h2 id="7-1Bitmaps"><a href="#7-1Bitmaps" class="headerlink" title="7.1Bitmaps"></a>7.1Bitmaps</h2><ul><li><p>获取指定key对应偏移量上的bit值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset</span><br></pre></td></tr></table></figure></li><li><p>设置指定key对应偏移量上的bit值，value只能是1或0 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure></li><li><p>对指定key按位进行交、并、非、异或操作，并将结果保存到destKey中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitop op destKey key1 [key2...]</span><br></pre></td></tr></table></figure><ul><li>and：交 </li><li>or：并 </li><li>not：非</li><li>xor：异或</li></ul></li><li><p>统计指定key中1的数量 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount key [start end]</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用场景13"><a href="#应用场景13" class="headerlink" title="应用场景13"></a>应用场景13</h3><ul><li>统计每天某一部电影是否被点播</li><li>统计每天有多少部电影被点播</li><li>统计每周/月/年有多少部电影被点播</li><li>统计年度哪部电影没有被点播</li><li><strong>答：redis 应用于信息状态统计</strong></li></ul><h2 id="7-2HyperLogLog"><a href="#7-2HyperLogLog" class="headerlink" title="7.2HyperLogLog"></a>7.2HyperLogLog</h2><ul><li><p>HyperLogLog 是用来做基数统计的，运用了LogLog的算法</p></li><li><p>基数是数据集去重后元素个数</p><p><img src="1588695761826.png" alt="1588695761826"></p></li><li><p>添加数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element [element ...]</span><br></pre></td></tr></table></figure></li><li><p>统计数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfcount key [key ...]</span><br></pre></td></tr></table></figure></li><li><p>合并数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfmerge destkey sourcekey [sourcekey...]</span><br></pre></td></tr></table></figure></li><li><p>相关说明</p><ul><li>用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据</li><li>核心是基数估算算法，最终数值存在一定误差<ul><li>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值</li></ul></li><li>耗空间极小，每个hyperloglog key占用了12K的内存用于标记基数</li><li>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存逐渐增大 </li><li>Pfmerge命令合并后占用的存储空间为12K，无论合并之前数据量多少</li></ul></li></ul><h3 id="应用场景15"><a href="#应用场景15" class="headerlink" title="应用场景15"></a>应用场景15</h3><ul><li>统计独立UV</li><li><strong>答：redis 应用于独立信息统计</strong></li></ul><h2 id="7-3GEO"><a href="#7-3GEO" class="headerlink" title="7.3GEO"></a>7.3GEO</h2><ul><li><p>添加坐标点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude member [longitude latitude member ...]</span><br></pre></td></tr></table></figure></li><li><p>获取坐标点 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geopos key member [member ...]</span><br></pre></td></tr></table></figure></li><li><p>计算坐标点距离</p></li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geodist key member1 member2 [unit]</span><br></pre></td></tr></table></figure><ul><li><p>根据坐标求范围内的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">georadius key longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br></pre></td></tr></table></figure></li><li><p>根据点求范围内数据.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">georadiusbymember key member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br></pre></td></tr></table></figure></li><li><p>获取指定点对应的坐标hash值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geohash key member [member ...]</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用场景15-1"><a href="#应用场景15-1" class="headerlink" title="应用场景15"></a>应用场景15</h3><ul><li>统计独立UV</li><li><strong>答：redis 应用于地理位置计算</strong></li></ul><h1 id="8主从复制"><a href="#8主从复制" class="headerlink" title="8主从复制"></a>8主从复制</h1><h2 id="8-1主从复制简介"><a href="#8-1主从复制简介" class="headerlink" title="8.1主从复制简介"></a>8.1主从复制简介</h2><ul><li><p>单机redis的风险与问题 </p><ul><li>机器故障【硬盘故障、系统崩溃】，数据丢失，很可能对业务造成灾难性打击 </li><li>容量瓶颈【内存不足】，硬件条件跟不上</li></ul></li><li><p>为了避免单点Redis服务器故障，准备多台服务器，<strong>互相连通</strong>。</p></li><li><p>将数据复制多个副本保存在不同的服务器上，连接在一起，并<strong>保证数据是同步</strong>的。即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时实现数据<strong>冗余备份</strong>。</p><ul><li>提供数据方：master 主服务器，主节点，主库，主客户端</li><li>接收数据方：slave 从服务器，从节点，从库，从客户端</li><li>需要解决的问题： 数据同步</li><li>核心工作： master的数据复制到slave中</li></ul><p><img src="1588729303276.png" alt="1588729303276"></p></li><li><p>主从复制</p><ul><li>主从复制即将master中的数据即时、有效的复制到slave中</li><li>特征：一个master可以拥有多个slave，一个slave只对应一个master </li><li>职责：<ul><li>master:①写数据 ②执行写操作时，将出现变化的数据自动同步到slave ③读数据（可忽略）</li><li>slave:①读数据 ②写数据（禁止）</li></ul></li><li>作用<ul><li>读写分离：master写、slave读，提高服务器的读写负载能力</li><li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li><li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li><li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li><li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</li></ul></li></ul></li></ul><h2 id="8-2主从复制工作流程"><a href="#8-2主从复制工作流程" class="headerlink" title="8.2主从复制工作流程"></a>8.2主从复制工作流程</h2><ul><li><p>主从复制过程大体可以分为3个阶段 </p><ul><li>建立连接阶段（即准备阶段）</li><li>数据同步阶段</li><li>命令传播阶段</li></ul><p><img src="1588730469479.png" alt="1588730469479"></p></li></ul><h3 id="8-2-1阶段一：建立连接阶段"><a href="#8-2-1阶段一：建立连接阶段" class="headerlink" title="8.2.1阶段一：建立连接阶段"></a>8.2.1阶段一：建立连接阶段</h3><p><img src="1588730888782.png" alt="1588730888782"></p><ul><li><p>建立slave到master的连接，使master能够识别slave，并保存slave端口号</p></li><li><p>主从连接（slave连接master）</p><ul><li><p>方式一：客户端发送命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure></li><li><p>方式二：启动服务器参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server -slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure></li><li><p>方式三：服务器配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>主从断开连接</p><ul><li><p>客户端发送命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure></li><li><p>说明： slave断开连接后，不会删除已有数据，只是不再接受master发送的数据</p></li></ul></li><li><p>slave启动服务器设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server –a &lt;password&gt;</span><br></pre></td></tr></table></figure></li><li><p>slave配置文件设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info</span><br></pre></td></tr></table></figure><p><img src="1588733018080.png" alt="1588733018080"></p></li></ul><h3 id="8-2-2阶段二：数据同步阶段工作流程"><a href="#8-2-2阶段二：数据同步阶段工作流程" class="headerlink" title="8.2.2阶段二：数据同步阶段工作流程"></a>8.2.2阶段二：数据同步阶段工作流程</h3><ul><li><p>在slave初次连接master后，复制master中的所有数据到slave</p></li><li><p>将slave的数据库状态更新成master当前的数据库状态</p><p><img src="1588735501655.png" alt="1588735501655"></p><blockquote><p>步骤1：请求同步数据</p><p>步骤2：创建RDB同步数据</p><p>步骤3：恢复RDB同步数据</p><p>步骤4：请求部分同步数据</p><p>步骤5：恢复部分同步数据 至此，数据同步工作完成！</p></blockquote></li><li><p>状态： </p><ul><li>slave： 具有master端全部数据，包含RDB过程接收的数据</li><li>master： 保存slave当前数据同步的位置</li></ul></li><li><p>总体： 之间完成了数据克隆</p></li></ul><p><img src="1588752186549.png" alt="1588752186549"></p><h4 id="8-2-2-1部分复制的三个核心要素——服务器的运行-id（run-id）"><a href="#8-2-2-1部分复制的三个核心要素——服务器的运行-id（run-id）" class="headerlink" title="8.2.2.1部分复制的三个核心要素——服务器的运行 id（run id）"></a>8.2.2.1部分复制的三个核心要素——服务器的运行 id（run id）</h4><ul><li>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id</li><li>组成：运行id由40位字符组成，是一个随机的十六进制字符 例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce</li><li>作用：运行id被用于在服务器间进行传输，识别身份 如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别</li><li>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发 送给slave，slave保存此ID，通过info Server命令，可以查看节点的runid</li></ul><h4 id="8-2-2-2部分复制的三个核心要素——主服务器的复制积压缓冲区"><a href="#8-2-2-2部分复制的三个核心要素——主服务器的复制积压缓冲区" class="headerlink" title="8.2.2.2部分复制的三个核心要素——主服务器的复制积压缓冲区"></a>8.2.2.2部分复制的三个核心要素——主服务器的复制积压缓冲区</h4><ul><li>概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命 令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区</li><li>复制缓冲区默认数据存储空间大小是1M，由于存储空间大小是固定的，当入队元素的数量大于队 列长度时，最先入队的元素会被弹出，而新元素会被放入队列</li><li>由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区 </li><li>作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select）</li><li>数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中</li></ul><p><img src="../../%E5%AF%92%E5%81%87%E5%8C%85/Q&A/1588737306352.png" alt="1588737306352"></p><h4 id="8-2-2-3部分复制的三个核心要素——主从服务器的复制偏移量"><a href="#8-2-2-3部分复制的三个核心要素——主从服务器的复制偏移量" class="headerlink" title="8.2.2.3部分复制的三个核心要素——主从服务器的复制偏移量"></a>8.2.2.3部分复制的三个核心要素——主从服务器的复制偏移量</h4><ul><li>概念：一个数字，描述复制缓冲区中的指令字节位置</li><li>分类： <ul><li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）</li><li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）</li></ul></li><li>数据来源： master端：发送一次记录一次 slave端：接收一次记录一次</li><li>作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用</li></ul><h4 id="8-2-2-4数据同步阶段master"><a href="#8-2-2-4数据同步阶段master" class="headerlink" title="8.2.2.4数据同步阶段master"></a>8.2.2.4数据同步阶段master</h4><ul><li><p>如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行</p></li><li><p>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-backlog-size 1mb</span><br></pre></td></tr></table></figure></li><li><p>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执行bgsave命令和创建复制缓冲区</p><p><img src="1588737389244.png" alt="1588737389244"></p></li></ul><h4 id="8-2-2-5数据同步阶段slave"><a href="#8-2-2-5数据同步阶段slave" class="headerlink" title="8.2.2.5数据同步阶段slave"></a>8.2.2.5数据同步阶段slave</h4><ul><li><p>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的写数据功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave-serve-stale-data yes|no</span><br></pre></td></tr></table></figure></li><li><p>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</p></li><li><p>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果 master带宽不足，因此数据同步需要根据业务需求，适量错峰</p></li><li><p>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟 较大，数据一致性变差，应谨慎选择</p></li></ul><h3 id="8-2-3阶段三：命令传播阶段"><a href="#8-2-3阶段三：命令传播阶段" class="headerlink" title="8.2.3阶段三：命令传播阶段"></a>8.2.3阶段三：命令传播阶段</h3><ul><li><p>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的 状态，同步的动作称为命令传播</p></li><li><p>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令</p><p><img src="1588750683337.png" alt="1588750683337"></p></li><li><p>命令传播阶段出现了断网现象</p><ul><li>网络闪断闪连——忽略</li><li>短时间网络中断——部分复制</li><li>长时间网络中断——全量复制</li></ul></li></ul><p><img src="1588752840834.png" alt="1588752840834"></p><h4 id="8-2-3-1心跳机制"><a href="#8-2-3-1心跳机制" class="headerlink" title="8.2.3.1心跳机制"></a>8.2.3.1心跳机制</h4><ul><li>进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线</li><li>master心跳：<ul><li>指令：PING </li><li>周期：由repl-ping-slave-period决定，默认10秒</li><li>作用：判断slave是否在线 </li><li>查询：INFO replication    获取slave最后一次连接时间间隔，lag项维持在0或1视为正常</li></ul></li><li>slave心跳任务<ul><li>指令：REPLCONF ACK {offset} </li><li>周期：1秒</li><li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li><li>作用2：判断master是否在线</li></ul></li></ul><h4 id="8-2-3-2心跳阶段注意事项"><a href="#8-2-3-2心跳阶段注意事项" class="headerlink" title="8.2.3.2心跳阶段注意事项"></a>8.2.3.2心跳阶段注意事项</h4><ul><li><p>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write [2] </span><br><span class="line">min-slaves-max-lag [8]</span><br></pre></td></tr></table></figure></li><li><p>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步</p></li><li><p>slave数量由slave发送REPLCONF ACK命令做确认</p></li><li><p>slave延迟由slave发送REPLCONF ACK命令做确认</p></li></ul><h2 id="9主从复制常见问题"><a href="#9主从复制常见问题" class="headerlink" title="9主从复制常见问题"></a>9主从复制常见问题</h2><h3 id="9-1频繁的全量复制一"><a href="#9-1频繁的全量复制一" class="headerlink" title="9.1频繁的全量复制一"></a>9.1频繁的全量复制一</h3><ul><li><p>伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的 全量复制操作</p></li><li><p>内部优化调整方案：</p><ul><li>master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave </li><li>在master关闭时执行命令 shutdown save，进行RDB持久化,将runid与offset保存到RDB文件中</li><li>repl-id repl-offset </li><li>通过redis-check-rdb命令可以查看该信息</li></ul></li><li><p>master重启后加载RDB文件，恢复数据重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master_repl_id &#x3D; repl master_repl_offset &#x3D; repl-offset</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>通过info命令可以查看该信息</p></li><li><p>*<em>作用： 本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master *</em></p></li></ul><h3 id="9-2频繁的全量复制二"><a href="#9-2频繁的全量复制二" class="headerlink" title="9.2频繁的全量复制二"></a>9.2频繁的全量复制二</h3><ul><li><p>问题现象：网络环境不佳，出现网络中断，slave不提供服务</p></li><li><p>问题原因：复制缓冲区过小，断网后slave的offset越界，触发全量复制</p></li><li><p>最终结果：slave反复进行全量复制</p></li><li><p>解决方案：修改复制缓冲区大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-backlog-size</span><br></pre></td></tr></table></figure></li><li><p>建议设置如下：</p><ul><li>测算从master到slave的重连平均时长second</li><li>获取master平均每秒产生写命令数据总量write_size_per_second</li><li>最优复制缓冲区空间 = 2 * second * write_size_per_second</li></ul></li></ul><h3 id="9-3频繁的网络中断一"><a href="#9-3频繁的网络中断一" class="headerlink" title="9.3频繁的网络中断一"></a>9.3频繁的网络中断一</h3><ul><li><p>问题现象：master的CPU占用过高 或 slave频繁断开连接</p></li><li><p>问题原因：</p><ul><li>slave每1秒发送REPLCONF ACK命令到master，当slave接到了慢查询时（keys * ，hgetall等），会大量占用CPU性能，master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应</li></ul></li><li><p>最终结果：master各种资源（输出缓冲区、带宽、连接等）被严重占用</p></li><li><p>解决方案：通过设置合理的超时时间，确认是否释放slave</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-timeout</span><br></pre></td></tr></table></figure><blockquote><p>该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave</p></blockquote></li></ul><h3 id="9-4频繁的网络中断二"><a href="#9-4频繁的网络中断二" class="headerlink" title="9.4频繁的网络中断二"></a>9.4频繁的网络中断二</h3><ul><li><p>问题现象：slave与master连接断开</p></li><li><p>问题原因 </p><ul><li>master发送ping指令频度较低 </li><li>master设定超时时间较短</li><li>ping指令在网络中存在丢包</li></ul></li><li><p>解决方案：提高ping指令发送的频度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-ping-slave-period</span><br></pre></td></tr></table></figure><blockquote><p> 超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时</p></blockquote></li></ul><h3 id="9-5数据不一致"><a href="#9-5数据不一致" class="headerlink" title="9.5数据不一致"></a>9.5数据不一致</h3><ul><li>问题现象：多个slave获取相同数据不同步</li><li>问题原因：网络信息不同步，数据发送有延迟</li><li>解决方案 <ul><li>优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象  </li><li>监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问</li></ul></li></ul><h1 id="10哨兵模式"><a href="#10哨兵模式" class="headerlink" title="10哨兵模式"></a>10哨兵模式</h1><h2 id="10-1哨兵简介"><a href="#10-1哨兵简介" class="headerlink" title="10.1哨兵简介"></a>10.1哨兵简介</h2><ul><li><p>引入——主机“宕机”</p><ul><li>关闭master和所有slave</li><li>找一个slave作为master</li><li>修改其他slave的配置，连接新的主</li><li>启动新的master与slave </li></ul><p><img src="1588756296796.png" alt="1588756296796"></p></li><li><p><strong>哨兵(sentinel) 是一个分布式系统</strong>，用于对主从结构中的每台服务器进行<strong>监控</strong>，当出现故障时通过投票机制<strong>选择</strong>新的 master并将所有slave连接到新的master。</p></li><li><p>哨兵的作用</p><ul><li><strong>监控</strong>：不断的检查master和slave是否正常运行。 master存活检测、master与slave运行情况检测</li><li><strong>通知（提醒）</strong>：当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。</li><li>自动故障转移：断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服 务器地址</li></ul></li><li><p>注意：</p><ul><li>哨兵也是一台redis服务器，只是不提供数据服务</li><li>通常哨兵配置数量为单数</li></ul></li></ul><h2 id="10-2启用哨兵模式"><a href="#10-2启用哨兵模式" class="headerlink" title="10.2启用哨兵模式"></a>10.2启用哨兵模式</h2><ul><li><p>配置一拖二的主从结构</p></li><li><p>配置三个哨兵（配置相同，端口不同） </p><ul><li><code>sentinel.conf</code>文件</li></ul></li><li><p>启动哨兵</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel [sentinel-端口号.conf]</span><br></pre></td></tr></table></figure></li></ul><h2 id="10-3哨兵工作原理"><a href="#10-3哨兵工作原理" class="headerlink" title="10.3哨兵工作原理"></a>10.3哨兵工作原理</h2><ul><li><p>监控阶段</p><p><img src="1588813168115.png" alt="1588813168115"></p></li><li><p>通知阶段</p><p><img src="1588813289351.png" alt="1588813289351"></p></li><li><p>故障转移阶段</p><ul><li><p>发现问题</p><p><img src="1588813971869.png" alt="1588813971869"></p></li><li><p><strong>竞选负责人，优选新master</strong></p><p><img src="1588814022315.png" alt="1588814022315"></p></li><li><p><strong>新master上任，其他slave切换master，原master作为slave故障恢复后连接</strong></p></li></ul><p><img src="1588814072747.png" alt="1588814072747"></p></li></ul><h1 id="11集群"><a href="#11集群" class="headerlink" title="11集群"></a>11集群</h1><h2 id="11-1集群简介"><a href="#11-1集群简介" class="headerlink" title="11.1集群简介"></a>11.1集群简介</h2><ul><li>集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果</li><li>作用<ul><li>分散单台服务器的访问压力，实现负载均衡</li><li>分散单台服务器的存储压力，实现可扩展性</li><li>降低单台服务器宕机带来的业务灾难</li></ul></li></ul><h2 id="11-2Redis集群结构设计"><a href="#11-2Redis集群结构设计" class="headerlink" title="11.2Redis集群结构设计"></a>11.2Redis集群结构设计</h2><p><img src="1588768233155.png" alt="1588768233155"></p><ul><li><p>增减节点就是改变槽的位置</p><p><img src="1588768368813.png" alt="1588768368813"></p><p><img src="1588768577301.png" alt="1588768577301"></p></li></ul><h2 id="11-3cluster集群结构搭建"><a href="#11-3cluster集群结构搭建" class="headerlink" title="11.3cluster集群结构搭建"></a>11.3cluster集群结构搭建</h2><h3 id="11-3-1Cluster配置"><a href="#11-3-1Cluster配置" class="headerlink" title="11.3.1Cluster配置"></a>11.3.1Cluster配置</h3><ul><li><p>添加节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-enabled yes|no</span><br></pre></td></tr></table></figure></li><li><p>cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-config-file &lt;filename&gt;</span><br></pre></td></tr></table></figure></li><li><p>节点服务响应超时时间，用于判定该节点是否下线或切换为从节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-node-timeout &lt;milliseconds&gt;</span><br></pre></td></tr></table></figure></li><li><p>master连接的slave最小数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-migration-barrier &lt;count&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="11-3-2Cluster节点操作命令"><a href="#11-3-2Cluster节点操作命令" class="headerlink" title="11.3.2Cluster节点操作命令"></a>11.3.2Cluster节点操作命令</h3><ul><li><p>查看集群节点信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure></li><li><p>进入一个从节点 redis，切换其主节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster replicate &lt;master-id&gt;</span><br></pre></td></tr></table></figure></li><li><p>发现一个新节点，新增主节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster meet ip:port</span><br></pre></td></tr></table></figure></li><li><p>忽略一个没有solt的节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster forget &lt;id&gt;</span><br></pre></td></tr></table></figure></li><li><p>手动故障转移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster failover</span><br></pre></td></tr></table></figure></li></ul><h1 id="12企业级解决方案"><a href="#12企业级解决方案" class="headerlink" title="12企业级解决方案"></a>12企业级解决方案</h1><h2 id="12-1缓存预热"><a href="#12-1缓存预热" class="headerlink" title="12.1缓存预热"></a>12.1缓存预热</h2><ul><li>缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓 存的问题！用户直接查询事先被预热的缓存数据！</li><li>现象：服务器启动后迅速宕机</li><li>问题排查：<ul><li>请求数量较高</li><li>主从之间数据吞吐量较大，数据同步操作频度较高</li></ul></li><li>解决方案<ul><li>前置准备工作<ul><li>日常例行统计数据访问记录，统计访问频度较高的热点数据 </li><li>利用LRU数据删除策略，构建数据留存队列 例如：storm与kafka配合</li></ul></li><li>准备工作<ul><li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</li><li>利用分布式多服务器同时进行数据读取，提速数据加载过程</li><li>热点数据主从同时预热</li></ul></li><li>实施<ul><li>使用脚本程序固定触发数据预热过程</li><li>如果条件允许，使用了CDN（内容分发网络），效果会更好</li></ul></li></ul></li></ul><h2 id="12-2缓存雪崩"><a href="#12-2缓存雪崩" class="headerlink" title="12.2缓存雪崩"></a>12.2缓存雪崩</h2><ul><li><p>缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现 （约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p><p><img src="1588776662147.png" alt="1588776662147"></p></li><li><p>现象</p><ul><li>系统平稳运行过程中，忽然数据库连接量激增</li><li>应用服务器无法及时处理请求</li><li>大量408，500错误页面出现</li><li>客户反复刷新页面获取数据</li><li>数据库崩溃</li><li>应用服务器崩溃</li><li>重启应用服务器无效</li><li>Redis服务器崩溃</li><li>Redis集群崩溃</li><li>重启数据库后再次被瞬间流量放倒</li></ul></li><li><p>问题排查</p><ul><li>在一个<strong>较短的</strong>时间内，缓存中较多的<strong>key集中过期</strong></li><li>此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</li><li>数据库同时接收到大量的请求无法及时处理</li><li>Redis大量请求被积压，开始出现超时现象</li><li>数据库流量激增，数据库崩溃</li><li>重启后仍然面对缓存中无数据可用</li><li>Redis服务器资源被严重占用，Redis服务器崩溃</li><li>Redis集群呈现崩塌，集群瓦解</li><li>应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</li><li>应用服务器，redis，数据库全部重启，效果不理想</li></ul></li><li><p>问题分析</p><ul><li>短时间范围内</li><li>大量key集中过期</li></ul></li><li><p>解决方案（道）</p><ul><li>更多的页面静态化处理</li><li>构建多级缓存架构【Nginx缓存+redis缓存+ehcache缓存】</li><li>检测Mysql严重耗时业务进行优化【对数据库的瓶颈排查：例如超时查询、耗时较高事务等】</li><li>灾难预警机制<ul><li>监控redis服务器性能指标</li><li>CPU占用、CPU使用率</li><li>内存容量</li><li>查询平均响应时间</li><li>线程数</li></ul></li><li>限流、降级 短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</li></ul></li><li><p>解决方案（术）</p><ul><li>LRU与LFU切换 </li><li>数据有效期策略调整<ul><li>根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟</li><li>过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量</li></ul></li><li>超热数据使用永久key </li><li>定期维护（自动+人工） 对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时</li><li>加锁 慎用！</li></ul></li></ul><h2 id="12-3缓存击穿"><a href="#12-3缓存击穿" class="headerlink" title="12.3缓存击穿"></a>12.3缓存击穿</h2><ul><li><p>缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服 务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度 较高，配合雪崩处理策略即可</p></li><li><p>现象</p><ul><li>系统平稳运行过程中</li><li>数据库连接量瞬间激增</li><li>Redis服务器无大量key过期</li><li>Redis内存平稳，无波动</li><li>Redis服务器CPU正常</li><li>数据库崩溃</li></ul></li><li><p>问题排查</p><ul><li>Redis中某个key过期，该key访问量巨大</li><li>多个数据请求从服务器直接压到Redis后，均未命中</li><li>Redis在短时间内发起了大量对数据库中同一数据的访问</li></ul></li><li><p>问题分析</p><ul><li>单个key高热数据</li><li>key过期</li></ul></li><li><p>解决方案（术）</p><ul><li>预先设定 以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长 注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</li><li>现场调整 监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</li><li>后台刷新数据 启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</li><li>二级缓存 设置不同的失效时间，保障不会被同时淘汰就行</li><li>加锁 分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！</li></ul></li></ul><h2 id="12-4缓存穿透"><a href="#12-4缓存穿透" class="headerlink" title="12.4缓存穿透"></a>12.4缓存穿透</h2><ul><li><p>缓存击穿访问了<strong>根本</strong>不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。</p></li><li><p>通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。</p></li><li><p>无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。</p></li><li><p>现象</p><ul><li>系统平稳运行过程中</li><li>应用服务器流量随时间增量较大</li><li>Redis服务器命中率随时间逐步降低</li><li>Redis内存平稳，内存无压力</li><li>Redis服务器CPU占用激增</li><li>数据库服务器压力激增</li><li>数据库崩溃</li></ul></li><li><p>问题排查</p><ul><li>获取的数据在数据库中也不存在，数据库查询未得到对应数据</li><li>Redis获取到null数据未进行持久化，直接返回</li><li>下次此类数据到达重复上述过程 </li><li>出现黑客攻击服务器</li></ul></li><li><p>问题分析</p><ul><li>Redis中大面积出现未命中</li><li>出现非正常URL访问</li></ul></li><li><p>解决方案（术）</p><ul><li>缓存null【对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟】</li><li>白名单策略<ul><li>提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放 行，加载异常数据时直接拦截（效率偏低）</li><li>使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）</li></ul></li><li>实施监控【实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比】<ul><li>非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象 </li><li>活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象</li><li>根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）</li></ul></li><li>key加密<ul><li>问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验 </li><li>例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问</li></ul></li></ul></li></ul><h2 id="12-5性能指标监控"><a href="#12-5性能指标监控" class="headerlink" title="12.5性能指标监控"></a>12.5性能指标监控</h2><ul><li><p>性能指标：Performance</p><table><thead><tr><th align="center">Name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">latency</td><td align="center">Redis响应一个请求的时间</td></tr><tr><td align="center">instantaneous_ ops_per_sec</td><td align="center">平均每秒处理请求总数</td></tr><tr><td align="center">hit rate (calculated)</td><td align="center">缓存命中率(计算出来的)</td></tr></tbody></table></li><li><p>内存指标：Memory </p><table><thead><tr><th align="center">Name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">used_memory</td><td align="center">已使用内存</td></tr><tr><td align="center">mem_fragmentation_ratio</td><td align="center">内存碎片率</td></tr><tr><td align="center">evicted_keys</td><td align="center">由于最大内存限制被移除的key的数量</td></tr><tr><td align="center">blocked_clients</td><td align="center">由于BLPOP, BRPOP, or BRPOPLPUSH而备阻塞的客户端</td></tr></tbody></table></li><li><p>基本活动指标：Basic activity </p><table><thead><tr><th align="center">Name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">connected_clients</td><td align="center">客户端连接数</td></tr><tr><td align="center">connected_slaves</td><td align="center">Slave数量</td></tr><tr><td align="center">master_last_io_seconds_ago</td><td align="center">最近一次主从交互之后的秒数</td></tr><tr><td align="center">keyspace</td><td align="center">数据库中的key值总数</td></tr></tbody></table></li><li><p>持久性指标：Persistence </p><table><thead><tr><th align="center">Name</th><th align="center">description</th></tr></thead><tbody><tr><td align="center">rdb_last_save_time</td><td align="center">最后一次持久化保存到磁盘的时间戳</td></tr><tr><td align="center">rdb_changes_since_last_save</td><td align="center">自最后一次持久化以来数据库的更改数</td></tr></tbody></table></li><li><p>错误指标：Error</p><table><thead><tr><th align="center">Name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">rejected_ connections</td><td align="center">由于达到maxclient限制而被拒绝的连接数</td></tr><tr><td align="center">keyspace_misses</td><td align="center">Key值查找失败(没有命中)次数</td></tr><tr><td align="center">master_ link_down_since_seconds</td><td align="center">主从断开的持续时间(以秒为单位)</td></tr></tbody></table></li><li><p>监控方式</p><ul><li>工具<ul><li>Cloud Insight Redis</li><li>Prometheus</li><li>Redis-stat</li><li>Redis-faina</li><li>RedisLive</li><li>zabbix</li></ul></li><li>命令<ul><li>benchmark【指令】</li><li>monitor【redis cli指令】</li><li>showlog【redis cli指令】</li></ul></li></ul></li></ul><p>179.redis 是什么？都有哪些使用场景？</p><ul><li>redis用于控制数据库表主键id ,为数据库表主键提供生成策略,保障数据库表的主键唯一性</li><li>redis 控制数据的生命周期,通过数据是否失效控制业务行为,适用于所有具有时效性限定控制的操作——setex</li><li>redis应用于各种结构型和非结构型高热度数据访问加速——String</li><li>redis应用于购物车数据存储设计——hash</li><li>redis应用于抢购,限购类、限量发放优惠卷、激活码等业务的数据存储设计——hash</li><li>redis应用于具有操作先后顺序的数据控制——list</li><li>redis应用于最新消息展示——list</li><li>redis应用于随机推荐类信息检索,例如热点歌单推荐,热点新闻推荐,热卖旅游线路,应用APP推荐,大V推荐等——set</li><li>redis应用于同类信息的关联搜索,二度关联搜索,深度关联搜索——set</li><li>redis应用于同类型不重复数据的合并操作——set</li><li>redis应用于计数器组合排序功能对应的排名——sorted_set</li><li>redis应用于定时任务执行顺序管理或任务过期管理</li><li>redis应用于即时任务/消息队列执行管理</li><li>redis应用于按次结算的服务控制</li><li>redis应用于基于时间顺序的数据操作,而不关注具体时间</li></ul><p>180.redis 有哪些功能？</p><p>181.redis 和 memecache 有什么区别？</p><p>182.redis 为什么是单线程的？</p><p>183.什么是缓存穿透？怎么解决？</p><p>184.redis 支持的数据类 型有哪些？</p><p>185.redis 支持的 java 客户端都有哪些？</p><p>186.jedis 和 redisson 有哪些区别？</p><p>187.怎么保证缓存和数据库数据的一致性？</p><p>188.redis 持久化有几种方式？</p><p>189.redis 怎么实现分布式锁？</p><p>190.redis 分布式锁有什么缺陷？</p><p>191.redis 如何做内存优化？ </p><p>192.redis 淘汰策略有哪些？</p><p>193.redis 常见的性能问题有哪些？该如何解决？</p>]]></content>
    
    <summary type="html">
    
      高级数据类型 主从复制 哨兵模式 集群
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Redis" scheme="http://goldcarpenter.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://goldcarpenter.github.io/2020/04/04/Redis_Part2/"/>
    <id>http://goldcarpenter.github.io/2020/04/04/Redis_Part2/</id>
    <published>2020-04-03T16:00:00.000Z</published>
    <updated>2020-06-17T07:22:44.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-Jedis"><a href="#2-Jedis" class="headerlink" title="2.Jedis"></a>2.Jedis</h1><ul><li>Java程序操作Redis的工具<ul><li>Jedis</li><li>SpringData Redis</li><li>Lettuce</li></ul></li></ul><h2 id="2-1Jedis入门程序"><a href="#2-1Jedis入门程序" class="headerlink" title="2.1Jedis入门程序"></a>2.1Jedis入门程序</h2><ul><li><p>pom.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>JedisTest</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package top.carpenter;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">public class JedisTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.连接Redis</span><br><span class="line">        Jedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line">        &#x2F;&#x2F; 2.操作Redis——与终端操作方法一致</span><br><span class="line">        jedis.set(&quot;name&quot;,&quot;carpenter&quot;);</span><br><span class="line">        System.out.println(jedis.get(&quot;name&quot;));</span><br><span class="line">        &#x2F;&#x2F; 3.关闭连接</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2Jedis读写redis数据"><a href="#2-2Jedis读写redis数据" class="headerlink" title="2.2Jedis读写redis数据"></a>2.2Jedis读写redis数据</h2><ul><li>案例：服务调用次数控制<ul><li>服务免费开放给企业试用，对试用用户的使用行为进行限速，限制每个用户每分钟最多发起10次调用</li></ul></li><li>案例要求<br>①设定A、B三个用户<br>②A用户限制10次/分调用, B用户限制30次/分调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.exceptions.JedisDataException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer EXPAIRTIME = <span class="number">300</span>;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt1 = <span class="keyword">new</span> MyThread(<span class="string">"初级用户"</span>,<span class="keyword">new</span> Integer(<span class="number">10</span>));</span><br><span class="line">        MyThread mt2 = <span class="keyword">new</span> MyThread(<span class="string">"高级用户"</span>,<span class="number">30</span>);</span><br><span class="line">        mt1.start() ;</span><br><span class="line">        mt2.start() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String id,Integer num)</span></span>&#123;</span><br><span class="line">        service = <span class="keyword">new</span> Service(id,num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            service.service();</span><br><span class="line">             <span class="keyword">try</span>&#123;</span><br><span class="line">                Random r = <span class="keyword">new</span> Random();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>+ r.nextInt(<span class="number">200</span>));</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> Integer num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Service</span><span class="params">(String id, Integer num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 模拟服务内容</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">business</span> <span class="params">(String id, <span class="keyword">long</span> num)</span></span>&#123;</span><br><span class="line">        System.out.println (<span class="string">"用户"</span>+id+<span class="string">"发起业务调用,当前第"</span>+num+<span class="string">"次"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line">        String value = jedis.get(<span class="string">"compid:"</span> + id);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断值是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 不存在 则创建该值</span></span><br><span class="line">                jedis.setex(<span class="string">"compid:"</span> + <span class="keyword">this</span>.id,JedisTest.EXPAIRTIME, <span class="string">""</span>+(Long.MAX_VALUE-<span class="keyword">this</span>.num));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 存在 自增 调用业务</span></span><br><span class="line">                Long val = jedis.incr(<span class="string">"compid:"</span> + id);</span><br><span class="line">                business(id, <span class="keyword">this</span>.num + val - Long.MAX_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisDataException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"用户: "</span> + id + <span class="string">"使用次数已达上限，请稍后再试或升级VIP会员"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3Jedis连接池"><a href="#2-3Jedis连接池" class="headerlink" title="2.3Jedis连接池"></a>2.3Jedis连接池</h2><ul><li><p><code>JedisPool</code>: Jedis提供的连接池技术</p><ul><li><code>poolConfig</code>:连接池配置对象</li><li><code>host</code>:redis服务地址</li><li><code>port</code>:redis服务端口号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public JedisPool (GenericObjectPoolConfig poolConfig, String host,int port) &#123;</span><br><span class="line">this(poolConfig, host, port, 2000，(String)null, 0,(String) null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String host = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxTotal ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ResourceBundle rb = ResourceBundle.getBundle(<span class="string">"redis"</span> );</span><br><span class="line">        host = rb. getString(<span class="string">"redis.host"</span>);</span><br><span class="line">        port = Integer.parseInt(rb. getString(<span class="string">"redis.port"</span>));</span><br><span class="line">        maxTotal = Integer.parseInt(rb. getString( <span class="string">"redis.maxTotal"</span>));</span><br><span class="line">        maxIdle = Integer. parseInt(rb. getString( <span class="string">"redis.maxIdle"</span>));</span><br><span class="line"></span><br><span class="line">        JedisPoolConfig jpc = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jpc.setMaxTotal (maxTotal);</span><br><span class="line">        jpc.setMaxIdle(maxIdle);</span><br><span class="line">        jp = <span class="keyword">new</span> JedisPool(jpc ,host,port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jp.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="3-基于Linux的Redis"><a href="#3-基于Linux的Redis" class="headerlink" title="3.基于Linux的Redis"></a>3.基于Linux的Redis</h1><h2 id="3-1Redis启动"><a href="#3-1Redis启动" class="headerlink" title="3.1Redis启动"></a>3.1Redis启动</h2><ul><li><p>默认配置启动【企业开发不用】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br><span class="line">redis-server --port 6380[更换端口启动]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli </span><br><span class="line">redis-cli -p 6380[更换端口启动]</span><br><span class="line">redis-cli -h 127.0.0.1[更换host]</span><br></pre></td></tr></table></figure></li><li><p>使用配置文件启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server config&#x2F;redis-6380.conf</span><br></pre></td></tr></table></figure></li><li><p><code>redis.conf</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以守护进程方式启动，redis将以服务的形式存在，日志不再打印到命令窗口</span></span><br><span class="line">daemonize yes </span><br><span class="line"><span class="meta">#</span><span class="bash"> 设定当前服务启动端口号</span></span><br><span class="line">port 6380</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设定当前服务文件保存位置，包含日志文件、持久化文件(后面详细讲解)等</span></span><br><span class="line">dir "/[自定义目录]/redis/data"</span><br><span class="line"><span class="meta">#</span><span class="bash">设定日志文件名，便于查阅</span></span><br><span class="line">logfile "***.log ”</span><br></pre></td></tr></table></figure></li><li><p>配置文件</p><ul><li><code>dbfilename dump.rdb</code>说明：设置本地数据库文件名，默认值为 dump.rdb <ul><li>经验：通常设置为<code>dump-端口号.rdb</code></li></ul></li><li><code>dir</code>说明：设置存储.rdb文件的路径 <ul><li>经验：通常设置成存储空间较大的目录中，目录名称data</li></ul></li><li><code>rdbcompression yes</code> 说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩 <ul><li>经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大）</li></ul></li><li><code>rdbchecksum yes</code>说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行<ul><li>经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险</li></ul></li><li><code>stop-writes-on-bgsave-error yes</code>说明：后台存储过程中如果出现错误现象，是否停止保存操作 <ul><li>经验：通常默认为开启状态</li></ul></li><li><code>appendonly yes|no</code>说明：是否开启AOF持久化功能<ul><li>默认为不开启状态</li></ul></li><li><code>appendfsync always|everysec|no</code> 说明：AOF写数据策略</li><li><code>appendfilename filename</code>说明：AOF持久化文件名，默认文件名<code>appendonly.aof</code><ul><li>建议配置为<code>appendonly-端口号.aof</code></li></ul></li></ul></li></ul><h1 id="4-Redis持久化"><a href="#4-Redis持久化" class="headerlink" title="4.Redis持久化"></a>4.Redis持久化</h1><ul><li><p>什么是持久化</p><ul><li><strong>利用永久性存储介质将数据进行保存</strong>，在特定的时间<strong>将保存的数据进行恢复</strong>的工作机制称为持久化</li></ul></li><li><p>为什么要进行持久化</p></li><li><p>防止数据的意外丢失，确保数据安全性</p></li><li><p>持久化过程保存什么</p><ul><li>将<strong>当前数据状态进行保存</strong>，快照形式，存储数据结果，存储格式简单，关注点在数据</li><li>将数据的<strong>操作过程进行保存</strong>，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程</li></ul><p><img src="1580311093979.png" alt="1580311093979"></p></li></ul><h2 id="4-1RDB方案"><a href="#4-1RDB方案" class="headerlink" title="4.1RDB方案"></a>4.1RDB方案</h2><h3 id="4-1-1RDB启动方式——save指令"><a href="#4-1-1RDB启动方式——save指令" class="headerlink" title="4.1.1RDB启动方式——save指令"></a>4.1.1RDB启动方式——save指令</h3><ul><li><p>手动执行一次保存操作</p><p><img src="1588579168526.png" alt="1588579168526"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save</span><br></pre></td></tr></table></figure><blockquote><p>本地生成<code>***.rdb</code>的文件，保存生产的快照信息</p></blockquote></li><li><p>注意: save指令的执行会阻塞当前Redis服务器，直到当前RDB过程完成为止，有可能会造成长时间阻塞，<strong>线上环境不建议使用。</strong></p></li></ul><h3 id="4-1-2RDB启动方式-——-bgsave指令命令"><a href="#4-1-2RDB启动方式-——-bgsave指令命令" class="headerlink" title="4.1.2RDB启动方式 —— bgsave指令命令"></a>4.1.2RDB启动方式 —— bgsave指令命令</h3><ul><li><p>手动启动后台保存操作，但不是立即执行</p><p><img src="1588580713240.png" alt="1588580713240"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgsave</span><br></pre></td></tr></table></figure></li><li><p>注意: bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式，s<strong>ave命令可以放弃使用</strong>。</p></li></ul><h3 id="4-1-3RDB启动方式——save配置"><a href="#4-1-3RDB启动方式——save配置" class="headerlink" title="4.1.3RDB启动方式——save配置"></a>4.1.3RDB启动方式——save配置</h3><ul><li><p>满足限定时间范围内key的变化数量达到指定数量即进行持久化</p><p><img src="1588582081351.png" alt="1588582081351"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save second changes</span><br></pre></td></tr></table></figure><blockquote><p>second：监控时间范围</p><p>changes：监控key的变化量</p></blockquote></li><li><p>位置：在conf文件中进行配置</p></li><li><p>注意：</p><ul><li>save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的 </li><li>save配置中对于second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系</li><li>save配置启动后执行的是bgsave操作</li></ul></li></ul><h3 id="4-1-4对比"><a href="#4-1-4对比" class="headerlink" title="4.1.4对比"></a>4.1.4对比</h3><table><thead><tr><th align="center">方式</th><th align="center">save指令</th><th align="center">bgsave指令</th></tr></thead><tbody><tr><td align="center">读写</td><td align="center">同步</td><td align="center">异步</td></tr><tr><td align="center">阻塞客户端指令</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">额外内存消耗</td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">启动新进程</td><td align="center">否</td><td align="center">是</td></tr></tbody></table><h3 id="4-1-5RDB特殊启动形式"><a href="#4-1-5RDB特殊启动形式" class="headerlink" title="4.1.5RDB特殊启动形式"></a>4.1.5RDB特殊启动形式</h3><ul><li><p>全量复制</p><ul><li>在主从复制中详细讲解 </li></ul></li><li><p>服务器运行过程中重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug reload</span><br></pre></td></tr></table></figure></li><li><p>关闭服务器时指定保存数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown save</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-1-6优点-amp-缺点"><a href="#4-1-6优点-amp-缺点" class="headerlink" title="4.1.6优点 &amp; 缺点"></a>4.1.6优点 &amp; 缺点</h3><ul><li><p>RDB优点</p><ul><li>RDB是一个紧凑压缩的二进制文件，<strong>存储效率较高</strong></li><li>RDB内部存储的是redis在某个时间点的数据快照，<strong>非常适合用于数据备份，全量复制等场景</strong> </li><li>RDB<strong>恢复数据</strong>的<strong>速度要比AOF快很多</strong> </li><li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。</li></ul></li><li><p>Rdb缺点</p><ul><li>RDB方式无论是执行指令还是利用配置，无法做到实时持久化，<strong>具有较大的可能性丢失数据</strong> </li><li>bgsave指令每次运行<strong>要执行fork操作创建子进程，要牺牲掉一些性能</strong></li><li>Redis的<strong>众多版本中未进行RDB文件格式的版本统一</strong>，有可能出现各版本服务之间数据格式无法兼容现象</li></ul></li></ul><h2 id="4-2AOF方案"><a href="#4-2AOF方案" class="headerlink" title="4.2AOF方案"></a>4.2AOF方案</h2><h3 id="4-2-1引入"><a href="#4-2-1引入" class="headerlink" title="4.2.1引入"></a>4.2.1引入</h3><ul><li>RDB存储的弊端<ul><li>存储数据量较大，效率较低【基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低】</li><li>大数据量下的IO性能较低</li><li>基于fork创建子进程，内存产生额外消耗</li><li>宕机带来的数据丢失风险</li></ul></li><li>解决思路<ul><li><strong>写全数据，仅记录部分数据</strong></li><li><strong>改记录数据为记录操作过程</strong></li><li><strong>对所有操作均进行记录，排除丢失数据的风险</strong></li></ul></li></ul><h3 id="4-2-2AOF概念"><a href="#4-2-2AOF概念" class="headerlink" title="4.2.2AOF概念"></a>4.2.2AOF概念</h3><ul><li><p>以独立日志的方式记录每次写命令，<strong>重启时再重新执行AOF文件中命令达到恢复数据的目的</strong>。与RDB相比可以简单描述为改记录数据为记录数据产生的过程</p></li><li><p>作用：解决了数据持久化的实时性，<strong>目前已经是Redis持久化的主流方式</strong></p><p><img src="1588584037410.png" alt="1588584037410"></p></li><li><p>AOF写数据三种策略(appendfsync)</p><ul><li><code>always(每次）</code>每次写入操作均同步到AOF文件中，<strong>数据零误差，性能较低</strong>，不建议使用。</li><li><code>everysec（每秒）</code>每秒将缓冲区中的指令同步到AOF文件中，<strong>数据准确性较高，性能较高</strong>，建议使用，也是默认配置 在系统突然宕机的情况下丢失1秒内的数据</li><li><code>no（系统控制）</code>由操作系统控制每次同步到AOF文件的周期，整体过程<strong>不可控</strong></li></ul></li></ul><h3 id="4-2-3AOF重写"><a href="#4-2-3AOF重写" class="headerlink" title="4.2.3AOF重写"></a>4.2.3AOF重写</h3><p><img src="1588584845063.png" alt="1588584845063"></p><ul><li>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了<strong>AOF重写机制压缩文件体积</strong>。</li><li>AOF文件重写：将<strong>Redis进程内的数据</strong>转化为<strong>写命令同步到新AOF文件的过程</strong>。【将对同一个数据的若干个条命令执行结果转化成最终结果数据对应的指令进行记录。】</li><li>作用<ul><li>降低磁盘占用量，提高磁盘利用率</li><li>提高持久化效率，降低持久化写时间，提高IO性能</li><li>降低数据恢复用时，提高数据恢复效率</li></ul></li></ul><h3 id="4-2-4AOF重写规则"><a href="#4-2-4AOF重写规则" class="headerlink" title="4.2.4AOF重写规则"></a>4.2.4AOF重写规则</h3><ul><li><strong>进程内已超时的数据不再写入文件</strong></li><li><strong>忽略无效指令，重写时使用进程内数据直接生成</strong>，这样新的AOF文件只保留最终数据的写入命令 <ul><li>如<code>del key1、 hdel key2、srem key3、set key4 111、set key4 222</code>等</li></ul></li><li>对同一数据的多条写命令合并为一条命令<ul><li>如<code>lpush list1 a、lpush list1 b、 lpush list1 c</code>可以转化为：<code>lpush list1 a b c</code>。</li><li>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</li></ul></li></ul><h3 id="4-2-5AOF重写方式"><a href="#4-2-5AOF重写方式" class="headerlink" title="4.2.5AOF重写方式"></a>4.2.5AOF重写方式</h3><ul><li><p>手动重写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgrewriteaof</span><br></pre></td></tr></table></figure><ul><li><p>bgrewriteaof指令工作原理</p><p><img src="1588584827646.png" alt="1588584827646"></p></li></ul></li><li><p>自动重写</p><ul><li><p>自动重写触发条件设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size [size] </span><br><span class="line">auto-aof-rewrite-percentage [percentage]</span><br></pre></td></tr></table></figure></li><li><p>自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aof_current_size</span><br><span class="line">aof_base_size</span><br></pre></td></tr></table></figure></li><li><p>自动重写触发条件</p><p><img src="1588585553364.png" alt="1588585553364"></p></li></ul></li></ul><h3 id="4-2-6AOF工作流程"><a href="#4-2-6AOF工作流程" class="headerlink" title="4.2.6AOF工作流程"></a>4.2.6AOF工作流程</h3><p><img src="1588586007153.png" alt="1588586007153"></p><p><img src="1588586438267.png" alt="1588586438267"></p><h2 id="4-3AOF-amp-RDB对比"><a href="#4-3AOF-amp-RDB对比" class="headerlink" title="4.3AOF &amp; RDB对比"></a>4.3AOF &amp; RDB对比</h2><p><img src="1588586605001.png" alt="1588586605001"></p><ul><li><strong>对数据非常敏感，建议使用默认的AOF持久化方案</strong><ul><li>AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。</li><li>注意：由于AOF文件存储体积较大，且恢复速度较慢</li></ul></li><li><strong>数据呈现阶段有效性，建议使用RDB持久化方案</strong><ul><li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段 点数据恢复通常采用RDB方案</li><li>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重总结：</li></ul></li><li>综合比对<ul><li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li><li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF </li><li>如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB</li><li>灾难恢复选用RDB</li><li>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量</li></ul></li></ul><h2 id="4-4持久化应用场景"><a href="#4-4持久化应用场景" class="headerlink" title="4.4持久化应用场景"></a>4.4持久化应用场景</h2><ul><li><del>Tips 1：redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性</del>【从DB读取最大】</li><li><del>Tips 3：redis应用于各种结构型和非结构型高热度数据访问加速</del>【从DB读取】</li><li><del>Tips 4：redis 应用于购物车数据存储设计</del>【从DB读取】</li><li>Tips 5：redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计</li><li><del>Tips 6：redis 应用于具有操作先后顺序的数据控制</del>【用MQ】</li><li><del>Tips 7：redis 应用于最新消息展示</del>【用RQ】</li><li><del>Tips 9：redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索</del>【从DB读取】</li><li><del>Tips 12：redis 应用于基于黑名单与白名单设定的服务控制【长期】</del>【从DB读取】</li><li>Tips 12：redis 应用于基于黑名单设定的服务控制【短期】</li><li>Tips 13：redis 应用于计数器组合排序功能对应的排名</li><li><del>Tips 15：redis 应用于即时任务/消息队列执行管理</del>【用MQ】</li><li>Tips 16：redis 应用于按次结算的服务控制</li></ul><h1 id="5-Redis事务"><a href="#5-Redis事务" class="headerlink" title="5.Redis事务"></a>5.Redis事务</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性 按照添加顺序依次执行，中间不会被打断或者干扰。</li><li>一个队列中，一次性、顺序性、排他性的执行一系列命令</li></ul><p><img src="1588599302710.png" alt="1588599302710"></p><h2 id="事务的基本操作"><a href="#事务的基本操作" class="headerlink" title="事务的基本操作"></a>事务的基本操作</h2><ul><li><p>开启事务</p><ul><li><p>设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multi</span><br></pre></td></tr></table></figure></li></ul></li><li><p>执行事务 </p><ul><li><p>设定事务的结束位置，同时执行事务。与multi成对出现，成对使用 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec</span><br></pre></td></tr></table></figure></li></ul></li><li><p>取消事务</p><ul><li><p>终止当前事务的定义，发生在multi之后，exec之前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discard</span><br></pre></td></tr></table></figure></li></ul></li><li><p>注意：加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行</p></li></ul><h2 id="事务的工作流程"><a href="#事务的工作流程" class="headerlink" title="事务的工作流程"></a>事务的工作流程</h2><p><img src="1588599890428.png" alt="1588599890428"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>定义事务的过程中，<strong>命令格式输入错误</strong>怎么办？ </p><ul><li>语法错误：命令书写格式有误</li><li>处理结果 如果定义的事务中所包含的命令存在语法错误，整体事务中所有命令均不会执行。包括那些语法正确的命令。</li></ul><p><img src="1588600366786.png" alt="1588600366786"></p></li><li><p>定义事务的过程中，<strong>命令执行出现错误</strong>怎么办？ </p><ul><li>运行错误：命令格式正确，但是无法正确的执行。例如对list进行incr操作 </li><li>能够正确运行的命令会执行，运行错误的命令不会被执行 </li></ul><p><img src="1588600336265.png" alt="1588600336265"></p></li><li><p><strong>已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚。</strong></p></li></ul><h2 id="基于特定条件的事务执行"><a href="#基于特定条件的事务执行" class="headerlink" title="基于特定条件的事务执行"></a>基于特定条件的事务执行</h2><ul><li><p>多个客户端有可能同时操作同一组数据，并且该数据一旦被操作修改后，将不适用于继续操作</p></li><li><p>在操作之前锁定要操作的数据，一旦发生变化，终止当前操作</p></li><li><p>对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch key1 [key2……]</span><br></pre></td></tr></table></figure><blockquote><p>watch 不能在multi命令之后</p></blockquote></li><li><p>取消对所有 key 的监视 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unwatch</span><br></pre></td></tr></table></figure></li></ul><h3 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h3><ul><li>redis 应用基于状态控制的批量任务执行</li></ul><h1 id="6-Redis-删除策略"><a href="#6-Redis-删除策略" class="headerlink" title="6.Redis 删除策略"></a>6.Redis 删除策略</h1><h2 id="6-1过期数据"><a href="#6-1过期数据" class="headerlink" title="6.1过期数据"></a>6.1过期数据</h2><ul><li>Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态<ul><li>XX ：具有时效性的数据</li><li>-1 ：永久有效的数据 ：已经过期的数</li><li>-2 ：<strong>已经过期的数据</strong> 或 被删除的数据 或 未定义的数据</li></ul></li></ul><h2 id="6-2数据删除策略"><a href="#6-2数据删除策略" class="headerlink" title="6.2数据删除策略"></a>6.2数据删除策略</h2><h3 id="6-2-1时效性数据的存储结构"><a href="#6-2-1时效性数据的存储结构" class="headerlink" title="6.2.1时效性数据的存储结构"></a>6.2.1时效性数据的存储结构</h3><p><img src="1588602997289.png" alt="1588602997289"></p><h3 id="6-2-2数据删除策略的目标"><a href="#6-2-2数据删除策略的目标" class="headerlink" title="6.2.2数据删除策略的目标"></a>6.2.2数据删除策略的目标</h3><p>在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露</p><h3 id="6-2-3定时删除"><a href="#6-2-3定时删除" class="headerlink" title="6.2.3定时删除"></a>6.2.3定时删除</h3><ul><li>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作<ul><li>优点：节约内存，到时就删除，快速释放掉不必要的内存占用 </li><li>缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量 </li><li>总结：用处理器性能换取存储空间 （拿时间换空间）</li></ul></li></ul><p><img src="1588603340595.png" alt="1588603340595"></p><p><img src="1588603390266.png" alt="1588603390266"></p><h3 id="6-2-4惰性删除"><a href="#6-2-4惰性删除" class="headerlink" title="6.2.4惰性删除"></a>6.2.4惰性删除</h3><ul><li><p>数据到达过期时间，不做处理。等下次访问该数据时</p><ul><li>如果未过期，返回数据</li><li>发现已过期，删除，返回不存在</li></ul></li><li><p>优点：节约CPU性能，发现必须删除的时候才删除</p></li><li><p>缺点：内存压力很大，出现长期占用内存的数据</p></li><li><p>总结：用存储空间换取处理器性能 （拿时间换空间）</p><p><img src="1588603547170.png" alt="1588603547170"></p><p><img src="1588603606205.png" alt="1588603606205"></p></li></ul><h3 id="6-2-5定期删除"><a href="#6-2-5定期删除" class="headerlink" title="6.2.5定期删除"></a>6.2.5定期删除</h3><ul><li><p>Redis启动服务器初始化时，读取配置server.hz的值，默认为10</p></li><li><p>每秒钟执行server.hz次<code>serverCron()</code></p><p>​                                                —-&gt;<code>databasesCron()</code></p><p>​                                                     —-&gt;<code>activeExpireCycle()</code></p></li><li><p><code>activeExpireCycle()</code>对每个<code>expires[*]</code>逐一进行检测，每次执行<code>250/server.hz</code>ms</p></li><li><p>对某个<code>expires[*]</code>检测时，随机挑选W个key检测 </p><ul><li>如果key超时，删除key </li><li>如果一轮中<code>删除的key的数量&gt;W*25%</code>，循环该过程</li><li>如果一轮中<code>删除的key的数量≤W*25%</code>，检查下一个<code>expires[\*]</code>，0-15循环</li></ul></li><li><p><code>W=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP</code>属性值</p></li><li><p>参数<code>current_db</code>用于记录<code>activeExpireCycle()</code>进入哪个<code>expires[*]</code>执行。如果activeExpireCycle()执行时间到期，下次从<code>current_db</code>继续向下执行</p></li><li><p>周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度</p><ul><li>特点1：CPU性能占用设置有峰值，检测频度可自定义设置</li><li>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理 </li></ul></li><li><p>总结：周期性抽查存储空间（随机抽查，重点抽查）</p></li></ul><p><img src="1588603704644.png" alt="1588603704644"></p><p><img src="1588604972997.png" alt="1588604972997"></p><h2 id="6-3逐出算法"><a href="#6-3逐出算法" class="headerlink" title="6.3逐出算法"></a>6.3逐出算法</h2><ul><li><p>Redis使用内存存储数据，在执行每一个命令前，会调用<code>freeMemoryIfNeeded()</code>检测内存是否充足。</p></li><li><p>逐出算法：<strong>如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略即为逐出算法。</strong></p></li><li><p>注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。</p><p><img src="1588606582199.png" alt="1588606582199"></p></li><li><p>最大可使用内存，占用物理内存的比例，默认值为0，表示不限制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory []</span><br></pre></td></tr></table></figure><blockquote><p>生产环境中根据需求设定，通常设置在50%以上。</p></blockquote></li><li><p>每次选取待删除数据的个数，选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-samples []</span><br></pre></td></tr></table></figure></li><li><p>删除策略，达到最大内存后的，对被挑选出来的数据进行删除的策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy []</span><br></pre></td></tr></table></figure><ul><li>检测易失数据（可能会过期的数据集server.db[i].expires ）<ul><li>① volatile-lru：挑选最近最少使用的数据淘汰</li><li>② volatile-lfu：挑选最近使用次数最少的数据淘汰 </li><li>③ volatile-ttl：挑选将要过期的数据淘汰 </li><li>④ volatile-random：任意选择数据淘汰 </li></ul></li><li>检测全库数据（所有数据集server.db[i].dict ）<ul><li>⑤ allkeys-lru：挑选最近最少使用的数据淘汰 </li><li>⑥ allkeys-lfu：挑选最近使用次数最少的数据淘汰 </li><li>⑦ allkeys-random：任意选择数据淘汰 </li></ul></li><li>放弃数据驱逐 <ul><li>⑧ no-enviction（驱逐）：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out Of Memory）</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Jedis Redis持久化 Redis事务 删除策略
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Redis" scheme="http://goldcarpenter.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Nginx</title>
    <link href="http://goldcarpenter.github.io/2020/03/29/Nginx%E5%9F%BA%E7%A1%80/"/>
    <id>http://goldcarpenter.github.io/2020/03/29/Nginx%E5%9F%BA%E7%A1%80/</id>
    <published>2020-03-28T16:00:00.000Z</published>
    <updated>2020-06-17T07:06:28.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h1 id="1-Nginx简介"><a href="#1-Nginx简介" class="headerlink" title="1 Nginx简介"></a>1 Nginx简介</h1><ul><li>Nginx是<strong>开源</strong>，<strong>高性能</strong>，<strong>高可靠的</strong>Http Web服务、代理服务、负载均衡<ul><li>高性能：支持海量并发，有报告表明能支持高达50, 000个并发连接数</li><li>可靠：服务稳定 </li><li>轻量：占用内存资源少</li></ul></li><li>Nginx优点<ul><li>轻量级<ul><li>功能模块少（源代码仅保留http与核心模块代码,其余不够核心代码会作为插件来安装）</li><li>代码模块化（易读，便于二次开发，对于开发人员非常友好）</li></ul></li><li>技术成熟，国内公司基本大规模使用<ul><li>适合当前主流架构趋势，微服务、云架构、中间层</li><li>统一技术栈，降低维护成本，降低技术更新成本</li></ul></li><li>Nginx采用Epoll网络模型，Apache 采用select模型<ul><li>select：当用户发起一次请求，select模型就会进行一次遍历扫描， 从而导致性能低下</li><li>Epoll：当用户发起请求，epool模型会直接进行处理，效率高效，并无连接限制</li></ul></li></ul></li><li>常用的HTTP Web服务<ul><li>Httpd——Apache基金会</li><li>IIS——微软服务器版</li><li>GWS——Google开发</li><li>Openrestry——基于Nginx+lua</li><li>Tengline——淘宝基于Nginx开发</li></ul></li></ul><h1 id="2-Nginx应用场景"><a href="#2-Nginx应用场景" class="headerlink" title="2 Nginx应用场景"></a>2 Nginx应用场景</h1><p><img src="1575686992791.png" alt="1575686992791"></p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><ul><li>正向代理：在客户端(浏览器)配置代理服务器，通过代理服务器进行互联网访问</li></ul><p><img src="1575687744434.png" alt="1575687744434"></p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><ul><li><p>我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据<br>返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器， 暴露的是<br>代理服务器地址,隐藏了真实服务器IP地址</p><p><img src="1588901698779.png" alt="1588901698779"></p></li></ul><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li><p>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器。</p><p><img src="1588902037728.png" alt="1588902037728"></p></li></ul><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><ul><li><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。</p><p><img src="1588903187825.png" alt="1588903187825"></p></li></ul><h2 id="Nginx安装方式"><a href="#Nginx安装方式" class="headerlink" title="Nginx安装方式"></a>Nginx安装方式</h2><ul><li><p>官方源 ——官方编译好的，封装成rpm包，并提供yum源【推荐】</p><ul><li><p>nginx.org 官网有详细过程[<a href="http://nginx.org/en/download.html]" target="_blank" rel="noopener">http://nginx.org/en/download.html]</a></p></li><li><p>配置Nginx官方yum仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@web01 ~]# vim /etc/yum.repos.d/nginx.repo</span><br><span class="line">    [nginx]</span><br><span class="line">    name=nginx repo</span><br><span class="line">    baseurl=http://nginx.org/packages/centos/7/$basearch/</span><br><span class="line">    gpgcheck=0</span><br><span class="line">    enabled=1</span><br></pre></td></tr></table></figure></li><li><p>安装nginx，必须安装官方源的nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@web01 ~]# yum install -y nginx</span><br><span class="line">[root@web01 ~]# nginx -v# 查询是否成功</span><br><span class="line">    nginx version: nginx/1.14.0</span><br></pre></td></tr></table></figure></li><li><p>访问网址 查询是否成功</p></li></ul></li><li><p>EPEL源——版本低，功能少</p></li><li><p>源代码——自己下载源代码，安装复杂，费时</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果企业之前的Nginx都是通过源码安装，这时需要我们部署新的Nginx服务器，怎么接手通过源代码方式安装</span><br><span class="line">通过nginx -v获得版本</span><br><span class="line">通过nginx -V查看配置选项</span><br></pre></td></tr></table></figure><h2 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h2><ul><li><p>查看nginx的版本号    </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -v</span><br></pre></td></tr></table></figure></li><li><p>启动nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure></li><li><p>关闭nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop</span><br></pre></td></tr></table></figure></li><li><p>重新加载nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></li><li><p>配置文件语法检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure></li></ul><p>  ​    </p><h2 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h2><ul><li>Nginx主配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;conf.d</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf</span><br></pre></td></tr></table></figure><ul><li>Cgi、Fastcgi、 Uwcgi配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx&#x2F;fastcgi_params</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;scgi_params</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;uwsgi_params</span><br></pre></td></tr></table></figure><ul><li>Nginx编码转换映射文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx&#x2F;win-utf</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;koi-utf</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;koi-win</span><br></pre></td></tr></table></figure><ul><li>http协议的Content-Type与扩展名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx&#x2F;mime.types</span><br></pre></td></tr></table></figure><ul><li>配置系统守护进程管理器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;1ib&#x2F;systemd&#x2F;system&#x2F;nginx.service</span><br></pre></td></tr></table></figure><ul><li>Nginx日志轮询，日志切割</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;logrotate.d&#x2F;nginx</span><br></pre></td></tr></table></figure><ul><li>Nginx终端管理命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;nginx</span><br><span class="line">&#x2F;usr&#x2F;sbin&#x2F;nginx-debug</span><br></pre></td></tr></table></figure><ul><li>Nginx模块目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx&#x2F;modules</span><br><span class="line">&#x2F;usr&#x2F;1ib64&#x2F;nginx</span><br><span class="line">&#x2F;usr&#x2F;1ib64&#x2F;nginx&#x2F;modules</span><br></pre></td></tr></table></figure><ul><li>Nginx默认站点目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;50x.html</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure><ul><li>Nginx的帮助手册</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.14.0</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;man&#x2F;man8&#x2F;nginx.8.gz</span><br></pre></td></tr></table></figure><ul><li>Nginx的缓存目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;cache&#x2F;nginx</span><br></pre></td></tr></table></figure><ul><li>Nginx的日志目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;log&#x2F;nginx</span><br></pre></td></tr></table></figure><h2 id="Nginx主配置文件"><a href="#Nginx主配置文件" class="headerlink" title="Nginx主配置文件"></a>Nginx主配置文件</h2><ul><li><p><code>nginx.conf</code>是一个纯文本类型的文件，整个配置文件是以区块的形式组织的。每个区块以一对大括号{}来表示开始与结束</p><p><img src="1575703052492.png" alt="1575703052492"></p></li></ul><h3 id="CoreModule核心模块"><a href="#CoreModule核心模块" class="headerlink" title="CoreModule核心模块"></a>CoreModule核心模块</h3><ul><li>从<strong>配置文件开始</strong>到<strong>events块</strong>之间的内容</li><li>主要会<strong>设置一些影响nginx服务器整体运行的配置指令</strong>，主要包括配置运行Nginx服务器的用户(组)、允许生成的worker process数，进程PID存放路径、日志存放路径和类型以及配置文件的引入等。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user nginx;#Nginx进程所使用的用户</span><br><span class="line">worker_processes 1;#Nginx运行的work进程数量(建议与CPU数量一致或auto)</span><br><span class="line">error_log &#x2F;1og&#x2F;nginx&#x2F;error.1og; #Nginx错误日志存放路径</span><br><span class="line">pid &#x2F;var&#x2F;run&#x2F;nginx.pid;#Nginx服务运行后产生的pid进程号</span><br></pre></td></tr></table></figure><h3 id="EventModule-事件驱动模块"><a href="#EventModule-事件驱动模块" class="headerlink" title="EventModule    事件驱动模块"></a>EventModule    事件驱动模块</h3><ul><li><p>影响Nginx服务器与用户的网络连接</p></li><li><p>常用的设置包括是否开启对多work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个word process可以同时支持的最大连接数等。</p></li><li><p><strong>对Nginx的性能影响较大，在实际中应该灵活配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;#每个worker进程支持的最大连接数</span><br><span class="line">    use epool;#事件驱动模型，epoll默认</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="HttpCoreModule-http内核模块"><a href="#HttpCoreModule-http内核模块" class="headerlink" title="HttpCoreModule http内核模块"></a>HttpCoreModule http内核模块</h3><ul><li><p>Nginx服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。</p></li><li><p>http内核模块</p><ul><li>http全局块</li><li>server 块</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">http &#123; </span><br><span class="line"><span class="meta">#</span><span class="bash"> http全局块</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#</span><span class="bash">使用server配置网站，每个Server&#123;&#125;代表一个网站(简称虛拟主机)</span></span><br><span class="line">server&#123;</span><br><span class="line">listen80;#监听端口，默认80</span><br><span class="line">server_namelocalhost; #提供服务的域名或主机名</span><br><span class="line">access_log host.access.1og  #访问日志</span><br><span class="line"><span class="meta">#</span><span class="bash">控制网站访问路径</span></span><br><span class="line">location / &#123;</span><br><span class="line">root/usr/share/nginx/html; //存放网站 代码路径</span><br><span class="line">index index.php index.html index.htm;</span><br><span class="line">//服务器返回的默认页面文件</span><br><span class="line">//指定错误代码，统一定义错误页面，错误代码重定向到新的Locaiton</span><br><span class="line">error_page500 502 503 504 /50x.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">第二个虚拟主机配置</span></span><br><span class="line">server&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">include /etc/nginx/conf.d/*.conf; #其他附加配置文件</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="http全局块"><a href="#http全局块" class="headerlink" title="http全局块"></a>http全局块</h4><ul><li>http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</li></ul><h4 id="server-块"><a href="#server-块" class="headerlink" title="server 块"></a>server 块</h4><ul><li><p>HTTP模块层允许有多个Server块  Server主要 用于配置多个网站</p></li><li><p>Server块又允许有多个Location Location主要用于定义网站访问路径</p><p><img src="1575703252359.png" alt="1575703252359"></p></li></ul><h4 id="location指令详解"><a href="#location指令详解" class="headerlink" title="location指令详解"></a>location指令详解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location [ &#x3D; | ~ | ~* | ^~ ] uri&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>没有修饰符：必须以指定模式开始，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">　　server_name baidu.com;</span><br><span class="line">　　location &#x2F;abc &#123;</span><br><span class="line">　　　　……</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">那么，如下是对的：</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc?p1</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abcde</span><br></pre></td></tr></table></figure></li><li><p><code>=</code>：用于不含正则表达式的uri前，要求请求字符串与uri严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">server_name sish</span><br><span class="line">　　location &#x3D; &#x2F;abc &#123;</span><br><span class="line">　　　　……</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">那么，如下是对的：</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc?p1</span><br><span class="line">如下是错的：</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abcde</span><br></pre></td></tr></table></figure></li><li><p><code>~</code> ： 用于表示uri包含正则表达式，并且区分大小写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name baidu.com;</span><br><span class="line">    location ~^ &#x2F;abc$ &#123;</span><br><span class="line">        ……</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">那么，如下是对的：</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc?p1&#x3D;11&amp;p2&#x3D;22</span><br><span class="line">如下是错的：</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;ABC</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abcde</span><br></pre></td></tr></table></figure></li><li><p><code>~*</code>：用于表示uri包含正则表达式，并且不区分大小写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">server_name baidu.com;</span><br><span class="line">location ~* ^&#x2F;abc$ &#123;</span><br><span class="line">　　　　……</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">那么，如下是对的：</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc</span><br><span class="line">http:&#x2F;&#x2F;baidu..com&#x2F;ABC</span><br><span class="line">http:&#x2F;&#x2F;baidu..com&#x2F;abc?p1&#x3D;11&amp;p2&#x3D;22</span><br><span class="line">如下是错的：</span><br><span class="line">http:&#x2F;&#x2F;baidu..com&#x2F;abc&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;baidu..com&#x2F;abcde</span><br></pre></td></tr></table></figure></li><li><p><code>^~</code>：用于不含正则表达式的 uri前，无修饰符的行为，也是以指定模式开始，不同的是，如果模式匹配，那么就停止搜索其他模式了。</p></li><li><p>注意：如果uri包含正则表达式，则必须要有<code>~</code>或者<code>~*</code>标识</p></li></ul><h4 id="root-amp-alias指令区别"><a href="#root-amp-alias指令区别" class="headerlink" title="root &amp; alias指令区别"></a><strong>root &amp; alias指令区别</strong></h4><ul><li><p><strong>alias是一个目录别名的定义，root则是最上层目录的定义。</strong></p></li><li><p>若按照上述配置的话，则访问/img/目录里面的文件时，ningx会自动去/var/www/image/目录找文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;img&#x2F; &#123;</span><br><span class="line">    alias &#x2F;var&#x2F;www&#x2F;image&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>#若按照这种配置的话，则访问/img/目录下的文件时，nginx会去/var/www/image/img/目录下找文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;img&#x2F; &#123;</span><br><span class="line">    root &#x2F;var&#x2F;www&#x2F;image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还有一个重要的区别是alias后面必须要用“/”结束，否则会找不到文件，而root则可有可无</p></li></ul><h2 id="Nginx搭建Web服务器"><a href="#Nginx搭建Web服务器" class="headerlink" title="Nginx搭建Web服务器"></a>Nginx搭建Web服务器</h2><ul><li><strong>Nginx可以作为静态页面的web服务器</strong>，同时还支持CGI协议的动态语言，比如perl、php等。但是<strong>不支持Java，Java程序只能通过与tomcat配合完成</strong></li></ul><ul><li><p>Nginx配置Web服务器网站【功能同Apache的Tomcat】——接收客户请求端请求，并响应</p><ul><li>功能：当我们访问game.oldboy.com的时候，访问/oldboy_code/里面的页面代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name yangyuxin.top;</span><br><span class="line">    index index.php index.html index.htm default.php default.htm default.html;</span><br><span class="line">    root &#x2F;www&#x2F;wwwroot&#x2F;yangyuxin.top;# 静态页面所在目录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h2><ul><li><p>功能：使用Nginx从<strong>80端口跳转到8080端口</strong>的Tomcat主页</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">    &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name yangyuxin.top;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">          root html;</span><br><span class="line">          proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;&#x2F;&#x2F;⭐</span><br><span class="line">          index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>功能：使用 nginx 反向代理，根据访问的路径跳转到不同端口的服务中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">    &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name yangyuxin.top;</span><br><span class="line">        location ~/hello/ &#123;</span><br><span class="line">          root html;</span><br><span class="line">          proxy_pass http://127.0.0.1:8080;</span><br><span class="line">          index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        location ~/world/ &#123;</span><br><span class="line">          root html;</span><br><span class="line">          proxy_pass http://127.0.0.1:8081;</span><br><span class="line">          index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="1588928819346.png" alt="1588928819346"></p><p><img src="1588928842462.png" alt="1588928842462"></p></li></ul><h2 id="Nginx负载均衡"><a href="#Nginx负载均衡" class="headerlink" title="Nginx负载均衡"></a>Nginx负载均衡</h2><ul><li><p>实现效果：浏览器地址栏输入地址负载均衡，按比例均衡到8080和8081端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">upstream myservername&#123;&#x2F;&#x2F;⭐</span><br><span class="line">    # ip_hash&#x2F;&#x2F; 每个请求按访问ip的hash结果分配，访客固定访问一个后端服务器,可以解决session的问题。</span><br><span class="line">    server 47.92.38.57:8080 weight&#x3D;2; &#x2F;&#x2F;⭐</span><br><span class="line">    server 47.92.38.57:8081 weight&#x3D;4;    &#x2F;&#x2F;⭐</span><br><span class="line">    # fair&#x2F;&#x2F; 按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server</span><br><span class="line">    &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name yangyuxin.top;</span><br><span class="line">        location ~&#x2F;hello&#x2F; &#123;</span><br><span class="line">          root html;</span><br><span class="line">          proxy_pass http:&#x2F;&#x2F;myservername;&#x2F;&#x2F;⭐</span><br><span class="line">          index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Nginx高可用"><a href="#Nginx高可用" class="headerlink" title="Nginx高可用"></a>Nginx高可用</h2><p><img src="1588955148812.png" alt="1588955148812"></p><ul><li>准备<ul><li>两台nginx服务器</li><li>分别安装keepalived</li><li>虚拟ip</li></ul></li></ul><h3 id="Keepalived实现高可用"><a href="#Keepalived实现高可用" class="headerlink" title="Keepalived实现高可用"></a>Keepalived实现高可用</h3><ul><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install keepalived -y</span><br></pre></td></tr></table></figure></li><li><p>安装之后，在<code>etc</code>里面生成目录<code>keepalived</code>, 有文件<code>keepalived.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;# 全局配置</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 192.168.200.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL# ⭐通过这个名字可以访问主机&#x2F;服务器 &#x2F;etc&#x2F;hosts文件下配置这个名字</span><br><span class="line">   vrrp_skip_check_adv_addr</span><br><span class="line">   vrrp_strict</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_http_port &#123;# 脚本配置</span><br><span class="line">script &quot;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_check.sh&quot;</span><br><span class="line">interval 2#(检测脚本执行的间隔)</span><br><span class="line">weight 2# 设置当前服务器权重</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;# 虚拟IP配置</span><br><span class="line">    state MASTER# 备份服务器改为BACKUP</span><br><span class="line">    interface eth0# 网卡</span><br><span class="line">    virtual_router_id 51# 主、备机的virtual_ router_ id必须相同</span><br><span class="line">    priority 100#主、备机取不同的优先级，主机值较大，备份机值较小</span><br><span class="line">    advert_int 1# 心跳时间</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.200.16#VRRP H虚拟IP</span><br><span class="line">        192.168.200.17</span><br><span class="line">        192.168.200.18</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>检测脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line">A&#x3D; &#96;ps -C nginx -no-header| wc -l&#96;</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br><span class="line">sleep 2</span><br><span class="line">if [&#96;ps -C nginx --no-header| wc -l&#96; -eq 0];</span><br><span class="line">killall keepalived</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><p>把两台服务器上nginx和keepalived启动。</p><ul><li><p>启动nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>启动keepalived</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start keepalived.services</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Nginx目录索引模块"><a href="#Nginx目录索引模块" class="headerlink" title="Nginx目录索引模块"></a>Nginx目录索引模块</h2><ul><li><p>官方文档使用说明</p><p><img src="1575780742140.png" alt="1575780742140"></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Nginx 默认是不允许列出整个目录浏览下载</span><br><span class="line">Syntax: autoindex on | off;</span><br><span class="line">Default: autoindex off;</span><br><span class="line">Context: http, server, location</span><br><span class="line"></span><br><span class="line"># autoindex常用参数</span><br><span class="line">autoindex_exact_size off;# 默认为on 显示出文件的确切大小 单位是bytes</span><br><span class="line"># 修改为off 显示出文件的大概大小 单位是kB或者MB或者GB</span><br><span class="line">autoindex_localtime on;# 默认为off 显示的文件时间为GMT时间</span><br><span class="line"># 修改为on 显示的文件时间为文件的服务器时间</span><br><span class="line">charset utf-8,gbk;# 默认中文目录乱码 添加解决乱码</span><br></pre></td></tr></table></figure><ul><li><p>访问game.oldboy.com/download，打开目录索引列表</p><ul><li>在配置文件中添加</li></ul><p><img src="1575783147690.png" alt="1575783147690"></p><p><img src="1575785803803.png" alt="1575785803803"></p></li></ul><h2 id="Nginx状态监控模块"><a href="#Nginx状态监控模块" class="headerlink" title="Nginx状态监控模块"></a>Nginx状态监控模块</h2><ul><li><p>ngx_http_stub_status_module用于展示Nginx连接状态信息</p><ul><li><p>需要–with-http_stub_status_module配置参数启用【nginx -V 查看】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Syntax:stub_status;</span><br><span class="line">Default:—</span><br><span class="line">Context:    server, location</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">- 如果使用restart重置服务，会清空所有的连接数</span><br><span class="line">- reload重载不会清空之前的连接数</span><br><span class="line">- 通过状态监控，可以区分长连接和短连接</span><br><span class="line">vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf#修改下面参数</span><br><span class="line">keepalive_timeout 0; #将长连接变为短连接</span><br></pre></td></tr></table></figure></li></ul><p><img src="1575786624450.png" alt="1575786624450"></p><p><img src="1575785770881.png" alt="1575785770881"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Active connections # 当前活动的连接数</span><br><span class="line">accepts4# 当前的总连接数TCP</span><br><span class="line">handled4# 成功的连接数TCP</span><br><span class="line">requests 61# 总的http请求数</span><br></pre></td></tr></table></figure></li></ul><h2 id="Nginx访问控制"><a href="#Nginx访问控制" class="headerlink" title="Nginx访问控制"></a>Nginx访问控制</h2><ul><li><p>访问控制分类</p><ul><li><p>基于IP的访问控制http_access_modul</p><ul><li>只允许10.0.0.1访问nginx_status,其他都拒绝</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">应用——网站后台</span><br><span class="line"></span><br><span class="line"># 从上往下依次匹配 满足则停止</span><br><span class="line"># 允许配置语法</span><br><span class="line">Syntax:allow address | CIDR | unix: | all;</span><br><span class="line">Default: —</span><br><span class="line">Context: http, server, location, limit_except</span><br><span class="line"># 拒绝配置语法</span><br><span class="line">Syntax:deny address | CIDR | unix: | all;</span><br><span class="line">Default:—</span><br><span class="line">Context: http, server, location, limit_except</span><br></pre></td></tr></table></figure><p><img src="1575791192758.png" alt="1575791192758"></p></li><li><p>基于用户登陆认证http_auth_basic_module</p><ul><li>身份认证后才可以登录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;配置语法</span><br><span class="line">Syntax: auth_basic string | off;</span><br><span class="line">Default:auth_basic off;</span><br><span class="line">Context:http, server, location, limit_except</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;配置语法 用户密码记录配置文件</span><br><span class="line">Syntax: auth_basic_user_file file;</span><br><span class="line">Default:-</span><br><span class="line">Context:http，server, location, limit_except</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;需要安装依赖组件</span><br><span class="line">[root@web01 ~]# yum install httpd-too1s</span><br><span class="line">[root@web01 ~]# htpasswd -b -c &#x2F;etc&#x2F;nginx&#x2F;.auth_conf username 123456</span><br></pre></td></tr></table></figure><p><img src="1575794573505.png" alt="1575794573505"></p></li></ul></li></ul><h2 id="Nginx访问限制"><a href="#Nginx访问限制" class="headerlink" title="Nginx访问限制"></a>Nginx访问限制</h2><ul><li>经常会遇到这种情况， 服务器流量异常，负载过大等等。</li><li>对于大流量恶意的攻击访问，会带来带宽的浪费， 服务器压力，影响业务，往往考虑对同一个IP的连接数，并发数进行限制</li><li>ngx_http_limit_conn_module 模块可以根据定义的key来限制每个键值的连接数，如同一个IP来源的连接数</li></ul><h3 id="limit-conn-module连接频率限制"><a href="#limit-conn-module连接频率限制" class="headerlink" title="limit_conn_module连接频率限制"></a>limit_conn_module连接频率限制</h3><ul><li>同一IP同一时间只允许有一个连接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$binary_remote_addr 变量的长度是固定的4字节</span><br><span class="line">$remote_addr变量的长度是7-15字节</span><br><span class="line"></span><br><span class="line">Syntax: limit_conn_zone key zone&#x3D;name:size;</span><br><span class="line">Default: -</span><br><span class="line">Context: http;</span><br><span class="line"></span><br><span class="line">Syntax:limit_conn zone number;</span><br><span class="line">Default: —</span><br><span class="line">Context: http, server, location</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;压力测试</span><br><span class="line">yum install -y httpd-tools</span><br><span class="line">ab -n 50 -c 20 http:&#x2F;&#x2F;127.0.0.1&#x2F;index.html# 一次50个请求 20个并发</span><br></pre></td></tr></table></figure><p><img src="1575797185873.png" alt="1575797185873"></p><h3 id="limit-req-module请求频率限制"><a href="#limit-req-module请求频率限制" class="headerlink" title="limit_req_module请求频率限制"></a>limit_req_module请求频率限制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Syntax: limit_req_zone key zone&#x3D;name:size rate&#x3D;rate;</span><br><span class="line">Default: -</span><br><span class="line">Context: http</span><br><span class="line"></span><br><span class="line">Syntax:limit_req zone&#x3D;name [burst&#x3D;number] [nodelay | delay&#x3D;number];</span><br><span class="line">Default:—</span><br><span class="line">Context:http, server, location </span><br><span class="line"></span><br><span class="line">Syntax: limit_req_status code;</span><br><span class="line">Default: 503</span><br><span class="line">Context: http, server, location</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义的区域名称为req_zone（zone&#x3D;req_zone） 分配内存大小为10m（如果限制域的存储空间耗尽了 对于后续所有请求 服务器都会返回503） </span><br><span class="line">同一个ip（$binary_remote_addr）平均处理的请求频率不能超过每秒1次（rate&#x3D;1r&#x2F;s）； 如果超过每秒1次但超过的请求数量小于等于3（burst&#x3D;3）时，会延迟请求。</span><br><span class="line">如果超过每秒1次的请求数超过3，则立即返回503（limit_req_status 503）给客户端</span><br></pre></td></tr></table></figure><p><img src="1575799641241.png" alt="1575799641241"></p><h3 id="请求-连接限制对比"><a href="#请求-连接限制对比" class="headerlink" title="请求/连接限制对比"></a>请求/连接限制对比</h3><ul><li>多个请求可以建立在一次的TCP连接之上，那么我们对请求的精度限制，当然比对一个连接的限制会更加的有效，因为同- -时刻只允许一个连接请求进入。但是同一 时刻多个请求可以通过一个 连接进入。所以<strong>请求限制才是比较优的解决方案</strong></li></ul><h1 id="Nginx原理"><a href="#Nginx原理" class="headerlink" title="Nginx原理"></a>Nginx原理</h1><ul><li><p><code>master &amp; worker</code></p><ul><li>master进程主要负责对外接收客户端的请求，并将活儿合理的分配给多个worker，每个worker进程主要负责处理请求。</li></ul><p><img src="1589002067112.png" alt="1589002067112"></p><p><img src="1589002116526.png" alt="1589002116526"></p></li><li><p><code>master-workers</code>的机制的优点</p><ul><li>可以使用 <code>nginx –s reload</code>热部署，利用 nginx进行热部署操作</li><li>每个worker进程是独立的进程，不需要加锁，节省锁带来的开销。</li><li>每个worker进程互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的worker进程。</li></ul></li><li><p>设置多少个 woker 合适</p><ul><li>Nginx同redis类似都采用了io 多路复用机制，每个worker都是一个独立的进程， 但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求，即使是千上万个请求也不在话下。每个worker的线程可以把一个cpu的性能发挥到极致。所以<strong>worker数和服务器的cpu数相等是最为适宜的</strong>。设少了会浪费qpu，设多了会造成cgpu频繁切换上下文带来的损耗。</li></ul><p><img src="1589002735126.png" alt="1589002735126"></p></li><li><p>发送请求，占用了 woker 的几个连接数？</p><ul><li><p>从用户的角度，http 1.1协议下，由于浏览器默认使用两个并发连接,因此计算方法：</p><ul><li>nginx作为http服务器的时候</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_clients &#x3D; worker_processes * worker_connections&#x2F;2</span><br></pre></td></tr></table></figure><ul><li>nginx作为反向代理服务器的时候：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_clients &#x3D; worker_processes * worker_connections&#x2F;4</span><br></pre></td></tr></table></figure></li><li><p>从一般建立连接的角度：客户并发连接为1.</p><ul><li><p>nginx作为http服务器的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_clients &#x3D; worker_processes * worker_connections</span><br></pre></td></tr></table></figure></li><li><p>nginx作为反向代理服务器的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_clients &#x3D; worker_processes * worker_connections&#x2F;2</span><br></pre></td></tr></table></figure><blockquote><p>nginx做反向代理时，和客户端之间保持一个连接，和后端服务器保持一个连接。  </p></blockquote></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Nginx简介 配置 应用场景
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Nginx" scheme="http://goldcarpenter.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://goldcarpenter.github.io/2020/03/26/Redis_Part1/"/>
    <id>http://goldcarpenter.github.io/2020/03/26/Redis_Part1/</id>
    <published>2020-03-26T00:56:17.000Z</published>
    <updated>2020-06-17T07:20:53.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-架构"><a href="#0-架构" class="headerlink" title="0.架构"></a>0.架构</h1><ul><li>Redis基础<ul><li>Redis 入门</li><li>数据类型</li><li>通用命令</li><li>Jedis</li></ul></li><li>Redis高级<ul><li>持久化</li><li>redis.conf</li><li>事务</li><li>集群</li></ul></li><li>Redis应用<ul><li>企业级解决方案</li></ul></li></ul><h1 id="1-Redis"><a href="#1-Redis" class="headerlink" title="1.Redis"></a>1.Redis</h1><h2 id="1-1NoSQL介绍"><a href="#1-1NoSQL介绍" class="headerlink" title="1.1NoSQL介绍"></a>1.1NoSQL介绍</h2><ul><li>网站崩溃现象来源：①海量用户②高并发</li><li>罪魁祸首——关系型数据库<ul><li>性能瓶颈：磁盘IO性能低下</li><li>扩展瓶颈：数据关系复杂,扩展性差,不便于大规模集群</li></ul></li><li>解决思路<ul><li>降低磁盘IO次数,越低越好——内存存储</li><li>去除数据间关系，越简单越好——不存储关系，仅存储数据</li></ul></li><li><strong><code>NoSQL</code>：即<code>Not-OnlySQL</code>(泛指非关系型的数据库）</strong></li><li><strong>定位：作为关系型数据库的补充</strong></li><li>作用：应对基于<strong>海量用户和海量数据</strong>前提下的数据处理问题。</li><li>特征：<ul><li>可扩容，可伸缩</li><li>大数据量下高性能</li><li>灵活的数据模型</li><li>高可用</li></ul></li><li>常见Nosql数据库：<ul><li>Redis</li><li>memcache</li><li>HBase</li><li>MongoDB</li></ul></li><li>电商场景解决方案<img src="1580133771032.png" alt="1580133771032"></li></ul><p><img src="1580133718517.png" alt="1580133718517"></p><h2 id="1-2Redis简介"><a href="#1-2Redis简介" class="headerlink" title="1.2Redis简介"></a>1.2Redis简介</h2><ul><li><p>Redis (Remote Dictionary Server)是一个<strong>开源</strong>的高性能<strong>键值对(key-value) 数据库</strong></p></li><li><p>特征</p><ul><li>数据间没有必然的关联关系</li><li>内部<strong>采用单线程机制</strong>进行工作</li><li>高性能。官方提供测试数据, 50个并发执行100000个请求读的速度是110000次/s，写的速度是81000次/s。</li><li>多数据类型支持<ul><li>字符串类型——string</li><li>列表类型——list</li><li>散列类型——hash</li><li>集合类型——set</li><li>有序集合类型——sorted_set</li></ul></li><li>持久化支持。可以进行数据灾难恢复（不是主要功能）</li></ul></li><li><p>应用</p><ul><li>为<strong>热点数据加速查询</strong>(主要场景)， 如热点商品、热点新闻、热点资讯、推广类等高访问量信息等</li><li>任务队列，如秒杀、抢购、购票排队等</li><li>即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息(聊天室、网站)、设备信号等</li><li>时效性信息控制，如验证码控制、投票控制等</li><li>分布式数据共享，如分布式集群架构中的session分离</li><li>消息队列</li><li>分布式锁</li></ul></li></ul><h2 id="1-3Redis下载-安装"><a href="#1-3Redis下载-安装" class="headerlink" title="1.3Redis下载/安装"></a>1.3Redis下载/安装</h2><ul><li><p>Windows：<code>Redis-x64-3.2.100.zip</code></p></li><li><p>绿色版，解压即可</p></li><li><p>解压文件</p><ul><li>核心文件<ul><li><code>redis-server.exe</code>——服务器启动命令</li><li><code>redis-cli.exe</code>——命令行客户端</li><li><code>redis.windows.conf</code>——redis核心配置文件</li><li><code>redis-benchmarkexe</code>——性能测试工具</li><li><code>redis-check- aof.exe</code>——AOF文件修复工具</li><li><code>redis-check-dump.exe</code>——RDB文件检查工具(快照持久化文件)</li></ul></li></ul><p><img src="1580178215132.png" alt="1580178215132"></p></li><li><p>Redis启动</p><p><img src="1580178483039.png" alt="1580178483039"></p></li></ul><h2 id="1-4Redis的基本操作"><a href="#1-4Redis的基本操作" class="headerlink" title="1.4Redis的基本操作"></a>1.4Redis的基本操作</h2><h3 id="1-4-1信息添加"><a href="#1-4-1信息添加" class="headerlink" title="1.4.1信息添加"></a>1.4.1信息添加</h3><ul><li><p>功能:设置key，value数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-4-2信息添加"><a href="#1-4-2信息添加" class="headerlink" title="1.4.2信息添加"></a>1.4.2信息添加</h3><ul><li><p>功能:根据key查询对应的value,如果不存在,返回空(nil)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-4-3清除屏幕信息"><a href="#1-4-3清除屏幕信息" class="headerlink" title="1.4.3清除屏幕信息"></a>1.4.3清除屏幕信息</h3><ul><li><p>功能:清除屏幕中的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-4-4帮助信息"><a href="#1-4-4帮助信息" class="headerlink" title="1.4.4帮助信息"></a>1.4.4帮助信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help [CMD]</span><br></pre></td></tr></table></figure><p><img src="1580179481797.png" alt="1580179481797"></p><h3 id="1-4-5退出客户端命令行模式"><a href="#1-4-5退出客户端命令行模式" class="headerlink" title="1.4.5退出客户端命令行模式"></a>1.4.5退出客户端命令行模式</h3><ul><li><p>功能:退出客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br><span class="line">exit </span><br><span class="line">&lt;ESC&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-5Redis数据类型"><a href="#1-5Redis数据类型" class="headerlink" title="1.5Redis数据类型"></a>1.5Redis数据类型</h2><ul><li><code>Redis</code>自身是一个Map，其中所有的数据都是采用<code>key：value</code>的形式存储</li><li><strong>数据类型</strong>指的是<strong>value的类型【存储的数据类型】</strong>，<strong>key部分永远都是字符串</strong></li></ul><p><img src="1580180268005.png" alt="1580180268005"></p><ul><li>Redis数据类型(5种常用）</li></ul><table><thead><tr><th>Redis</th><th>类比Java</th></tr></thead><tbody><tr><td>string</td><td>String</td></tr><tr><td>hash</td><td>HashMap</td></tr><tr><td>list</td><td>LinkedList</td></tr><tr><td>set</td><td>HashSet</td></tr><tr><td>sorted_set</td><td>TreeSet</td></tr></tbody></table><h3 id="1-5-1String类型"><a href="#1-5-1String类型" class="headerlink" title="1.5.1String类型"></a>1.5.1String类型</h3><ul><li>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型</li><li>存储数据的格式：一个存储空间保存一个数据</li><li>存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用</li></ul><p><img src="1580205552862.png" alt="1580205552862"></p><ul><li><p>添加/修改数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br></pre></td></tr></table></figure></li><li><p>获取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br><span class="line"># (integer) 0 删除失败</span><br><span class="line"># (integer) 1 删除成功</span><br></pre></td></tr></table></figure></li><li><p>添加/修改多个数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key1 value1 key2 value2 ..</span><br></pre></td></tr></table></figure></li><li><p>获取多个数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key1 key2 ..</span><br></pre></td></tr></table></figure><p><img src="1588406142155.png" alt="1588406142155"></p></li><li><p>获取数据字符个数（字符串长度）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strlen key</span><br><span class="line"># (integer) [N长度]</span><br></pre></td></tr></table></figure><p><img src="1588406184745.png" alt="1588406184745"></p></li><li><p>追加信息到原始信息后部（如果原始信息存在则追加，否则新建）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append key value</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li><p>数据操作不成功的反馈与数据正常操作之间的差异<br>①表示运行结果是否成功</p><ul><li>(integer)0 →false 失败</li><li>(integer)1 →true成功</li></ul><p>②表示运行结果值</p><ul><li>(integer)3 →3    3个</li><li>(integer)1 →1    1个</li></ul></li><li><p>数据未获取到——(nil)等同于null</p></li><li><p>数据最大存储量——512MB</p></li></ul></li></ul><h4 id="应用场景1"><a href="#应用场景1" class="headerlink" title="应用场景1"></a>应用场景1</h4><ul><li><p>大型企业级应用中，分表操作是基本操作，使用多张表存储同类型数据，但是对应的主键id必须保证统一性, 不能重复。MySQL数据库并不具有类似的机制，那么如何解决?</p><p><img src="1588408646800.png" alt="1588408646800"></p><ul><li><p><strong>答：Redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性。此方案适用于所有数据库，且支持数据库集群</strong></p><ul><li><p>设置数值数据增加指定范围的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">incr key</span><br><span class="line">incrby key increment[increment可以为负]</span><br><span class="line">incrbyfloat key increment</span><br></pre></td></tr></table></figure></li><li><p>设置数值数据减少指定范围的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decr key</span><br><span class="line">decrby key increment</span><br></pre></td></tr></table></figure><blockquote><ul><li>String在Redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算</li><li>redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。</li><li>注意:按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis数值上限范围，将报错。【9223372036854775807（Java中Long型数据最大值，Long.MAX_VALUE）】</li></ul></blockquote></li></ul></li></ul></li></ul><h4 id="应用场景2"><a href="#应用场景2" class="headerlink" title="应用场景2"></a>应用场景2</h4><ul><li><p>微信每4小时只能投1票/商品热门期维持3天自动取消热门/自动控制热点新闻的时效性</p><ul><li><p><strong>答：Redis控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作</strong></p></li><li><p>设置数据具有指定的生命周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setex key seconds value</span><br><span class="line">psetex key milliseconds value</span><br></pre></td></tr></table></figure><blockquote><p> 超时则抹去Id，存在则禁止重复投票</p></blockquote></li></ul><p><img src="1588409243264.png" alt="1588409243264"></p></li></ul><h4 id="应用场景3"><a href="#应用场景3" class="headerlink" title="应用场景3"></a>应用场景3</h4><ul><li><p>高频访问信息显示控制，例如新浪微博大V主页显示粉丝数与微博数量</p><ul><li><p>在redis中为大V用户设定用户信息，以用户主键和属性值作为key，后台设定定时刷新策略即可</p><ul><li>数据库中的热点数据命名惯例【大部分数据还是从数据库中来】</li></ul><p><img src="1580214221673.png" alt="1580214221673"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set user:id:3506728370:fans  12210947</span><br><span class="line">set user:id:3506728370:blogs 6164</span><br><span class="line">set user:id:3506728370:focus 83</span><br></pre></td></tr></table></figure></li><li><p>在redis中以json格式存储大V用户信息，定时刷新(也可以使用hash类型)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set user:id:3506728370 &#123;id:3506728370, fans:12210862, blogs:6164, focus:83&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>答：redis应用于各种结构型和非结构型高热度数据访问加速</strong></p></li></ul><h3 id="1-5-2Hash类型"><a href="#1-5-2Hash类型" class="headerlink" title="1.5.2Hash类型"></a>1.5.2Hash类型</h3><ul><li><p><strong>对象类数据用String类型以json格式存储，如果具有较频繁的更新需求操作会显得笨重</strong></p><p><img src="1588411271044.png" alt="1588411271044"></p></li><li><p>新的存储需求：对一系列存储的数据进行编组，方便管理，<strong>典型应用是存储对象信息</strong></p></li><li><p>需要的存储结构: <strong>一个存储空间保存多个键值对数据</strong>【感觉就像是Map套Map】</p><p><img src="1580214384748.png" alt="1580214384748"></p></li><li><p>hash类型：底层使用<strong>哈希表</strong>结构实现数据存储</p><p> <img src="1580214490752.png" alt="1580214490752"></p><blockquote><ul><li>如果field数量较少，存储结构优化为类数组结构</li><li>如果field数量较多，存储结构使用HashMap结构</li></ul></blockquote></li><li><p>添加/修改数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hset key field value</span><br></pre></td></tr></table></figure></li><li><p>获取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hget key field</span><br><span class="line">hgetall key</span><br><span class="line">hkeys key[获取的到的field字段]</span><br><span class="line">hvals key[获取的到的value字段]</span><br></pre></td></tr></table></figure><p><img src="1588411695151.png" alt="1588411695151"></p></li><li><p>删除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdel key field1 [field2]</span><br></pre></td></tr></table></figure></li><li><p>添加/修改多个数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset key field1 value1 field2 val</span><br></pre></td></tr></table></figure></li><li><p>获取多个数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmget key field1 field2</span><br></pre></td></tr></table></figure></li><li><p>获取哈希表中字段的数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure></li><li><p>获取哈希表中是否存在指定的字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexists key field</span><br></pre></td></tr></table></figure><p><img src="1588411806322.png" alt="1588411806322"></p></li><li><p>设置指定字段的数值数据增加指定范围的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hincrby key field increment</span><br><span class="line">hincrbyfloat key field increment</span><br></pre></td></tr></table></figure></li><li><p>不存在则添加，否则不变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hsetnx key field value</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为(nil)</li><li>每个hash可以存储23^2-1个键值对</li><li><strong>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性</strong>。但hash设计初衷不是为了存储大量对象而设计的，切记不可滥用，不可以将hash作为对象列表使用</li><li>hgetall操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈</li></ul></li></ul><h4 id="应用场景4"><a href="#应用场景4" class="headerlink" title="应用场景4"></a>应用场景4</h4><ul><li><p>电商网站购物车设计与实现</p><p><img src="1580216111249.png" alt="1580216111249"></p><ul><li><p><strong>问题：</strong>当前仅仅是将数据存储到了redis中，并没有起到加速的作用，商品信息还需要根据商品id二次查询商品信息的数据库</p></li><li><p><strong>方案：</strong>每条购物车中的商品记录保存成两条field</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">field1专用于保存购买数量</span><br><span class="line">命名格式:商品id:nums</span><br><span class="line">保存数据:数值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">field2专用于保存购物车中显示的信息，包含文字描述，图片地址，所属商家信息等</span><br><span class="line">命名格式:商品id:info</span><br><span class="line">保存数据: json</span><br></pre></td></tr></table></figure></li><li><p><strong>问题：</strong>商品id:info将因为用户购买相同商品，而重复大量的商品信息</p></li><li><p><strong>方案：</strong>将商品信息单独做成hash</p></li><li><p><strong>问题：</strong>我们一开始不能将所有商品信息都导入Redis，但是用一个加一个则与之前没有区别</p></li><li><p>方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hsetnx key field value</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>答：应用于购物车数据存储设计</strong></p></li></ul><h4 id="应用场景5"><a href="#应用场景5" class="headerlink" title="应用场景5"></a>应用场景5</h4><ul><li><p>双11活动日,销售手机充值卡的商家对移动、联通、电信的30元、50元、 100元商品推出抢购活动，每种商<br>品抢购上限1000张</p><p><img src="1588413458917.png" alt="1588413458917"></p></li><li><p><strong>答：redis应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计</strong></p></li></ul><h4 id="补充：String存储对象（Json）-VS-Hash存储对象"><a href="#补充：String存储对象（Json）-VS-Hash存储对象" class="headerlink" title="补充：String存储对象（Json） VS Hash存储对象"></a>补充：String存储对象（Json） VS Hash存储对象</h4><ul><li><p>String存在对象讲究整体性，以读为主</p></li><li><p>Hash存储对象讲究分散性，以写为主</p></li></ul><h3 id="1-5-3List类型"><a href="#1-5-3List类型" class="headerlink" title="1.5.3List类型"></a>1.5.3List类型</h3><ul><li><p>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</p></li><li><p>需要的存储结构：一个存储空间保存够个数据，且通过数据可以体现进入顺序</p></li><li><p>list类型：保存多个数据，底层使用<strong>双向链表存储结构</strong>实现</p><p><img src="1580217854615.png" alt="1580217854615"></p><p><img src="1588414055584.png" alt="1588414055584"></p></li><li><p>添加/修改数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpush key value1 [value2] ....</span><br><span class="line">rpush key value1 [value2] ....</span><br></pre></td></tr></table></figure></li><li><p>获取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lrange key start stop</span><br><span class="line">lindex key index</span><br><span class="line">llen key</span><br></pre></td></tr></table></figure><p><img src="1588413931788.png" alt="1588413931788"></p></li><li><p>获取并移除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpop key</span><br><span class="line">rpop key</span><br></pre></td></tr></table></figure></li><li><p>规定时间内获取并移除数据【规定时间内阻塞 队列中有就移除 没有就算了】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blpop key1 [key2] timeout[block]</span><br><span class="line">brpop key1 [key2] timeout</span><br></pre></td></tr></table></figure></li><li><p>移除指定数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrem key count value</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>list中保存的数据都是string类型的，数据总容量是有限的，最多23^2- 1个元素(4294967295)</li><li>list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作</li><li>获取全部数据操作结束索引设置为-1</li><li>list可以对数据进行分页操作，通常第一页的信息来自于list, 第2页及更多的信息通过数据库的形式加载</li></ul></li></ul><h4 id="应用场景6"><a href="#应用场景6" class="headerlink" title="应用场景6"></a>应用场景6</h4><ul><li>微信朋友圈点赞，要求按照点赞顺序显示点赞好友信息如果取消点赞，移除对应好友信息</li><li><strong>答：redis应用于具有操作先后顺序的数据控制</strong></li></ul><h4 id="应用场景7"><a href="#应用场景7" class="headerlink" title="应用场景7"></a>应用场景7</h4><ul><li>twitter、新浪微博、腾讯微博中个人用户的关注列表需要按照用户的关注顺序进行展示,粉丝列表需要将最近关注的粉丝列在前面</li><li>新闻、资讯类网站如何将最新的新闻或资讯按照发生的时间顺序展示</li><li>企业运营过程中,系统将产生出大量的运营数据,如何保障多台服务器操作日志的统一顺序输出</li><li><strong>答：redis应用于依赖list的数据具有顺序的特征对信息进行管理，使用队列模型解决多路信息汇总合并的问题，使用栈模型解决最新消息的问题</strong></li></ul><h3 id="1-5-5Set类型"><a href="#1-5-5Set类型" class="headerlink" title="1.5.5Set类型"></a>1.5.5Set类型</h3><ul><li>新的存储需求：存储大量的数据，<strong>在查询方面提供更高的效率</strong></li><li>需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</li><li>set类型：与hash存储结构完全相同，仅存储键，不存储值(nil) ，且值不允许重复的</li></ul><p><img src="1580219557499.png" alt="1580219557499"></p><ul><li><p>添加数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd key member1 [member2]</span><br></pre></td></tr></table></figure></li><li><p>获取全部数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem key member1 [member2]</span><br></pre></td></tr></table></figure></li><li><p>获取集合数据总量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scard key</span><br></pre></td></tr></table></figure></li><li><p>判断集合中是否包含指定数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sismember key member</span><br></pre></td></tr></table></figure><p><img src="1588432636898.png" alt="1588432636898"></p></li><li><p>随机获取集合中指定数量的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srandmember key [count]</span><br></pre></td></tr></table></figure></li><li><p>随机获取集合中的某个数据并将该数据移出集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spop key</span><br></pre></td></tr></table></figure></li><li><p>求两个集合的交、并、差集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinter key1 [key2]</span><br><span class="line">sunion key1 [key2]</span><br><span class="line">sdiff key1 [key2]</span><br></pre></td></tr></table></figure></li><li><p>求两个集合的交、并、差集并存储到指定集合中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinterstore destination key1 [key2]</span><br><span class="line">sunionstore destination key1 [key2]</span><br><span class="line">sdiffstore destination key1 [key2]</span><br></pre></td></tr></table></figure></li><li><p>将指定数据从原始集合中移动到目标集合中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smove source destination member</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>set类型不允许数据重复，如果添加的数据在set中已经存在，将只保留一份</li><li>set虽然与hash的存储结构相同，但是无法启用hash中存储值的空间</li></ul></li></ul><h4 id="应用场景8"><a href="#应用场景8" class="headerlink" title="应用场景8"></a>应用场景8</h4><ul><li>后期为了增加用户的活跃度、兴趣点，必须让用户 对其他信息类别逐渐产生兴趣，增加客户留存度，实现随机推送</li><li><strong>答：redis应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等</strong></li></ul><h4 id="应用场景9"><a href="#应用场景9" class="headerlink" title="应用场景9"></a>应用场景9</h4><ul><li><strong>答：redis应用于同类信息的关联搜索，二度关联搜索，深度关联搜索</strong><ul><li>显示共同关注(一度)</li><li>显示共同好友(一度)</li><li>由用户A出发，获取到好友用户B的好友信息列表(一度)</li><li>由用户A出发，获取到好友用户B的购物清单列表(二度)</li><li>由用户A出发，获取到好友用户B的游戏充值列表(二度)</li></ul></li></ul><h4 id="应用场景10"><a href="#应用场景10" class="headerlink" title="应用场景10"></a>应用场景10</h4><ul><li>PV:网站被访问次数，可通过刷新页面提高访问量</li><li>UV:网站被不同用户访问的次数,可通过cookie统计访问量, 相同用户切换IP地址，UV不变</li><li>IP:网站被不同IP地址访问的总次数，可通过IP地址统计访问量，相同IP不同用户访问，IP不变</li><li>建立string类型数据，利用incr统计日访问量(PV)</li><li>建立set模型，记录不同cookie数量(UV)</li><li>建立set模型，记录不同IP数量(IP)</li><li><strong>答：redis应用于同类型数据的快速去重</strong></li></ul><h3 id="1-5-6Sorted-set类型"><a href="#1-5-6Sorted-set类型" class="headerlink" title="1.5.6Sorted_set类型"></a>1.5.6Sorted_set类型</h3><ul><li><p>新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式</p></li><li><p>需要的存储结构：新的存储模型，<strong>可以保存可排序的数据</strong></p></li><li><p>sorted_set类型：在set的存储结构基础上添加可排序字段</p><p><img src="1580223454856.png" alt="1580223454856"></p></li><li><p>添加数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd key score1 memberl [score2 member2 ]</span><br></pre></td></tr></table></figure></li><li><p>获取全部数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrange key start stop [WITHSCORES]</span><br><span class="line">zrevrange key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><p><img src="1588470818167.png" alt="1588470818167"></p></li><li><p>删除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key member [member ...]</span><br></pre></td></tr></table></figure></li><li><p>按条件获取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore key min max [WITHSCORES] [LIMIT OFFSET COUNT]</span><br><span class="line">zrevrangebyscore key max min [WITHSCORES]</span><br></pre></td></tr></table></figure></li><li><p>条件删除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyrank key start stop</span><br><span class="line">zremrangebyscore key min max</span><br></pre></td></tr></table></figure></li><li><p>注意:</p><ul><li>min与max用于限定搜索查询的条件</li><li>start与stop用于限定查询范围，作用于索引，表示开始和结束索引</li><li>offset与count用于限定查询范围，作用于查询结果，表示开始位置和数据总量</li></ul></li><li><p>获取集合数据总量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zcard key</span><br><span class="line">zcount key min max</span><br></pre></td></tr></table></figure></li><li><p>集合交、并操作【默认合并相加】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zinterstore destination numkeys key [key ...]</span><br><span class="line">zunionstore destination numkeys key [key . ..]</span><br></pre></td></tr></table></figure></li><li><p>获取数据对应的索引(排名)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrank key member</span><br><span class="line">zrevrank key member</span><br></pre></td></tr></table></figure></li><li><p>score值获取与修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zscore key member</span><br><span class="line">zincrby key increment member</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li><li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，使用时候要慎重</li><li>sorted_set底层存储还是基于set结构的，因此<strong>数据不能重复</strong>，如果重复添加相同的数据，score值将被反复覆盖，保留最后一次修改的结果</li></ul></li></ul><h4 id="业务场景11"><a href="#业务场景11" class="headerlink" title="业务场景11"></a>业务场景11</h4><ul><li>票选广东十大杰出青年，各类综艺选秀海选投票</li><li>各类资源网站TOP10(电影，歌曲，文档，电商，游戏等)</li><li>聊天室活跃度统计</li><li>游戏好友亲密度</li><li><strong>答：redis应用于计数器组合排序功能对应的排名</strong></li></ul><h4 id="业务场景12"><a href="#业务场景12" class="headerlink" title="业务场景12"></a>业务场景12</h4><ul><li><p>网站会定期开启投票、讨论，限时进行，逾期作废。如何有效管理此类过期信息。</p></li><li><p><strong>答：redis 应用于定时任务执行顺序管理或任务过期管理</strong></p></li></ul><h2 id="1-6Redis通用命令"><a href="#1-6Redis通用命令" class="headerlink" title="1.6Redis通用命令"></a>1.6Redis通用命令</h2><h3 id="1-6-1Key通用命令"><a href="#1-6-1Key通用命令" class="headerlink" title="1.6.1Key通用命令"></a>1.6.1Key通用命令</h3><ul><li><p><strong>key是一个字符串</strong>， 通过key获取redis中保存的数据</p></li><li><p>获取key的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure></li><li><p>获取key是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure></li><li><p>删除指定key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure></li><li><p>为指定key设置有效期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expire key seconds</span><br><span class="line">pexpire key milliseconds</span><br><span class="line">expireat key timestamp [时间戳的形式 time命令获取]</span><br><span class="line">pexpireat key milliseconds-timestamp</span><br></pre></td></tr></table></figure></li><li><p>获取key的有效时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br><span class="line"># (integer) -2 过期</span><br><span class="line"># (integer) -1 没设置有效期</span><br><span class="line"># (integer) N  有效期</span><br><span class="line">pttl key</span><br></pre></td></tr></table></figure></li><li><p>切换key从时效性转换为永久性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">persist key</span><br><span class="line"># (integer) 0  失败</span><br><span class="line"># (integer) 1  成功</span><br></pre></td></tr></table></figure></li><li><p>查询key</p><blockquote><p>* 匹配任意数量的任意符号<br>? 配合一个任意符号<br>[] 匹配个指定符</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys [pattern]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">keys * 查询所有</span><br><span class="line">keys it *查询所有以it开头</span><br><span class="line">keys *heima查询所有以he ima结尾</span><br><span class="line">keys ??heima查 询所有前面两个字符任意，后面以he ima结尾</span><br><span class="line">keys user:?查询所有以user:开头，最后一个字符任意</span><br><span class="line">keys u[st]er:1 查询所有以u开头，以er:1结尾， 中间包含一个字母，s或t</span><br></pre></td></tr></table></figure></li><li><p>为key改名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rename key newkey[可能覆盖同名key]</span><br><span class="line">renamenx key newkey[不会覆盖同名key]</span><br></pre></td></tr></table></figure></li><li><p>对所有key排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort key[只排序不保存]</span><br></pre></td></tr></table></figure></li><li><p>其他key通用操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help @generic</span><br></pre></td></tr></table></figure></li><li><p>配置文件设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config set requirepass &lt;password&gt; </span><br><span class="line">config get requirepass</span><br></pre></td></tr></table></figure></li><li><p>客户端发送命令设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass &lt;password&gt;</span><br></pre></td></tr></table></figure></li><li><p>启动客户端设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli –a &lt;password&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-6-2数据库通用命令"><a href="#1-6-2数据库通用命令" class="headerlink" title="1.6.2数据库通用命令"></a>1.6.2数据库通用命令</h3><ul><li><p>redis为<strong>每个服务提供有16个数据库，编号从0到15</strong>【默认使用select 0】</p></li><li><p>每个数据库之间的数据相互独立</p><p><img src="1580294591592.png" alt="1580294591592"></p><blockquote><p>没有大小 共有同一空间</p></blockquote></li><li><p>测试服务器是否连通</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping</span><br></pre></td></tr></table></figure><p><img src="1588477361997.png" alt="1588477361997"></p></li><li><p>切换数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select [index]</span><br></pre></td></tr></table></figure><p><img src="1588477302443.png" alt="1588477302443"></p></li><li><p>数据移动</p><ul><li>目标数据库必须不存在才能成功</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move key dbindex</span><br></pre></td></tr></table></figure></li><li><p>数据清除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbsize[查看key数量]</span><br><span class="line">flushdb[删除本库]</span><br><span class="line">flushall[删除所有0-15库]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>自动重写</p><ul><li><p>自动重写触发条件设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size [size] </span><br><span class="line">auto-aof-rewrite-percentage [percentage]</span><br></pre></td></tr></table></figure></li><li><p>自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aof_current_size</span><br><span class="line">aof_base_size</span><br></pre></td></tr></table></figure></li><li><p>自动重写触发条件</p><p><img src="1588585553364.png" alt="1588585553364"></p></li></ul></li></ul><ul><li><p>s的高可用，同时实现数据<strong>冗余备份</strong>。</p><ul><li>提供数据方：master 主服务器，主节点，主库，主客户端</li><li>接收数据方：slave 从服务器，从节点，从库，从客户端</li><li>需要解决的问题： 数据同步</li><li>核心工作： master的数据复制到slave中</li></ul><p><a href="1588729303276.png">1588729303276</a></p></li><li><p>主从复制</p><ul><li>主从复制即将master中的数据即时、有效的复制到slave中</li><li>特征：一个master可以拥有多个slave，一个slave只对应一个master </li><li>职责：<ul><li>master:①写数据 ②执行写操作时，将出现变化的数据自动同步到slave ③读数据（可忽略）</li><li>slave:①读数据 ②写数据（禁止）</li></ul></li><li>作用<ul><li>读写分离：master写、slave读，提高服务器的读写负载能力</li><li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li><li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li><li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li><li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Redis架构 简介 Redis数据类型
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Redis" scheme="http://goldcarpenter.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>JDK8新特性</title>
    <link href="http://goldcarpenter.github.io/2020/03/10/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part3/"/>
    <id>http://goldcarpenter.github.io/2020/03/10/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part3/</id>
    <published>2020-03-09T16:00:00.000Z</published>
    <updated>2020-06-17T08:12:05.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><ul><li>在Java 8中，得益于Lambda所带来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。</li></ul><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><h4 id="传统集合循环遍历的弊端"><a href="#传统集合循环遍历的弊端" class="headerlink" title="传统集合循环遍历的弊端"></a>传统集合循环遍历的弊端</h4><ul><li><p>几乎所有的集合（如 Collection 接口或 Map 接口等）都支持直接或间接的遍历操作</p></li><li><p><code>Java 8</code>循环遍历的弊端的<code>Lambda</code>让我们可以更加专注于<strong>做什么</strong>（What），而不是<strong>怎么做</strong>（How）</p><ul><li>for循环的语法就是<strong>“怎么做”</strong> </li><li>for循环的循环体才是<strong>“做什么”</strong></li></ul></li><li><p>为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，<strong>而并不是从第一个到最后一个顺次处理的循环</strong>。前者是目的，后者是方式。</p></li></ul><p>在Java 8之前的做法可能为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"张无忌"</span>);</span><br><span class="line">list.add(<span class="string">"周芷若"</span>);</span><br><span class="line">List&lt;String&gt; zhangList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line"><span class="keyword">for</span> (String name : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.startsWith(<span class="string">"张"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        zhangList.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; shortList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line"><span class="keyword">for</span> (String name : zhangList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.length() == <span class="number">3</span>) &#123;</span><br><span class="line">        shortList.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line"><span class="keyword">for</span> (String name : shortList) &#123; </span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。循环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使用另一个循环从头开始。</p><h4 id="Stream的更优写法"><a href="#Stream的更优写法" class="headerlink" title="Stream的更优写法"></a>Stream的更优写法</h4><p>下面来看一下借助Java 8的Stream API，什么才叫优雅：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> list.add(<span class="string">"张无忌"</span>);</span><br><span class="line"> list.add(<span class="string">"周芷若"</span>);</span><br><span class="line"><span class="comment">//       list.stream().filter(new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//           @Override</span></span><br><span class="line"><span class="comment">//           public boolean test(String s) &#123;</span></span><br><span class="line"><span class="comment">//               return s.startsWith("张");</span></span><br><span class="line"><span class="comment">//           &#125;</span></span><br><span class="line"><span class="comment">//       &#125;)</span></span><br><span class="line"> list.stream().filter(name-&gt;name.startsWith(<span class="string">"张"</span>))</span><br><span class="line">               .filter(name-&gt;name.length()==<span class="number">3</span>)</span><br><span class="line">               .forEach(System.out::println);       <span class="comment">//方法引用</span></span><br></pre></td></tr></table></figure><p>直接阅读代码的字面意思即可<strong>完美展示</strong>无关逻辑方式的<strong>语义</strong>：<strong>获取流、过滤姓张、过滤长度为3、逐一打印</strong>。</p><p>代码中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。</p><h3 id="1-2-流式思想概述"><a href="#1-2-流式思想概述" class="headerlink" title="1.2 流式思想概述"></a>1.2 流式思想概述</h3><ul><li><p>注意：<strong>暂时忘记对传统IO流的固有印象</strong>！ 整体来看，流式思想类似于工厂车间的“生产流水线”。</p></li><li><p>当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先<strong>拼好一个“模型”步骤方案</strong>，然后再按照方案去执行它。</p><p><img src="1580898920476.png" alt="1580898920476"></p><p>这张图中展示了过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种“函数模型”。图中的<strong>每一个方框都是一个“流”</strong>，调用指定的方法，可以<strong>从一个流模型转换为另一个流模型</strong>。而最右侧的数字 3是最终结果。</p></li><li><p>这里的<code>filter</code>、<code>map</code> 、<code>skip</code>都是在对函数模型进行操作，集合元素并没有真正被处理。<strong>只有当终结方法 count 执行</strong>的时候，<strong>整个模型才会按照指定策略执行操作</strong>。而这得<strong>益于Lambda的延迟执行特性。</strong></p></li></ul><blockquote><p>备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。</p></blockquote><p>Stream（流）是一个来自数据源的元素队列</p><ul><li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li><li><strong>数据源</strong>/流的来源。 可以是<strong>集合，数组</strong>等。</li></ul><p>和以前的<code>Collection</code>操作不同， Stream操作还有两个基础的特征：</p><ul><li><code>Pipelining</code>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路(short-circuiting)。 </li><li>内部迭代： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。</li></ul><p>当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结果</p><h3 id="1-3-获取流"><a href="#1-3-获取流" class="headerlink" title="1.3 获取流"></a>1.3 获取流</h3><ul><li><p><code>java.util.stream.Stream&lt;T&gt;</code>是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。）</p></li><li><p>获取一个流非常简单，有以下几种常用的方式：</p><ul><li><p><strong>所有的<code>Collection</code>集合都可以通过<code>stream</code>默认方法获取流；</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default Stream&lt;E&gt; stream()</span><br></pre></td></tr></table></figure></li><li><p><strong><code>Stream</code>接口的静态方法<code>of</code>可以获取数组对应的流。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; Stream&lt;T&gt; of(T... values) 参数是一个可变参数,那么我们就可以传递一个数组</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="根据Collection获取流"><a href="#根据Collection获取流" class="headerlink" title="根据Collection获取流"></a>根据Collection获取流</h4><ul><li>首先，<code>java.util.Collection</code>接口中加入了<code>default</code>方法 stream 用来获取流，所以其所有实现类均可获取流。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;把集合转换为Stream流</span><br><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream1 &#x3D; list.stream();</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream2 &#x3D; set.stream();</span><br></pre></td></tr></table></figure><h4 id="根据Map获取流"><a href="#根据Map获取流" class="headerlink" title="根据Map获取流"></a>根据Map获取流</h4><p>java.util.Map 接口不是 Collection 的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F;获取键,存储到一个Set集合中</span><br><span class="line">Set&lt;String&gt; keySet &#x3D; map.keySet();</span><br><span class="line">Stream&lt;String&gt; stream3 &#x3D; keySet.stream();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取值,存储到一个Collection集合中</span><br><span class="line">Collection&lt;String&gt; values &#x3D; map.values();</span><br><span class="line">Stream&lt;String&gt; stream4 &#x3D; values.stream();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取键值对(键与值的映射关系 entrySet)</span><br><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entries &#x3D; map.entrySet();</span><br><span class="line">Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream5 &#x3D; entries.stream();</span><br></pre></td></tr></table></figure><h4 id="根据数组获取流"><a href="#根据数组获取流" class="headerlink" title="根据数组获取流"></a>根据数组获取流</h4><ul><li>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法 of ，使用很简单：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;把数组转换为Stream流</span><br><span class="line">Stream&lt;Integer&gt; stream6 &#x3D; Stream.of(1, 2, 3, 4, 5);</span><br><span class="line">&#x2F;&#x2F;可变参数可以传递数组</span><br><span class="line">Integer[] arr &#x3D; &#123;1,2,3,4,5&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream7 &#x3D; Stream.of(arr);</span><br><span class="line">String[] arr2 &#x3D; &#123;&quot;a&quot;,&quot;bb&quot;,&quot;ccc&quot;&#125;;</span><br><span class="line">Stream&lt;String&gt; stream8 &#x3D; Stream.of(arr2);</span><br></pre></td></tr></table></figure><blockquote><p>备注： of 方法的参数其实是一个可变参数，所以支持数组。</p></blockquote><h3 id="1-4-常用方法"><a href="#1-4-常用方法" class="headerlink" title="1.4 常用方法"></a>1.4 常用方法</h3><p><img src="1580899952784.png" alt="1580899952784"></p><ul><li><p>流模型的操作很丰富，这里介绍一些常用的API。</p></li><li><p>这些方法可以被分成两种： </p><ul><li>延迟方法：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方 法均为延迟方法。） </li><li>终结方法：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调 用。本小节中，终结方法包括 count 和 forEach 方法。</li></ul></li></ul><h4 id="逐一处理：forEach"><a href="#逐一处理：forEach" class="headerlink" title="逐一处理：forEach"></a>逐一处理：forEach</h4><p>虽然方法名字叫 forEach ，但是与for循环中的“for-each”昵称不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void forEach(Consumer&lt;? super T&gt; action);</span><br></pre></td></tr></table></figure><p>该方法接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理。 </p><h4 id="复习Consumer接口"><a href="#复习Consumer接口" class="headerlink" title="复习Consumer接口"></a>复习Consumer接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.function.Consumer&lt;T&gt;接口是一个消费型接口。</span><br><span class="line">Consumer接口中包含抽象方法void accept(T t)，意为消费一个指定泛型的数据。</span><br></pre></td></tr></table></figure><h4 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); </span><br><span class="line">stream.forEach(name‐&gt; System.out.println(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="过滤：filter"><a href="#过滤：filter" class="headerlink" title="过滤：filter"></a>过滤：filter</h4><p>可以通过 filter 方法将一个流转换成另一个子集流。方法签名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</span><br></pre></td></tr></table></figure><p>该接口接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</p><p><img src="1580899980697.png" alt="1580899980697"></p><h4 id="复习Predicate接口"><a href="#复习Predicate接口" class="headerlink" title="复习Predicate接口"></a>复习Predicate接口</h4><p>此前我们已经学习过 java.util.stream.Predicate 函数式接口，其中唯一的抽象方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean test(T t);</span><br></pre></td></tr></table></figure><p>该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的 filter 方法 将会留用元素；如果结果为false，那么 filter 方法将会舍弃元素。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p> Stream流中的 filter 方法基本使用的代码如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); </span><br><span class="line">Stream&lt;String&gt; result &#x3D; original.filter(s ‐&gt; s.startsWith(&quot;张&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里通过Lambda表达式来指定了筛选的条件：必须姓张。</p><h4 id="映射：map"><a href="#映射：map" class="headerlink" title="映射：map"></a>映射：map</h4><p>如果需要将流中的元素映射到另一个流中，可以使用 map 方法。方法签名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</span><br></pre></td></tr></table></figure><p>该接口需要一个 Function 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p><p><img src="1580899926624.png" alt="1580899926624"></p><h4 id="复习Function接口"><a href="#复习Function接口" class="headerlink" title="复习Function接口"></a>复习Function接口</h4><p>此前我们已经学习过 java.util.stream.Function 函数式接口，其中唯一的抽象方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R apply(T t);</span><br></pre></td></tr></table></figure><p>这可以将一种T类型转换成为R类型，而这种转换的动作，就称为“映射”。 </p><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p> Stream流中的 map 方法基本使用的代码如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Stream&lt;String&gt; original &#x3D; Stream.of(&quot;10&quot;, &quot;12&quot;, &quot;18&quot;); Stream&lt;Integer&gt; result &#x3D; original.map(str‐&gt;Integer.parseInt(str));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="统计个数：count"><a href="#统计个数：count" class="headerlink" title="统计个数：count"></a>统计个数：count</h4><p>正如旧集合 Collection 当中的 size 方法一样，流提供 count 方法来数一数其中的元素个数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long count();</span><br></pre></td></tr></table></figure><p>该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); </span><br><span class="line">Stream&lt;String&gt; result &#x3D; original.filter(s ‐&gt; s.startsWith(&quot;张&quot;)); </span><br><span class="line">System.out.println(result.count()); &#x2F;&#x2F; 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="取用前几个：limit"><a href="#取用前几个：limit" class="headerlink" title="取用前几个：limit"></a>取用前几个：limit</h4><p>limit 方法可以对流进行截取，只取用前n个。方法签名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; limit(long maxSize);</span><br></pre></td></tr></table></figure><p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用</p><p><img src="1580900011097.png" alt="1580900011097"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); </span><br><span class="line">Stream&lt;String&gt; result &#x3D; original.limit(2); </span><br><span class="line">System.out.println(result.count()); &#x2F;&#x2F; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="跳过前几个：skip"><a href="#跳过前几个：skip" class="headerlink" title="跳过前几个：skip"></a>跳过前几个：skip</h4><p>如果希望跳过前几个元素，可以使用 skip 方法获取一个截取之后的新流：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; skip(long n);</span><br></pre></td></tr></table></figure><p>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用：</p><p><img src="1580900027816.png" alt="1580900027816"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);</span><br><span class="line">    Stream&lt;String&gt; result &#x3D; original.skip(2); </span><br><span class="line">    System.out.println(result.count()); &#x2F;&#x2F; 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合：concat"><a href="#组合：concat" class="headerlink" title="组合：concat"></a>组合：concat</h4><p>如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span><br></pre></td></tr></table></figure><blockquote><p>备注：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。 </p></blockquote><p>该方法的基本使用代码如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       Stream&lt;String&gt; stream1 &#x3D; Stream.of(&quot;张三丰&quot;, &quot;张翠山&quot;);</span><br><span class="line">       String[] arr &#x3D; &#123;&quot;美羊羊&quot;,&quot;喜洋洋&quot;&#125;;</span><br><span class="line">       Stream&lt;String&gt; stream2 &#x3D; Stream.of(arr);</span><br><span class="line">       Stream&lt;String&gt; concat &#x3D; Stream.concat(stream1, stream2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="JDK5新特性"><a href="#JDK5新特性" class="headerlink" title="JDK5新特性"></a>JDK5新特性</h1><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><ul><li>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：<ul><li><strong>…</strong> 用在参数上，称之为可变参数。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure><ul><li>其实这个书写完全等价与</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure><p><strong>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可【简单之处】。</strong></p><p>如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，<strong>可变参数一定要写在参数列表的末尾位置。</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">62</span>, <span class="number">431</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = getSum(arr);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="comment">//  6  7  2 12 2121</span></span><br><span class="line">        <span class="comment">// 求 这几个元素和 6  7  2 12 2121</span></span><br><span class="line">        <span class="keyword">int</span> sum2 = getSum(<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">2121</span>);</span><br><span class="line">        System.out.println(sum2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可变参数写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JDK9新特性"><a href="#JDK9新特性" class="headerlink" title="JDK9新特性"></a>JDK9新特性</h1><h2 id="对集合添加的优化"><a href="#对集合添加的优化" class="headerlink" title="对集合添加的优化"></a>对集合添加的优化</h2><p>通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用，使得代码重复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"abc"</span>);</span><br><span class="line">        list.add(<span class="string">"def"</span>);</span><br><span class="line">        list.add(<span class="string">"ghi"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJDK9</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Set&lt;String&gt; str1=Set.of(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);  </span><br><span class="line">        <span class="comment">//str1.add("c");这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合  </span></span><br><span class="line">        System.out.println(str1);  </span><br><span class="line">        Map&lt;String,Integer&gt; str2=Map.of(<span class="string">"a"</span>,<span class="number">1</span>,<span class="string">"b"</span>,<span class="number">2</span>);  </span><br><span class="line">        System.out.println(str2);  </span><br><span class="line">        List&lt;String&gt; str3=List.of(<span class="string">"a"</span>,<span class="string">"b"</span>);  </span><br><span class="line">        System.out.println(str3);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意以下两点：</p><blockquote><ol><li><p>of方法只适用于List接口,Set接口,Map接口,不适用于接接口的实现类</p></li><li><p>of方法的返回值是一个不能改变的集合,集合不能再使用add,put方法添加元素,会抛出异常</p></li><li><p>Set接口和Map接口在调用of方法的时候,不能有重复的元素,否则会抛出异常</p></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      Stream流 JDK5新特性 JDK9新特性
    
    </summary>
    
    
      <category term="Java高级" scheme="http://goldcarpenter.github.io/categories/Java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="Java" scheme="http://goldcarpenter.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDK8新特性</title>
    <link href="http://goldcarpenter.github.io/2020/02/29/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part2/"/>
    <id>http://goldcarpenter.github.io/2020/02/29/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part2/</id>
    <published>2020-02-28T16:00:00.000Z</published>
    <updated>2020-06-17T08:11:25.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK8新特性"><a href="#JDK8新特性" class="headerlink" title="JDK8新特性"></a>JDK8新特性</h1><h1 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3.函数式接口"></a>3.函数式接口</h1><h3 id="3-1概念"><a href="#3-1概念" class="headerlink" title="3.1概念"></a>3.1概念</h3><ul><li>函数式接口在Java中是指：<strong>有且仅有一个抽象方法的接口</strong></li><li>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。</li><li>只有确保接口中<strong>有且仅有一个抽象方法</strong> , Java中的Lambda才能顺利地进行推导。</li></ul><h3 id="3-2格式"><a href="#3-2格式" class="headerlink" title="3.2格式"></a>3.2格式</h3><ul><li><p>只要确保接口中有且仅有一个抽象方法【可以同时有默认方法、静态方法】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface [接口名称] &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名称(可选参数信息);</span><br><span class="line">    <span class="comment">//其他非抽象方法内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3-FunctionalInterface注解"><a href="#3-3-FunctionalInterface注解" class="headerlink" title="3.3@FunctionalInterface注解"></a>3.3<code>@FunctionalInterface</code>注解</h3><ul><li><p><code>Java 8</code>中专门为函数式接口引入了一个新的注解<code>@FunctionalInterface</code></p></li><li><p><strong>作用</strong>：编译阶段可以<strong>检测</strong>接口是否是一个函数式接口，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionalInterface</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4自定义函数式编程"><a href="#3-4自定义函数式编程" class="headerlink" title="3.4自定义函数式编程"></a>3.4自定义函数式编程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用自定义的函数式接口作为方法参数 其实就是传入一个接口作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(MyFunctionalInterface inter)</span> </span>&#123; </span><br><span class="line">inter.myMethod(); <span class="comment">// 调用自定义的函数式接口方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//传递接口的实现类对象</span></span><br><span class="line">       show(<span class="keyword">new</span> MyFunctionalInterfaceImpl());</span><br><span class="line"></span><br><span class="line">       <span class="comment">//传递接口的匿名内部类</span></span><br><span class="line">       show(<span class="keyword">new</span> MyFunctionalInterface() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"使用匿名内部类重写接口中的抽象方法"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//Lambda表达式</span></span><br><span class="line">       show(()-&gt;&#123;</span><br><span class="line">           System.out.println(<span class="string">"使用Lambda表达式重写接口中的抽象方法"</span>);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//简化Lambda表达式【去掉&#123;&#125; ; return】</span></span><br><span class="line">       show(()-&gt; System.out.println(<span class="string">"使用Lambda表达式重写接口中的抽象方法"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-函数式编程"><a href="#2-函数式编程" class="headerlink" title="2.函数式编程"></a>2.函数式编程</h2><h3 id="2-1Lambda的延迟执行"><a href="#2-1Lambda的延迟执行" class="headerlink" title="2.1Lambda的延迟执行"></a>2.1Lambda的延迟执行</h3><ul><li>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以作为解决方案，提升性能。</li></ul><h4 id="性能浪费的日志案例"><a href="#性能浪费的日志案例" class="headerlink" title="性能浪费的日志案例"></a>性能浪费的日志案例</h4><ul><li>典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> level, String msg)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (level == <span class="number">1</span>) &#123; </span><br><span class="line">System.out.println(msg);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">String msgA = <span class="string">"Hello"</span>; </span><br><span class="line">String msgB = <span class="string">"World"</span>; </span><br><span class="line">String msgC = <span class="string">"Java"</span>;</span><br><span class="line">log(<span class="number">1</span>, msgA + msgB + msgC); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>问题：无论级别是否满足要求，作为 log 方法的第二个参数，三个字符串<strong>一定会首先被拼接</strong>并传入方法内，然后才会进行级别判断。如果<strong>级别不符合</strong>要求，那么字符串的<strong>拼接操作就白做了</strong>，存在性能浪费。</li></ul><blockquote><p>备注：SLF4J是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行字符串的拼接，而是将字符串的若干部分作为可变参数传入方法中，仅在日志级别满足要求的情况下才会进行字符串拼接。</p><p>例如： LOGGER.debug(“变量{}的取值为{}。”, “os”, “macOS”) ，其中的大括号 {} 为占位符。如果满足日志级别要求，则会将“os”和“macOS”两个字符串依次拼接到大括号的位置；否则不会进行字符串拼接。这也是一种可行解决方案，但Lambda可以做到更好。</p></blockquote><h4 id="Lambda的更优写法"><a href="#Lambda的更优写法" class="headerlink" title="Lambda的更优写法"></a>Lambda的更优写法</h4><ul><li>使用Lambda必然需要一个函数式接口：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MessageBuilder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">buildMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后对<code>log</code>方法进行改造：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> level, MessageBuilder messageBuilder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(messageBuilder.buildMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String msgA = <span class="string">"Hello"</span>; String msgB = <span class="string">"World"</span>; String msgC = <span class="string">"Java"</span>;</span><br><span class="line">    log(<span class="number">0</span>,()-&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"Lambda执行！"</span>);</span><br><span class="line">        <span class="keyword">return</span> msgA+msgB+msgC;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有当级别满足要求的时候，才会进行三个字符串的拼接；否则三个字符串将不会进行拼接。</p><blockquote><p>扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的。</p></blockquote><h3 id="2-2-使用Lambda作为参数和返回值"><a href="#2-2-使用Lambda作为参数和返回值" class="headerlink" title="2.2 使用Lambda作为参数和返回值"></a>2.2 使用Lambda作为参数和返回值</h3><ul><li><p>使用<strong>Lambda表达式作为方法参数</strong>，其实就是<strong>使用函数式接口作为方法参数</strong>。</p><ul><li><code>java.lang.Runnable</code>接口就是一个函数式接口，<code>Thread</code>类的构造方法参数使用该接口作为参数，那么就可以使用Lambda进行传参。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">(Runnable task)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    startThread(() ‐&gt; System.out.println(<span class="string">"线程任务执行！"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用<strong>Lambda表达式作为返回值类型</strong>，实就是返回一个函数式接口</p><ul><li>当需要通过一个方法来获取一个<code>java.util.Comparator</code>接口类型的对象作为排序器时，就可以调该方法获取。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个方法,方法的返回值类型使用函数式接口Comparator</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title">getComparator</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法的返回值类型是一个接口,返回这个接口的匿名内部类</span></span><br><span class="line">    <span class="comment">/*return new Comparator&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">        public int compare(String o1, String o2) &#123;</span></span><br><span class="line"><span class="comment">            //按照字符串的降序排序</span></span><br><span class="line"><span class="comment">            return o2.length()-o1.length();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;;*/</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//方法的返回值类型是一个函数式接口,返回一个Lambda表达式</span></span><br><span class="line">    <span class="comment">/*return (String o1, String o2)-&gt;&#123;</span></span><br><span class="line"><span class="comment">        //按照字符串的降序排序</span></span><br><span class="line"><span class="comment">        return o2.length()-o1.length();</span></span><br><span class="line"><span class="comment">    &#125;;*/</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//Lambda表达式</span></span><br><span class="line">    <span class="keyword">return</span> (o1, o2)-&gt;o2.length()-o1.length();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    String[] arr = &#123;<span class="string">"aaa"</span>,<span class="string">"b"</span>,<span class="string">"cccccc"</span>,<span class="string">"dddddddddddd"</span>&#125;;</span><br><span class="line">    System.out.println(Arrays.toString(arr));<span class="comment">//[aaa, b, cccccc, dddddddddddd]</span></span><br><span class="line">    <span class="comment">//调用Arrays中的sort方法,对字符串数组进行排序</span></span><br><span class="line">    Arrays.sort(arr,getComparator());</span><br><span class="line">    <span class="comment">//输出排序后的数组</span></span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">    <span class="comment">//[dddddddddddd, cccccc, aaa, b]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h1><p>JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在 <code>java.util.function</code>包中被提供。 下面是最简单的几个接口及使用示例。</p><h2 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h2><ul><li><code>java.util.comparator</code>能实现比较器功能，即比较两个对象谁排在前谁排在后<ul><li><code>public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</li></ul></li></ul><blockquote><p>两个对象比较的结果有三种：大于，等于，小于。</p><p><strong>如果要按照升序排序：o1 - o2 &lt; 0 参数列表o1在左侧</strong></p><p>则o1 小于o2，返回（负数），相等返回0，o1大于o2返回（正数）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"cba"</span>);</span><br><span class="line">        list.add(<span class="string">"aba"</span>);</span><br><span class="line">        list.add(<span class="string">"sba"</span>);</span><br><span class="line">        list.add(<span class="string">"nba"</span>);</span><br><span class="line">        <span class="comment">//排序方法  按照第一个单词的降序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.charAt(<span class="number">0</span>) - o1.charAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="对比补充：Comparable-普通接口"><a href="#对比补充：Comparable-普通接口" class="headerlink" title="对比补充：Comparable[普通接口]"></a>对比补充：Comparable[普通接口]</h3><ul><li>采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了<strong>被排序的类</strong>型需要<strong>实现</strong>Comparable<strong>接口</strong>完成比较的<strong>功能</strong>，在String类型上如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span></span><br></pre></td></tr></table></figure><p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则固定写死了，那比如我想要字符串按照第一个字符降序排列[默认升序]，那么这样就要修改String的源代码，这是不可能的了，那么这个时候提出了上述的Comparator接口</p><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要写在对比的Pojo类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age-o.age;<span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写在main业务代码中</span></span><br><span class="line">ArrayList&lt;Student&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arrayList.add(stu1);</span><br><span class="line"> arrayList.add(stu2);</span><br><span class="line">    Collections.sort(arrayList);</span><br></pre></td></tr></table></figure><p>对比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写在main业务代码中</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.getAge()-o1.getAge();<span class="comment">//以学生的年龄降序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Comparable-普通接口-和Comparator-函数式接口-区别"><a href="#Comparable-普通接口-和Comparator-函数式接口-区别" class="headerlink" title="Comparable[普通接口]和Comparator[函数式接口]区别"></a>Comparable[普通接口]和Comparator[函数式接口]区别</h3><p><strong>Comparable：</strong>强行对实现它的每个类的对象进行整体排序。<strong>这种排序被称为类的自然排序</strong>，类的compareTo方法被称为它的自然比较方法。<strong>只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序</strong>。实现此接口的对象列表（和数组）<strong>可以通过<code>Collections.sort（和Arrays.sort）</code>进行自动排序</strong>，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p><p><strong>Comparator：</strong>强行对某个对象进行整体排序。<strong>可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制</strong>。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p><p>用</p><h2 id="Supplier接口"><a href="#Supplier接口" class="headerlink" title="Supplier接口"></a>Supplier接口</h2><ul><li><p><strong>获取一个泛型参数指定类型的对象数据。</strong></p></li><li><p><code>java.util.function.Supplier&lt;T&gt;</code>接口仅包含一个无参的方法：<code>T get()</code>。</p></li><li><p><code>Supplier&lt;T&gt;</code>接口被称之为生产型接口，指定接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个方法,方法的参数传递Supplier&lt;T&gt;接口,泛型执行String,get方法就会返回一个String</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(Supplier&lt;String&gt; sup)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sup.get();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//调用getString方法,方法的参数Supplier是一个函数式接口,所以可以传递Lambda表达式</span></span><br><span class="line">      String s = getString(()-&gt;&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"掘金木匠"</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">      System.out.println(s);<span class="comment">//掘金木匠</span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">//Lambda表达式</span></span><br><span class="line">      String s2 = getString(()-&gt;<span class="string">"掘金木匠"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(Supplier&lt;Integer&gt; sup)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sup.get();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">100</span>,<span class="number">0</span>,-<span class="number">50</span>,<span class="number">880</span>,<span class="number">99</span>,<span class="number">33</span>,-<span class="number">30</span>&#125;;</span><br><span class="line">        <span class="comment">//调用getMax方法,方法的参数Supplier是一个函数式接口,所以可以传递Lambda表达式</span></span><br><span class="line">        <span class="keyword">int</span> maxValue = getMax(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//获取数组的最大值,并返回</span></span><br><span class="line">            <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;     </span><br><span class="line">                <span class="keyword">if</span>(i&gt;max)&#123;</span><br><span class="line">                    <span class="comment">//如果i大于max,则替换max作为最大值</span></span><br><span class="line">                    max = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"数组中元素的最大值是:"</span>+maxValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer接口</h2><ul><li><code>java.util.function.Consumer&lt;T&gt;</code>接口则正好与Supplier接口相反，它不是生产一个数据，而是<strong>消费一个数据</strong>，其数据类型由泛型决定。 </li><li><code>Consumer</code>接口是一个消费型接口,泛型执行什么类型,就可以使用<code>accept</code>方法消费什么类型的数据，至于具体怎么消费(使用),需要自定义(输出,计算….)</li></ul><h3 id="抽象方法：accept"><a href="#抽象方法：accept" class="headerlink" title="抽象方法：accept"></a>抽象方法：accept</h3><ul><li><p><code>Consumer</code>接口中包含抽象方法<code>void accept(T t)</code> ，意为消费一个指定泛型的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        方法的参数传递Consumer接口,泛型使用String</span></span><br><span class="line"><span class="comment">        可以使用Consumer接口消费字符串的姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String name, Consumer&lt;String&gt; con)</span></span>&#123;</span><br><span class="line">        con.accept(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用method方法,传递字符串姓名,方法的另一个参数是Consumer接口,是一个函数式接口,所以可以传递Lambda表达式</span></span><br><span class="line">        method(<span class="string">"赵丽颖"</span>,(String name)-&gt;&#123;</span><br><span class="line">            <span class="comment">//消费方式:把字符串进行反转输出</span></span><br><span class="line">            String reName = <span class="keyword">new</span> StringBuffer(name).reverse().toString();</span><br><span class="line">            System.out.println(reName);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="默认方法：andThen"><a href="#默认方法：andThen" class="headerlink" title="默认方法：andThen"></a>默认方法：andThen</h3><ul><li><p>如果一个方法的参数和返回值全都是<code>Consumer</code>类型，那么就可以实现效果：消费数据的时候，首先做一个操作， 然后再做一个操作，实现组合。而这个方法就是<code>Consumer</code>接口中的<code>default</code>方法<code>andThen</code>。下面是JDK的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123; </span><br><span class="line">    Objects.requireNonNull(after); </span><br><span class="line">    <span class="keyword">return</span> (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>java.util.Objects 的 requireNonNull 静态方法将会在参数为null时主动抛出 NullPointerException 异常。这省去了重复编写if语句和抛出空指针异常的麻烦。</p></blockquote></li><li><p>要想实现组合，需要两个或多个Lambda表达式即可，而 andThen 的语义正是“一步接一步”操作。例如两个步骤组 合的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个方法,方法的参数传递一个字符串和两个Consumer接口,Consumer接口的泛型使用字符串</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String s, Consumer&lt;String&gt; con1 ,Consumer&lt;String&gt; con2)</span></span>&#123;</span><br><span class="line">       <span class="comment">//con1.accept(s);</span></span><br><span class="line">       <span class="comment">//con2.accept(s);</span></span><br><span class="line">       <span class="comment">//使用andThen方法,把两个Consumer接口连接到一起,在消费数据</span></span><br><span class="line">       con1.andThen(con2).accept(s);<span class="comment">//con1连接con2,先执行con1消费数据,在执行con2消费数据</span></span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//调用method方法,传递一个字符串,两个Lambda表达式</span></span><br><span class="line">          method(<span class="string">"Hello"</span>,</span><br><span class="line">               (t)-&gt; System.out.println(t.toUpperCase()), <span class="comment">//消费方式:把字符串转换为大写</span></span><br><span class="line">               (t)-&gt; System.out.println(t.toLowerCase()));<span class="comment">//消费方式:把字符串转换为小写</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h2><ul><li>有时候我们<strong>需要对某种类型的数据进行判断，从而得到一个boolean值结果</strong>。这时可以使用<code>java.util.function.Predicate&lt;T&gt;</code>接口。</li></ul><h3 id="抽象方法：test"><a href="#抽象方法：test" class="headerlink" title="抽象方法：test"></a>抽象方法：test</h3><ul><li><p>Predicate 接口中包含一个抽象方法：<code>boolean test(T t)</code> 。用于条件判断的场景：</p><ul><li>结果：符合条件，返回true </li><li>结果：不符合条件，返回false</li></ul></li><li><p>条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     参数传递一个String类型的字符串</span></span><br><span class="line"><span class="comment">     传递一个Predicate接口,泛型使用String</span></span><br><span class="line"><span class="comment">     使用Predicate中的方法test对字符串进行判断,并把判断的结果返回</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span>  pre.test(s);</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//定义一个字符串</span></span><br><span class="line">     String s = <span class="string">"abcdef"</span>;</span><br><span class="line">     <span class="comment">//Lambda表达式</span></span><br><span class="line">     <span class="keyword">boolean</span> b = checkString(s,str-&gt;str.length()&gt;<span class="number">5</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="默认方法：and"><a href="#默认方法：and" class="headerlink" title="默认方法：and"></a>默认方法：and</h3><ul><li><p>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个 Predicate 条件使用“与”逻辑连接起来实现“并且”的效果时，可以使用default方法 and 。其JDK源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123; </span><br><span class="line">Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (t) ‐&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断一个字符串<strong>既要</strong>长度是否大于52，<strong>又要</strong>判断字符串中是否包含a</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre1,Predicate&lt;String&gt; pre2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//return pre1.test(s) &amp;&amp; pre2.test(s);</span></span><br><span class="line">    <span class="keyword">return</span> pre1.and(pre2).test(s);<span class="comment">//等价于return pre1.test(s) &amp;&amp; pre2.test(s);</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"abcdef"</span>;</span><br><span class="line">    <span class="comment">//调用checkString方法,参数传递字符串和两个Lambda表达式</span></span><br><span class="line">    <span class="keyword">boolean</span> b = checkString(s,(str)-&gt; str.length()&gt;<span class="number">5</span>,(str)-&gt; str.contains(<span class="string">"a"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="默认方法：or"><a href="#默认方法：or" class="headerlink" title="默认方法：or"></a>默认方法：or</h3><ul><li><p>与 and 的“与”类似，默认方法 or 实现逻辑关系中的“或”。JDK源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123; </span><br><span class="line">Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (t) ‐&gt; test(t) || other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断一个字符串<strong>满足</strong>长度是否大于52，<strong>或</strong>判断字符串中是否包含a</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//return pre1.test(s) || pre2.test(s);</span></span><br><span class="line">    <span class="keyword">return</span>  pre1.or(pre2).test(s);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"bc"</span>;</span><br><span class="line">    <span class="comment">//调用checkString方法,参数传递字符串和两个Lambda表达式</span></span><br><span class="line">    <span class="keyword">boolean</span> b = checkString(s,(String str)-&gt; str.length()&gt;<span class="number">5</span>,(String str)-&gt; str.contains(<span class="string">"a"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="默认方法：negate"><a href="#默认方法：negate" class="headerlink" title="默认方法：negate"></a>默认方法：negate</h3><ul><li><p>“与”、“或”已经了解了，剩下的“非”（取反）也会简单。默认方法 negate 的JDK源代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default Predicate&lt;T&gt; negate() &#123; </span><br><span class="line">return (t) ‐&gt; !test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从实现中很容易看出，它是执行了test方法之后，对结果boolean值进行“!”取反而已。<strong>一定要在 test 方法调用之前调用 negate 方法，正如 and 和 or 方法一样</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Predicate接口判断字符串的长度是否大于5</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">       <span class="comment">//return !pre.test(s);</span></span><br><span class="line">       <span class="keyword">return</span>  pre.negate().test(s);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String s = <span class="string">"abc"</span>;</span><br><span class="line">       <span class="comment">//调用checkString方法,参数传递字符串和Lambda表达式</span></span><br><span class="line">       <span class="keyword">boolean</span> b = checkString(s,(String str)-&gt; str.length()&gt;<span class="number">5</span>);</span><br><span class="line">       System.out.println(b);<span class="comment">//true</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-7-Function接口"><a href="#3-7-Function接口" class="headerlink" title="3.7 Function接口"></a>3.7 Function接口</h2><ul><li><code>java.util.function.Function&lt;T,R&gt;</code>接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</li></ul><h3 id="抽象方法：apply"><a href="#抽象方法：apply" class="headerlink" title="抽象方法：apply"></a>抽象方法：apply</h3><ul><li><p><code>Function</code>接口中最主要的抽象方法为：<code>R apply(T t)</code>，根据类型T的参数获取类型R的结果。</p></li><li><p>使用的场景例如：将 String 类型转换为 Integer 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       方法的参数传递一个Function接口,泛型使用&lt;String,Integer&gt;</span></span><br><span class="line"><span class="comment">       使用Function接口中的方法apply,把字符串类型的整数,转换为Integer类型的整数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String s, Function&lt;String,Integer&gt; fun)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> in = fun.apply(s);</span><br><span class="line">       System.out.println(in);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//定义一个字符串类型的整数</span></span><br><span class="line">       String s = <span class="string">"1234"</span>;</span><br><span class="line">       <span class="comment">//调用change方法,传递字符串类型的整数,方法引用</span></span><br><span class="line">       change(s, Integer::parseInt); <span class="comment">//把字符串类型的整数,转换为Integer类型的整数返回</span></span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="默认方法：andThen-1"><a href="#默认方法：andThen-1" class="headerlink" title="默认方法：andThen"></a>默认方法：andThen</h3><ul><li><p><code>Function</code>接口中有一个默认的<code>andThen</code>方法，用来进行组合操作。JDK源代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123; </span><br><span class="line">Objects.requireNonNull(after); </span><br><span class="line">    <span class="keyword">return</span> (T t) ‐&gt; after.apply(apply(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法同样用于“先做什么，再做什么”的场景，和 Consumer 中的 andThen 差不多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        参数串一个字符串类型的整数</span></span><br><span class="line"><span class="comment">        参数再传递两个Function接口</span></span><br><span class="line"><span class="comment">            一个泛型使用Function&lt;String,Integer&gt;</span></span><br><span class="line"><span class="comment">            一个泛型使用Function&lt;Integer,String&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String s, Function&lt;String,Integer&gt; fun1,Function&lt;Integer,String&gt; fun2)</span></span>&#123;</span><br><span class="line">        String ss = fun1.andThen(fun2).apply(s);</span><br><span class="line">        System.out.println(ss);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"123"</span>;</span><br><span class="line">        <span class="comment">//调用change方法,传递字符串和两个Lambda表达式</span></span><br><span class="line">        <span class="comment">//把整数转换为字符串</span></span><br><span class="line">        change(s,str-&gt; parseInt(str)+<span class="number">10</span>,  </span><br><span class="line">                String::valueOf);    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      函数式接口 常用函数式接口
    
    </summary>
    
    
      <category term="Java高级" scheme="http://goldcarpenter.github.io/categories/Java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="Java" scheme="http://goldcarpenter.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDK8新特性</title>
    <link href="http://goldcarpenter.github.io/2020/02/25/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part1/"/>
    <id>http://goldcarpenter.github.io/2020/02/25/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part1/</id>
    <published>2020-02-24T16:00:00.000Z</published>
    <updated>2020-06-17T08:10:23.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK8新特性"><a href="#JDK8新特性" class="headerlink" title="JDK8新特性"></a>JDK8新特性</h1><h1 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1.Lambda表达式"></a>1.Lambda表达式</h1><h2 id="函数式编程思想概述"><a href="#函数式编程思想概述" class="headerlink" title="函数式编程思想概述"></a>函数式编程思想概述</h2><ul><li>相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。<ul><li>面向对象的思想:<ul><li>做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</li></ul></li><li>函数式编程思想:<ul><li>只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</li></ul></li></ul></li></ul><h2 id="编程思想转换"><a href="#编程思想转换" class="headerlink" title="编程思想转换"></a>编程思想转换</h2><p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code>run</code>方法体内的代码传递给<code>Thread</code>类知晓。</p><p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p><p>Java 8（JDK 1.8）中，加入了<strong>Lambda表达式</strong>的重量级新特性，为我们打开了新世界的大门。</p><h2 id="回顾匿名内部类"><a href="#回顾匿名内部类" class="headerlink" title="回顾匿名内部类"></a>回顾匿名内部类</h2><h3 id="使用实现类"><a href="#使用实现类" class="headerlink" title="使用实现类"></a>使用实现类</h3><p>要启动一个线程，需要创建一个<code>Thread</code>类的对象并调用<code>start</code>方法。而为了指定线程执行的内容，需要调用<code>Thread</code>类的构造方法：</p><ul><li><code>public Thread(Runnable target)</code></li></ul><p>为了获取<code>Runnable</code>接口的实现对象，可以为该接口定义一个实现类<code>RunnableImpl</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"多线程任务执行！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建该实现类的对象作为<code>Thread</code>类的构造参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03ThreadInitParam</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Runnable task = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line"><span class="keyword">new</span> Thread(task).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h3><p>这个<code>RunnableImpl</code>类只是为了实现<code>Runnable</code>接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04ThreadNameless</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"多线程任务执行！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类的好处与弊端"><a href="#匿名内部类的好处与弊端" class="headerlink" title="匿名内部类的好处与弊端"></a>匿名内部类的好处与弊端</h4><p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p><ul><li><p>仔细分析该代码中的语义，<code>Runnable</code>接口只有一个<code>run</code>方法的定义：</p></li><li><p><code>public abstract void run();</code></p></li><li><p>即制定了一种做事情的方案（其实就是一个函数）：</p><ul><li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li><li><strong>无返回值</strong>：该方案不产生任何结果。</li><li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li></ul></li><li><p>同样的语义体现在<code>Lambda</code>语法中，要更加简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">"多线程任务执行！"</span>)</span><br></pre></td></tr></table></figure><ul><li>前面的一对小括号即<code>run</code>方法的参数（无），代表不需要任何条件；</li><li>中间的一个箭头代表将前面的参数传递给后面的代码；</li><li>后面的输出语句即业务逻辑代码。</li></ul></li></ul><h2 id="Lambda标准格式"><a href="#Lambda标准格式" class="headerlink" title="Lambda标准格式"></a>Lambda标准格式</h2><ul><li><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p><ul><li>一些参数</li><li>一个箭头</li><li>一段代码</li></ul></li><li><p>Lambda表达式的<strong>标准格式</strong>为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数类型 参数名称) -&gt; &#123; 代码语句 &#125;</span><br></pre></td></tr></table></figure></li><li><p>格式说明：</p><ul><li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li><li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li><li>大括号内的语法与传统方法体要求基本一致。</li></ul></li></ul><h2 id="Lambda省略格式"><a href="#Lambda省略格式" class="headerlink" title="Lambda省略格式"></a>Lambda省略格式</h2><h4 id="可推导即可省略"><a href="#可推导即可省略" class="headerlink" title="可推导即可省略"></a>可推导即可省略</h4><p>Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。</p><h4 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h4><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p><ol><li>小括号内参数的类型可以省略；</li><li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li><li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li></ol><h2 id="Lambda的使用前提"><a href="#Lambda的使用前提" class="headerlink" title="Lambda的使用前提"></a>Lambda的使用前提</h2><ol><li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li><li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li></ol><blockquote><p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p></blockquote><h1 id="2-方法引用"><a href="#2-方法引用" class="headerlink" title="2.方法引用"></a>2.方法引用</h1><ul><li>在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑 一种情况：<strong>如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？</strong></li></ul><h2 id="2-1-冗余的Lambda场景"><a href="#2-1-冗余的Lambda场景" class="headerlink" title="2.1 冗余的Lambda场景"></a>2.1 冗余的Lambda场景</h2><ul><li><p>来看一个简单的函数式接口以应用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printable</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printout</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Printable</code>接口当中唯一的抽象方法<code>printout</code>接收一个字符串参数，目的就是为了打印显示它。那么通过<code>Lambda</code>来使用它的代码很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(Printable p)</span> </span>&#123;</span><br><span class="line">       p.printout(<span class="string">"HelloWorld"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//调用printString方法,方法的参数Printable是一个函数式接口,所以可以传递Lambda</span></span><br><span class="line">       printString((s) -&gt; &#123;</span><br><span class="line">           System.out.println(s);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-问题分析"><a href="#2-2-问题分析" class="headerlink" title="2.2 问题分析"></a>2.2 问题分析</h2><ul><li>这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是<code>System.out</code>对象中的<code>println(String)</code>方法。既然Lambda希望做的事情就是调用<code>println(String)</code>方法，那何必自己手动调用呢？</li></ul><h3 id="2-3-用方法引用改进代码"><a href="#2-3-用方法引用改进代码" class="headerlink" title="2.3 用方法引用改进代码"></a>2.3 用方法引用改进代码</h3><ul><li><p>能否省去Lambda的语法格式（尽管它已经相当简洁）呢？只要“引用”过去就好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       分析:</span></span><br><span class="line"><span class="comment">       Lambda表达式的目的,打印参数传递的字符串</span></span><br><span class="line"><span class="comment">       把参数s,传递给了System.out对象,调用out对象中的方法println对字符串进行了输出</span></span><br><span class="line"><span class="comment">       注意:</span></span><br><span class="line"><span class="comment">       1.System.out对象是已经存在的</span></span><br><span class="line"><span class="comment">       2.println方法也是已经存在的</span></span><br><span class="line"><span class="comment">       所以我们可以使用方法引用来优化Lambda表达式</span></span><br><span class="line"><span class="comment">       可以使用System.out方法直接引用(调用)println方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">printString(System.out::println);</span><br></pre></td></tr></table></figure><p>请注意其中的双冒号<code>::</code>写法，这被称为“方法引用”，而双冒号是一种新的语法。</p></li></ul><h2 id="2-4-方法引用符"><a href="#2-4-方法引用符" class="headerlink" title="2.4 方法引用符"></a>2.4 方法引用符</h2><p>双冒号<code>::</code>为引用运算符，而它所在的表达式被称为<strong>方法引用</strong>。<strong>如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。</strong> </p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><ul><li>例如上例中， <code>System.out</code>对象中有一个重载的<code>println(String)</code>方法恰好就是我们所需要的。那么对于<code>printString</code>方法的函数式接口参数，对比下面两种写法，完全等效： <ul><li>Lambda表达式写法：<code>s -&gt; System.out.println(s);</code>——拿到参数之后经<code>Lambda</code>之手，继而传递给 <code>System.out.println</code>方法去处理。</li><li>方法引用写法： <code>System.out::println</code>——复用了已有方案</li></ul></li><li>Lambda 中 <strong>传递的参数</strong> <strong>一定</strong>是方法引用中 的那个方法<strong>可以接收的类型</strong>,否则会抛出异常 </li></ul><h3 id="推导与省略"><a href="#推导与省略" class="headerlink" title="推导与省略"></a>推导与省略</h3><ul><li><p>如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式——它们都 将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。</p></li><li><p>函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。</p></li></ul><h3 id="通过对象名引用成员方法"><a href="#通过对象名引用成员方法" class="headerlink" title="通过对象名引用成员方法"></a>通过对象名引用成员方法</h3><ul><li><p>最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodRerObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个成员方法,传递字符串,把字符串按照大写输出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUpperCaseString</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        System.out.println(str.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    通过对象名引用成员方法</span></span><br><span class="line"><span class="comment">    使用前提是对象名是已经存在的,成员方法也是已经存在</span></span><br><span class="line"><span class="comment">    就可以使用对象名来引用成员方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01ObjectMethodReference</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个方法,方法的参数传递Printable接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(Printable p)</span></span>&#123;</span><br><span class="line">        p.printout(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用printString方法,方法的参数Printable是一个函数式接口,所以可以传递Lambda表达式</span></span><br><span class="line">        printString((s)-&gt;&#123;</span><br><span class="line">            <span class="comment">//创建MethodRerObject对象</span></span><br><span class="line">            MethodRerObject obj = <span class="keyword">new</span> MethodRerObject();</span><br><span class="line">            <span class="comment">//调用MethodRerObject对象中的成员方法printUpperCaseString,把字符串按照大写输出</span></span><br><span class="line">            obj.printUpperCaseString(s);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用方法引用优化Lambda</span></span><br><span class="line"><span class="comment">            对象是已经存在的MethodRerObject</span></span><br><span class="line"><span class="comment">            成员方法也是已经存在的printUpperCaseString</span></span><br><span class="line"><span class="comment">            所以我们可以使用对象名引用成员方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//创建MethodRerObject对象</span></span><br><span class="line">        MethodRerObject obj = <span class="keyword">new</span> MethodRerObject();</span><br><span class="line">        printString(obj::printUpperCaseString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="通过类名称引用静态方法"><a href="#通过类名称引用静态方法" class="headerlink" title="通过类名称引用静态方法"></a>通过类名称引用静态方法</h3><ul><li><p>由于在<code>java.lang.Math</code>类中已经存在了静态方法<code>abs</code>，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calcable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个抽象方法,传递一个整数,对整数进行绝对值计算并返回</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calsAbs</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    通过类名引用静态成员方法</span></span><br><span class="line"><span class="comment">    类已经存在,静态成员方法也已经存在</span></span><br><span class="line"><span class="comment">    就可以通过类名直接引用静态成员方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01StaticMethodReference</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个方法,方法的参数传递要计算绝对值的整数,和函数式接口Calcable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> number,Calcable c)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> c.calsAbs(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用method方法,传递计算绝对值得整数,和Lambda表达式</span></span><br><span class="line">        <span class="keyword">int</span> number = method(-<span class="number">10</span>,(n)-&gt;&#123;</span><br><span class="line">            <span class="comment">//对参数进行绝对值得计算并返回结果</span></span><br><span class="line">            <span class="keyword">return</span> Math.abs(n);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(number);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用方法引用优化Lambda表达式</span></span><br><span class="line"><span class="comment">            Math类是存在的</span></span><br><span class="line"><span class="comment">            abs计算绝对值的静态方法也是已经存在的</span></span><br><span class="line"><span class="comment">            所以我们可以直接通过类名引用静态方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> number2 = method(-<span class="number">10</span>,Math::abs);</span><br><span class="line">        System.out.println(number2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="通过super引用成员方法"><a href="#通过super引用成员方法" class="headerlink" title="通过super引用成员方法"></a>通过super引用成员方法</h3><ul><li><p>如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Greetable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个见面的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类<code>Human</code>的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo07.SuperMethodReference;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个sayHello的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello 我是Human!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是子类<code>Man</code>的内容，其中使用了Lambda的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo07.SuperMethodReference;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="comment">//子类重写父类sayHello的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello 我是Man!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法参数传递Greetable接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Greetable g)</span></span>&#123;</span><br><span class="line">        g.greet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//调用method方法,方法的参数Greetable是一个函数式接口,所以可以传递Lambda</span></span><br><span class="line">        <span class="comment">/*method(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">            //创建父类Human对象</span></span><br><span class="line"><span class="comment">            Human h = new Human();</span></span><br><span class="line"><span class="comment">            //调用父类的sayHello方法</span></span><br><span class="line"><span class="comment">            h.sayHello();</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为有子父类关系,所以存在的一个关键字super,代表父类,所以我们可以直接使用super调用父类的成员方法</span></span><br><span class="line">       <span class="comment">/* method(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">            super.sayHello();</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">           使用super引用类的成员方法</span></span><br><span class="line"><span class="comment">           super是已经存在的</span></span><br><span class="line"><span class="comment">           父类的成员方法sayHello也是已经存在的</span></span><br><span class="line"><span class="comment">           所以我们可以直接使用super引用父类的成员方法</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      method(<span class="keyword">super</span>::sayHello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Man().show(); <span class="comment">//Hello 我是Human!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="通过this引用成员方法"><a href="#通过this引用成员方法" class="headerlink" title="通过this引用成员方法"></a>通过this引用成员方法</h3><ul><li>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“this::成员方法”的格式来使用方 法引用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用this引用本类的成员方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello 我是Man!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法参数传递Greetable接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Greetable g)</span></span>&#123;</span><br><span class="line">        g.greet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//调用method方法,方法的参数Greetable是一个函数式接口,所以可以传递Lambda</span></span><br><span class="line">        <span class="comment">/*method(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">           // 使用this.成员方法,调用父类的sayHello方法</span></span><br><span class="line"><span class="comment">            this.sayHello();</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用方法引用优化Lambda表达式</span></span><br><span class="line"><span class="comment">            this是已经存在的</span></span><br><span class="line"><span class="comment">            本类的成员方法sayHello也是已经存在的</span></span><br><span class="line"><span class="comment">            所以我们可以直接使用this引用本类的成员方法buyHouse</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        method(<span class="keyword">this</span>::sayHello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Human().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="类的构造器引用"><a href="#类的构造器引用" class="headerlink" title="类的构造器引用"></a>类的构造器引用</h3><ul><li><p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 类名称::new 的格式表示。创建 Person 对象的函数式接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个方法,根据传递的姓名,创建Person对象返回</span></span><br><span class="line">    <span class="function">Person <span class="title">builderPerson</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo09.ConstructorMethodReference;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    类的构造器(构造方法)引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个方法,参数传递姓名和PersonBuilder接口,方法中通过姓名创建Person对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">(String name,PersonBuilder pb)</span></span>&#123;</span><br><span class="line">        Person person = pb.builderPerson(name);</span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用printName方法,方法的参数PersonBuilder接口是一个函数式接口,可以传递Lambda</span></span><br><span class="line">        printName(<span class="string">"迪丽热巴"</span>,(String name)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用方法引用优化Lambda表达式</span></span><br><span class="line"><span class="comment">            构造方法new Person(String name) 已知</span></span><br><span class="line"><span class="comment">            创建对象已知 new</span></span><br><span class="line"><span class="comment">            就可以使用Person引用new创建对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        printName(<span class="string">"古力娜扎"</span>,Person::<span class="keyword">new</span>);<span class="comment">//使用Person类的带参构造方法,通过传递的姓名创建对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数组的构造器引用"><a href="#数组的构造器引用" class="headerlink" title="数组的构造器引用"></a>数组的构造器引用</h3><ul><li><p>数组也是 Object 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时， 需要一个函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArrayBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个创建int类型数组的方法,参数传递数组的长度,返回创建好的int类型数组</span></span><br><span class="line">    <span class="keyword">int</span>[] builderArray(<span class="keyword">int</span> length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    数组的构造器引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法</span></span><br><span class="line"><span class="comment">        方法的参数传递创建数组的长度和ArrayBuilder接口</span></span><br><span class="line"><span class="comment">        方法内部根据传递的长度使用ArrayBuilder中的方法创建数组并返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] createArray(<span class="keyword">int</span> length, ArrayBuilder ab)&#123;</span><br><span class="line">        <span class="keyword">return</span>  ab.builderArray(length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用createArray方法,传递数组的长度和Lambda表达式</span></span><br><span class="line">        <span class="keyword">int</span>[] arr1 = createArray(<span class="number">10</span>,(len)-&gt;&#123;</span><br><span class="line">            <span class="comment">//根据数组的长度,创建数组并返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(arr1.length);<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用方法引用优化Lambda表达式</span></span><br><span class="line"><span class="comment">            已知创建的就是int[]数组</span></span><br><span class="line"><span class="comment">            数组的长度也是已知的</span></span><br><span class="line"><span class="comment">            就可以使用方法引用</span></span><br><span class="line"><span class="comment">            int[]引用new,根据参数传递的长度来创建数组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span>[] arr2 =createArray(<span class="number">10</span>,<span class="keyword">int</span>[]::<span class="keyword">new</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line">        System.out.println(arr2.length);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      Lambda表达式 方法引用
    
    </summary>
    
    
      <category term="Java高级" scheme="http://goldcarpenter.github.io/categories/Java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="Java" scheme="http://goldcarpenter.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JavaIO</title>
    <link href="http://goldcarpenter.github.io/2020/02/02/javaIO/"/>
    <id>http://goldcarpenter.github.io/2020/02/02/javaIO/</id>
    <published>2020-02-02T09:55:36.000Z</published>
    <updated>2020-06-17T07:16:32.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-File类"><a href="#1-File类" class="headerlink" title="1.File类"></a>1.File类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ul><li><code>java.io.File</code> 类是<strong>文件和目录</strong>路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作</li><li>File类是一个与系统无关的类，任何的操作系统都可以使用这个类中的方法</li></ul><h2 id="1-2静态成员变量"><a href="#1-2静态成员变量" class="headerlink" title="1.2静态成员变量"></a>1.2静态成员变量</h2><ul><li><code>static String pathSeparator</code>：与系统有关的路径分隔符，为了方便，它被表示为一个字符串。</li><li><code>static char pathSeparatorChar</code>：与系统有关的路径分隔符。</li><li><code>static string separator</code>：与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。</li><li><code>static char separatorChar：</code>与系统有关的默认名称分隔符。</li></ul><h2 id="1-3-构造方法"><a href="#1-3-构造方法" class="headerlink" title="1.3 构造方法"></a>1.3 构造方法</h2><ul><li><code>public File(String pathname)</code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的File实例。  </li><li><code>public File(String parent, String child)</code> ：拼接 <strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</li><li><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。  </li><li>构造举例，代码如下：</li></ul><blockquote><ol><li>无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li><li>路径可以是以文件结尾，也可以是以文件夹结尾</li><li>路径可以是相对路径,也可以是绝对路径</li><li>路径可以是存在，也可以是不存在</li><li>创建File对象，只是把字符串路径封装为File对象，不考虑路径的真假情况</li></ol></blockquote><h2 id="1-4-常用方法"><a href="#1-4-常用方法" class="headerlink" title="1.4 常用方法"></a>1.4 常用方法</h2><h3 id="1-4-1获取功能的方法"><a href="#1-4-1获取功能的方法" class="headerlink" title="1.4.1获取功能的方法"></a>1.4.1获取功能的方法</h3><ul><li><code>public String getAbsolutePath()</code> ：返回此File的<strong>绝对路径名字</strong>符串。</li><li><code>public String getPath()</code> ：将此File转换为<strong>绝对/相对路径名字</strong>符串，<code>toString</code>调用此方法实现。 </li><li><code>public String getName()</code>  ：返回由此File表示的<strong>文件或目录的名称</strong>。  </li><li><code>public long length()</code>  ：返回由此File表示的<strong>文件的大小</strong>，字节单位。 </li></ul><blockquote><p>API中说明：length()——表示文件的大小。但是File对象表示目录，则返回值0。</p></blockquote><h3 id="1-4-2绝对路径和相对路径"><a href="#1-4-2绝对路径和相对路径" class="headerlink" title="1.4.2绝对路径和相对路径"></a>1.4.2绝对路径和相对路径</h3><ul><li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li><li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilePath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// D盘下的bbb.java文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"D:\\bbb.java"</span>);</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 项目下的bbb.java文件</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"bbb.java"</span>);</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">D:\bbb.java</span><br><span class="line">D:\idea_project_test4\bbb.java</span><br></pre></td></tr></table></figure><h3 id="1-4-3判断功能的方法"><a href="#1-4-3判断功能的方法" class="headerlink" title="1.4.3判断功能的方法"></a>1.4.3判断功能的方法</h3><ul><li><code>public boolean exists()</code> ：此File表示的<strong>文件或目录是否实际存在</strong>。</li><li><code>public boolean isDirectory()</code> ：此File表示的<strong>是否为目录</strong>。</li><li><code>public boolean isFile()</code> ：此File表示的<strong>是否为文件</strong>。</li></ul><blockquote><p>isFile() &amp; isDirectory() 使用前提，路径必须是存在的，否则都返回false</p></blockquote><h3 id="1-4-4创建删除功能的方法"><a href="#1-4-4创建删除功能的方法" class="headerlink" title="1.4.4创建删除功能的方法"></a>1.4.4创建删除功能的方法</h3><ul><li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，<strong>创建一个新的空文件</strong>。 <ul><li>只能创建文件，不能创建文件夹</li><li>创建文件的路径必须存在，否则会抛出异常</li><li>文件存在，不会创建，返回false</li></ul></li><li><code>public boolean delete()</code> ：<strong>删除</strong>由此File表示的<strong>文件或目录</strong>。  <ul><li>如果此File表示目录，文件夹中有内容，不会删除返回false，目录必须为空才能删除</li><li>构造方法中路径不存在，返回false</li><li>直接在硬盘删除文件/文件夹，不走回收站，删除要谨慎</li></ul></li><li><code>public boolean mkdir()</code> 【不常用】：<strong>创建</strong>由此File表示的<strong>单级目录</strong>。<ul><li>文件夹存在，不会创建，返回false</li><li>构造方法中给出的路径不存在，返回false</li></ul></li><li><code>public boolean mkdirs()</code> 【常用】：创建由此File表示的目录，<strong>包括任何必需但不存在的父目录</strong>。<ul><li>既可以创建单级文件夹，也可以创建多级文件夹</li></ul></li></ul><h2 id="1-5目录的遍历"><a href="#1-5目录的遍历" class="headerlink" title="1.5目录的遍历"></a>1.5目录的遍历</h2><ul><li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li><li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">"d:\\java_code"</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取当前目录下的文件以及文件夹的名称。</span></span><br><span class="line">String[] names = dir.list();</span><br><span class="line"><span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>调用遍历方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</li><li>可以遍历到隐藏的文件夹</li></ol></blockquote><h2 id="1-6文件过滤器实现"><a href="#1-6文件过滤器实现" class="headerlink" title="1.6文件过滤器实现"></a>1.6文件过滤器实现</h2><ul><li><code>java.io.FileFilter</code>是一个接口，File过滤器。 该接口的对象可以传递给File类<code>listFiles(FileFilter)</code> 作为参数， 接口中只有一个方法。</li><li><code>boolean accept(File pathname)</code> ：测试pathname是否应该包含在当前File目录中，符合则返回true。</li></ul><p><strong>分析</strong>：</p><ol><li>接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。</li><li><code>accept</code>方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则：<ol><li>要么是.java文件。</li><li>要么是目录，用于继续遍历。</li></ol></li><li>通过过滤器的作用，<code>listFiles(FileFilter)</code>返回的数组元素中，子文件对象都是符合条件的，可以直接打印。</li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">"D:\\aaa"</span>);</span><br><span class="line">        printDir2(dir);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDir2</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 匿名内部类方式,创建过滤器子类对象</span></span><br><span class="line">        File[] files = dir.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pathname.getName().endsWith(<span class="string">".java"</span>)||pathname.isDirectory();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="comment">// 循环打印</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"文件名:"</span> + file.getAbsolutePath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                printDir2(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-7文件过滤器实现Lambda优化"><a href="#1-7文件过滤器实现Lambda优化" class="headerlink" title="1.7文件过滤器实现Lambda优化"></a>1.7文件过滤器实现Lambda优化</h2><p><strong>分析：</strong><code>FileFilter</code>是只有一个方法的接口，因此可以用lambda表达式简写。</p><p>lambda格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()-&gt;&#123; &#125;</span><br></pre></td></tr></table></figure><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDir3</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// lambda的改写</span></span><br><span class="line">    File[] files = dir.listFiles(f -&gt;&#123; </span><br><span class="line">      <span class="keyword">return</span> f.getName().endsWith(<span class="string">".java"</span>) || f.isDirectory(); </span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 循环打印</span></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"文件名:"</span> + file.getAbsolutePath());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        printDir3(file);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-IO流"><a href="#2-IO流" class="headerlink" title="2.IO流"></a>2.IO流</h1><h2 id="2-1IO的分类"><a href="#2-1IO的分类" class="headerlink" title="2.1IO的分类"></a>2.1IO的分类</h2><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p><ul><li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </li><li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li></ul><p>格局数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p><ul><li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li><li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li></ul><h2 id="2-2顶级父类"><a href="#2-2顶级父类" class="headerlink" title="2.2顶级父类"></a>2.2顶级父类</h2><table><thead><tr><th align="center"></th><th align="center"><strong>输入流</strong></th><th align="center">输出流</th></tr></thead><tbody><tr><td align="center"><strong>字节流</strong></td><td align="center">字节输入流<br/><strong>InputStream</strong></td><td align="center">字节输出流<br/><strong>OutputStream</strong></td></tr><tr><td align="center"><strong>字符流</strong></td><td align="center">字符输入流<br/><strong>Reader</strong></td><td align="center">字符输出流<br/><strong>Writer</strong></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      File类 IO流结构
    
    </summary>
    
    
      <category term="Java基础" scheme="http://goldcarpenter.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://goldcarpenter.github.io/tags/Java/"/>
    
      <category term="IO" scheme="http://goldcarpenter.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal总结</title>
    <link href="http://goldcarpenter.github.io/2019/12/21/ThreadLocal/"/>
    <id>http://goldcarpenter.github.io/2019/12/21/ThreadLocal/</id>
    <published>2019-12-21T15:19:21.000Z</published>
    <updated>2020-06-17T03:25:33.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><ul><li><code>ThreadLocal</code>可以为当前线程关联一个数据【普通变量，对象，数组，集合】</li><li>可以像 Map一样存取数据，key 为当前线程，<strong>保证各个线程的变量相对独立于其他线程内的变量，解决多线程的数据安全问题</strong>。</li><li>每一个<code>ThreadLocal</code>对象，只能为当前线程关联一个数据，如果要为当前线程关联多个数据，就需要使用多个<code>ThreadLocal</code>对象</li><li>每个<code>ThreadLocal</code>对象实例定义的时候，<strong>一般都是static类型</strong></li><li><code>ThreadLocal</code>中保存数据，在线程销毁后。会由JVM虚拟自动释放</li></ul><h2 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2.常用方法"></a>2.常用方法</h2><table><thead><tr><th align="center">方法声明</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ThreadLocal()</td><td align="center">创建ThreadLocal对象</td></tr><tr><td align="center">public T get()</td><td align="center">设置当前线程绑定的局部变量</td></tr><tr><td align="center">public void set(T value)</td><td align="center">获取当前线程绑定的局部变量</td></tr><tr><td align="center">public void remove()</td><td align="center">移除当前线程绑定的局部变量</td></tr></tbody></table><h2 id="3-案例"><a href="#3-案例" class="headerlink" title="3.案例"></a>3.案例</h2><ul><li>线程隔离，在多线程并发的场景下，每个线程中的变量都是相互独立<br>线程1——设置(变量1)——获取(变量1)<br>线程2——设置(变量2)——获取(变量2)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;       </span><br><span class="line">    String content;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main main = <span class="keyword">new</span> Main();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                main.setContent(Thread.currentThread().getName() + <span class="string">"的数据"</span>);</span><br><span class="line">                System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"---&gt;"</span> + main.getContent());</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">"线程"</span>+i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--------------------</span><br><span class="line">线程2---&gt;线程2的数据</span><br><span class="line">--------------------</span><br><span class="line">线程3---&gt;线程3的数据</span><br><span class="line">--------------------</span><br><span class="line">线程0---&gt;线程4的数据</span><br><span class="line">--------------------</span><br><span class="line">线程4---&gt;线程1的数据</span><br><span class="line">--------------------</span><br><span class="line">线程1---&gt;线程1的数据</span><br></pre></td></tr></table></figure><ul><li><p>尝试使用Synchronized解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main main = <span class="keyword">new</span> Main();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Load10<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    main.setContent(Thread.currentThread().getName() + <span class="string">"的数据"</span>);</span><br><span class="line">                System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"---&gt;"</span> + main.getContent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">"线程"</span>+i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>从结果可以发现，加锁确实可以解决这个问题，但是在<strong>这里我们强调的是线程数据隔离的问题</strong>，并<strong>不是多线程共享数据的问题</strong>，在这个案例中使用synchronized关键字是不合适的。</li></ul></blockquote></li><li><p>ThreadLocal与synchronized的区别</p><ul><li><p>虽然ThreadLocal模式与synchronized关键字都用于处理多线程并发访问变量的问题,不过两者处理问题的角度和思路不同。</p><table><thead><tr><th></th><th align="center">synchronized</th><th align="center">ThreadLocal</th></tr></thead><tbody><tr><td>原理</td><td align="center">同步机制采用以时间换空间的方式，只提供了一份变量，让不同的线程排队访问</td><td align="center">ThreadLocal采用以空间换时间的方式，为<strong>每一个线程原都提供了一份变量的副本</strong>，从而实现同时访问而相不干扰</td></tr><tr><td>侧重点</td><td align="center">多个线程之间<strong>访问资源同步</strong></td><td align="center">多线程中让每个线程之间的<strong>数据相互隔离</strong></td></tr></tbody></table></li></ul></li><li><p>ThreadLocal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String content = threadLocal.get();</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.threadLocal.set(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-ThreadLocal方案的好处"><a href="#4-ThreadLocal方案的好处" class="headerlink" title="4.ThreadLocal方案的好处"></a>4.ThreadLocal方案的好处</h2><ul><li>线程隔离：各线程之间的数据相互隔离却又具备并发性，<strong>避免同步方式带来的性能损失</strong>【案例1】</li><li>传递数据：保存每个线程绑定的数据，在需要的地方可以直接获取，<strong>避免参数直接传递带来的代码耦合问题</strong>【Service层和Dao层传递Connection对象】</li></ul><h2 id="4-内部结构"><a href="#4-内部结构" class="headerlink" title="4.内部结构"></a>4.内部结构</h2><ul><li><p>早期</p><ul><li>每个ThreadLocal都创建一个Map，然后用线程作为Map的key，要存储的局部变量作为Map的value ，这样就能达到各个线程的局部变量隔离的效果。</li></ul><p><img src="ThreadLocal_img/1589278568621.png" alt="1589278568621"></p></li><li><p>JDK8</p><ul><li><p>每个Thread维护一个ThreadLocalMap，这个Map的key是ThreadLocal实例本身，value 才是真正要存储的值Object。</p></li><li><p>具体的过程是这样的:</p><ul><li>每个Thread线程内部都有一个Map【ThreadLocalMap】</li><li>Map【ThreadLocalMap】<code>key</code>存储<strong>ThreadLocal对象</strong>和 <code>value</code>存储<strong>线程的变量副本</strong></li><li>Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。</li><li>对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，<br>互不干扰。</li></ul><p><img src="ThreadLocal_img/1589278729316.png" alt="1589278729316"></p></li></ul></li><li><p>JDK8 VS 早期的优点</p><ul><li>每个Map存储的Entry数量变少</li><li>当Thread销毁的时候, ThreadLocalMap也会随之销毁,减少内存的使用</li></ul></li></ul><h2 id="5-ThreadLocal源码分析"><a href="#5-ThreadLocal源码分析" class="headerlink" title="5.ThreadLocal源码分析"></a>5.ThreadLocal源码分析</h2><h3 id="5-1-set方法"><a href="#5-1-set方法" class="headerlink" title="5.1.set方法"></a>5.1.set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 设置当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value 将要保存在当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">pub1ic <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程对象</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">//判断map是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (map != nu11)&#123;</span><br><span class="line">            <span class="comment">//存在则调用map.set设置此实体entry</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 1)当前线程Thread不存在ThreadLocalMap对象</span></span><br><span class="line">            <span class="comment">// 2)则调用createMap进行ThreaduocalMap对象的初始化</span></span><br><span class="line">            <span class="comment">// 3)并将t(当前线程)和value(t对应的值)作为第一 个entry存放至ThreadLocalMap中</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *获取当前线程Thr ead对应维护的ThreadLocalMap</span></span><br><span class="line"><span class="comment">  *<span class="doctag">@param</span> t the current thread 当前线程</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the map 对应维护的ThreadLocalMap</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadlocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建当前线程Thread对应维护的ThreadLocalMap</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> t 当前线程</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> firstValue存放到map中第一个entry的值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t,T firstValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里的this 是调用此方法的threadLocal</span></span><br><span class="line">        t.threadlocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>代码执行流程<ul><li>首先获取当前线程,并根据当前线程获取一个Map</li><li>如果获取的Map不为空,则将参数设置到Map中(当前ThreadLocal的引用作为key )</li><li>如果Map为空,则给该线程创建Map，并设置初始值</li></ul></li></ul><h3 id="5-2-get方法"><a href="#5-2-get方法" class="headerlink" title="5.2.get方法"></a>5.2.get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程中保存ThreadLocal的值</span></span><br><span class="line"><span class="comment"> * 如果当前线程没有此ThreadLocal变量</span></span><br><span class="line"><span class="comment"> * 则它会通过调用&#123;<span class="doctag">@link</span> #initialvalue&#125; 方法进行初始化值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回当前线程对应此ThreadLocal的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程对象</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t) ;</span><br><span class="line">        <span class="comment">//如果此map存在</span></span><br><span class="line">        <span class="keyword">if</span> (map != nu11) &#123;</span><br><span class="line">        <span class="comment">//以当前的ThreadLocal为key,调用getEntry获取对应的存储实体e</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//对e进行判空</span></span><br><span class="line">            <span class="keyword">if</span> (e != nu11) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                <span class="comment">//获取存储实体e对应的value值</span></span><br><span class="line">                <span class="comment">//即为我们想要的当前线程对应此ThreadLocal的值</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            初始化:有两种情况有执行当前代码</span></span><br><span class="line"><span class="comment">            第一种情况: map不存在，表示此线程没有维护的ThreadLocalMap对象</span></span><br><span class="line"><span class="comment">            第二种情况: map存在， 但是没有与当前ThreadLocal关联的entry</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> setInitialvalue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value初始化后的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用initialvalue获取初始化的值</span></span><br><span class="line">        <span class="comment">//此方法可以被子类重写，如果不重写默认返回null</span></span><br><span class="line">        T value = initialValue();</span><br><span class="line">        <span class="comment">//获取当前线程对象</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">//判断map是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (map != nu11)&#123;</span><br><span class="line">            <span class="comment">//存在则调用map.set设置此实体entry</span></span><br><span class="line">            map.set(<span class="keyword">this</span>,value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 1)当前线程Thread 不存在ThreadL oca 1Map对象</span></span><br><span class="line">        <span class="comment">// 2)则调用cr eat eMap进行ThreadLoca 1Map对象的初始化</span></span><br><span class="line">        <span class="comment">// 3)并将t(当前线程)和value(t对应的值)作为第一个entry存放至Thr eadL ocalMap中</span></span><br><span class="line">        createMap(t,value);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//返回设置的值value</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>代码执行流程<ol><li>首先获取当前线程，根据当前线程获取一个Map</li><li>如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的<code>Entry e</code>，否则转到4</li><li>如果e不为null，则返回<code>e.value</code>，否则转到4</li><li><code>Map</code>为空或者<code>e</code>为空,则通过<code>initialValue</code>函数获取初始值<code>value</code> ,然后用<code>Threadlocal</code>的引用和<code>value</code>作为<code>firstKey</code>和<code>firstValue</code>创建一个新的<code>Map</code></li></ol></li><li>总结：先获取当前线程的ThreadLocalMap变量，如果存在则返回值，不存在则创建并返回初始值。</li></ul><h3 id="5-3-remove方法"><a href="#5-3-remove方法" class="headerlink" title="5.3.remove方法"></a>5.3.remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除当前线程中保存的Thr eadLoca 1对应的实体entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">        <span class="comment">//如果此map存在</span></span><br><span class="line">        <span class="keyword">if</span> (m != nu11)&#123;</span><br><span class="line">            <span class="comment">//存在则调用map.remove</span></span><br><span class="line">            <span class="comment">//以当前ThreadLocal为key删除对应的实体entry</span></span><br><span class="line">            m.remove(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>代码执行流程<ul><li>首先获取当前线程，并根据当前线程获取一个Map</li><li>如果获取的Map不为空，则移除当前ThreadLocal对象对应的entry</li></ul></li></ul><h3 id="5-4-initialValue方法"><a href="#5-4-initialValue方法" class="headerlink" title="5.4.initialValue方法"></a>5.4.initialValue方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方返回当前线程对应的Threadlocal的初始值</span></span><br><span class="line"><span class="comment"> * 此方法的第一次调用发生在，当线程通过get方法访问此线程的ThreadLocal值时</span></span><br><span class="line"><span class="comment"> * 除非线程先调用了set方法，在这种情况下，initialvalue才不会被这个线程调用。</span></span><br><span class="line"><span class="comment"> * 通常情况下，每个线程最多调用一次这个方法。</span></span><br><span class="line"><span class="comment"> * 这个方法仅仅简单的返回null &#123;<span class="doctag">@code</span> nu11&#125;;</span></span><br><span class="line"><span class="comment"> * 如果程序员想ThreadLoca1线程局部变量有一个除null以外的初始值，</span></span><br><span class="line"><span class="comment"> * 必须通过子类继承&#123;<span class="doctag">@code</span> ThreadLocal&#125; 的方式去重写此方法</span></span><br><span class="line"><span class="comment"> * 通常，可以通过匿名内部类的方式实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前ThreadLocal的初始值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> nu11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>此方法的作用是返回该线程局部变量的初始值。<ul><li>这个方法是一个延迟调用方法，从上面的代码我们得知，在set方法还未调用而先调用了get方法时才执行，并且仅执行一次</li><li>这个方法缺省实现直接返回<code>null</code></li><li>如果想要一个除<code>null</code>之外的初始值,可以重写此方法。( 备注:该访法是一个protected的方法，显然是<br>为了让子类覆盖而设计的)</li></ul></li></ul><h2 id="6-ThreadLocalMap源码分析"><a href="#6-ThreadLocalMap源码分析" class="headerlink" title="6.ThreadLocalMap源码分析"></a>6.ThreadLocalMap源码分析</h2><ul><li>分析ThreadLocal方法了解到ThreadLocal的操作实际上是围绕ThreadLocalMap展开的。</li><li>ThreadLocalMap的源码相对比较复杂，以下三个方面进行讨论。</li></ul><h3 id="6-1基本结构"><a href="#6-1基本结构" class="headerlink" title="6.1基本结构"></a>6.1基本结构</h3><ul><li><p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的<strong>内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也是独立实现。</strong></p><p><img src="ThreadLocal_img/1589289298701.png" alt="1589289298701"></p></li><li><p>成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *初始容量--必须是2的整次幂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> InItIAl_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  存放数据的table，Entry类的定义在下面分析</span></span><br><span class="line"><span class="comment"> *  同样，数组长度必须是2的整次幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组里面entrys的个数，可以用于判断table当前使用量是否超过阈值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 进行扩容的阈值，表使用量大于它的时候进行扩容。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><ul><li>跟HashMap类似，<code>INITIAL_CAPACITY</code>代表这个Map的初始容量，table是一个<code>Entry</code>类型的数组，用于存储数据，size代表表中的存储数目， threshold代表需要扩容时对应size的阈值。</li></ul></li><li><p>存储结构Entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Entry继承WeakReference，并且用ThreadLocal作为key</span></span><br><span class="line"><span class="comment"> * 如果key为null(entry.get() == nu11) 意味着key不再被引用</span></span><br><span class="line"><span class="comment"> * 因此这时候entry也可以从tab1e中清除。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this Threadocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。不过Entry中的key只能是ThreadLocal对象 ,这点在构造方法中已经限定死了。</li><li>另外, Entry继承WeakReference，也就是key ( ThreadLocal )是弱引用，其目的是将ThreadLocal对象的生命周期和线程生命周期解绑。</li></ul></li></ul><h3 id="6-2弱引用和内存泄漏"><a href="#6-2弱引用和内存泄漏" class="headerlink" title="6.2弱引用和内存泄漏"></a>6.2弱引用和内存泄漏</h3><ul><li><p>内存泄漏相关概念</p><ul><li>Memory overflow：内存溢出,没有足够的内存提供申请者使用</li><li>Memory leak：内存泄漏是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。内存泄漏的堆积终将导致内存溢出。</li></ul></li><li><p>弱引用相关概念</p><ul><li>Java中的引用有4种类型：强、软、弱、虚。</li><li>强引用：最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾回收器就不会回收这种对象。</li><li>弱引用：垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</li></ul></li><li><p><strong>在使用ThreadLocal的过程中有内存泄漏的情况发生</strong></p></li></ul><h4 id="6-2-1与否与ThreadLocalMap中的key使用弱引用有关"><a href="#6-2-1与否与ThreadLocalMap中的key使用弱引用有关" class="headerlink" title="6.2.1与否与ThreadLocalMap中的key使用弱引用有关"></a>6.2.1与否与ThreadLocalMap中的key使用弱引用有关</h4><p><img src="ThreadLocal_img/1589292275492.png" alt="1589292275492"></p><ul><li>假设在业务代码中使用完<code>ThreadLocal</code> ，<code>threadLocalRef</code>被回收了</li><li>由于<code>ThreadLocalMap</code>只持有<code>ThreadLocal</code>的弱引用，没有任何强引用指向<code>threadlocal</code>实例,所以<code>threadlocal</code>就可以顺利被GC回收，此时<code>Entry</code>中的<code>key=null</code></li><li>【在没有手动删除这个<code>Entry</code>以及<code>CurrentThread</code>依然运行的前提下】，存在有强引用链<code>threadRef-&gt; currentThread-&gt; threadLocalMap-&gt;entry-&gt;value</code>，<code>value</code>不会被回收，而这块<code>value</code>永远不会被访问到了，导致<code>value</code>内存泄漏</li><li><strong>ThreadLocalMap中的key使用了弱引用，有可能内存泄漏。</strong></li></ul><h4 id="6-2-2假设ThreadLocalMap中的key使用强引用"><a href="#6-2-2假设ThreadLocalMap中的key使用强引用" class="headerlink" title="6.2.2假设ThreadLocalMap中的key使用强引用"></a>6.2.2假设ThreadLocalMap中的key使用强引用</h4><ul><li><p>假设<code>ThreadLocalMap</code>中的<code>key</code>使用了强引用，那么会出现内存泄漏吗?</p></li><li><p>此时<code>ThreadLocal</code>的内存图如下:</p><p><img src="ThreadLocal_img/1589291319111.png" alt="1589291319111"></p><ul><li>在业务代码中使用完<code>ThreadLocal</code>，<code>threadLocalRef</code>被回收了</li><li>因为<code>threadLocalMap</code>的<code>Entry</code>强引用了<code>threadLocal</code>，造成<code>threadLocal</code>无法被回收</li><li>【在没有手动删除这个<code>Entry</code>以及<code>CurrentThread</code>依然运行的前提下】，始终有强引用链<code>threadRef-&gt; currentThread-&gt; threadLocalMap-&gt; entry</code>，<code>Entry</code>就不会被回收（包括了<code>ThreadLocal</code>实例和<code>value</code>)，导致Entry内存泄漏</li><li><strong>ThreadLocalMap中的key使用了强引用，是无法完全避免内存泄漏的。</strong></li></ul></li></ul><h4 id="6-2-3为什么使用弱引用"><a href="#6-2-3为什么使用弱引用" class="headerlink" title="6.2.3为什么使用弱引用"></a>6.2.3为什么使用弱引用</h4><ul><li><strong>在<code>ThreadLocalMap</code>中的<code>set/getEntry</code>方法中，会对<code>key</code>为<code>null</code> (也即是<code>ThreadLocal</code>为<code>null</code> )进行判</strong><br><strong>断，如果为<code>null</code>的话，那么是会对<code>value</code>置为<code>null</code>的</strong></li><li>意味着使用完<code>ThreadLocal</code> ，<code>CurrentThread</code>依然运行的前提下，就算忘记调用<code>remove</code>方法，<strong>弱引比</strong><br><strong>强引用可以多一层保障</strong>，弱引用的ThreadLocal会被回收，<strong>对应的value在下一次<code>ThreadLocalMap</code>调用<code>set get remove</code>中的任一方法的时候会被清除，从而避免内存泄漏。</strong></li></ul><h4 id="6-2-4出现内存泄漏的真实原因"><a href="#6-2-4出现内存泄漏的真实原因" class="headerlink" title="6.2.4出现内存泄漏的真实原因"></a>6.2.4出现内存泄漏的真实原因</h4><ul><li><strong>内存泄漏的发生跟<code>ThreadLocalMap</code>中的<code>key</code>使用哪种类型引用是没有关系的</strong></li><li>在以上两种内存泄漏的情况中，都有两个前提:<ul><li>没有手动删除这个<code>Entry</code><ul><li><strong>只要在使用完<code>ThreadLocal</code>，调用其<code>remove</code>方法删除对应的<code>Entry</code>，就能避免内存泄漏</strong></li></ul></li><li><code>CurrentThread</code>依然运行<ul><li><code>ThreadLocalMap</code>是<code>Thread</code>的一个属性，被当前线程所引用，所以它的生命周期跟<code>Thread</code>样长。</li><li><strong>那么在使用完<code>ThreadLocal</code>的使用，如果当前<code>Thread</code>也随之执行结束，</strong><code>ThreadLocalMap</code>自然也会被GC回收，<strong>从根源上避免了内存泄漏。</strong>【不好控制，使用线程池的时候，线程结束是不会销毁的】</li></ul></li></ul></li><li>综上，<code>ThreadLocal</code>内存泄漏的根源是：ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏。</li></ul><h3 id="6-3-hash冲突的解决"><a href="#6-3-hash冲突的解决" class="headerlink" title="6.3 hash冲突的解决"></a>6.3 hash冲突的解决</h3><ul><li><p>hash冲突的解决是Map中的一个重要内容。我们以hash冲突的解决为线索,来研究一下ThreadLocalMap的<br>核心源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 设置当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value 将要保存在当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">pub1ic <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != nu11)&#123;</span><br><span class="line">            <span class="comment">//threadLocalMap的set方法</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            createMap(t, value);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadlocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t,T firstValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//threadLocalMap构造方法</span></span><br><span class="line">        t.threadlocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-3-1构造方法"><a href="#6-3-1构造方法" class="headerlink" title="6.3.1构造方法"></a>6.3.1构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * firstKey : 本ThreadLocal实例(this)</span></span><br><span class="line"><span class="comment"> * firstValue :要保存的线程本地变量</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        <span class="comment">//初始化table</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="comment">//计算索引(重点代码)</span></span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//设置值</span></span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//设置阈值</span></span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的索引，然后存储到table中，并设置size和threshold</p></li><li><p>重点分析: <code>int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</code></p><ul><li><p><code>firstKey.threadLocalHashCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//AtomicInteger是一个提供原子操作的Integer类，通过线程安全的方式操作加减, 适合高并发情况下的使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">   <span class="comment">//特殊的hash值    </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br></pre></td></tr></table></figure><p>这里定义了一个AtomicInteger类型，每次获取当前值并加上HASH_INCREMENT，这个值跟斐波那契数列(黄金分割数)有关，其主要目的就是为了让哈希码能均匀的分布在2的n次方的数组里,也就是Entry[] table中，这样做可以尽星避免hash冲突。</p></li><li><p><code>(INITIAL_CAPACITY - 1)</code></p><ul><li>计算hash的时候里面采用了<code>hashCode &amp; (size - 1)</code>的算法，这相当于取模运算<code>hashCode % size</code>的一个更高效的实现。正是因为这种算法，我们要求size必须是2的整次幂，这也能保证在索引不越界的前提下,使得hash发生冲突的次数减小。</li></ul></li></ul></li></ul><h4 id="6-3-2set方法"><a href="#6-3-2set方法" class="headerlink" title="6.3.2set方法"></a>6.3.2set方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">     Entry[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line">     <span class="comment">//计算索引(重点代码，刚才分析过了)</span></span><br><span class="line">     <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">     <span class="comment">//使用线性探测法查找元素(重点代码)</span></span><br><span class="line">     <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">          e != <span class="keyword">null</span>;</span><br><span class="line">          e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">         ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//Threadlocal对应的key存在，直接覆盖之前的值</span></span><br><span class="line">         <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">             e.value = value;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">// key为null 但是值不为null 说明之前的ThreadLocal对象已经被回收了，</span></span><br><span class="line">        <span class="comment">// 当前数组中的Entry是一个陈旧(stale)的元素</span></span><br><span class="line">         <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">             replaceStaleEntry(key, value, i);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line"> <span class="comment">//Threadlocal对应的key不存在并且没有找到陈旧的元素，则在空元素的位置创建一个新的Entry</span></span><br><span class="line">     tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">     <span class="keyword">int</span> sz = ++size;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * cleanSomeSlots用于清除那些e.get()==null的元素，</span></span><br><span class="line"><span class="comment">       * 这种数据key关联的对象已经被回收，所以这个Entry(table[index])可以被置null</span></span><br><span class="line"><span class="comment">       * 如果没有清除任何entry ,并且当前使用量达到了负载因子所定义(长度的2/3)。那么进行rehash(执行一次全表的扫描清理工作)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">     <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">         rehash();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *获取环形数组的下一个索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span>&lt; len)?i+<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>代码执行流程</p><ul><li>首先还是根据key计算出索引i，然后查找i位置上的Entry</li><li>若是Entry已经存在并且key等于传入的key，那么这时候直接给这个Entry赋新的value值</li><li>若是Entry存在，但是key为null，则调用<code>replaceStaleEntry</code>来更换这个key为空的Entry</li><li>不断循环检测，直到遇到为null的地方，这时候要是还没在循环过程中return，则在空元素的位置创建一个新的Entry，并且插入同时size增加1。</li><li>最后调用cleanSomeSlots，清理key为null的Entry，最后返回是否清理了Entry，接下来再判断sz是否&gt;=<br>threshold达到了rehash的条件，达到的话就会调用rehash函数执行一次全表的扫描清理。</li></ul></li><li><p>重点分析: <strong>ThreadLocalMap使用线性探测法来解决哈希冲突的</strong></p><ul><li>该方法一次探测下一个地址，直到有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。</li><li>举个例子<ul><li>假设当前table长度为16 ,也就是说如果计算出来key的hash值为14，如果table[14]上已经有值，并且其key与当前key不一致，那么就发生了hash冲突，这个时候将14加1得到15 ,取table[15]进行判断，这个时候如果还是冲突会回到0，取table[0]，以此类推,直到可以插入。</li><li>可以把Entry[] table看成一个环形数组</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      ThreadLocal方案 ThreadLocal源码分析 ThreadLocalMap源码分析
    
    </summary>
    
    
      <category term="Java基础" scheme="http://goldcarpenter.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ThreadLocal" scheme="http://goldcarpenter.github.io/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="http://goldcarpenter.github.io/2019/11/19/SpringMVC_Part3/"/>
    <id>http://goldcarpenter.github.io/2019/11/19/SpringMVC_Part3/</id>
    <published>2019-11-18T16:00:00.000Z</published>
    <updated>2020-06-17T08:03:16.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-Spring返回模型数据和结果视图"><a href="#4-Spring返回模型数据和结果视图" class="headerlink" title="4.Spring返回模型数据和结果视图"></a>4.Spring返回模型数据和结果视图</h1><ul><li><p>处理模型数据方式一：<strong>将方法的返回值设置为<code>ModelAndView</code></strong></p></li><li><p>处理模型数据方式二：<strong>方法的返回值仍是<code>String</code>类型，在方法的入参中传入<code>Map</code> <code>Model</code>或者<code>ModelMap</code></strong></p></li><li><p>不管将处理器方法的返回值设置为<code>ModelAndView</code>还是在方法的入参中传入<code>Map</code> <code>Model</code>或者<code>ModelMap</code>，<code>SpringMVC</code>都会转换为一个<code>ModelAndView</code>对象</p><p><img src="1584758167073.png" alt="1584758167073"></p></li></ul><h2 id="4-1-返回字符串类型"><a href="#4-1-返回字符串类型" class="headerlink" title="4.1.返回字符串类型"></a>4.1.返回字符串类型</h2><h3 id="4-1-1-直接返回目标jsp文件名"><a href="#4-1-1-直接返回目标jsp文件名" class="headerlink" title="4.1.1.直接返回目标jsp文件名"></a>4.1.1.直接返回目标jsp文件名</h3><ul><li><p><code>controller</code>方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址</p><ul><li><p><code>index.jsp</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="yyx/hello"&gt;返回字符串&lt;/a&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>Controlller.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"returnfunction"</span>,<span class="string">"string"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>success.jsp</code></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;入门成功&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">sessionScope.<span class="keyword">return</span>:  $&#123;sessionScope.returnfunction&#125;&lt;br&gt;</span><br><span class="line">requestScope.<span class="keyword">return</span>:  $&#123;requestScope.returnfunction&#125;&lt;br&gt;</span><br></pre></td></tr></table></figure><p><img src="1578536963748.png" alt="1578536963748"></p></li></ul></li></ul><p><img src="1578537238298.png" alt="1578537238298"></p><h3 id="4-1-2-返回使用forward转发"><a href="#4-1-2-返回使用forward转发" class="headerlink" title="4.1.2.返回使用forward转发"></a>4.1.2.返回使用<code>forward</code>转发</h3><ul><li>相当于<code>Request.getRequestDispatcher (&quot;url&quot;).forward (request, response)</code></li><li>使用请求转发，既可以转发到<code>jsp</code>,也可以转发到其他的控制器方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"returnfunction"</span>,<span class="string">"string"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"forward:/WEB-INF/pages/success.jsp"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1578538119827.png" alt="1578538119827"></p><p><img src="1578540927192.png" alt="1578540927192"></p><h3 id="4-1-3-返回使用Redirect重定向"><a href="#4-1-3-返回使用Redirect重定向" class="headerlink" title="4.1.3.返回使用Redirect重定向"></a>4.1.3.返回使用<code>Redirect</code>重定向</h3><ul><li><code>contrller</code>方法提供了一个<code>String</code>类型返回值之后，需要在返回值里使用:<code>redirect:</code></li><li>相当于<code>Response.sendRedirect(url)</code></li><li>重定向到<code>jsp</code>页面，则<code>jsp</code>页面不能写在<code>WEB-INF</code>目录中，否则无法找到</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"returnfunction"</span>,<span class="string">"string"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/index.jsp"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-返回void类型"><a href="#4-2-返回void类型" class="headerlink" title="4.2.返回void类型"></a>4.2.返回void类型</h2><ul><li>将上例中方法返回值修改为<code>void</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">model.addAttribute(<span class="string">"returnfunction"</span>,<span class="string">"string"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行程序报<code>404</code>的异常，默认查找页面没有找到。</li></ul><p><img src="1578537385549.png" alt="1578537385549"></p><ul><li><strong>会有默认请求路径：<code>方法路径.jsp</code></strong>——<strong>请求转发或者重定向跳转到指定的页面</strong></li><li>如果<strong>就想返回void</strong>，见下</li></ul><h3 id="4-2-1-方法一：Request使用请求转发"><a href="#4-2-1-方法一：Request使用请求转发" class="headerlink" title="4.2.1.方法一：Request使用请求转发"></a>4.2.1.方法一：<code>Request</code>使用请求转发</h3><ul><li>请求转发是一次请求 不用编写项目名称 但不会调用视图解析器 必须带<code>.jsp</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Model model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    request.getRequestDispatcher(<span class="string">"/WEB-INF/pages/success.jsp"</span>).forward(request,response);</span><br><span class="line">    model.addAttribute(<span class="string">"returnfunction"</span>,<span class="string">"string"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1578538119827.png" alt="1578538119827"></p><p><img src="1578538042126.png" alt="1578538042126"></p><h3 id="4-2-2-方法二：Response页面重定向"><a href="#4-2-2-方法二：Response页面重定向" class="headerlink" title="4.2.2.方法二：Response页面重定向"></a>4.2.2.方法二：<code>Response</code>页面重定向</h3><ul><li>重定向是两次请求 要编写项目名称 WEB-INF目录下文件无法访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Model model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">   Response.sendRedirect(request.getContextPath()+<span class="string">"/index.jsp"</span>);</span><br><span class="line">   model.addAttribute(<span class="string">"returnfunction"</span>,<span class="string">"string"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-3-方法三：输出流直接响应"><a href="#4-2-3-方法三：输出流直接响应" class="headerlink" title="4.2.3.方法三：输出流直接响应"></a>4.2.3.方法三：输出流直接响应</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">    response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">    response.getWriter().println(<span class="string">"早上好"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1578538633002.png" alt="1578538633002"></p><h2 id="4-3-返回ModelAndView类型【常用】"><a href="#4-3-返回ModelAndView类型【常用】" class="headerlink" title="4.3.返回ModelAndView类型【常用】"></a>4.3.返回ModelAndView类型【常用】</h2><ul><li><code>ModelAndView</code>是SpringMVC为我们提供的一个对象，其既包含视图信息，也包含模型数据信息<ul><li><code>SpringMVC</code>会把<code>ModelAndView</code>的<code>model</code>中数据放入到<code>request</code>域对象中</li><li>添加模型数据：<code>MoelAndView addObject(String attributeName, Object attributeValue)</code></li><li>设置视图：<code>void setViewName(String viewName)</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    modelAndView.addObject(<span class="string">"returnfunction"</span>,<span class="string">"ModelAndView"</span>);</span><br><span class="line">    modelAndView.setViewName(<span class="string">"success"</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1578539195616.png" alt="1578539195616"></p><h2 id="4-4-返回-ResponseBody的json数据"><a href="#4-4-返回-ResponseBody的json数据" class="headerlink" title="4.4.返回@ResponseBody的json数据"></a>4.4.返回<code>@ResponseBody</code>的<code>json</code>数据</h2><h3 id="4-4-1-防止静态资源被拦截"><a href="#4-4-1-防止静态资源被拦截" class="headerlink" title="4.4.1.防止静态资源被拦截"></a>4.4.1.防止静态资源被拦截</h3><ul><li><p><code>DispatcherServlet</code>会拦截到所有的资源，导致静态资源（<code>images</code>、 <code>css</code>，<code>js</code>） 会被拦截到，当成一个普通请求处理，因找不到对应处理器将导致错误，从而不能被使用。</p></li><li><p>解决问题就是需要配置静态资源不进行拦截，在<code>springmvc.xml</code>配置文件添加如下配置</p><ul><li><code>springmvc.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/js/**"</span> <span class="attr">location</span>=<span class="string">"/js/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/css/**"</span> <span class="attr">location</span>=<span class="string">"/css/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/images/**"</span> <span class="attr">location</span>=<span class="string">"/images/"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>在SpringMVC上下文中定义一个<code>DefaultServletHttpRequestHandler</code>,它会对进入<code>DispatcherServlet</code>的请求进行筛查，如果发现是没有经过映射的请求，就将该请求交由<code>WEB</code>应用服务器默认的<code>Servlet</code>处理，如果不是静态资源的请求，才由<code>DispatcherServlet</code>继续处理</p></li><li><p>一般WEB应用服务器默认的Servlet的名称都是default。若所使用的<code>WEB</code>服务器的默认<code>Servlet</code>名称不是<code>default</code>，则需要通过<code>default-servlet-name</code>属性显式指定</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>index.jsp</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> isELIgnored=<span class="string">"false"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">        &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            $(function () &#123;</span><br><span class="line">                $(<span class="string">"#btn"</span>).click(<span class="function">function <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  # 此时此处的按键将会有响应</span><br><span class="line">                  alert(<span class="string">"hello btn"</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;入门程序&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    &lt;button id="btn"&gt;发送ajax请求&lt;/button&gt;</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-4-2-使用json请求"><a href="#4-4-2-使用json请求" class="headerlink" title="4.4.2.使用json请求"></a>4.4.2.使用json请求</h3><ul><li><p>使用<code>@RequestBody</code>注解把json的字符串转换成<code>JavaBean</code>的对象</p></li><li><p>导包</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>index.jsp</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> isELIgnored=<span class="string">"false"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        $(function () &#123;</span><br><span class="line">            $(<span class="string">"#btn"</span>).click(function() &#123;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    <span class="comment">// 编写json格式 设置属性和值</span></span><br><span class="line">                    url:<span class="string">"yyx/hello"</span>,</span><br><span class="line">                    contentType: <span class="string">"application/json; charset=UTF-8"</span> ,</span><br><span class="line">                    data: <span class="string">'&#123;"uname": "yyx", "age" :"123"&#125;'</span>,</span><br><span class="line">                    dataType:<span class="string">"json"</span>,</span><br><span class="line">                    type: <span class="string">"post"</span>,</span><br><span class="line">                    success: function(data)&#123;</span><br><span class="line">                        <span class="comment">// data : 服务器端响应的json数据 进行解析</span></span><br><span class="line">                        alert(data);</span><br><span class="line">                        alert(data.age);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;入门程序&lt;/h3&gt;</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">        &lt;button id="btn"&gt;发送ajax请求&lt;/button&gt;</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(@RequestBody String body)</span></span>&#123;</span><br><span class="line">    <span class="comment">// &#123;"uname": "yyx", "age" :123&#125;</span></span><br><span class="line">    System.out.println(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1578556292682.png" alt="1578556292682"></p><h3 id="4-4-3-使用-ResponseBody响应json"><a href="#4-4-3-使用-ResponseBody响应json" class="headerlink" title="4.4.3.使用@ResponseBody响应json"></a>4.4.3.使用<code>@ResponseBody</code>响应<code>json</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">User <span class="title">sayHello</span><span class="params">(@RequestBody User user)</span></span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1578556235223.png" alt="1578556235223"></p><p><img src="1578556135298.png" alt="1578556135298"></p><h3 id="4-4-4-原理"><a href="#4-4-4-原理" class="headerlink" title="4.4.4.原理"></a>4.4.4.原理</h3><ul><li><p><code>HttpMessageConverter&lt;T&gt;</code>是 Spring3.0 新添加的一个<strong>接口</strong>，负责将<strong>请求信息转换为一个对象</strong>（类型为 T）或将<strong>对象（ 类型为 T）输出为响应信息</strong></p><ul><li>使用<code>@RequestBody / @ResponseBody</code>对处理方法进行标注</li><li>使用<code>HttpEntity&lt;T&gt; / ResponseEntity&lt;T&gt;</code>作为处理方法的入参或返回值</li></ul><p><img src="1584847753988.png" alt="1584847753988"></p></li><li><p><code>HttpMessageConverter&lt;T&gt;</code>接口实现类</p><p><img src="1584847800708.png" alt="1584847800708"></p></li><li><p><code>DispatcherServlet</code>默认装配<code>RequestMappingHandlerAdapter</code>，而<code>RequestMappingHandlerAdapter</code> 默认装配如下<code>HttpMessageConverter</code></p><p><img src="1584847886253.png" alt="1584847886253"></p><blockquote><p>加入 jackson jar 包后 新增[6]</p></blockquote></li><li><p>原理</p><ul><li>Spring 首先根据请求头或响应头的 Accept 属性选择匹配的<code>HttpMessageConverter</code>,</li><li>进而根据参数类型或泛型类型的过滤得到匹配的<code>HttpMessageConverter</code>, 若找不到可用的<code>HttpMessageConverter</code>将报错</li></ul><p><img src="1584847993959.png" alt="1584847993959"></p></li></ul><h2 id="自定义视图"><a href="#自定义视图" class="headerlink" title="自定义视图"></a>自定义视图</h2><ul><li><p>常用的视图解析器实现类</p><p><img src="1584777827863.png" alt="1584777827863"></p></li><li><p>自定义过程</p><ul><li><p>编写自定时视图类并实现View接口</p></li><li><p>将<code>@Component</code>标致在只定义类上</p></li><li><p>使用<code>BeanNameViewResolver</code>作为视图解析器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置视图BeanNameViewResolver 解析器:使用视图的名字来解析视图--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过order属性来定义视图解析器的优先级，order值越小优先级越高--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>= <span class="string">"org. springframework.web.servlet.view.BeanNameViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>= <span class="string">"order"</span> <span class="attr">value</span>= <span class="string">"100"</span>&gt;</span><span class="tag">&lt;/ <span class="attr">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      返回模型数据和结果视图 拦截器 异常处理
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="SpringMVC" scheme="http://goldcarpenter.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="http://goldcarpenter.github.io/2019/11/16/SpringMVC_Part4/"/>
    <id>http://goldcarpenter.github.io/2019/11/16/SpringMVC_Part4/</id>
    <published>2019-11-15T16:00:00.000Z</published>
    <updated>2020-06-17T08:02:53.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-SpringMVC上传文件"><a href="#5-SpringMVC上传文件" class="headerlink" title="5.SpringMVC上传文件"></a>5.SpringMVC上传文件</h1><h2 id="5-1-SpringMVC上传文件概念"><a href="#5-1-SpringMVC上传文件概念" class="headerlink" title="5.1.SpringMVC上传文件概念"></a>5.1.SpringMVC上传文件概念</h2><ul><li><p>文件上传要求</p><ul><li><p><code>form</code>表单的<code>enctype</code>取值必须是：<code>multipart/form-data</code></p><ul><li><code>multipart/form-data</code>：表单请求正文的类型</li></ul></li><li><p><code>method</code>属性的取值必须是<code>Post</code></p></li><li><p>提供一个文件选择域<code>&lt;input type=&quot;file&quot;/&gt;</code></p></li></ul></li><li><p>文件上传原理分析</p><ul><li>当<code>form</code>表单的<code>enctype</code>取值不是默认值后，<code>request.getParameter()</code>将失效</li><li><code>enctype=&quot;application/x-ww-form-urlencoded&quot;</code>时，form 表单的正文内容是:<code>key=value &amp;key=value &amp;key=value</code></li><li>当<code>form</code>表单的<code>enctype</code>取值为<code>Mutilpart/form-data</code>时，请求正文内容就变成:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">------WebKitFormBoundaryYMJEn4NC2H3fo8Ls</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;picname&quot;</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryYMJEn4NC2H3fo8Ls</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;uploadFile&quot;; filename&#x3D;&quot;exam.sql&quot;</span><br><span class="line">Content-Type: application&#x2F;octet-stream</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">select * from emp;</span><br><span class="line">select * from dept;</span><br><span class="line">select * from salgrade;</span><br><span class="line">*&#x2F;</span><br><span class="line">------WebKitFormBoundaryYMJEn4NC2H3fo8Ls--</span><br></pre></td></tr></table></figure></li><li><p>依赖的<code>jar</code>包</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Spring MVC 为文件上传提供了直接的支持，这种支持是通过即插即用的 MultipartResolver 实现的。</li><li>Spring 用 Jakarta Commons FileUpload 技术实现了一个 MultipartResolver 实现类<code>CommonsMultipartResovler</code></li></ul><h2 id="5-2-SpringMVC上传文件案例"><a href="#5-2-SpringMVC上传文件案例" class="headerlink" title="5.2.SpringMVC上传文件案例"></a>5.2.SpringMVC上传文件案例</h2><p><img src="upfile.bmp" alt=""></p><ul><li>编写按键</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"yyx/upfile"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"picname"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"uploadFile"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"upload"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写控制器方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"upfile"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upFile</span><span class="params">(String picname, MultipartFile uploadFile, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//      1.设置文件名</span></span><br><span class="line">        String fileName = <span class="string">""</span>;</span><br><span class="line">        String uploadFilename = uploadFile.getOriginalFilename();</span><br><span class="line">        fileName = uploadFilename;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      2. 获取文件路径</span></span><br><span class="line">        String context = request.getSession().getServletContext().getRealPath(<span class="string">"/uploads"</span>);</span><br><span class="line">        File file = <span class="keyword">new</span> File(context);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())</span><br><span class="line">        &#123;</span><br><span class="line">            file.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 上传</span></span><br><span class="line">        uploadFile.transferTo(<span class="keyword">new</span> File(file, fileName));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>配置文件解析器</p><ul><li><p><code>Spring MVC</code>上下文中默认没有装配<code>MultipartResovler</code>，因此默认情况下不能处理文件的上传工作，如果想使用 Spring 的文件上传功能，需现在上下文中配置<code>MultipartResolver</code></p></li><li><p><strong>文件上传的解析器id是固定的，不能起别的名称，否则无法实现请求参数的绑定。(不光是文件， 其他字段也将无法绑定)</strong></p></li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxInMemorySize"</span> <span class="attr">value</span>=<span class="string">"5000000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="6-SpringMVC异常处理"><a href="#6-SpringMVC异常处理" class="headerlink" title="6.SpringMVC异常处理"></a>6.SpringMVC异常处理</h1><h2 id="6-1-SpringMVC-异常处理概念"><a href="#6-1-SpringMVC-异常处理概念" class="headerlink" title="6.1.SpringMVC 异常处理概念"></a>6.1.SpringMVC 异常处理概念</h2><ul><li>系统的<code>dao</code>，<code>service</code>，<code>controller</code>出现都通过<code>throws Exception</code>向上抛出，最后由<code>SpringMVC</code>前端控制器交由<strong>异常处理器</strong>进行异常处理</li></ul><p><img src="%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.bmp" alt=""></p><ul><li><p><code>Spring MVC</code>通过<code>HandlerExceptionResolver</code>接口处理程序的异常，包括<code>Handler</code>映射、数据绑定以及目标方法执行时发生的异常</p></li><li><p><code>SpringMVC</code>提供的<code>HandlerExceptionResolver</code>的实现类</p><ul><li><p><code>ExceptionHandlerExceptionResolver</code></p></li><li><p><code>ResponseStatusExceptionResolver</code></p></li><li><p><code>DefaultHandlerExceptionResolver</code></p></li><li><p><code>SimpleMappingExceptionResolver</code></p></li></ul></li><li><p>使用了<code>&lt;mvc:annotation-driven/&gt;</code>配置<code>DispatcherServlet</code>默认装配的<code>HandlerExceptionResolver</code></p><p><img src="1584868554434.png" alt="1584868554434"></p></li></ul><h3 id="6-1-1-ExceptionHandlerExceptionResolver"><a href="#6-1-1-ExceptionHandlerExceptionResolver" class="headerlink" title="6.1.1 ExceptionHandlerExceptionResolver"></a>6.1.1 ExceptionHandlerExceptionResolver</h3><ul><li><p>主要处理<code>Handler</code>中用<code>@ExceptionHandler</code>注解定义的 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1.在<span class="doctag">@ExceptionHandler</span>方法的入参中可以加入Exception类型的参数，该参数即对应发生的异常对象</span></span><br><span class="line"><span class="comment">    * 2.<span class="doctag">@ExceptionHandler</span>方法的入参中不能传入Map. 若希望把异常信息传导页面上,需要使用ModelAndView 作为返回值</span></span><br><span class="line"><span class="comment">    * 3.<span class="doctag">@ExceptionHandler</span>方法标记的异常有优先级的问题</span></span><br><span class="line"><span class="comment">    * 4.<span class="doctag">@ControllerAdvice</span>: 如果在当前Handler中找不到<span class="doctag">@ExceptionHandler</span>方法来出来当前方法出现的异常，则将去<span class="doctag">@ControllerAdvice</span>标记的类中查找<span class="doctag">@ExceptionHandler</span>标记的方法来处理异常。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(&#123;ArithmeticException<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ModelAndView</span> <span class="title">handleArithmeticException</span>(<span class="title">Exception</span> <span class="title">ex</span>)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"出异常了:"</span>+ ex);</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>);</span><br><span class="line">    mv.addobject(<span class="string">"exception"</span>, ex);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ExceptionHandlerMethodResolver</code>内部若找不到<code>@ExceptionHandler</code>注解的话，会找<code>@ControllerAdvice</code>中的<code>@ExceptionHandler</code>注解方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleException</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>( &#123;ArithmeticException. <span class="class"><span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ModelAndView</span> <span class="title">handleArithmeticException</span>( <span class="title">Exception</span> <span class="title">ex</span>)</span>&#123;</span><br><span class="line">        System.out. println(<span class="string">"----&gt;出异常了:"</span> + ex);</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>);</span><br><span class="line">        mv.add0bject(<span class="string">"exception"</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-1-2-ResponseStatusExceptionResolver"><a href="#6-1-2-ResponseStatusExceptionResolver" class="headerlink" title="6.1.2 ResponseStatusExceptionResolver"></a>6.1.2 ResponseStatusExceptionResolver</h3><ul><li><p>在异常及异常父类中找到<code>@ResponseStatus</code>注解，然后使用这个注解的属性进行处理。</p></li><li><p>定义一个<code>@ResponseStatus</code>注解修饰的异常类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseStatus</span>(value=HttpStatus.FORBIDDEN, reason= <span class="string">"用户名和密码不匹配! "</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserNameNotMatchPasswordException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="number">1</span>ong serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于触发的异常<code>UnauthorizedException</code>带有<code>@ResponseStatus</code>注解。因此会被<code>ResponseStatusExceptionResolver</code>解析到。</p></li><li><p>最后响应给客户端</p><p><img src="1584869462518.png" alt="1584869462518"></p></li></ul><h3 id="6-1-3DefaultHandlerExceptionResolver"><a href="#6-1-3DefaultHandlerExceptionResolver" class="headerlink" title="6.1.3DefaultHandlerExceptionResolver"></a>6.1.3DefaultHandlerExceptionResolver</h3><ul><li>对一些特殊的异常进行处理<ul><li><code>NoSuchRequestHandlingMethodException</code></li><li><code>HttpReques tMethodNotSupportedException</code></li><li><code>HttpMediaTypeNotSupportedException</code> </li><li><code>HttpMediaTypeNotAcceptableException</code>等</li></ul></li></ul><h3 id="6-1-4-SimpleMappingExceptionResolver"><a href="#6-1-4-SimpleMappingExceptionResolver" class="headerlink" title="6.1.4.SimpleMappingExceptionResolver"></a>6.1.4.SimpleMappingExceptionResolver</h3><ul><li><p>如果希望对所有异常进行统一处理，可以使用 SimpleMappingExceptionResolver，它将异常类名映射为视图名，即发生异常时使用对应的视图报告异常</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleMappingExceptionResolver"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>= <span class="string">"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>= <span class="string">"exceptionMappings"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"java.lang.ArithmeticException"</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="6-2-SpringMVC-异常处理配置"><a href="#6-2-SpringMVC-异常处理配置" class="headerlink" title="6.2.SpringMVC 异常处理配置"></a>6.2.SpringMVC 异常处理配置</h2><ol><li>编写自定义异常类(做提示信息的)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyError</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyError</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//set get function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>编写异常处理器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerExceptionResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> </span>&#123;</span><br><span class="line">        Exception exception = <span class="keyword">null</span>;</span><br><span class="line">        MyError myError = <span class="keyword">null</span>;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">//如果抛出的是系统自定义异常则直接转换</span></span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> MyError)</span><br><span class="line">        &#123;</span><br><span class="line">            myError = (MyError)e;</span><br><span class="line">            modelAndView.addObject(<span class="string">"message"</span>,myError.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果抛出的不是系统自定义异常则重新构造一个系统错误异常。</span></span><br><span class="line">            exception = <span class="keyword">new</span> Exception (<span class="string">"系统错误，请与系统管理员联系! "</span>);</span><br><span class="line">            modelAndView.addObject(<span class="string">"message"</span>,exception.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        modelAndView.setViewName(<span class="string">"fail"</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置异常处理器(跳转到提示页面)</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exceptionResolver"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.exception.ExceptionResolver"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><img src="1578578156330.png" alt="1578578156330"></p><p><img src="1578578182783.png" alt="1578578182783"></p><h1 id="7-SpringMVC-拦截器"><a href="#7-SpringMVC-拦截器" class="headerlink" title="7.SpringMVC 拦截器"></a>7.SpringMVC 拦截器</h1><h2 id="7-1-SpringMVC-拦截器概念"><a href="#7-1-SpringMVC-拦截器概念" class="headerlink" title="7.1.SpringMVC 拦截器概念"></a>7.1.SpringMVC 拦截器概念</h2><ul><li><code>SpringMVC</code>的处理器拦截器类似于<code>Servlet</code>开发中的过滤器<code>Filter</code>,用于对处理器进行预处理和后处理</li><li>用户可以自己定义一些拦截器来实现特定的功能。</li><li>拦截器链：将拦截器按一定的顺字联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。</li><li>过滤器/拦截器区别<ul><li>过滤器<ul><li>过滤器是<code>servlet</code>规范中的一部分，任何<code>java web</code>工程都可以使用</li><li>过滤器在<code>url-pattern</code>中配置了<code>/*</code>之后，可以对所有要访问的资源拦截</li></ul></li><li>拦截器<ul><li>拦截器它是只会拦截访问的控制器方法，如果访问的是<code>jsp</code>，<code>html</code>，<code>css</code>,<code>image</code>或者<code>js</code>是不会进行拦载的</li><li>拦截器是<code>SpringMVC</code>框架自己的，只有使用了<code>SpringMVC</code>框架的工程才能用。</li></ul></li></ul></li><li>它也是AOP思想的具体应用。</li><li>想自定义拦截器，要求必须实现<code>HandlerInterceptor</code>接口</li></ul><h2 id="7-2-SpringMVC-拦截器配置"><a href="#7-2-SpringMVC-拦截器配置" class="headerlink" title="7.2.SpringMVC 拦截器配置"></a>7.2.SpringMVC 拦截器配置</h2><ol><li>自定义拦截器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 预处理，controller方法执行前</span></span><br><span class="line">    <span class="comment">// return true 放行，执行下一个拦截器，如果没有，执行controller中的方法</span></span><br><span class="line">    <span class="comment">// return false 不放行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"preHandle~~"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后处理方法，controller方法执行后，***.jsp执行之前</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postHandle~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ***.jsp页面执行后，该方法会执行 用于释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"afterCompletion~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>Springmvc.xml</code>配置拦截器</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        包含某些路径方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/yyx/**"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mvc:exclude-mapping path=""/&gt;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myHandlerInterceptor"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.handler.MyHandlerInterceptor"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="1578582999074.png" alt="1578582999074"></p><h2 id="7-3-SpringMVC-拦截器相关细节"><a href="#7-3-SpringMVC-拦截器相关细节" class="headerlink" title="7.3.SpringMVC 拦截器相关细节"></a>7.3.SpringMVC 拦截器相关细节</h2><ul><li><p>拦截器的放行</p><ul><li>如果有下一个拦截器就执行下一个，如果该拦截器处于拦截器链的最后一个， 则执行控制器中的方法。</li></ul></li><li><p>前置处理：</p><ul><li>如何调用<ul><li>按拦截器定义顺序调用</li></ul></li><li>何时调用<ul><li>只要配置了都会调用</li></ul></li><li>有什么用:<ul><li>如果程序员决定该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去进行处理，则返回true</li><li>如果程序员决定不需要再调用其他的组件去处理请求，则返回false。</li></ul></li></ul></li><li><p>后置处理</p><ul><li>如何调用：按拦截器定义<strong>逆序调用</strong></li><li>何时调用：在拦截器链内所有拦截器返成功调用</li><li>有什么用<ul><li>在业务处理器处理完请求后，但是<code>DispatcherServlet</code>向客户端返回响应前被调用，在该方法中对用户请求request进行处理</li></ul></li></ul></li><li><p>AfterCompletion</p><ul><li>如何调用：按拦截器定义<strong>逆序调用</strong></li><li>何时调用：<strong>只有preHandle返回true才调用</strong></li><li>有什么用<ul><li>在DispatcherServlet完全处理完请求后被调用，<strong>进行一些资源清理的操作</strong></li></ul></li></ul></li><li><p>多个拦截器的执行顺序</p></li></ul><p><img src="1578583878348.png" alt="1578583878348"></p><h1 id="Spring-MVC-与-Spring"><a href="#Spring-MVC-与-Spring" class="headerlink" title="Spring MVC 与    Spring"></a>Spring MVC 与    Spring</h1><ul><li><p>问题：需要进行<code>Spring</code>整合<code>SpringMVC</code>吗/是否还需要再加入<code>Spring</code>的<code>IoC</code>容器/是否需要再<code>web. xml</code>文件中配置启动<code>Spring IoC</code>容器的<code>ContextLoaderListener</code>?</p><ul><li>需要：通常情况下，类似于数据源，事务，整合其他框架都是放在<code>Spring</code>的配置文件中(而不是放在<code>SpringMVC</code>的配置文件中)。实际上放入Spring配置文件对应的<code>IoC</code>容器中的还有<code>Service</code>和<code>Dao</code></li></ul></li><li><p>问题：若<code>Spring</code>的<code>IOC</code>容器和<code>SpringMVC</code>的<code>IoC</code>容器扫描的包有重合的部分，就会导致有的<code>bean</code>会被创建2次。</p><ul><li><p>Spring 的 IOC 容器不应该扫描 SpringMVC 中的 bean, 对应的 SpringMVC 的 IOC 容器不应该扫描 Spring 中的 bean</p></li><li><p>【方案一】使Spring的IOC容器扫描的包和SpringMVC的IOC容器扫描的包没有重合的部分.</p></li><li><p>【方案二】使用exclude- filter和include-filter子节点来规定只能扫描的注解</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.atguigu.springmvc"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>= <span class="string">"org.springframework. stereotype.Controller"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.web.bind.annotation.controllerAdvice"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>多个 Spring IOC 容器之间可以设置为父子关系， 以实现良好的解耦。</p><ul><li><strong>Spring MVC WEB 层容器可作为 “业务层” Spring 容器的子容器：即 WEB 层容器可以引用业务层 容器的 Bean，而业务层容器却访问不到 WEB 层 容器的 Bean</strong></li></ul></li></ul><p>100.说一下 spring mvc 运行流程？</p><p>101.spring mvc 有哪些组件？</p><p>102.@RequestMapping 的作用是什么？</p><p>103.@Autowired 的作用是什么？</p>]]></content>
    
    <summary type="html">
    
      上传文件 拦截器 异常处理
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="SpringMVC" scheme="http://goldcarpenter.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="http://goldcarpenter.github.io/2019/11/13/SpringMVC_Part2/"/>
    <id>http://goldcarpenter.github.io/2019/11/13/SpringMVC_Part2/</id>
    <published>2019-11-12T16:00:00.000Z</published>
    <updated>2020-06-17T08:01:28.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-常用注解"><a href="#3-常用注解" class="headerlink" title="3. 常用注解"></a>3. 常用注解</h1><h2 id="3-1-RequestParam-重要"><a href="#3-1-RequestParam-重要" class="headerlink" title="3.1.@RequestParam[重要]"></a>3.1.<code>@RequestParam</code>[重要]</h2><ul><li>原因：在绑定机制中，要求<strong>参数名称</strong>必须和控制器中<strong>方法的形参名称</strong>保持一致。</li><li>作用：把<strong>请求的名称参数给</strong>控制器中的<strong>形参赋值</strong>。</li><li>属性<ul><li><code>value/name</code>：请求参数的名称</li><li><code>required</code>：请求参数中是否必须提供此参数。默认值: true。 表示必须提供，如果不提供将报错</li><li><code>defaultValue</code>：请求参数的默认值</li></ul></li><li><strong>请求类型</strong><ul><li><strong>Get请求</strong></li><li><strong>POST DELETE请求</strong>：<strong>请求头中的Content-Type 为 application/x-www-form-urlencoded[默认属性]</strong></li><li><strong>如果改用 <code>json</code> 字符串来传值的话，类型设置为 <code>application/json</code>，点击发送的话，会报错，后台接收不到值，为 <code>null</code>。——&gt;引入注解@RequestBody</strong></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"yyx/hello?username=yyx"</span>&gt;</span>入门程序<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@RequestParam(value = <span class="string">"username"</span>, required= <span class="keyword">false</span>)</span> String name)</span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>前端使用$.ajax的话，一定要指定 <code>contentType: &quot;application/json;charset=utf-8;&quot;</code>，默认为 <code>application/x-www-form-urlencoded</code>。</li></ul><h2 id="3-2-RequestBody-重要"><a href="#3-2-RequestBody-重要" class="headerlink" title="3.2.@RequestBody[重要]"></a>3.2.<code>@RequestBody</code>[重要]</h2><ul><li><p>作用：用于获取<strong>请求体</strong>内容</p><ul><li>直接使用得到是<code>key=values&amp;key=value&amp;..</code>结构的数据</li><li>get请求方式不适用</li><li><strong>用于处理非 <code>Content-Type: application/x-www-form-urlencoded</code>编码格式的数据</strong></li><li><strong>用于处理<code>application/json</code>、<code>application/xml</code>等类型的数据。</strong></li></ul></li><li><p>属性</p></li><li><p><code>required</code>：是否必须有请求体。默认值<code>true</code>。当取值为<code>true</code>时,<code>get</code>请求方式会报错。如果取值<code>false</code>或 <code>get</code>，请求得到是<code>null</code>。</p></li><li><p>例1</p><p><img src="1578384645597.png" alt="1578384645597"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"yyx/saveUser"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    账户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"uname"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    年  龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/saveUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(@RequestBody String str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(str);<span class="comment">//uname=%E6%9D%A8%E9%9B%A8%E9%91%AB&amp;age=23</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>例2</p><p><img src="1543609-20190711195647145-1083582365.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/test"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"id = &#123;&#125;, name = &#123;&#125;, age = &#123;&#125;"</span>, user.getId(), user.getName(), user.getAge());<span class="comment">//id = 1, name = yc, age = 23</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="小对比"><a href="#小对比" class="headerlink" title="小对比"></a>小对比</h3><ul><li><p><strong>使用@RequestParam：Content-Type为application/x-www-form-urlencoded，参数在FormData中</strong><br><img src="20181010140426784.png" alt="img"></p></li><li><p><strong>使用@RequestBody：Content-Type为application/json，参数在Request PayLoad中</strong><br><img src="20181010141048192.png" alt="img"></p></li></ul><h1 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h1><h2 id="从content-type方面总结："><a href="#从content-type方面总结：" class="headerlink" title="从content-type方面总结："></a>从content-type方面总结：</h2><p>① form-data、x-www-form-urlencoded：不可以用@RequestBody；可以用@RequestParam。见postman的格局，这两种方式的时候没有json字符串部分。</p><p>② application/json：json字符串部分可以用@RequestBody；url中的?后面参数可以用@RequestParam。见postman的格局</p><ul><li><p>application/json格局图<br><img src="aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDYxMzc5LTYzYWJjNmNjODZhMDYzYWYucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMDAwL2Zvcm1hdC93ZWJw.jpg" alt="img"></p></li><li><p>form-data、x-www-form-urlencoded格局图</p><p><img src="aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDYxMzc5LTQ5MTAxNDllZGEzZTRiZDQucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMDAwL2Zvcm1hdC93ZWJw.jpg" alt="img"></p></li></ul><h2 id="从两种注解方式总结："><a href="#从两种注解方式总结：" class="headerlink" title="从两种注解方式总结：**"></a>从两种注解方式总结：**</h2><p><strong>@RequestBody</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="meta">@RequestBody</span> Map map)</span><br><span class="line">(<span class="meta">@RequestBody</span> Object object)</span><br><span class="line">application/json时候可用</span><br><span class="line">form-data、x-www-form-urlencoded时候不可用</span><br></pre></td></tr></table></figure><p><strong>@RequestParam</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="meta">@RequestParam</span> Map map)</span><br><span class="line">application/json时候，json字符串部分不可用，url中的?后面添加参数即可用，form-data、x-www-form-urlencoded时候可用，但是要将Headers里的Content-Type删掉</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="meta">@RequestParam</span> String waterEleId,</span><br><span class="line"> <span class="meta">@RequestParam</span> String enterpriseName)</span><br><span class="line">application/json时候，json字符串部分不可用，url中的?后面添加参数即可用</span><br><span class="line">form-data、x-www-form-urlencoded时候可用，且参数可以没有顺序（即前端传过来的参数或者url中的参数顺序不必和后台接口中的参数顺序一致，只要字段名相同就可以），但是要将Headers里的Content-Type删掉</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="meta">@RequestParam</span> Object object)</span><br><span class="line">不管application/json、form-data、x-www-form-urlencoded都不可用</span><br></pre></td></tr></table></figure><h1 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h1><p>@RequestBody</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RequestBody Map / Object</span><br><span class="line">GET请求中不可以使用<span class="meta">@RequestBody</span></span><br></pre></td></tr></table></figure><p>@RequestParam</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="meta">@RequestParam</span> Map map)</span><br><span class="line">在url中的?后面添加参数即可使用</span><br><span class="line">(<span class="meta">@RequestParam</span> String waterEleId,<span class="meta">@RequestParam</span> String enterpriseName)</span><br><span class="line">在url中的?后面添加参数即可使用</span><br><span class="line">(<span class="meta">@RequestParam</span> Object object)</span><br><span class="line">GET请求中不可以使用</span><br></pre></td></tr></table></figure><h2 id="3-3-PathVariable-重要"><a href="#3-3-PathVariable-重要" class="headerlink" title="3.3.@PathVariable[重要]"></a>3.3.<code>@PathVariable</code>[重要]</h2><h3 id="3-3-1-Rest风格"><a href="#3-3-1-Rest风格" class="headerlink" title="3.3.1.Rest风格"></a>3.3.1.Rest风格</h3><ul><li>请求路径一样，可以根据不同的请求方式去执行后台的不同方法</li><li>Restful风格的URL优点<ul><li>结构清晰</li><li>符合标准</li><li>易于理解</li><li>扩展方便</li></ul></li></ul><p><img src="1578385736979.png" alt="1578385736979"></p><p><img src="1578385750781.png" alt="1578385750781"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.理解本真的REST架构风格: http:&#x2F;&#x2F;kb.cnblogs.com&#x2F;page&#x2F;186516&#x2F;</span><br><span class="line">2.深入浅出REST: http:&#x2F;&#x2F;www.infog.com&#x2F;cn&#x2F;articles&#x2F;rest-introduction</span><br></pre></td></tr></table></figure><h3 id="3-3-2-PathVariable"><a href="#3-3-2-PathVariable" class="headerlink" title="3.3.2.@PathVariable"></a>3.3.2.<code>@PathVariable</code></h3><ul><li>作用：用于绑定<code>url</code>中的占位符。<ul><li>请求<code>url</code>中<code>/delete/{id}</code>，这个<code>{id}</code>就是<code>url</code>占位符</li><li><strong><code>url</code>支持占位符是<code>spring3.0</code>之后加入的，是<code>springmvc</code>支持<code>rest</code>风格<code>URL</code>的一个重要标志。</strong></li></ul></li><li>属性<ul><li><code>value</code>：用于指定url中占位符名称</li><li><code>required</code>：是否必须提供占位符</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"yyx/hello/yyx"</span>&gt;</span>入门程序<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello/&#123;abcd&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@PathVariable(value = <span class="string">"abcd"</span>)</span> String name)</span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1578386196782.png" alt="1578386196782"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yyx</span><br></pre></td></tr></table></figure><h2 id="3-4-RequestHeader"><a href="#3-4-RequestHeader" class="headerlink" title="3.4.@RequestHeader"></a>3.4.<code>@RequestHeader</code></h2><ul><li>作用：用于获取请求消息头</li><li>属性：【同3.1<code>@RequestParam</code>】</li><li><strong>在实际开发中一般不怎么用</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"yyx/hello"</span>&gt;</span>入门程序<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@RequestHeader(value = <span class="string">"Content-Type"</span>,required = <span class="keyword">false</span>)</span> String contype,</span></span><br><span class="line"><span class="function">@<span class="title">RequestHeader</span><span class="params">(value = <span class="string">"Date"</span>)</span> String date)</span>&#123;</span><br><span class="line">    System.out.println(contype);</span><br><span class="line">    System.out.println(date);</span><br><span class="line">    <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用API Test插件</li></ul><p><img src="1578389359852.png" alt="1578389359852"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multipart&#x2F;form-dataBROKEN REFERENCE</span><br><span class="line">23</span><br></pre></td></tr></table></figure><h2 id="3-5-CookieValue"><a href="#3-5-CookieValue" class="headerlink" title="3.5.@CookieValue"></a>3.5.<code>@CookieValue</code></h2><ul><li><p>作用：用于把指定cookie名称的值传入控制器方法参数</p></li><li><p>属性：【同3.1<code>@RequestParam</code>】</p></li><li><p><strong>在实际开发中一般不怎么用</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;yyx&#x2F;hello&quot;&gt;入门程序&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@CookieValue(value = <span class="string">"JSESSIONID"</span>,required = <span class="keyword">false</span>)</span> String id)</span>&#123;</span><br><span class="line">    System.out.println(id);</span><br><span class="line">    <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1578386196782.png" alt="1578386196782"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8115EE2160ABBA27808A76664D050473</span><br></pre></td></tr></table></figure><h3 id="总结1："><a href="#总结1：" class="headerlink" title="总结1："></a>总结1：</h3><ul><li><p>Http协议常用的四种请求方式：Post、Get、Put、Delete等；其中Put、Delete请求方式很少见，都可用Post方式代替</p><ul><li>对数据库而言： get 请求不修改数据库，只是查询。Post是增加记录，put是更新，Delete数据库删除</li><li>Put，Post，Delete 方式的请求参数会直接放在requestBody里</li><li>处理 request uri 部分的注解，路径参数变量：@PathVariable</li><li>处理request header部分的注解：   @RequestHeader, @CookieValue，@RequestParam</li><li>处理request body部分的注解：@RequestParam， @RequestBody；　　</li></ul></li><li><p>综上所述：@RequestParam注解既可以接收Get方式的请求头中的参数，也可以接收Post方式的请求体中的参数；</p></li></ul><h3 id="总结2："><a href="#总结2：" class="headerlink" title="总结2："></a>总结2：</h3><ul><li>get请求的 headers 中没有 content-type 这个字段，post 的 content-type 有 ：<ul><li><code>application/x-www-form-urlencoded</code>，这种就是一般的文本表单用 post 传地数据，只要将得到的 data 用 @RequestParam 或 request.getParamter() 获取即可；</li><li><code>multipart/form-data</code> ，用于文件上传，此时 form 的 enctype 属性必须指定为 multipart/form-data；</li><li><code>application/json</code>，将数据以json对象的格式传递</li><li><code>text/xml</code></li></ul></li><li>put 和 delete 请求的headers 是有 content-type 这个字段的，只不过这两个方法类型目前不常用；</li></ul><h2 id="3-6-ModelAttribute"><a href="#3-6-ModelAttribute" class="headerlink" title="3.6.@ModelAttribute"></a>3.6.<code>@ModelAttribute</code></h2><ul><li>作用：该注解是<code>SpringMVC4.3</code>版本以后新加入的，它可以用于修饰方法和参数。<ul><li>在方法上：当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。</li><li>在参数上，获取指定的数据给参数赋值。</li></ul></li><li>属性:<ul><li><code>value/name</code>：用于获取数据的<code>key</code>。<code>key</code>可以是<code>POJO</code>的属性名称，也可以是<code>map</code>结构的<code>key</code>。</li></ul></li><li>应用场景：当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。<ul><li>例如：我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据是肯定没有此字段的内容，一旦更新会把该字段内容置为null,此时就可以使用此注解解决问题</li></ul></li></ul><h3 id="3-6-1-ModelAttribute方法会在控制器的方法执行之前执行"><a href="#3-6-1-ModelAttribute方法会在控制器的方法执行之前执行" class="headerlink" title="3.6.1.@ModelAttribute方法会在控制器的方法执行之前执行"></a>3.6.1.<code>@ModelAttribute</code>方法会在控制器的方法执行之前执行</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/saveUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testController</span><span class="params">(String uname, String age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testController"</span>+ uname + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testModelAttribute</span><span class="params">(String uname, String age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testModelAttribute"</span>+uname + age);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//============================================================</span></span><br><span class="line">    &lt;form action=<span class="string">"yyx/saveUser"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">        账户名：&lt;input type=<span class="string">"text"</span> name=<span class="string">"uname"</span>&gt;&lt;br/&gt;</span><br><span class="line">        年  龄：&lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span>&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"ok"</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br></pre></td></tr></table></figure><p><img src="1578399505850.png" alt="1578399505850"></p><p><img src="1578399494050.png" alt="1578399494050"></p><h3 id="3-6-2-ModelAttribute方法带返回值——保证没有提交数据的字段使用数据库对象原来的数据"><a href="#3-6-2-ModelAttribute方法带返回值——保证没有提交数据的字段使用数据库对象原来的数据" class="headerlink" title="3.6.2.@ModelAttribute方法带返回值——保证没有提交数据的字段使用数据库对象原来的数据"></a>3.6.2.<code>@ModelAttribute</code>方法带返回值——保证没有提交数据的字段使用数据库对象原来的数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/saveUser"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">testController</span><span class="params">(User user)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"testController"</span>+ user);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@ModelAttribute</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">testModelAttribute</span><span class="params">(String uname, String age)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       User user = serviceFindByName(uname);</span><br><span class="line">       System.out.println(<span class="string">"testModelAttribute run..."</span>+ user);</span><br><span class="line">       <span class="keyword">return</span> user;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 模拟数据库查询</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">serviceFindByName</span><span class="params">(String username)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       User user = <span class="keyword">new</span> User();</span><br><span class="line">       user.setUname(username);</span><br><span class="line">       user.setAge(<span class="number">19</span>);</span><br><span class="line">       user.setDate(<span class="keyword">new</span> Date());</span><br><span class="line">       <span class="keyword">return</span>  user;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"yyx/saveUser"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    账户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"uname"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    年  龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="1578400070341.png" alt="1578400070341"></p><p>表单中数据会<strong>覆盖</strong>从数据库读取的数据</p><p><img src="1578400139350.png" alt="1578400139350"></p><h3 id="3-6-3-ModelAttribute方法不带返回值——保证没有提交数据的字段使用数据库对象原来的数据"><a href="#3-6-3-ModelAttribute方法不带返回值——保证没有提交数据的字段使用数据库对象原来的数据" class="headerlink" title="3.6.3.@ModelAttribute方法不带返回值——保证没有提交数据的字段使用数据库对象原来的数据"></a>3.6.3.<code>@ModelAttribute</code>方法不带返回值——保证没有提交数据的字段使用数据库对象原来的数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@RequestMapping</span>(path=<span class="string">"/saveUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testController</span><span class="params">(@ModelAttribute(<span class="string">"abcd"</span>)</span>User user)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testController"</span>+ user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testModelAttribute</span><span class="params">(String uname, String age, Map&lt;String,User&gt; map)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        User user = serviceFindByName(uname);</span><br><span class="line">        System.out.println(<span class="string">"testModelAttribute run..."</span>+ user);</span><br><span class="line">        map.put(<span class="string">"abcd"</span>,user);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟数据库查询 同上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//============================================================</span></span><br><span class="line">     <span class="comment">//表单提交 同上</span></span><br></pre></td></tr></table></figure><p><img src="1578400070341.png" alt="1578400070341"></p><p>表单中数据会<strong>覆盖</strong>从数据库读取的数据</p><p><img src="1578400447580.png" alt="1578400447580"></p><h2 id="3-7-SessionAttributes-重要"><a href="#3-7-SessionAttributes-重要" class="headerlink" title="3.7.@SessionAttributes[重要]"></a>3.7.<code>@SessionAttributes</code>[重要]</h2><ul><li>默认情况下<code>Spring MVC</code>将模型中的数据存储到<code>request</code>域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到<code>session</code></li><li>作用：<strong>可以使得模型中的数据存储一份到<code>session</code>域中</strong></li><li>范围：<strong>仅仅作用在类上</strong></li><li>属性：<ul><li><code>value/names</code>：存储到session域数据的属性名称</li><li><code>types</code>：用于指定存入的数据类型</li></ul></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开始EL表达式注解</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> isELIgnored=<span class="string">"false"</span> %&gt;</span><br></pre></td></tr></table></figure><ul><li><code>success.jsp</code></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sessionScope.username:  $&#123;sessionScope.username&#125;&lt;br&gt;</span><br><span class="line">sessionScope.password:  $&#123;sessionScope.password&#125;&lt;br&gt;</span><br><span class="line">sessionScope.age:  $&#123;sessionScope.age&#125;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">requestScope.username:  $&#123;requestScope.username&#125;&lt;br&gt;</span><br><span class="line">requestScope.password:  $&#123;requestScope.password&#125;&lt;br&gt;</span><br><span class="line">requestScope.age:  $&#123;requestScope.age&#125;&lt;br&gt;</span><br></pre></td></tr></table></figure><ul><li><code>SessionAttributesTest</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.ModelMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.SessionAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.support.SessionStatus;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes</span>(value = &#123;<span class="string">"username"</span>,<span class="string">"password"</span>&#125;)</span><br><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/springmvc"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionAttributesTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/sessionPut"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPut</span><span class="params">(Model model)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"username"</span>,<span class="string">"gold"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"password"</span>,<span class="string">"123"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"age"</span>,<span class="string">"23"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/sessionGet"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testGet</span><span class="params">(ModelMap model)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(model.get(<span class="string">"username"</span>));</span><br><span class="line">        System.out.println(model.get(<span class="string">"password"</span>));</span><br><span class="line">        System.out.println(model.get(<span class="string">"age"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/sessionClean"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testClean</span><span class="params">(SessionStatus sessionStatus)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sessionStatus.setComplete();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>index.jsp</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="springmvc/sessionPut"&gt;存入SessionAttribute&lt;/a&gt;</span><br><span class="line">&lt;a href="springmvc/sessionGet"&gt;取出SessionAttribute&lt;/a&gt;</span><br><span class="line">&lt;a href="springmvc/sessionClean"&gt;清除SessionAttribute&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><img src="1578404462290.png" alt="1578404462290"></p><p><img src="1578404472995.png" alt="1578404472995"></p><p><img src="1578404504684.png" alt="1578404504684"></p><p><img src="1578404496939.png" alt="1578404496939"></p><p><img src="1578404513763.png" alt="1578404513763"></p><p><img src="1578404520248.png" alt="1578404520248"></p><p><img src="1578404530895.png" alt="1578404530895"></p><p><img src="1578404612544.png" alt="1578404612544"></p><p><img src="1578404623243.png" alt="1578404623243"></p>]]></content>
    
    <summary type="html">
    
      常用注解
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="SpringMVC" scheme="http://goldcarpenter.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="http://goldcarpenter.github.io/2019/11/05/SpringMVC_Part1/"/>
    <id>http://goldcarpenter.github.io/2019/11/05/SpringMVC_Part1/</id>
    <published>2019-11-04T16:00:00.000Z</published>
    <updated>2020-06-17T08:00:57.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-SpringMVC入门"><a href="#1-SpringMVC入门" class="headerlink" title="1.SpringMVC入门"></a>1.SpringMVC入门</h1><h2 id="1-1-MVC模式"><a href="#1-1-MVC模式" class="headerlink" title="1.1.MVC模式"></a>1.1.MVC模式</h2><ul><li><code>MVC</code>全名是<code>Model View Controller</code>是模型(<code>model</code>)  视图(<code>view</code>) 控制器(<code>controller</code>)的缩写，是一种用于设计创建Web应用程序<strong>表现层</strong>的模式。</li><li>MVC中每个部分各司其职:<ul><li>Model (模型) ：通常指的就是数据模型，<code>JavaBean</code>类。一般情况下用于封装数据</li><li>View (视图) ：通常指的就是我们的<code>jsp</code>/<code>html</code>。一般用于展示数据的</li><li>Controller (控制器) ：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。</li></ul></li></ul><h2 id="1-2-SpringMVC模式"><a href="#1-2-SpringMVC模式" class="headerlink" title="1.2.SpringMVC模式"></a>1.2.SpringMVC模式</h2><ul><li>SpringMVC是一种基于Java的实现<strong>MVC设计模型</strong>的请求驱动类型的<strong>轻量级Web框架</strong></li><li>属于Spring FrameWork的后续产品，已经融合在Spring Web Flow 里面</li><li><code>Spring</code>框架提供了构建Web应用程序的<strong>全功能MVC模块</strong>。</li><li>使用Spring可插入的MVC架构，从而在进行WEB开发时，可以选择<code>Spring</code>的<code>Spring MVC</code>框架或其他MVC开发框架，如<code>Struts2</code>等</li></ul><h2 id="1-3-入门程序"><a href="#1-3-入门程序" class="headerlink" title="1.3.入门程序"></a>1.3.入门程序</h2><p><img src="1578324261588.png" alt="1578324261588"></p><ul><li>当启动<code>Tomcat</code>服务器的时候，因为配置了<code>load-on-startup</code>标签，所以会创建<code>DispatcherServlet</code>对象，就会加载<code>springmvc.xml</code>配置文件</li><li><code>springmvc.xml</code>开启了注解扫描，<code>Spring</code>容器就会创建<code>HelloController</code>对象</li><li>打开浏览器，从<code>index.jsp</code>发送请求，请求会先到达<code>DispatcherServlet</code>核心控制器，根据配置<code>@RequestMapping</code>注解找到执行的具体方法</li><li>根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的<code>JSP</code>文件</li><li><code>Tomcat</code>服务器渲染页面，做出响应</li></ul><p><img src="1578365574745.png" alt="1578365574745"></p><ul><li><code>pom.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.carpenter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringMVC_Study<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>web.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置中央调度器 拦截所有请求--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--配置DispatcherServlet 的一个初始化参数:配置SpringMVC 配置文件的位置和名称--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>index.jsp</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;入门程序&lt;&#x2F;h3&gt;</span><br><span class="line">######注意！此处URL没有&#x2F; 如果有&#x2F;则访问时没有项目路径</span><br><span class="line">&lt;a href&#x3D;&quot;hello&quot;&gt;入门程序&lt;&#x2F;a&gt;  </span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><ul><li><code>success.jsp</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;入门成功&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li><code>springmvc.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注解扫描位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top.carpenter"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    视图解析器对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--SpringMVC 框架支持注解--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>HelloController</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello MVC"</span>);</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-组件方式执行流程"><a href="#1-4-组件方式执行流程" class="headerlink" title="1.4.组件方式执行流程"></a>1.4.组件方式执行流程</h2><p><img src="%E7%BB%84%E4%BB%B6.png" alt=""></p><ul><li><p><code>DispatcherServlet</code>前端控制器</p><ul><li>用户请求到达前端控制器，它就相当于<code>mvc</code>模式中的<code>c</code>，<code>dispatcherservlet</code>是整个流程控制的中心，由它调用其它组件处理用户的请求，<code>dispatcherServlet</code>的存在降低了组件之间的耦合性</li></ul></li><li><p><code>HandlerMapping</code>处理器映射器</p><ul><li><p><code>HandlerMapping</code>负责根据用户请求找到<code>Handler</code>即处理器，<code>SpringMVC</code>提供了不同的映射器实现不同的映射方式，例如:配置文件方式，实现接口方式，注解方式等。</p><p><img src="1584879264052.png" alt="1584879264052"></p><p><code>&lt;mvc:default-servlet-handler/&gt;</code></p><p><img src="1584879305167.png" alt="1584879305167"></p></li></ul></li><li><p><code>Handler</code>处理器</p><ul><li>它就是我们开发中要编写的具体业务控制器。由<code>DispatcherServlet</code>把用户请求转发到<code>Handler</code>，由<br><code>Handler</code>对具体的用户请求进行处理。</li></ul></li><li><p><code>HandlAdapter</code>处理器适配器</p><ul><li>通过<code>HandlerAdapter</code>对处理器进行执行，这是<strong>适配器模式的应用</strong>，通过扩展适配器可以对更多类型的处理器进行执行<ul><li>表单数据类型校验/转换….</li></ul></li></ul></li><li><p><code>View Resolver</code>视图解析器</p><ul><li><code>View Resolver</code>负责将处理结果生成View视图，<code>View Resolver</code>首先根据<strong>逻辑视图名</strong>解析成<strong>物理视图名</strong><br>即具体的页面地址，再生成<code>View</code>视图对象，最后对<code>View</code>进行渲染将处理结果通过页面展示给用户</li><li>所有的视图解析器都必须实现 ViewResolver 接口</li><li>可以选择一种视图解析器或混用多种视图解析器</li><li>每个视图解析器都实现了<code>Ordered</code>接口并开放出一个<code>order</code>属性，可以通过<code>order</code>属性指定解析器的优先顺序，<code>order</code>越小优先级越高。 </li><li><code>SpringMVC</code>会按视图解析器顺序的优先顺序对逻辑视图名进行解析，直到解析成功并返回视图对象，否则将抛出 ServletException 异常</li></ul></li><li><p><code>View</code>视图</p><ul><li><code>SpringMVC</code>框架提供了很多的View视图类型的支持，包括:<code>jstlView</code>、<code>freemarkerView</code>、<code>pdfView</code><br>等，最常用的视图就是<code>jsp</code></li><li>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面</li><li><strong>视图对象由视图解析器负责实例化。由于视图是无状态的，所以不会有线程安全的问题</strong></li></ul></li></ul><h2 id="1-5-xml-注解配置说明"><a href="#1-5-xml-注解配置说明" class="headerlink" title="1.5.xml/注解配置说明"></a>1.5.xml/注解配置说明</h2><ul><li><p><code>&lt;mvc:annotation-driven&gt;</code></p><ul><li>在<code>SpringMVC</code>的各个组件中，<strong>处理器映射器</strong>、<strong>处理器适配器</strong>、<strong>视图解析器</strong>称为SpringMVC的三大组件</li><li>使用<code>&lt;mvc: annotation-driven&gt;</code>自动加载<code>RequestMappingHandlerMapping</code> (处理映射器)和<code>RequestMappingHandlerAdapter</code>(处理适配器) <code>ExceptionHandlerExceptionResolver</code>，可用在<code>springMVC.xml</code>配置文件中使用<code>&lt;mvc:annotation-driven&gt;</code>替代注解处理器和适配器的配置。</li></ul></li><li><p>支持使用<code>ConversionService</code>实例对表单参数进行类型转换</p><ul><li>支持使用<code>@NumberFormat</code>、<code>@DateTimeFormat</code>注解完成数据类型的格式化</li><li>支持使用<code>@Valid</code>注解对<code>JavaBean</code>实例进行<code>JSR 303</code>验证</li><li>支持使用<code>@RequestBody</code>和<code>@ResponseBody</code>注解</li></ul></li><li><p><code>@RequestMaping</code></p><ul><li><p>用于建立请求URL和处理请求方法之间的对应关系</p></li><li><p>属性</p><ul><li><code>value/path</code>:用于指定请求的URL</li><li><code>method</code>:用于指定请求的方式</li><li><code>params</code>:用于限制请求的参数，即必须包含的参数。它支持简单的表达式，要求<code>url</code>请求参数的<code>key</code>和<code>value</code>必须和此参数配置的一模一样【不常用】</li><li><code>headers</code>:用于限制请求消息头，即必须包含的消息头【不常用】</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>,params = &#123;<span class="string">"name=yyx"</span>&#125;,  method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello MVC"</span>+ name);</span><br><span class="line">    <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>位置</p><ul><li>类名——<strong>需要以<code>/</code>开头</strong>：第一级的访问目录</li><li>方法名：第二级的访问目录</li></ul></li></ul></li></ul><h1 id="2-SpringMVC请求参数的绑定"><a href="#2-SpringMVC请求参数的绑定" class="headerlink" title="2.SpringMVC请求参数的绑定"></a>2.SpringMVC请求参数的绑定</h1><ul><li>不使用@RequestParam注解直接进行对象属性赋值（不推荐使用，容易和@ReuqestBody混淆）</li></ul><h2 id="2-1绑定的机制"><a href="#2-1绑定的机制" class="headerlink" title="2.1绑定的机制"></a>2.1绑定的机制</h2><ul><li><p>表单中请求参数都是基于<code>key=value</code>的</p></li><li><p>SpringMVC绑定请求参数的过程是通过<strong>表单提交请求参数</strong>，作为<strong>控制器中方法参数</strong>进行<strong>绑定</strong>的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"yyx/hello?name=yyx"</span>&gt;</span>入门程序<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Hello MVC"</span>+ name);</span><br><span class="line">      <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-支持的数据类型"><a href="#2-2-支持的数据类型" class="headerlink" title="2.2.支持的数据类型"></a>2.2.支持的数据类型</h2><ul><li><code>SpringMVC</code>绑定请求参数是<strong>自动实现</strong>的，但是要想使用，<strong>必须遵循使用要求</strong></li></ul><h3 id="2-2-1-基本类型参数和String类型"><a href="#2-2-1-基本类型参数和String类型" class="headerlink" title="2.2.1.基本类型参数和String类型"></a>2.2.1.<strong>基本类型参数</strong>和<strong><code>String</code>类型</strong></h3><ul><li><strong>参数名称</strong>必须和控制器中<strong>方法的形参名称</strong>保持一致【严格区分大小写】</li></ul><h3 id="2-2-2-pojo类型参数：包括实体类，以及关联的实体类"><a href="#2-2-2-pojo类型参数：包括实体类，以及关联的实体类" class="headerlink" title="2.2.2.pojo类型参数：包括实体类，以及关联的实体类"></a>2.2.2.<strong><code>pojo</code>类型参数</strong>：包括实体类，以及关联的实体类</h3><ul><li><strong>表单中参数名</strong>称和<strong><code>pojo</code>类的属性名称</strong>保持一致。并且控制器<strong>方法的参数类型是pojo</strong>类型</li><li>如果一个<code>JavaBean</code>类中包含其他的引用类型， 那么表单的<code>name</code>属性需要编写成:对象.属性例如：<code>address.name</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"yyx/accountSave"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    账户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密  码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    金  额：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"money"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user.uname"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    年  龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user.age"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String uname;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    # set get toString方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    # set get toString方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@RequestMapping</span>(path=<span class="string">"/accountSave"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(Account account)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(account);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//========================================================</span></span><br><span class="line">Account&#123;username=<span class="string">'杨雨鑫'</span>, password=<span class="string">'123'</span>, money=<span class="number">4.0</span>, user=User&#123;uname=<span class="string">'杨雨鑫'</span>, age=<span class="number">23</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-数组，List结构和Map结构的集合"><a href="#2-2-3-数组，List结构和Map结构的集合" class="headerlink" title="2.2.3.数组，List结构和Map结构的集合"></a>2.2.3.<strong>数组</strong>，<strong>List结构</strong>和<strong>Map结构</strong>的集合</h3><ul><li>在表单中<strong>请求参数名称</strong>要和<strong><code>pojo</code>中集合属性名称</strong>相同<ul><li>给List集合中的元素赋值，使用下标</li><li>给Map集合中的元素赋值，使用键值对    </li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"yyx/accountSave"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    账户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密  码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    金  额：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"money"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"list_users[0].uname"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"map_users['yyx'].uname"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    年  龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"list_users[0].age"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    年  龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"map_users['yyx'].age"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; list_users;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,User&gt; map_users;</span><br><span class="line">    <span class="comment">//set get toString方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String uname;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//set get toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/accountSave"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(Account account)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.println(account);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">========================================================</span><br><span class="line">Account&#123;username=<span class="string">'杨雨鑫'</span>, password=<span class="string">'123'</span>, money=<span class="number">4.0</span>, list_users=[User&#123;uname=<span class="string">'杨雨鑫'</span>, age=<span class="number">23</span>&#125;], map_users=&#123;yyx=User&#123;uname=<span class="string">'杨雨鑫'</span>, age=<span class="number">23</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-4-数据绑定流程"><a href="#2-2-4-数据绑定流程" class="headerlink" title="2.2.4 数据绑定流程"></a>2.2.4 数据绑定流程</h3><ul><li><code>Spring MVC</code>主框架<strong>将<code>ServletRequest</code>对象及目标方法的入参实例传递给<code>WebDataBinderFactory</code>实例</strong>，以创建<code>DataBinder</code>实例对象</li><li><code>DataBinder</code>调用装配在<code>Spring MVC</code>下文中的<code>ConversionService</code>组件进行数据类型转换、数据格式化工作。将 Servlet 中的请求信息填充到入参对象中 </li><li>调用<code>Validator</code>组件对已经绑定了请求消息的入参对象进行数据合法性校验，并最终生成数据绑定结果<code>BindingData</code>对象</li><li><code>Spring MVC</code>抽取<code>BindingResult</code>中的入参对象和校验错误对象，将它们赋给处理方法的响应入参</li></ul><p><img src="1584782101133.png" alt="1584782101133"></p><blockquote><p>数据绑定的核心部件是 DataBinder</p></blockquote><h3 id="2-2-5-自定义类型转换器"><a href="#2-2-5-自定义类型转换器" class="headerlink" title="2.2.5.自定义类型转换器"></a>2.2.5.自定义类型转换器</h3><ul><li><p><strong><code>ConversionService</code>是 Spring 类型转换体系的核心接口</strong></p></li><li><p>可以利用<code>ConversionServiceFactoryBean</code>在<code>Spring</code>的<code>IOC</code>容器中定义一个<code>ConversionService</code> ，<code>Spring</code>将自动识别出 IOC 容器中的<code>ConversionService</code>，并在 Bean 属性配置及 Spring MVC 处理方法入参绑定等场合使用它进行数据的转换</p></li><li><p>可通过<code>ConversionServiceFactoryBean</code>的<code>converters</code>属性注册自定义的类型转换器</p></li><li><p><code>&lt;mvc:annotation-driven conversion-service= &quot;conversionService&quot;/&gt;</code>会将自定义的<code>ConversionService</code>注册到<code>Spring MVC</code>的上下文中</p><p><img src="1584788751251.png" alt="1584788751251"></p></li><li><p>Spring 定义了 3 种类型的转换器接口，实现任意一个转换 器接口都可以作为自定义转换器注册到 ConversionServiceFactroyBean 中</p><ul><li>Converter&lt;S,T&gt;：将 S 类型对象转为 T 类型对象</li><li>ConverterFactory：将相同系列多个 “同质” Converter 封装在一 起。如果希望将一种类型的对象转换为另一种类型及其子类的对 象（例如将 String 转换为 Number 及 Number 子类 （Integer、Long、Double 等）对象）可使用该转换器工厂类 </li><li>GenericConverter：会根据源类对象及目标类对象所在的宿主类 中的上下文信息进行类型转换</li></ul></li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul><li><p>表单提交的任何数据类型全部都是字符串类型，但是后台定义Integer类型，数据也可以封装上，说明Spring框架内部会默认进行数据类型转换</p></li><li><p>如果想自定义数据类型转换，可以实现Converter的接口</p></li><li><p>问题引入</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"yyx/saveUser"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    账户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"uname"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密  码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    日  期：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"date"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String uname;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">    <span class="comment">//set get toString方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/saveUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(User user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1578380463888.png" alt="1578380463888"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入 xxxx/xx/xx成功封装</span></span><br><span class="line">User&#123;uname=<span class="string">'杨雨鑫'</span>, age=<span class="number">123</span>, date=Wed Mar <span class="number">03</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">2010</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="1578380541526.png" alt="1578380541526"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入 xxxx-xx-xx封装失败</span></span><br></pre></td></tr></table></figure><p><img src="1578380553445.png" alt="1578380553445"></p><ul><li><p>定义一个类实现<code>Converter</code>接口，<strong>实现自定义的转换器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.utils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.convert.converter.Converter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//    实现其唯一抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        DateFormat formate = <span class="keyword">null</span>;</span><br><span class="line">        Date date = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(str))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"请输入日期"</span>);</span><br><span class="line">            formate = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">            date = formate.parse(str);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>Spring</code>配置文件中配置类型转换器</p><ul><li><code>Spring</code>配置类型转换器的机制是，将<strong>自定义的转换器注册到类型转换服务</strong>中去。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    在Spring配置文件中配置类型转换器工厂--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> =<span class="string">"converterService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--       使用工厂类的set注入一个新的类型转换器（自定义的）--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"top.carpenter.utils.StringToDateConverter"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>annotation-driven</code>标签中引用配置的类型转换服务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"converterService"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="1578381876422.png" alt="1578381876422"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User&#123;uname&#x3D;&#39;杨雨鑫&#39;, age&#x3D;123, date&#x3D;Sat Mar 02 00:00:00 CST 2019&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-6数据格式化"><a href="#2-2-6数据格式化" class="headerlink" title="2.2.6数据格式化"></a>2.2.6数据格式化</h3><ul><li><p><code>Spring</code>在格式化模块中定义了一个实现<code>ConversionService</code>接口的<code>FormattingConversionService</code>实现类，该实现类扩展了<code>GenericConversionService</code>，因此它<strong>既具有类型转换的功能，又具有格式化</strong>的功能 </p></li><li><p><code>FormattingConversionService</code>拥有一个<code>FormattingConversionServiceFactroyBean</code>工厂类， 后者用于在 Spring 上下文中构造前者</p></li><li><p>FormattingConversionServiceFactroyBean 内部已经注册了</p><ul><li>NumberFormatAnnotationFormatterFactroy：支持对数字类型的属性 使用 @NumberFormat 注解</li><li>JodaDateTimeFormatAnnotationFormatterFactroy：支持对日期类型 的属性使用 @DateTimeFormat 注解</li></ul></li><li><p>装配了<code>FormattingConversionServiceFactroyBean</code>后，就可以在<code>Spring MVC</code>入参绑定及模型数据输出时使用注解驱动了。</p></li><li><p><code>&lt;mvc:annotation-driven/&gt;</code>默认创建的<code>ConversionService</code>实例即为<code>FormattingConversionServiceFactroyBean</code></p></li><li><p>日期格式化</p><ul><li><code>@DateTimeFormat</code>注解可对<code>java.util.Date</code> <code>java.util.Calendar</code> <code>java.long.Long</code>时间</li><li>类型进行标注： <code>pattern</code>属性：类型为字符串。指定解析/格式化字段数据的模式， 如：<code>yyyy-MM-dd hh:mm:ss</code></li></ul></li><li><p>数值格式化</p><ul><li><code>@NumberFormat</code>可对类似数字类型的属性进行标注</li></ul></li></ul><h3 id="2-2-7-JSR-303"><a href="#2-2-7-JSR-303" class="headerlink" title="2.2.7 JSR 303"></a>2.2.7 JSR 303</h3><ul><li><p>JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对 Bean 进行验证</p><p><img src="1584790438648.png" alt="1584790438648"></p></li><li><p><strong>Hibernate Validator 是 JSR 303 的一个参考实现</strong>，除支持 所有标准的校验注解外，它还支持以下的扩展注解</p><p><img src="1584790471272.png" alt="1584790471272"></p></li><li><p><strong>Spring 4.0 拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。</strong></p></li><li><p>Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在 Spring MVC 中，可直接通过注解驱动的方式进行数据校验</p></li><li><p>Spring 的 LocalValidatorFactroyBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在 Spring 容器中定义了一个 LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean 中。</p></li><li><p><code>&lt;mvc:annotation-driven/&gt;</code>会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标 注 @valid 注解即可让 Spring MVC 在完成数据绑定后执行 数据校验的工作</p></li><li><p>校验结果保存到随后的入参中，这个保存校验结果的入参必须是 BindingResult 或 Errors 类型，这两个类都位于 org.springframework.validation 包中</p></li><li><p>Spring 本身并没有提供 JSR303 的实现，所以必须将 JSR303 的实现者的 jar 包放到类路径下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/emp"</span>, method=RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(@Valid Employee employee, BindingResult result, Map&lt;String, Object&gt; mapl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(result.getErrorCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"出错了!"</span>);</span><br><span class="line">        <span class="keyword">for</span>(FieldError error : result. getFieldErrors())&#123;</span><br><span class="line">            System.out.println(error.getField() + <span class="string">":"</span> + error.getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//若验证出错，则转向定制的页面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">" input"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    employeeDao.save( employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/emps"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>需校验的 Bean 对象和其绑定结果对象或错误对象时成对出现的，之间不允许声明其他的入参 </p></li><li><p>Errors 接口提供了获取错误信息的方法</p><pre><code>* getErrorCount()* getFieldErrors(String field) </code></pre></li><li><p>BindingResult 扩展了 Errors 接口</p></li></ul></blockquote></li></ul><h2 id="2-3-解决中文乱码问题"><a href="#2-3-解决中文乱码问题" class="headerlink" title="2.3.解决中文乱码问题"></a>2.3.解决中文乱码问题</h2><ul><li><code>SpringMVC</code>可以配置中文乱码</li><li><code>web.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  配置中文乱码过滤器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="1578379929857.png" alt="1578379929857"></p><h2 id="2-4-使用ServletAPI对象作为方法参数-重要"><a href="#2-4-使用ServletAPI对象作为方法参数-重要" class="headerlink" title="2.4.使用ServletAPI对象作为方法参数[重要]"></a>2.4.使用ServletAPI对象作为方法参数[重要]</h2><ul><li><p><code>SpringMVC</code>支持使用原始<code>ServletAPI</code>对象作为控制器方法的参数。</p></li><li><p>支持原始ServletAPI对象有:</p><ul><li><code>HttpServletRequest</code></li><li><code>HttpServletResponse</code></li><li><code>HttpSession</code></li><li><code>java.security.Principal</code></li><li><code>Locale</code></li><li><code>InputStream</code></li><li><code>OutputStream</code></li><li><code>Reader</code></li><li><code>Writer</code></li></ul></li><li><p>我们可以把上述对象，<strong>直接写在控制的方法参数</strong>中使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/saveUser"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(User user, HttpServletRequest request)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      System.out.println(user);</span><br><span class="line">      System.out.println(request.getSession());</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      SpringMVC入门
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="SpringMVC" scheme="http://goldcarpenter.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>String底层总结</title>
    <link href="http://goldcarpenter.github.io/2019/11/01/String%E6%80%BB%E7%BB%93/"/>
    <id>http://goldcarpenter.github.io/2019/11/01/String%E6%80%BB%E7%BB%93/</id>
    <published>2019-11-01T14:54:45.000Z</published>
    <updated>2020-06-17T03:17:31.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String底层总结"><a href="#String底层总结" class="headerlink" title="String底层总结"></a>String底层总结</h1><h2 id="1-字符串创建方式"><a href="#1-字符串创建方式" class="headerlink" title="1.字符串创建方式"></a>1.字符串创建方式</h2><ul><li>字符串有六种基本的创建方式<ul><li>使用<code>char[]</code>数组配合<code>new</code>来创建</li><li>使用<code>byte[]</code>数组配合<code>new</code>来创建</li><li>使用<code>int[]</code>数组配合<code>new</code>来创建</li><li>使用 已有字符串 配合<code>new</code>来创建</li><li>使用字面量创建（不使用<code>new</code>）</li><li>合二为一，使用<code>+</code>运算符来拼接创建</li></ul></li></ul><p>可以看到，至少从表面上讲，后两种都没有用到 new 关键字</p><h3 id="1-1-char-数组创建"><a href="#1-1-char-数组创建" class="headerlink" title="1.1 char[] 数组创建"></a>1.1 char[] 数组创建</h3><ul><li>这种是最基本的，因为字符串本身就是将字符串起来</li><li>String底层结构就是多个字符的 char[] 数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;);</span><br></pre></td></tr></table></figure><p>它的内部结构如下（1.8）</p><p><img src="st01-1589963576703.png" alt=""></p><p>其中 97 其实就是 ‘a’ ，98 其实就是 ‘b’ ，99 其实就是 ‘c’ </p><h3 id="1-2-byte-数组创建"><a href="#1-2-byte-数组创建" class="headerlink" title="1.2 byte[] 数组创建"></a>1.2 byte[] 数组创建</h3><ul><li><p>什么时候会根据 byte[] 数组来创建字符串呢【从 byte[] 转为字符串的需求】</p><ul><li>从网络（例如一个浏览器的 http 请求）传递过来的字节数据</li><li>从 I/O（例如从一个文本文件）读取到的数据</li></ul></li><li><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;); <span class="comment">// abc</span></span><br></pre></td></tr></table></figure><p>其中 <code>new byte[]{97, 98, 99}</code> 就可以是</p><ul><li>从网络（例如一个浏览器的 http 请求）传递过来的字节数据</li><li>从 I/O（例如从一个文本文件）读取到的数据</li></ul></li><li><p>它的内部结构其实也是</p></li></ul><p><img src="st01.png" alt=""></p><p>这时 byte[] 会在构造时被转换为 char[]，其中 byte[] 和 char [] 的结构如下</p><p><img src="st02.png" alt=""></p><p>看到上幅图有同学会说，对于 byte[] 转换为 char[]，97 还是对应 97，98 还是对应 98，99 还是对应 99 啊，看不出 byte[] 和 char[] 的任何区别啊？你要知道，首先他们的大小不一样，其次上面的 char[] 中的 97（a），98（b），99（c） 都属于拉丁字符集，如果用到其它字符集，那么结果就不一样了，看下面的例子</p><ul><li><p>按 gbk 字符集转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = &#123;(<span class="keyword">byte</span>) <span class="number">0xD5</span>, (<span class="keyword">byte</span>) <span class="number">0xC5</span>&#125;;</span><br><span class="line">String str = <span class="keyword">new</span> String(bytes, Charset.forName(<span class="string">"gbk"</span>));</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><p>这时</p></li></ul><p><img src="st04.png" alt=""></p><ul><li><p>其中两个<code>byte 0xD5</code>和 <code>0xC5</code>被转换成了一个 char 0x5F20（汉字【张】）</p></li><li><p>按<code>utf-8</code>字符集转换</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = &#123;(<span class="keyword">byte</span>) <span class="number">0xE5</span>, (<span class="keyword">byte</span>) <span class="number">0xBC</span>, (<span class="keyword">byte</span>) <span class="number">0xA0</span>&#125;;</span><br><span class="line">      String str = <span class="keyword">new</span> String(bytes, Charset.forName(<span class="string">"utf-8"</span>));</span><br><span class="line"><span class="comment">//String str = new String(bytes);等价</span></span><br><span class="line">      System.out.println(str);</span><br></pre></td></tr></table></figure><p><img src="st03.png" alt=""></p><p>其中三个<code>byte 0xE5</code>，<code>0xBC</code> 和<code>0xA0</code> 被转换成了一个<code>char 0x5F20</code>（汉字【张】）</p><p><strong>其实 java 中的 char 字符都是以 unicode 编码的，从外界不同的编码（如 gbk，utf-8）传过来的 byte[] 最终到 java 中的 char 都统一了</strong></p><h3 id="1-3-int-数组创建"><a href="#1-3-int-数组创建" class="headerlink" title="1.3 int[] 数组创建"></a>1.3 int[] 数组创建</h3><p>有时候我们还需要用两个 char 表示一个字符，比如 😂 这个笑哭的字符，它用 unicode 编码表示为 0x1F602，存储范围已经超过了 char 能表示的最大值 0xFFFF，因此需要使用 int[] 来构造这样的字符串，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0x1F602</span>&#125;, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>转换过程如图所示</p><p><img src="st05.png" alt=""></p><blockquote><p>参考</p><p><a href="http://unicode.org/versions/Unicode9.0.0/" target="_blank" rel="noopener">unicode 9.0 说明</a></p><p><a href="http://www.unicode.org/emoji/charts/emoji-versions.html#v9.0_2016" target="_blank" rel="noopener">unicode 中的 emoji 表情</a></p></blockquote><h3 id="1-4-从已有字符串创建"><a href="#1-4-从已有字符串创建" class="headerlink" title="1.4 从已有字符串创建"></a>1.4 从已有字符串创建</h3><p>直接看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种最为简单，但要注意是两个字符串对象<strong>引用同一个 char[] 对象</strong>，但是引用值不相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(s1);</span><br></pre></td></tr></table></figure><p>内存结构如下</p><p><img src="st09.png" alt=""></p><h3 id="1-5-字面量创建"><a href="#1-5-字面量创建" class="headerlink" title="1.5 字面量创建"></a>1.5 字面量创建</h3><p>以上四种创建方式，大家用的实际上相对少一点，最熟悉的是这种字面量的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"abc"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>&quot;abc&quot;</code>  被叫做字符串字面量</strong>（英文 Literal），但恰恰是这种方式其实奥妙最多<ul><li><strong>非对象</strong></li><li><strong>懒加载</strong></li><li><strong>不重复</strong></li></ul></li></ul><h4 id="1-5-1非对象"><a href="#1-5-1非对象" class="headerlink" title="1.5.1非对象"></a>1.5.1非对象</h4><p>严格地说，<strong>字面量在代码运行到它所在语句之前，它还不是字符串对象</strong></p><p>要理解从字面量变成字符串对象的过程，需要从字节码的角度来分析</p><p>在上面的 java 代码被编译为 class 文件后，<code>&quot;abc&quot;</code>  存储于【类文件常量池】中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constant pool: &#x2F;&#x2F; 常量池</span><br><span class="line">   #1 &#x3D; Methodref          #19.#41        &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; String             #42            &#x2F;&#x2F; abc</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>当 class 完成类加载之后，<code>&quot;abc&quot;</code>  这个字面量被存储于【运行时常量池】（归属于方法区）中，其中 #1 #2 都会被翻译为运行时真正的内存地址</p><p>再看一下 class 中 main 方法的字节码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]); &#x2F;&#x2F; 字节码指令</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;2, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String abc</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: return</span><br><span class="line">         ...</span><br></pre></td></tr></table></figure><p>将来 main 方法被调用时，就会执行里面的字节码指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: ldc           #2                  &#x2F;&#x2F; String abc</span><br><span class="line">2: astore_1</span><br><span class="line">3: return</span><br></pre></td></tr></table></figure><p><strong><code>ldc #2</code> 就是到运行时常量池中找到 #2 的内存地址，找到 <code>&quot;abc&quot;</code>  这个字面量，再根据它创建一个 String 对象。</strong></p><p><img src="st11.png" alt=""></p><h4 id="1-5-2懒加载"><a href="#1-5-2懒加载" class="headerlink" title="1.5.2懒加载"></a>1.5.2懒加载</h4><ul><li><p><strong>当第一次用到 <code>&quot;abc&quot;</code>  字面量时（就是执行到 <code>ldc #2</code> 时） ，才会创建对应的字符串对象</strong></p></li><li><p>如何验证呢？</p></li></ul><p>例如有如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"1"</span>); <span class="comment">// 断点1 2411</span></span><br><span class="line">System.out.println(<span class="string">"2"</span>); <span class="comment">// 断点2 2412</span></span><br><span class="line">System.out.println(<span class="string">"3"</span>); <span class="comment">// 断点3</span></span><br></pre></td></tr></table></figure><p>可以给每行语句加上断点，然后用 idea 的 debug 界面中的 memory 工具来查看字符串对象的数量</p><p>刚开始在断点1 处，其它类中创建的字符串对象有 2411 个</p><p><img src="st06.png" alt=""></p><p>执行到断点2 处，这时新创建了 <code>&quot;1&quot;</code> 对应的字符串对象，个数为 2412</p><p><img src="st07.png" alt=""></p><p>执行到断点3 处，这时新创建了 <code>&quot;2&quot;</code> 对应的字符串对象，个数为 2413</p><p><img src="st08.png" alt=""></p><h4 id="1-5-3不重复"><a href="#1-5-3不重复" class="headerlink" title="1.5.3不重复"></a>1.5.3不重复</h4><p><strong>同一个类中的值相同字面量，其实只有一份</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量池为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #25.#48        &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; String             #49            &#x2F;&#x2F; abc</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>对应的字节码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String abc</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: ldc           #2                  &#x2F;&#x2F; String abc</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: return</span><br><span class="line">         ...</span><br></pre></td></tr></table></figure><p>可以看到 <code>&quot;abc&quot;</code> 这个字面量虽然出现了 2 次，但实际上都是对应着常量池中 #2 这个地址</p><p>如果是不同类中的 <code>&quot;abc&quot;</code> 呢？【类文件常量池】包括【运行时常量池】都是以类为单位的</p><p>例如，另一个类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"a"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的常量池</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #5.#22         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = String             #23            // a</span><br><span class="line">   #3 = String             #24            // abc</span><br></pre></td></tr></table></figure><p>可以看到在这个类中，<code>&quot;abc&quot;</code> 对应的常量池的编号是 #3，与 TestString1 中的已经不同</p><p>这时候【字面量】是两份，而【字符串对象】会有几个呢？</p><p>我们来做个实验，把刚才的代码做个改写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>; <span class="comment">// 字符串对象 "abc"</span></span><br><span class="line">        String s2 = <span class="string">"abc"</span>; <span class="comment">// 字符串对象 "abc"</span></span><br><span class="line">        TestString2.main(<span class="keyword">new</span> String[]&#123;s1, s2&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// args[0] "abc", args[1] "abc"</span></span><br><span class="line">        String s1 = <span class="string">"a"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(args[<span class="number">0</span>] == s2);</span><br><span class="line">        System.out.println(args[<span class="number">1</span>] == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>具体原理我们下一个章节再讲</p><h3 id="1-5-拼接创建"><a href="#1-5-拼接创建" class="headerlink" title="1.5 拼接创建"></a>1.5 拼接创建</h3><p>最后还可以通过 <code>+</code> 运算符将两个字符串（其中一个也可以是其它类型）拼接为一个新字符串，例如</p><p>例1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span> + <span class="string">"b"</span>;</span><br></pre></td></tr></table></figure><p>例2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="string">"a"</span> + x;</span><br></pre></td></tr></table></figure><p>例3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="string">"a"</span> + x;</span><br></pre></td></tr></table></figure><p>例4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>有同学会问，例1与例2与例3 不同吗？还别说，真就不同，其中例1 与例2 原理是一样的，例3 与例4 原理是一样的，反编译一下</p><p>例1 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span> + <span class="string">"b"</span>;</span><br></pre></td></tr></table></figure><p>常量池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #4.#20         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; String             #21            &#x2F;&#x2F; ab</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>主方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;2, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String ab</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: return</span><br><span class="line">         ...</span><br></pre></td></tr></table></figure><p>可以看到，其实并没有真正的【拼接】操作发生，从源码编译为字节码时，javac 就已经把 “a” 和 “b” 串在一起了，这是一种编译期的优化处理</p><p>例2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="string">"a"</span> + x;</span><br></pre></td></tr></table></figure><p>常量池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #5.#22         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; String             #23            &#x2F;&#x2F; b</span><br><span class="line">   #3 &#x3D; String             #24            &#x2F;&#x2F; ab</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>主方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String b   final b</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: ldc           #3                  &#x2F;&#x2F; String ab</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: return</span><br><span class="line">         ...</span><br></pre></td></tr></table></figure><p>可以看到，还是没有真正的【拼接】操作发生，final 意味着 x 的值不可改变，因此其它引用 x 的地方都可以安全地被替换为 “b”，而不用担心 x 被改变，从源码编译为字节码时，javac 就也进行了优化，把所有出现 x 的地方都替换成为了 “b”</p><p>那么，什么是真正的【拼接】操作呢？看一下例3 反编译后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="string">"a"</span> + x;</span><br></pre></td></tr></table></figure><p>常量池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #9.#26         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; String             #27            &#x2F;&#x2F; b</span><br><span class="line">   #3 &#x3D; Class              #28            &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">   #4 &#x3D; Methodref          #3.#26         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #5 &#x3D; String             #29            &#x2F;&#x2F; a</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>可以看到常量池中并没有 ab 字面量</p><p>主方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String b</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: new           #3                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">         6: dup</span><br><span class="line">         7: invokespecial #4                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        10: ldc           #5                  &#x2F;&#x2F; String a</span><br><span class="line">        12: invokevirtual #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        15: aload_1</span><br><span class="line">        16: invokevirtual #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        19: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">        22: astore_2</span><br><span class="line">        23: return</span><br></pre></td></tr></table></figure><p>翻译成人能读懂的就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="string">"a"</span> + x;</span><br><span class="line"></span><br><span class="line">String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="keyword">new</span> StringBuilder().append(<span class="string">"a"</span>).append(x).toString();</span><br></pre></td></tr></table></figure><p>StringBuilder 的 toString() 方法又是怎么实现的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从 AbstractStringBuilder 继承的属性，方便阅读加在此处</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create a copy, don't share the array</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，本质上就是根据 StringBuilder 维护的 char[] 创建了新的 String 对象</p><h3 id="1-6-JDK-9-之后的改变"><a href="#1-6-JDK-9-之后的改变" class="headerlink" title="1.6 JDK 9 之后的改变"></a>1.6 JDK 9 之后的改变</h3><p>前面我们讲的是 JDK 8 中的字符串，但从 JDK 9 开始，String 的内部存储方式、以及拼接方式又发生了较大的改变</p><ul><li>不再用 char[] 存储字符，改为了 byte[]，目的是更节约内存</li><li>使用 invokedynamic 指令扩展了字符串的拼接的实现方式</li></ul><h4 id="1-6-1内存结构改变"><a href="#1-6-1内存结构改变" class="headerlink" title="1.6.1内存结构改变"></a>1.6.1内存结构改变</h4><p>例如，字符串中仅有拉丁字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;);</span><br></pre></td></tr></table></figure><p><img src="st12.png" alt=""></p><p>例如，字符串中有中文字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(</span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;(<span class="keyword">byte</span>) <span class="number">0xd5</span>, (<span class="keyword">byte</span>) <span class="number">0xc5</span>&#125;, </span><br><span class="line">    Charset.forName(<span class="string">"gbk"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="st13.png" alt=""></p><p>例如，既有中文字符也有拉丁字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(</span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;(<span class="keyword">byte</span>) <span class="number">0xd5</span>, (<span class="keyword">byte</span>) <span class="number">0xc5</span>, <span class="number">97</span>&#125;, </span><br><span class="line">    Charset.forName(<span class="string">"gbk"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="st14.png" alt=""></p><h4 id="1-6-2拼接方式改变"><a href="#1-6-2拼接方式改变" class="headerlink" title="1.6.2拼接方式改变"></a>1.6.2拼接方式改变</h4><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String x = <span class="string">"b"</span>;</span><br><span class="line">    String s = <span class="string">"a"</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #5.#22         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; String             #23            &#x2F;&#x2F; b</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>主方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String b</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: aload_1</span><br><span class="line">         4: invokedynamic #3,  0              &#x2F;&#x2F; InvokeDynamic #0:makeConcatWithConstants:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">         9: astore_2</span><br><span class="line">        10: return</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>直接跟 <code>invokedynamic</code> 对应的字节码比较难，我直接翻译成人能看懂的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    String x = <span class="string">"b"</span>;</span><br><span class="line">    <span class="comment">// String s = "a" + x; </span></span><br><span class="line">    <span class="comment">// 会生成如下等价的字节码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器会提供 lookup，用来查找 MethodHandle</span></span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    CallSite callSite = StringConcatFactory.makeConcatWithConstants(</span><br><span class="line">        lookup,</span><br><span class="line">        <span class="comment">// 方法名，不重要，编译器会自动生成</span></span><br><span class="line">        <span class="string">"arbitrary"</span>,</span><br><span class="line">        <span class="comment">// 方法的签名，第一个 String 为返回值类型，之后是入参类型</span></span><br><span class="line">        MethodType.methodType(String<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class">        // 具体处方格式，其中 \1 意思是变量的占位符，将来被 <span class="title">x</span> 代替</span></span><br><span class="line">        "a\1"</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// callSite.getTarget() 返回的是 MethodHandle 对象，用来反射执行拼接方法</span></span><br><span class="line">    String s = (String) callSite.getTarget().invoke(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么搞这么麻烦！！！</strong>主要是为了对字符串的拼接做各种扩展优化，多了扩展途径。其中最为重要的是 <code>MethodHandle</code> ，它使用了<strong>策略模式</strong>生成，JDK 提供的所有的策略可以在 <code>StringConcatFactory.Strategy</code> 中找到：</p><table><thead><tr><th>策略名</th><th>内部调用</th><th>解释</th></tr></thead><tbody><tr><td>BC_SB</td><td>字节码拼接生成 StringBuilder 代码</td><td>等价于 new StringBuilder()</td></tr><tr><td>BC_SB_SIZED</td><td>字节码拼接生成 StringBuilder 代码</td><td>等价于 new StringBuilder(n) n为预估大小</td></tr><tr><td>BC_SB_SIZED_EXACT</td><td>字节码拼接生成 StringBuilder 代码</td><td>等价于 new StringBuilder(n) n为准确大小</td></tr><tr><td>MH_SB_SIZED</td><td>MethodHandle 生成 StringBuilder 代码</td><td>等价于 new StringBuilder(n) n为预估大小</td></tr><tr><td>MH_SB_SIZED_EXACT</td><td>MethodHandle 生成 StringBuilder 代码</td><td>等价于 new StringBuilder(n) n为准确大小</td></tr><tr><td>MH_INLINE_SIZED_EXACT</td><td>MethodHandle 内部使用字节数组直接构造出 String</td><td>默认策略</td></tr></tbody></table><p>如果想改变策略，可以在运行时添加 JVM 参数，例如将策略改为 BC_SB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Djava.lang.invoke.stringConcat&#x3D;BC_SB</span><br><span class="line">-Djava.lang.invoke.stringConcat.debug&#x3D;true</span><br><span class="line">-Djava.lang.invoke.stringConcat.dumpClasses&#x3D;匿名类导出路径</span><br></pre></td></tr></table></figure><p>还有一种选择，是在 <code>javac</code> 编译时仍使用JDK1.5<code>StringBuilder</code>的办法拼接字符串，而不是采用 <code>invokedynamic</code>，就是在 <code>javac</code> 时加上参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XDstringConcat&#x3D;inline</span><br></pre></td></tr></table></figure><h4 id="1-6-3默认拼接策略"><a href="#1-6-3默认拼接策略" class="headerlink" title="1.6.3默认拼接策略"></a>1.6.3默认拼接策略</h4><p>默认策略为 MH_INLINE_SIZED_EXACT，使用字节数组直接构造出 String</p><p>例如有下面的字符串拼接代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="string">"a"</span> + x + <span class="string">"c"</span> + <span class="string">"d"</span>;</span><br></pre></td></tr></table></figure><p>使用了 MH_INLINE_SIZED_EXACT 策略后，内部会执行如下等价调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"b"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预先分配字符串需要的字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新字符串，这时内部字节数组值为 [0,0,0,0]</span></span><br><span class="line">String s = StringConcatHelper.newString(buf, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行【拼接】，字符串内部字节数组值为 [97,0,0,0]</span></span><br><span class="line">StringConcatHelper.prepend(<span class="number">1</span>, buf, <span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行【拼接】，字符串内部字节数组值为 [97,98,0,0]</span></span><br><span class="line">StringConcatHelper.prepend(<span class="number">2</span>, buf, x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行【拼接】，字符串内部字节数组值为 [97,98,99,100]</span></span><br><span class="line">StringConcatHelper.prepend(<span class="number">4</span>, buf, <span class="string">"cd"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到此【拼接完毕】</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> </p><ul><li>StringConcatHelper 对外是不可见的，因此无法直接测试，只能反射测试</li><li>prepend 可以直接修改字符串中的 bytes 属性值，他们都是 java.lang 包下的</li></ul></blockquote><h4 id="1-6-4模仿-BC-SB-策略"><a href="#1-6-4模仿-BC-SB-策略" class="headerlink" title="1.6.4模仿 BC_SB 策略"></a>1.6.4模仿 BC_SB 策略</h4><p>接下来我模拟其中一种策略的实现过程：以字节码指令生成拼接方法为例</p><p>先说明一下我的目的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"hello,"</span>;</span><br><span class="line">String y = <span class="string">"world"</span>;</span><br><span class="line">String s = x + y;</span><br></pre></td></tr></table></figure><p>其中 + 可以被 invokedynamic 优化为多种实现策略，如果让我自己来实现，我仅会用 StringBuilder 来拼接，因此我希望 x+y 能够被翻译为对下面方法的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concat</span><span class="params">(String x, String y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder().append(x).append(y).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-方法手动生成"><a href="#1-方法手动生成" class="headerlink" title="1. 方法手动生成"></a>1. 方法手动生成</h5><p>提供一个拼接方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concat</span><span class="params">(String x, String y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder().append(x).append(y).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 MethodHandle 反射调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"hello,"</span>;</span><br><span class="line">String y = <span class="string">"world"</span>;</span><br><span class="line">MethodHandle mh = MethodHandles.lookup().findStatic(</span><br><span class="line">    TestString4<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">    "concat", </span><br><span class="line">    MethodType.methodType(String<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">)</span>;</span><br><span class="line">String s = (String) mh.invoke(x,y);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello,world</span><br></pre></td></tr></table></figure><p>但这样需要自己提供 concat 方法，而且其参数个数都固定死了，能否动态生成这么一个方法呢，答案是肯定的，为了简化生成逻辑，这里我仍然以固定参数为例</p><h5 id="2-字节码生成方法"><a href="#2-字节码生成方法" class="headerlink" title="2. 字节码生成方法"></a>2. 字节码生成方法</h5><p>Unsafe 对象访问类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeAccessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 asm 生成匿名类字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] dump() &#123;</span><br><span class="line"></span><br><span class="line">    ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">    FieldVisitor fv;</span><br><span class="line">    MethodVisitor mv;</span><br><span class="line">    AnnotationVisitor av0;</span><br><span class="line"></span><br><span class="line">    cw.visit(<span class="number">52</span>, ACC_PUBLIC + ACC_SUPER, <span class="string">"cn/itcast/string/TestString4"</span>, <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    cw.visitSource(<span class="string">"TestString4.java"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        mv = cw.visitMethod(ACC_PUBLIC, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        mv.visitCode();</span><br><span class="line">        Label l0 = <span class="keyword">new</span> Label();</span><br><span class="line">        mv.visitLabel(l0);</span><br><span class="line">        mv.visitLineNumber(<span class="number">3</span>, l0);</span><br><span class="line">        mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">        mv.visitMethodInsn(INVOKESPECIAL, <span class="string">"java/lang/Object"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">false</span>);</span><br><span class="line">        mv.visitInsn(RETURN);</span><br><span class="line">        Label l1 = <span class="keyword">new</span> Label();</span><br><span class="line">        mv.visitLabel(l1);</span><br><span class="line">        mv.visitLocalVariable(<span class="string">"this"</span>, <span class="string">"Lcn/itcast/string/TestString4;"</span>, <span class="keyword">null</span>, l0, l1, <span class="number">0</span>);</span><br><span class="line">        mv.visitMaxs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        mv.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, <span class="string">"concat"</span>, <span class="string">"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        mv.visitCode();</span><br><span class="line">        Label l0 = <span class="keyword">new</span> Label();</span><br><span class="line">        mv.visitLabel(l0);</span><br><span class="line">        mv.visitLineNumber(<span class="number">9</span>, l0);</span><br><span class="line">        mv.visitTypeInsn(NEW, <span class="string">"java/lang/StringBuilder"</span>);</span><br><span class="line">        mv.visitInsn(DUP);</span><br><span class="line">        mv.visitMethodInsn(INVOKESPECIAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">false</span>);</span><br><span class="line">        mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">        mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line">        mv.visitVarInsn(ALOAD, <span class="number">1</span>);</span><br><span class="line">        mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line">        mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"toString"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">false</span>);</span><br><span class="line">        mv.visitInsn(ARETURN);</span><br><span class="line">        Label l1 = <span class="keyword">new</span> Label();</span><br><span class="line">        mv.visitLabel(l1);</span><br><span class="line">        mv.visitLocalVariable(<span class="string">"x"</span>, <span class="string">"Ljava/lang/String;"</span>, <span class="keyword">null</span>, l0, l1, <span class="number">0</span>);</span><br><span class="line">        mv.visitLocalVariable(<span class="string">"y"</span>, <span class="string">"Ljava/lang/String;"</span>, <span class="keyword">null</span>, l0, l1, <span class="number">1</span>);</span><br><span class="line">        mv.visitMaxs(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        mv.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    cw.visitEnd();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cw.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么多字节码主要目的仅仅是生成一个匿名类的字节码，其中包括了拼接方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concat</span><span class="params">(String x, String y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder().append(x).append(y).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就可以生成匿名类，供 MethodHandler 反射调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成匿名类所需字节码</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = dump();</span><br><span class="line"><span class="comment">// 根据字节码生成匿名类.class</span></span><br><span class="line">Class&lt;?&gt; innerClass = UnsafeAccessor.UNSAFE</span><br><span class="line">    .defineAnonymousClass(TestString4<span class="class">.<span class="keyword">class</span>, <span class="title">bytes</span>, <span class="title">null</span>)</span>;</span><br><span class="line"><span class="comment">// 确保匿名类初始化</span></span><br><span class="line">UnsafeAccessor.UNSAFE.ensureClassInitialized(innerClass);</span><br><span class="line"><span class="comment">// 找到匿名类中 String concat(String x, String y)</span></span><br><span class="line">MethodHandle mh = MethodHandles.lookup().findStatic(</span><br><span class="line">    innerClass,</span><br><span class="line">    <span class="string">"concat"</span>, </span><br><span class="line">    MethodType.methodType(String<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">)</span>;</span><br></pre></td></tr></table></figure><p>最终就可以使用该 MethodHandle 反射完成字符串拼接了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"hello,"</span>;</span><br><span class="line">String y = <span class="string">"world"</span>;</span><br><span class="line">String s = (String) mh.invoke(x, y);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello,world</span><br></pre></td></tr></table></figure><p>JDK 9 当然做的更为专业，可以适配生成不同的参数个数、类型的 MethodHandle，但原理就是这样。</p><h2 id="2-字符串之家-StringTable"><a href="#2-字符串之家-StringTable" class="headerlink" title="2.字符串之家 - StringTable"></a>2.字符串之家 - StringTable</h2><h3 id="2-1-家养与野生"><a href="#2-1-家养与野生" class="headerlink" title="2.1 家养与野生"></a>2.1 家养与野生</h3><p>其实字符串分为家养的和野生的。</p><p>前面我们讲解了 String 的六种创建方式，<strong>除了字面量方式创建的字符串是家养的以外，其它方法创建的字符串都是野生的。</strong>什么意思呢？</p><ul><li><p>字面量方式创建的字符串，会放入 StringTable 中，StringTable 管理的字符串，才具有不重复的特性，这种就像是家养的</p></li><li><p>而 char[]，byte[]，int[]，String，以及 + 方式本质上都是使用 new 来创建，它们都是在堆中创建新的字符串对象，<strong>不会考虑字符串重不重复</strong>，这种就像是野生的，野生字符串的缺点就是如果存在大量值相同的字符串，对内存占用非常严重</p></li></ul><p>如何保证家养的字符串对象不重复呢？JDK 使用了 <strong>StringTable 来解决，StringTable 是采用 c++ 代码编写的，数据结构上就是一个 hash 表</strong>，字符串对象就充当 hash 表中的 key，key 的不重复性，是 hash 表的基本特性</p><p><img src="st10.png" alt=""></p><p>当代码运行到一个字面量 “abc” 时，会首先检查 StringTable 中有没有相同的 key，如果没有，创建新字符串对象加入；否则直接返回已有的字符串对象</p><h3 id="2-2-收留野生字符串"><a href="#2-2-收留野生字符串" class="headerlink" title="2.2 收留野生字符串"></a>2.2 收留野生字符串</h3><p>野生的字符串也有机会得到教育</p><p>字符串提供了 intern 方法来实现去重，让字符串对象有机会受到 StringTable 的管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>它会尝试将调用者放入 StringTable</p><h4 id="2-2-1如果-StringTable-中已有"><a href="#2-2-1如果-StringTable-中已有" class="headerlink" title="2.2.1如果 StringTable 中已有"></a>2.2.1如果 StringTable 中已有</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = ...;</span><br><span class="line">String s = x.intern();</span><br></pre></td></tr></table></figure><p>总会返回家养的 String 对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant x as x</span><br><span class="line">participant s as s</span><br><span class="line">participant st as StringTable</span><br><span class="line"></span><br><span class="line">x -&gt;&gt; st : intern()</span><br><span class="line">st -&gt;&gt; st : 如果已有</span><br><span class="line">st --&gt;&gt; s : 返回 StringTable 对象</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;); <span class="comment">// 野生的</span></span><br><span class="line">String y = <span class="string">"abc"</span>; <span class="comment">// 将 "abc"字符串对象 加入 StringTable</span></span><br><span class="line">String z = x.intern(); <span class="comment">// 已有，返回 StringTable 中 "abc"，即 y</span></span><br><span class="line">System.out.println(z == y);</span><br><span class="line">System.out.println(z == x);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h4 id="2-2-2如果-StringTable-中没有（1-7-以上-JDK-的做法）"><a href="#2-2-2如果-StringTable-中没有（1-7-以上-JDK-的做法）" class="headerlink" title="2.2.2如果 StringTable 中没有（1.7 以上 JDK 的做法）"></a>2.2.2如果 StringTable 中没有（1.7 以上 JDK 的做法）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = ...;</span><br><span class="line">String s = x.intern();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant x as x</span><br><span class="line">participant s as s</span><br><span class="line">participant st as StringTable</span><br><span class="line"></span><br><span class="line">x -&gt;&gt; st : intern()</span><br><span class="line">st -&gt;&gt; st : 如果没有</span><br><span class="line">st -&gt;&gt; st : 将x引用的对象加入</span><br><span class="line">st --&gt;&gt; s : 返回 StringTable 对象</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;); <span class="comment">// 野生的</span></span><br><span class="line">String z = x.intern(); <span class="comment">// 野生的 x 加入 StringTable，StringTable 中有了 "abc"</span></span><br><span class="line">String y = <span class="string">"abc"</span>; <span class="comment">// 已有，不会产生新的对象，用的是 StringTable 中 "abc"</span></span><br><span class="line">System.out.println(z == x);</span><br><span class="line">System.out.println(z == y);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><h4 id="2-2-3如果-StringTable-中没有（1-6-JDK-的做法）"><a href="#2-2-3如果-StringTable-中没有（1-6-JDK-的做法）" class="headerlink" title="2.2.3如果 StringTable 中没有（1.6 JDK 的做法）"></a>2.2.3如果 StringTable 中没有（1.6 JDK 的做法）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = ...;</span><br><span class="line">String s = x.intern();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant x as x</span><br><span class="line">participant s as s</span><br><span class="line">participant st as StringTable</span><br><span class="line"></span><br><span class="line">x -&gt;&gt; st : intern()</span><br><span class="line">st -&gt;&gt; st : 如果没有</span><br><span class="line">st -&gt;&gt; st : 将x引用的对象复制</span><br><span class="line">st -&gt;&gt; st : 将复制后的对象加入</span><br><span class="line">st --&gt;&gt; s : 返回 StringTable 对象</span><br></pre></td></tr></table></figure><p>例子，代码同上面 1.7 相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;); <span class="comment">// 野生的</span></span><br><span class="line">String z = x.intern(); <span class="comment">// 野生的 x 被复制后加入 StringTable，StringTable 中有了 "abc"</span></span><br><span class="line">String y = <span class="string">"abc"</span>; <span class="comment">// 已有，不会产生新的对象，用的是 StringTable 中 "abc"</span></span><br><span class="line">System.out.println(z == x);</span><br><span class="line">System.out.println(z == y);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><h3 id="2-3-去重的好处"><a href="#2-3-去重的好处" class="headerlink" title="2.3 去重的好处"></a>2.3 去重的好处</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 intern 减少内存占用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        List&lt;String&gt; address = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"linux.words"</span>), <span class="string">"utf-8"</span>))) &#123;</span><br><span class="line">                String line = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    line = reader.readLine();</span><br><span class="line">                    <span class="keyword">if</span>(line == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    address.add(line.intern());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"cost:"</span> +(System.nanoTime()-start)/<span class="number">1000000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-家的位置"><a href="#2-4-家的位置" class="headerlink" title="2.4 家的位置"></a>2.4 家的位置</h3><p><strong>StringTable 的位置（1.6）</strong></p><p><img src="8.png" alt=""></p><p><strong>StringTable 的位置（1.8）</strong></p><p>![](</p><p>9.png)</p><p>如何证明</p><ul><li>1.6 不断将字符串用 intern 加入 StringTable，最后撑爆的是永久代内存，为了让错误快速出现，将永久代内存设置的小一些：<code>-XX:MaxPermSize=10m</code>，最终会出现 <code>java.lang.OutOfMemoryError: PermGen space</code></li><li>1.8 不断将字符串用 intern 加入 StringTable，最后撑爆的是堆内存，为了让错误快速出现，将堆内存设置的小一些：<code>-Xmx10m -XX:-UseGCOverheadLimit</code> 后一个虚拟机参数是避免 GC 频繁引起其他错误而不是我们期望的 <code>java.lang.OutOfMemoryError: Java heap space</code></li></ul><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 StringTable 位置</span></span><br><span class="line"><span class="comment"> * 在jdk8下设置 -Xmx10m -XX:-UseGCOverheadLimit</span></span><br><span class="line"><span class="comment"> * 在jdk6下设置 -XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">260000</span>; j++) &#123;</span><br><span class="line">                list.add(String.valueOf(j).intern());</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-intern-去重原理"><a href="#2-5-intern-去重原理" class="headerlink" title="2.5 intern 去重原理"></a>2.5 intern 去重原理</h3><p>查阅一下 jdk 的源码</p><p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/5bd0e0bcb152/src/share/vm/classfile/symbolTable.cpp" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/5bd0e0bcb152/src/share/vm/classfile/symbolTable.cpp</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string_or_null 字符串对象</span></span><br><span class="line"><span class="comment">// name 字符串原始指针</span></span><br><span class="line"><span class="comment">// len 字符串长度</span></span><br><span class="line">oop StringTable::intern(Handle string_or_null, jchar* name,</span><br><span class="line">                        <span class="keyword">int</span> len, TRAPS) &#123;</span><br><span class="line">  <span class="comment">// 获取字符串的 hash 值</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hashValue = hash_string(name, len);</span><br><span class="line">  <span class="comment">// 算出 hash table 桶下标  </span></span><br><span class="line">  <span class="keyword">int</span> index = the_table()-&gt;hash_to_index(hashValue);</span><br><span class="line">  <span class="comment">// 看字符串在 hash table 中有没有 </span></span><br><span class="line">  oop found_string = the_table()-&gt;lookup(index, name, len, hashValue);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有，直接返回（避免重复加入）</span></span><br><span class="line">  <span class="keyword">if</span> (found_string != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保该字符串对象没有被垃圾回收  </span></span><br><span class="line">    ensure_string_alive(found_string);</span><br><span class="line">    <span class="keyword">return</span> found_string;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  debug_only(StableMemoryChecker smc(name, len * <span class="keyword">sizeof</span>(name[<span class="number">0</span>])));</span><br><span class="line">  assert(!Universe::heap()-&gt;is_in_reserved(name),</span><br><span class="line">         <span class="string">"proposed name of symbol must be stable"</span>);</span><br><span class="line"></span><br><span class="line">  Handle <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// try to reuse the string if possible</span></span><br><span class="line">  <span class="keyword">if</span> (!string_or_null.is_null()) &#123;</span><br><span class="line">    <span class="built_in">string</span> = string_or_null;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 根据 unicode 创建【字符串对象 string】 </span></span><br><span class="line">    <span class="built_in">string</span> = java_lang_String::create_from_unicode(name, len, CHECK_NULL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> INCLUDE_ALL_GCS</span></span><br><span class="line">  <span class="keyword">if</span> (G1StringDedup::is_enabled()) &#123;</span><br><span class="line">    <span class="comment">// Deduplicate the string before it is interned. Note that we should never</span></span><br><span class="line">    <span class="comment">// deduplicate a string after it has been interned. Doing so will counteract</span></span><br><span class="line">    <span class="comment">// compiler optimizations done on e.g. interned string literals.</span></span><br><span class="line">    G1StringDedup::deduplicate(<span class="built_in">string</span>());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Grab the StringTable_lock before getting the_table() because it could</span></span><br><span class="line">  <span class="comment">// change at safepoint.</span></span><br><span class="line">  oop added_or_found;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLocker <span class="title">ml</span><span class="params">(StringTable_lock, THREAD)</span></span>;</span><br><span class="line">    <span class="comment">// 将【字符串对象 string】加入 hash table</span></span><br><span class="line">    added_or_found = the_table()-&gt;basic_add(index, <span class="built_in">string</span>, name, len,</span><br><span class="line">                                  hashValue, CHECK_NULL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ensure_string_alive(added_or_found);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> added_or_found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 lookup 的定义为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index 桶下标</span></span><br><span class="line"><span class="comment">// name 字符串原始指针</span></span><br><span class="line"><span class="comment">// len 字符串长度</span></span><br><span class="line"><span class="comment">// hash 哈希码</span></span><br><span class="line">oop StringTable::lookup(<span class="keyword">int</span> index, jchar* name,</span><br><span class="line">                        <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash) &#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (HashtableEntry&lt;oop, mtSymbol&gt;* l = bucket(index); l != <span class="literal">NULL</span>; l = l-&gt;next()) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (l-&gt;hash() == hash) &#123;</span><br><span class="line">      <span class="keyword">if</span> (java_lang_String::equals(l-&gt;literal(), name, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> l-&gt;literal();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果链表过长，需要 rehash</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt;= rehash_count &amp;&amp; !needs_rehashing()) &#123;</span><br><span class="line">    _needs_rehashing = check_rehash_table(count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 basic_add 的定义为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index_arg 桶下标</span></span><br><span class="line"><span class="comment">// string 字符串对象</span></span><br><span class="line"><span class="comment">// name 字符串原始指针</span></span><br><span class="line"><span class="comment">// len 字符串长度</span></span><br><span class="line">oop StringTable::basic_add(<span class="keyword">int</span> index_arg, Handle <span class="built_in">string</span>, jchar* name,</span><br><span class="line">                           <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> hashValue_arg, TRAPS) &#123;</span><br><span class="line"></span><br><span class="line">  assert(java_lang_String::equals(<span class="built_in">string</span>(), name, len),</span><br><span class="line">         <span class="string">"string must be properly initialized"</span>);</span><br><span class="line">  <span class="comment">// Cannot hit a safepoint in this function because the "this" pointer can move.</span></span><br><span class="line">  No_Safepoint_Verifier nsv;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if the symbol table has been rehashed, if so, need to recalculate</span></span><br><span class="line">  <span class="comment">// the hash value and index before second lookup.</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hashValue;</span><br><span class="line">  <span class="keyword">int</span> index;</span><br><span class="line">  <span class="keyword">if</span> (use_alternate_hashcode()) &#123;</span><br><span class="line">    hashValue = hash_string(name, len);</span><br><span class="line">    index = hash_to_index(hashValue);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    hashValue = hashValue_arg;</span><br><span class="line">    index = index_arg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Since look-up was done lock-free, we need to check if another</span></span><br><span class="line">  <span class="comment">// thread beat us in the race to insert the symbol.</span></span><br><span class="line"></span><br><span class="line">  oop test = lookup(index, name, len, hashValue); <span class="comment">// calls lookup(u1*, int)</span></span><br><span class="line">  <span class="keyword">if</span> (test != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// Entry already added</span></span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 构造新的 HashtableEntry 节点</span></span><br><span class="line">  HashtableEntry&lt;oop, mtSymbol&gt;* entry = new_entry(hashValue, <span class="built_in">string</span>());</span><br><span class="line">  <span class="comment">// 加入链表  </span></span><br><span class="line">  add_entry(index, entry);</span><br><span class="line">  <span class="comment">// 返回字符串对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-G1-去重"><a href="#2-6-G1-去重" class="headerlink" title="2.6 G1 去重"></a>2.6 G1 去重</h3><p>懒惰是程序员的一大美德，不追求懒惰的程序员不是好程序员</p><p>如果你使用的 JDK 8u20，那么可以使用下面的 JVM 参数开启 G1 垃圾回收器，并开启字符串去重功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC -XX:+UseStringDeduplication</span><br></pre></td></tr></table></figure><p>原理是让多个字符串对象引用同一个 char[] 来达到节省内存的目的</p><p><img src="st09.png" alt=""></p><p>特点</p><ul><li>由 G1 垃圾回收器在 minor gc 阶段自动分析优化，不需要程序员自己干预</li><li>只有针对那些多次回收还不死的字符串对象，才会进行去重优化，可以通过 <code>-XX:StringDeduplicationAgeThreshold=n</code> 来调整</li><li>可以通过 <code>-XX:+PrintStringDeduplicationStatistics</code> 查看 G1 去重的统计信息</li><li>与调用 intern 去重相比，G1 去重好处在于自动，但缺点是即使 char[] 不重复，但字符串对象本身还要占用一定内存（对象头、value引用、hash），intern 去重是字符串对象只存一份，更省内存</li></ul><h3 id="2-7-家的大小"><a href="#2-7-家的大小" class="headerlink" title="2.7 家的大小"></a>2.7 家的大小</h3><p>StringTable 足够大，才能发挥性能优势，大意味着 String 在 hash 表中冲突减少，链表短，性能高。</p><p>可以通过 <code>-XX:+PrintStringTableStatistics</code> 来查看 StringTable 的大小，<strong>JDK 8 中它的默认大小为 60013</strong></p><p><strong>要注意 StringTable 底层的 hash 表在 JVM 启动后大小就固定不变了</strong></p><p>这个 hash 表可以在链表长度太长时进行 rehash，但不是利用扩容实现的 rehash，而是通过重新计算字符串的 hash 值来让它们分布均匀</p><p>如果想在启动前调整 StringTable 的大小，可以通过 <code>-XX:StringTableSize=n</code> 来指定</p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示串池大小对性能的影响</span></span><br><span class="line"><span class="comment"> * -XX:+PrintStringTableStatistics -XX:StringTableSize=1009</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"linux.words"</span>), <span class="string">"utf-8"</span>))) &#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                line = reader.readLine();</span><br><span class="line">                <span class="keyword">if</span> (line == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                line.intern();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"cost:"</span> + (System.nanoTime() - start) / <span class="number">1000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8-字符串之死"><a href="#2-8-字符串之死" class="headerlink" title="2.8 字符串之死"></a>2.8 字符串之死</h3><p>字符串也是一个对象，只要是对象，终究逃不过死亡的命运。字符串对象与其它 Java 对象一样，只要失去了利用价值，就会被垃圾回收，无论是野生字符串，还是家养字符串</p><p>怎么证明家养的字符串也能被垃圾回收呢，可以用以下 JVM 参数来查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 StringTable 垃圾回收</span></span><br><span class="line"><span class="comment"> * -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123; <span class="comment">// j=100, j=10000</span></span><br><span class="line">                String.valueOf(j).intern();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、面试题讲解"><a href="#三、面试题讲解" class="headerlink" title="三、面试题讲解"></a>三、面试题讲解</h2><p><strong>1. 判断输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"string"</span>; <span class="comment">// 家</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"string"</span>); <span class="comment">// 野生</span></span><br><span class="line">String str3 = str2.intern(); <span class="comment">// 家</span></span><br><span class="line"></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//#1  false</span></span><br><span class="line">System.out.println(str1==str3);<span class="comment">//#2  true</span></span><br></pre></td></tr></table></figure><p><strong>2. 判断输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String baseStr = <span class="string">"baseStr"</span>;</span><br><span class="line"><span class="keyword">final</span> String baseFinalStr = <span class="string">"baseStr"</span>;</span><br><span class="line"></span><br><span class="line">String str1 = <span class="string">"baseStr01"</span>; <span class="comment">// 家</span></span><br><span class="line">String str2 = <span class="string">"baseStr"</span>+<span class="string">"01"</span>; <span class="comment">// 家</span></span><br><span class="line">String str3 = baseStr + <span class="string">"01"</span>; <span class="comment">// 野生</span></span><br><span class="line">String str4 = baseFinalStr+<span class="string">"01"</span>;<span class="comment">// 家</span></span><br><span class="line">String str5 = <span class="keyword">new</span> String(<span class="string">"baseStr01"</span>).intern(); <span class="comment">// 家</span></span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//#3 true</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//#4 false </span></span><br><span class="line">System.out.println(str1 == str4);<span class="comment">//#5 true</span></span><br><span class="line">System.out.println(str1 == str5);<span class="comment">//#6 true</span></span><br></pre></td></tr></table></figure><p><strong>3. 判断输出（注意版本）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"str"</span>)+<span class="keyword">new</span> String(<span class="string">"01"</span>);</span><br><span class="line">str2.intern(); <span class="comment">//1.6</span></span><br><span class="line">String str1 = <span class="string">"str01"</span>;</span><br><span class="line">System.out.println(str2==str1);<span class="comment">//#7 1.7 true, 1.6 false</span></span><br></pre></td></tr></table></figure><p><strong>4. 判断输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"str01"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"str"</span>)+<span class="keyword">new</span> String(<span class="string">"01"</span>);</span><br><span class="line">str2.intern();</span><br><span class="line">System.out.println(str2 == str1);<span class="comment">//#8 false</span></span><br></pre></td></tr></table></figure><p><strong>5. String s = new String(“xyz”)，创建了几个String Object?</strong></p><p><strong>6. 判断输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>7. 判断输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><strong>8. 判断输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"a"</span>;</span><br><span class="line">String s3 = <span class="string">"bc"</span>;</span><br><span class="line">String s4 = s2 + s3;</span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><strong>9. 判断输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">final</span> String s2 = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">final</span> String s3 = <span class="string">"bc"</span>;</span><br><span class="line">String s4 = s2 + s3;</span><br><span class="line">System.out.println(s1 == s4);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>10. 判断输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">// 野生</span></span><br><span class="line">String s1 = <span class="string">"abc"</span>; <span class="comment">// 家</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">// 野生</span></span><br><span class="line">System.out.println(s == s1.intern()); <span class="comment">// false</span></span><br><span class="line">System.out.println(s == s2.intern()); <span class="comment">// false</span></span><br><span class="line">System.out.println(s1 == s2.intern()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      字符串创建方式 StringTable
    
    </summary>
    
    
      <category term="Java高级" scheme="http://goldcarpenter.github.io/categories/Java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="JVM" scheme="http://goldcarpenter.github.io/tags/JVM/"/>
    
      <category term="String" scheme="http://goldcarpenter.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Spring FrameWork</title>
    <link href="http://goldcarpenter.github.io/2019/09/22/Spring_AOP/"/>
    <id>http://goldcarpenter.github.io/2019/09/22/Spring_AOP/</id>
    <published>2019-09-22T15:19:21.000Z</published>
    <updated>2020-06-17T03:24:07.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-AOP引入"><a href="#6-AOP引入" class="headerlink" title="6.AOP引入"></a>6.AOP引入</h1><h2 id="6-1-环境准备——引出问题"><a href="#6-1-环境准备——引出问题" class="headerlink" title="6.1.环境准备——引出问题"></a>6.1.环境准备——引出问题</h2><ul><li><code>sql</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table1 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">40</span>),</span><br><span class="line">money <span class="built_in">float</span></span><br><span class="line">)<span class="built_in">character</span> <span class="keyword">set</span> utf8 <span class="keyword">collate</span> utf8_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table1(<span class="keyword">name</span>,money) <span class="keyword">values</span>(<span class="string">"aaa"</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><img src="1578021143043.png" alt="1578021143043"></p><ul><li><code>pojo.Account.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.pojo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Float money;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Account&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", money="</span> + money +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get set function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>dao.impl.AccountDaoImpl.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.pojo.Account;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.utils.ConnectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QueryRunner runner;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> runner.query(connectionUtils.getThreadConnection(), <span class="string">"select * from table1"</span>,<span class="keyword">new</span> BeanListHandler&lt;Account&gt;(Account<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> runner.query(connectionUtils.getThreadConnection(), <span class="string">"select * from table1 where id = ?"</span>,<span class="keyword">new</span> BeanHandler&lt;Account&gt;(Account<span class="class">.<span class="keyword">class</span>),<span class="title">accountId</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        runner.update(connectionUtils.getThreadConnection(), <span class="string">"insert into table1(name,money) values(?,?) "</span>,account.getName(),account.getMoney());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        runner.update(connectionUtils.getThreadConnection(), <span class="string">"update table1 set name=?, money=? where id = ?"</span>,account.getName(),account.getMoney(),account.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAccount</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        runner.update(connectionUtils.getThreadConnection(), <span class="string">"delete from table1 where id=?"</span>,accountId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountByName</span><span class="params">(String accountName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Account&gt; accounts = runner.query(connectionUtils.getThreadConnection(), <span class="string">"select * from table1 where name=?"</span>, <span class="keyword">new</span> BeanListHandler&lt;Account&gt;(Account<span class="class">.<span class="keyword">class</span>), <span class="title">accountName</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (accounts == <span class="keyword">null</span> || accounts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (accounts.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"&gt;0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> accounts.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>dao.IAccountDao</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.carpenter.pojo.Account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function">Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function">Account <span class="title">findAccountByName</span><span class="params">(String accountName)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAccount</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>service.IAccountService</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.carpenter.pojo.Account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function">Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAccount</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>service.impl.AccountServiceImpl</code></strong><ul><li><strong>存在问题</strong>：<strong>大量【事务控制】的重复代码，引出问题</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.pojo.Account;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.utils.TransactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransactionManager tx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        List&lt;Account&gt; allAccount = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx.beginTransaction();</span><br><span class="line">            allAccount = accountDao.findAllAccount();</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            tx.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allAccount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx.beginTransaction();</span><br><span class="line">            account = accountDao.findAccountById(accountId);</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            tx.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx.beginTransaction();</span><br><span class="line">            accountDao.saveAccount(account);</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            tx.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx.beginTransaction();</span><br><span class="line">            accountDao.updateAccount(account);</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            tx.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAccount</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx.beginTransaction();</span><br><span class="line">            accountDao.deleteAccount(accountId);</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            tx.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx.beginTransaction();</span><br><span class="line">            Account sourceAccount = accountDao.findAccountByName(sourceName);</span><br><span class="line">            Account targetAccount = accountDao.findAccountByName(targetName);</span><br><span class="line">            sourceAccount.setMoney(sourceAccount.getMoney() - money);</span><br><span class="line">            targetAccount.setMoney(targetAccount.getMoney() + money);</span><br><span class="line">            accountDao.updateAccount(sourceAccount);</span><br><span class="line">            accountDao.updateAccount(targetAccount);</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            tx.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Client.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.ui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.pojo.Account;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        IAccountService accountService = (IAccountService) ac.getBean(<span class="string">"accountServiceImpl"</span>);</span><br><span class="line">        List&lt;Account&gt; allAccount = accountService.findAllAccount();</span><br><span class="line">        <span class="keyword">for</span>(Account item : allAccount)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(item.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        accountService.transfer(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="number">100f</span>);</span><br><span class="line">        allAccount =  accountService.findAllAccount();</span><br><span class="line">        <span class="keyword">for</span>(Account item : allAccount)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(item.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>bean.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top.carpenter"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">以下注释已用注解方式完成其功能 此处仅作参看</span><br><span class="line"><span class="comment">&lt;!--    &lt;bean id="accountService" class="top.carpenter.service.impl.AccountServiceImpl"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name="tx" ref="transactionManager"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name="accountDao" ref="accountDaoImpl"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean id="tx" class="top.carpenter.utils.TransactionManager"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name="connectionUtils" ref="connectionUtils"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean id="accountDao" class="top.carpenter.dao.impl.AccountDaoImpl"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name="connectionUtils" ref="connectionUtils"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name="runner" ref="runner"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean id="connectionUtils" class="top.carpenter.utils.ConnectionUtils"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name="dataSource" ref="dataSource"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runner"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbutils.QueryRunner"</span>  <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/spring_study"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>pom.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.carpenter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring_restudy_day01<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-2-代理前置知识"><a href="#6-2-代理前置知识" class="headerlink" title="6.2.代理前置知识"></a>6.2.代理前置知识</h2><h3 id="6-2-1静态代理"><a href="#6-2-1静态代理" class="headerlink" title="6.2.1静态代理"></a>6.2.1静态代理</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li>代理对象继承目标对象，重写需要增强的方法</li><li>缺点：会代理类过多,非常复杂<ul><li>日志子类 <strong>权限验证子类</strong> 运行时间计算子类</li><li>日志子类的权限验证继承类 <strong>权限验证子类的日志继承类</strong> 日志子类的运行时间计算继承类…</li><li>…</li></ul></li></ul><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><ul><li>【代理模式】</li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul><li><p>本质：生成<code>.class</code>字节数组，使用本地方法<code>defineClass0</code>生成<code>class</code>对象</p><p><img src="1590926927757.png" alt="1590926927757"></p></li><li><p>特点：字节码随用随创建，随用随加载</p></li><li><p>作用：不修改源码的基础上对方法增强</p></li></ul><h4 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h4><ul><li>涉及类：<code>Proxy</code></li><li>提供者：JDK官方</li><li>创建代理对象要求：被代理对象<strong>至少实现一个接口</strong>，如果没有则不能使用【已经继承了Proxy 不能多继承】</li><li>如何创建代理对象：<code>Proxy</code>类的<code>newProxyInstance()</code><ul><li><code>ClassLoader</code><ul><li>用于<strong>加载代理对象字节码的，和被代理对象使用相同的类加载器</strong>。</li><li>固定写法：<code>被代理对象.getClass().getClassLoader()</code></li></ul></li><li><code>Class[] interfaces</code><ul><li>是用于让<strong>反射得到的代理对象和被代理对象有相同方法</strong></li><li>固定写法：<code>被代理对象.getClass().getInterfaces()</code></li></ul></li><li><code>InvocationHandler</code>：<ul><li>写具体<strong>如何代理</strong>，一般都是接口的实现类。通常情况下都是<strong>匿名内部类</strong>，但不是必须的</li><li>此接口的实现类都是谁用谁写</li></ul></li></ul></li><li><code>IProducer.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Producer.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span>  <span class="title">IProducer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sale bonus is "</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Main.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> IProducer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        IProducer producerProxy = (IProducer)Proxy.newProxyInstance(producer.getClass().getClassLoader(),</span><br><span class="line">                producer.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Object returnValue = <span class="keyword">null</span>;</span><br><span class="line">                        Float money = (Float)args[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">if</span>(<span class="string">"saleProduct"</span>.equals(method.getName()))</span><br><span class="line">                            returnValue = method.invoke(producer,money*<span class="number">0.8f</span>);</span><br><span class="line">                        <span class="keyword">return</span> returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        producerProxy.saleProduct(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以将生成的Class对象保存下来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">IProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"><span class="comment">// 唯一的一个构造方法 就是传入InvocationHandler</span></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// protected InvocationHandler h; 解释了三个参数的由来</span></span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">"top.carpenter.IProducer"</span>).getMethod(<span class="string">"saleProduct"</span>, Float.TYPE);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h4><ul><li><code>pom.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>涉及类：<code>Enhancer</code></p></li><li><p>提供者：第三方<code>cglib</code>库</p></li><li><p>创建代理对象要求：被代理类不能是最终类</p></li><li><p>如何创建代理对象：<code>Enhancer</code>类的<code>create()</code></p><ul><li><code>Class</code><ul><li>固定写法：<code>被代理对象.getClass()</code></li></ul></li></ul><ul><li><code>Callback</code>：<ul><li>提供增强代码</li><li>写如何代理，一般都是接口的实现类。通常情况下都是匿名内部类，但不是必须的</li><li>此接口的实现类都是谁用谁写</li><li>一般写的都是该接口的子接口实现类：<code>MethodInterceptor</code></li></ul></li></ul></li><li><p><code>Producer.java</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span>  <span class="title">IProducer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sale bonus is "</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Main.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        System.out.println(producer);</span><br><span class="line">        Producer producerProxy = (Producer) Enhancer.create(producer.getClass(),</span><br><span class="line">                <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Object returnValue = <span class="keyword">null</span>;</span><br><span class="line">                        Float money = (Float)args[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">if</span>(<span class="string">"saleProduct"</span>.equals(method.getName()))</span><br><span class="line">                            returnValue =method.invoke(producer,money*<span class="number">0.8f</span>);</span><br><span class="line">                        <span class="keyword">return</span> returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        producerProxy.saleProduct(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-基于动态代理的问题解决"><a href="#6-3-基于动态代理的问题解决" class="headerlink" title="6.3.基于动态代理的问题解决"></a>6.3.基于动态代理的问题解决</h2><ul><li><code>factory.BeanFactory.java</code>——用于创建Service的代理类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.utils.TransactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IAccountService accountService;</span><br><span class="line">    <span class="keyword">private</span> TransactionManager tx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTx</span><span class="params">(TransactionManager tx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tx = tx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAccountService</span><span class="params">(IAccountService accountService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountService = accountService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IAccountService <span class="title">getAccountService</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        IAccountService proxyInstance = (IAccountService)Proxy.newProxyInstance(accountService.getClass().getClassLoader(),</span><br><span class="line">                accountService.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Object reValue = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            tx.beginTransaction();</span><br><span class="line">                            reValue = method.invoke(accountService, args);</span><br><span class="line">                            tx.commit();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">                        &#123;</span><br><span class="line">                            tx.rollback();</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                            tx.release();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> reValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> proxyInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>AccountServiceImpl</code>——文件变得清爽，问题解决</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.pojo.Account;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(IAccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  accountDao.findAllAccount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAccountById(accountId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        accountDao.saveAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        accountDao.updateAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAccount</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        accountDao.deleteAccount(accountId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Account sourceAccount = accountDao.findAccountByName(sourceName);</span><br><span class="line">        Account targetAccount = accountDao.findAccountByName(targetName);</span><br><span class="line">        sourceAccount.setMoney(sourceAccount.getMoney() - money);</span><br><span class="line">        targetAccount.setMoney(targetAccount.getMoney() + money);</span><br><span class="line">        accountDao.updateAccount(sourceAccount);</span><br><span class="line">        accountDao.updateAccount(targetAccount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>bean.xml</code>——修改一下部分内容</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyAccountService"</span> <span class="attr">factory-bean</span>=<span class="string">"beanFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getAccountService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanFactory"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.factory.BeanFactory"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountService"</span> <span class="attr">ref</span>=<span class="string">"accountService"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tx"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-4-基于Spring框架中AOP的问题解决"><a href="#6-4-基于Spring框架中AOP的问题解决" class="headerlink" title="6.4.基于Spring框架中AOP的问题解决"></a>6.4.基于Spring框架中AOP的问题解决</h2><ul><li><code>@EnableAspectJAutoProxy (proxyTargetClass=true)</code>——使用CGLib</li><li><code>@EnableAspectJAutoProxy (proxyTargetClass=false)</code><ul><li>实现接口——JDK官方动态代理</li><li>不实现接口——使用CGLib</li></ul></li><li>见7.2 &amp; 7.3</li></ul><h1 id="7-AOP"><a href="#7-AOP" class="headerlink" title="7.AOP"></a>7.AOP</h1><h2 id="AOP-amp-SpringAOP"><a href="#AOP-amp-SpringAOP" class="headerlink" title="AOP &amp; SpringAOP"></a>AOP &amp; SpringAOP</h2><ul><li><p><strong>AOP是一种思想</strong></p></li><li><p><strong>SpringAOP是AOP的一种实现</strong></p></li><li><p><strong>同样，AspectJ是AOP的一种实现</strong></p></li><li><p>Spring旧版有自己的AOP语法，但是非常复杂。</p></li><li><p><strong>故：Spring借助AspectJ的语法(AspectJ的注解，故要导入AspectJ的Jar包)，但底层使用自己Spring实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="7-1-AOP基础知识"><a href="#7-1-AOP基础知识" class="headerlink" title="7.1.AOP基础知识"></a>7.1.AOP基础知识</h2><ul><li><p><code>AOP</code>：全称是<code>Aspect oriented Programming</code>面向切面编程，通过预编译方式和<strong>运行期动态代理</strong>实现程序功能的统一维护的一种技术</p></li><li><p>作用：<strong>解决与主业务逻辑无关的横切性问题，把程序重复的代码抽取出来</strong>，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对已有方法进行增强</p></li><li><p>优势</p><ul><li>减少重复代码</li><li>提高开发效率</li><li>维护方便</li></ul></li><li><p><strong>与OOP对比</strong>，面向切面，传统的OOP开发中的代码逻辑是至上而下的，在这些至上而下的过程中会产生一些横切性的问题，这些横切性的问题和我们的主业务逻辑关系不大，会散落在代码的各个地方，造成难以维护，AOP的编程思想就是把业务逻辑和横切的问题进行分离，从而达到解耦的目的，使代码的重用性和开发效率高</p></li><li><p>应用场景</p><ul><li>日志记录</li><li>权限验证</li><li>效率检查</li><li>事务管理</li></ul></li><li><p>专业词汇</p><ul><li><p><code>Joinpoint</code>（连接点）</p><ul><li>被拦截到的点【如Service层的所有需要增强（目标对象）的方法】。在spring中，这些点指的是方法，因为spring只支持方法类型的连接点。</li></ul></li><li><p><code>Pointcut</code> （切入点）</p><ul><li>要对哪些Joinpoint进行拦截并增强【如Service层的需要增强的方法】，连接点的集合</li></ul></li><li><p><code>Advice</code>（通知/增强）</p><ul><li><p>所谓通知是指拦截到Joinpoint之后所要做的事情就是通知</p><ul><li>增强的位置</li><li>增强的内容</li></ul></li><li><p>通知的类型：</p><ul><li>前置通知，后置通知，异常通知，最终通知</li><li>环绕通知</li></ul><p><img src="1578117576531.png" alt="1578117576531"></p></li></ul></li><li><p><code>Introduction</code>（引介）:</p><ul><li><p>一种特殊的通知。在不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法或Field</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsageTracking</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DeclareParents</span>(value=<span class="string">"com.xzy.myapp.service.*"</span>, defaultImpl=DefaultUsageTracked<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">static</span> <span class="title">sageTracked</span> <span class="title">mixin</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Target</code>（目标对象）</p><ul><li>被代理的对象</li></ul></li><li><p><code>Weaving</code>（织入）</p><ul><li>织入：目标对象的需要增强的<strong>方法变</strong>成代理对象的<strong>方法的过程</strong></li><li>代理：目标对象变成代理对象的过程</li><li>spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入</li></ul></li><li><p><code>Proxy</code>（代理）</p><ul><li>一个类被AOP织入增强后，就产生一个结果代理类</li></ul></li><li><p><code>Aspect</code> （切面）</p><ul><li>切入点和通知(引介)的结合</li></ul></li></ul></li><li><p><code>pom.xml</code></p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="7-2-Spring中基于XML的AOP配置步骤"><a href="#7-2-Spring中基于XML的AOP配置步骤" class="headerlink" title="7.2.Spring中基于XML的AOP配置步骤"></a>7.2.Spring中基于XML的AOP配置步骤</h2><ul><li><p><code>通知Bean</code>也交给spring来管理</p></li><li><p><strong>使用<code>&lt;aop:config&gt;</code>标签表明开始AOP的配置</strong></p></li><li><p><strong>使用<code>&lt;aop:aspect&gt;</code>标签表明配置切面</strong></p><ul><li><strong><code>id</code>属性：切面唯一标识</strong></li><li><strong><code>ref</code>属性：通知类<code>bean</code>的<code>Id</code></strong></li></ul></li><li><p>在<code>&lt;aop:aspect&gt;</code>标签的<strong>内部使用对应标签</strong>来配置通知的类型</p><ul><li><code>&lt;aop:before&gt;</code>：表示配置前置通知<ul><li><code>method</code>属性：通知类中哪个方法是前置通知</li><li><code>pointcut</code>属性：切入点表达式，对业务层中哪些方法增强</li></ul></li><li>切入点表达式写法：<ul><li>关键字<code>execution(表达式)</code><ul><li>标准表达式：<code>访问修饰符 返回值 包名.包名.包名...类名.方法名(参数列表)</code></li><li><strong>访问修饰符可以省略</strong>：<code>返回值 包名.包名.包名...类名.方法名(参数列表)</code></li><li><strong>返回值可以使用通配符</strong>，表示任意返回值：<code>* 包名.包名.包名...类名.方法名(参数列表)</code></li><li>包名可以使用通配符，表示任意包。但是有几级包，需要写几个*：<code>*  *.*.*.类名.方法名(参数列表)</code></li><li>包名可以使用..表示当前包及其子包：<code>*  *..类名.方法名(参数列表)</code></li><li>类名和方法名都可以使用*来实现通配：<code>* *..*.*(参数列表)</code></li><li>参数列表可以直接写数据类型<ul><li>基本类型直接写名称——<code>int</code></li><li>引用类型写包名.类名的方式——<code>java.lang.String</code></li><li>可以使用通配符表示任意类型，但是必须有参数</li><li><strong>可以使用..表示有无参数均可，有参数可以是任意类型</strong></li></ul></li><li>全通配写法：<code>* *..*.*(..)</code></li><li>实际开发中切入点表达式的通常写法: </li><li>切到业务层实现类下的所有方法：<code>top.carpenter.service.impl.*.*(..)</code></li></ul></li><li>关键字<code>withIn</code>以类作为控制粒度</li><li>关键字<code>args</code>以参数作为控制粒度</li><li>关键字<code>@annotation</code>以注解作为控制粒度</li><li>关键字<code>@withIn(X)</code>以类是否加了X注解作为控制粒度</li><li>关键字<code>@args(X)</code>以参数是否加了X注解作为控制粒度</li><li>关键字<code>this(X)</code>是否是<code>X</code>的代理对象</li><li>关键字<code>target(X)</code>是否是<code>X</code>的目标对象</li><li>上述所有的表达式<strong>在通知中可以混合使用<code>||</code> <code>&amp;&amp;</code></strong> </li></ul></li></ul></li><li><p><code>bean.xml</code>约束</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="7-2-基于Spring框架中AOP的问题解决"><a href="#7-2-基于Spring框架中AOP的问题解决" class="headerlink" title="7.2.基于Spring框架中AOP的问题解决"></a>7.2.基于Spring框架中AOP的问题解决</h3><h4 id="7-2-1-基于前置-后置-异常以及最终通知的问题解决"><a href="#7-2-1-基于前置-后置-异常以及最终通知的问题解决" class="headerlink" title="7.2.1.基于前置 后置 异常以及最终通知的问题解决"></a>7.2.1.基于前置 后置 异常以及最终通知的问题解决</h4><ul><li><code>Bean.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">...约束头...</span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top.carpenter"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"servicePointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* top.carpenter.service.impl.AccountServiceImpl.*(..))"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"txManagerAdvice"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置前置通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"beginTransaction"</span> <span class="attr">pointcut-ref</span>=<span class="string">"servicePointcut"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置后置通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"commit"</span> <span class="attr">pointcut-ref</span>=<span class="string">"servicePointcut"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置异常通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"rollback"</span> <span class="attr">pointcut-ref</span>=<span class="string">"servicePointcut"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置最终通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"release"</span> <span class="attr">pointcut-ref</span>=<span class="string">"servicePointcut"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"account"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.pojo.Account"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.dao.impl.AccountDaoImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionUtils"</span> <span class="attr">ref</span>=<span class="string">"connectionUtils"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"runner"</span> <span class="attr">ref</span>=<span class="string">"runner"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.utils.TransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionUtils"</span> <span class="attr">ref</span>=<span class="string">"connectionUtils"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionUtils"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.utils.ConnectionUtils"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runner"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbutils.QueryRunner"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/spring_study"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>AccountServiceImpl</code>——同6.3无需更改 </li></ul><h4 id="7-2-2-基于环绕通知的问题解决"><a href="#7-2-2-基于环绕通知的问题解决" class="headerlink" title="7.2.2.基于环绕通知的问题解决"></a>7.2.2.基于环绕通知的问题解决</h4><ul><li><p>Spring框架为我们提供了一个接口：<code>ProceedingJoinPoint</code> </p></li><li><p>该接口有一个方法<code>proceed()</code>，此方法就相当于明确调用切入点方法</p></li><li><p>该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。</p></li><li><p><strong>环绕通知：spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。</strong></p></li><li><p><code>bean.xml</code></p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 修改7.3.1中配置</span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"servicePointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* top.carpenter.service.impl.AccountServiceImpl.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"txManagerAdvice"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"aroundTransaction"</span> <span class="attr">pointcut-ref</span>=<span class="string">"servicePointcut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>TransactionManager</code>——新增<code>aroundTransaction()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectionUtils</span><span class="params">(ConnectionUtils connectionUtils)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionUtils = connectionUtils;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"beginTransaction"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"commit"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().commit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"rollback"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().rollback();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"release"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().close();</span><br><span class="line">        connectionUtils.removeThreadConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundTransaction</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            beginTransaction();</span><br><span class="line">            rtValue = pjp.proceed(args);</span><br><span class="line">            commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            release();</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rtValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3-Spring中基于注解的AOP"><a href="#7-3-Spring中基于注解的AOP" class="headerlink" title="7.3.Spring中基于注解的AOP"></a>7.3.Spring中基于注解的AOP</h2><ul><li><code>bean.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>@Aspect</code> ——表示当前类是个切面类</p></li><li><p><code>@Before</code>——前置通知方法</p></li><li><p><code>@AfterReturning()</code>——后置通知方法</p></li><li><p><code>@AfterThrowing()</code>——异常通知方法</p></li><li><p><code>@After()</code>——最终通知方法</p></li><li><p><code>@Around()</code>——环绕通知方法</p></li><li><p><code>@Pointcut</code>——切入点表达式</p></li></ul><h3 id="7-3-基于Spring框架中AOP的问题解决"><a href="#7-3-基于Spring框架中AOP的问题解决" class="headerlink" title="7.3.基于Spring框架中AOP的问题解决"></a>7.3.基于Spring框架中AOP的问题解决</h3><h4 id="7-3-1-基于前置-后置-异常以及最终通知的问题解决-不建议使用-Spring框架存在一定bug"><a href="#7-3-1-基于前置-后置-异常以及最终通知的问题解决-不建议使用-Spring框架存在一定bug" class="headerlink" title="7.3.1.基于前置 后置 异常以及最终通知的问题解决[不建议使用 Spring框架存在一定bug]"></a>7.3.1.基于前置 后置 异常以及最终通知的问题解决[不建议使用 Spring框架存在一定bug]</h4><ul><li><code>bean.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="comment">配置Spring开启注解AOP支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>TransactionManager</code>切面类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span><span class="comment">//将切面类放入Spring容器管理</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//表明切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个切点 包含了众多连接点/方法</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* top.carpenter.service.impl.AccountServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectionUtils</span><span class="params">(ConnectionUtils connectionUtils)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionUtils = connectionUtils;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通知：位置+逻辑</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"beginTransaction"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"commit"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"rollback"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().rollback();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"release"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().close();</span><br><span class="line">        connectionUtils.removeThreadConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>JoinPoint</code>可以作为方法参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pt1()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    Object target = joinPoint.getTarget();  <span class="comment">//top.carpenter.UserService1@79da1ec0</span></span><br><span class="line">    Object aThis = joinPoint.getThis();  <span class="comment">//UserService1$$EnhancerBySpringCGLlB$$8fa9ac4d@2552</span></span><br><span class="line">    Object signature = joinPoint.getSignature();    <span class="comment">//void top.carpenter.UserService1.print()</span></span><br><span class="line">    System.out.println(<span class="string">"beginTransaction"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-3-2-基于环绕通知的问题解决"><a href="#7-3-2-基于环绕通知的问题解决" class="headerlink" title="7.3.2.基于环绕通知的问题解决"></a>7.3.2.基于环绕通知的问题解决</h4><ul><li><code>bean.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="comment">配置Spring开启注解AOP支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>TransactionManager</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* top.carpenter.service.impl.AccountServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectionUtils</span><span class="params">(ConnectionUtils connectionUtils)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionUtils = connectionUtils;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"beginTransaction"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"commit"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"rollback"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().rollback();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"release"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().close();</span><br><span class="line">        connectionUtils.removeThreadConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundTransaction</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Object[] args = pjp.getArgs();<span class="comment">//⭐</span></span><br><span class="line">        Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            beginTransaction();</span><br><span class="line">            rtValue = pjp.proceed(args);<span class="comment">//⭐</span></span><br><span class="line">            commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            release();</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rtValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ProceedIngjoinpoint</code>继承了<code>JoinPoint</code>，<code>proceed()</code>这个是aop代理链执行的方法。</li><li>proceed()有重载，有个带参数的方法,可以修改目标方法的的参数</li></ul><h1 id="8-Sping事务控制API"><a href="#8-Sping事务控制API" class="headerlink" title="8.Sping事务控制API"></a>8.Sping事务控制API</h1><h2 id="8-1-明确前提"><a href="#8-1-明确前提" class="headerlink" title="8.1.明确前提"></a>8.1.明确前提</h2><ul><li>JavaEE体系进行分层开发，事务处理位于<strong>业务层</strong>，Spring提供了分层设计业务层的事务处理解决方案。</li><li><strong>Spring框架为我们提供了一组事务控制的接口。</strong>这组接口是在<code>spring-tx-5.0.2.RELEASE.jar</code>中</li><li><strong>Spring的事务控制都是基于AOP的</strong><ul><li><strong>可以使用编程式事务实现【太麻烦】</strong></li><li>可以使用<strong>声明式事务实现</strong>。<strong>重点是使用声明式事务实现</strong></li></ul></li></ul><h2 id="8-2-事务控制API"><a href="#8-2-事务控制API" class="headerlink" title="8.2.事务控制API"></a>8.2.事务控制API</h2><ul><li><code>pom.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配合AOP使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>PlatformTransactionManager</code></p><ul><li><p>此接口是<code>Spring</code>的事务管理器，提供了常用的操作事务方法</p><ul><li><code>void commit(TransactionStatus status)</code></li><li><code>void rollback(TransactionStatus status)</code></li><li><code>TransactionStatus getTransaction(TransactionDefinition definition)</code></li></ul></li><li><p>开发中<strong>使用其实现类</strong>管理事务的对象</p><ul><li><strong><code>org.springframework.jdbc.datasource.DataSourceTransactionManager</code></strong>使用 SpringJDBC或iBatis进行持久化数据时使用</li><li><code>org.springframework.orm. hibernate5.HibernateTransactionManager</code><br>使用Hibernate版本进行持久化数据时使用</li></ul></li></ul></li><li><p><code>TransactionDefinition</code></p><ul><li>事务的定义信息对象<ul><li><code>String getName()</code>——获取事务对象名称</li><li><code>int getlsolationLevel()</code>——获取事务隔离级【默认同数据库】</li><li><code>int getPropagationBehavior()</code>——获取事务传播行为</li><li><code>int getTimeout()</code>——获取事务超时时间</li><li><code>boolean isReadOnly()</code>——获取事务是否只读</li></ul></li></ul></li><li><p>事务的隔离级别</p><ul><li>事务隔离级反映事务提交并发访问时的处理态度<ul><li><code>ISOLATION_DEFAULT</code>——默认级别，归属下列某一种</li><li><code>ISOLATION _READ_UNCOMMITTED</code>——可以读取未提交数据</li><li><code>ISOLATION READ_COMMITTED</code>——只能读取已提交数据，解决脏读问题(Oracle默认级别)</li><li><code>ISOLATION_REPEATABLE_READ</code>——是否读取其他事务提交修改后的数据，解决不可重复读问题(MySQL默认级别)</li><li><code>ISOLATION_SERIALIZABLE</code>——是否读取其他事务提交添加后的数据，解决幻影读问题</li></ul></li></ul></li><li><p>事务的传播行为</p><ul><li><code>REQUIRED</code>：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择【默认值】</li><li><code>SUPPORTS</code>：支持当前事务，如果当前没有事务，就以非事务方式执行(没有事务)</li></ul></li><li><p>超时时间</p><ul><li>默认值是-1，没有超时限制</li><li>如果有，以秒为单位进行设置</li></ul></li><li><p>是否是只读事务</p><ul><li>建议查询设置为只读</li></ul></li><li><p><code>TransactionStatus</code></p><ul><li>此接口提供的事务具体的运行状态包含有6个具体的操作<ul><li><code>void flush()</code>——刷新事务</li><li><code>boolean hasSavepoint()</code>——获取是否是否存在存储点</li><li><code>boolean isCompleted()</code>——获取事务是否完成</li><li><code>boolean isNewTransaction()</code>——获取事务是否为新的事务</li><li><code>boolean isRollbackOnly()</code>——获取事务是否回滚</li><li><code>void setRollbackOnly()</code>——设置事务回滚</li></ul></li></ul></li></ul><p>​    </p><h2 id="8-3-基于XML的实现"><a href="#8-3-基于XML的实现" class="headerlink" title="8.3.基于XML的实现"></a>8.3.基于XML的实现</h2><ul><li>需要导入事务的的约束 </li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>配置事务管理器</p><p><img src="1578313947538.png" alt="1578313947538"></p></li><li><p><strong>使用<code>&lt;tx:advice&gt;</code>标签配置事务的通知，以及配置的事务属性</strong></p><ul><li>在<code>&lt;tx:advice&gt;</code>标签内部<ul><li>属性<ul><li><code>id</code>：事务通知唯一标识</li><li><code>transaction-manager</code>：给事务通知提供一个事务管理器引用</li></ul></li></ul></li></ul><p><img src="1578313804043.png" alt="1578313804043"></p></li><li><p>配置AOP中的通用切入点表达式，并建立事务通知和切入点表达式的对应关系</p><p><img src="1578313839120.png" alt="1578313839120"></p></li></ul><h2 id="8-4-基于注解的实现"><a href="#8-4-基于注解的实现" class="headerlink" title="8.4.基于注解的实现"></a>8.4.基于注解的实现</h2><ul><li>需要导入事务的的约束</li><li>配置事务管理器</li><li>开启Spring对注解事物的支持</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- @EnableTransactionManagement等价于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transacannotation-drivention-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在需要事务支持的地方使用<code>@Transactional</code>注解</li></ul><h2 id="8-5-事务的传播特性"><a href="#8-5-事务的传播特性" class="headerlink" title="8.5.事务的传播特性"></a>8.5.事务的传播特性</h2><p>[1]死活不要事务的 PROPAGATION_NEVER：没有就非事务执行，有就抛出异常 PROPAGATION_NOT_SUPPORTED：没有就非事务执行，有就直接挂起，然后非事务执行 [2]可有可无的 PROPAGATION_SUPPORTS: 有就用，没有就算了 [3]必须有事务的 PROPAGATION_REQUIRES_NEW：有没有都新建事务，如果原来有，就将原来的挂起。 PROPAGATION_NESTED: 如果没有，就新建一个事务；如果有，就在当前事务中嵌套其他事务。 PROPAGATION_REQUIRED: 如果没有，就新建一个事务；如果有，就加入当前事务 PROPAGATION_MANDATORY: 如果没有，就抛出异常；如果有，就使用当前事务。</p><h1 id="9-面试"><a href="#9-面试" class="headerlink" title="9.面试"></a>9.面试</h1><ul><li><p>Spring 动态代理是如何实现的</p></li><li><p>为什么要使用 spring？</p></li><li><p>解释一下什么是 aop？</p></li><li><p>解释一下什么是 ioc？</p></li><li><p>spring 有哪些主要模块？</p></li><li><p>spring 常用的注入方式有哪些？</p></li><li><p>spring 中的 bean 是线程安全的吗？</p></li><li><p>spring 支持几种 bean 的作用域？</p></li><li><p>spring 自动装配 bean 有哪些方式？</p></li><li><p>spring 事务实现方式有哪些？</p></li><li><p>spring 的事务隔离？</p></li></ul>]]></content>
    
    <summary type="html">
    
      SpringAOP
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Spring" scheme="http://goldcarpenter.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring FrameWork</title>
    <link href="http://goldcarpenter.github.io/2019/09/12/Spring_IOC/"/>
    <id>http://goldcarpenter.github.io/2019/09/12/Spring_IOC/</id>
    <published>2019-09-12T14:43:11.000Z</published>
    <updated>2020-06-17T03:23:20.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Spring-FrameWork"><a href="#1-Spring-FrameWork" class="headerlink" title="1.Spring FrameWork"></a>1.Spring FrameWork</h1><ul><li><p>Spring是一个开源框架，Spring是于2003年兴起的一个轻量级的Java开发框架，它是为了解决企业应用开发的复杂性而创建的。</p></li><li><p>Spring使用基本的<code>JavaBean</code>来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，<strong>任何Java应用都可以从Spring中受益</strong>。</p></li><li><p>简单来说，Spring是一个轻量级的<strong>控制反转（IoC）</strong>和<strong>面向切面（AOP）</strong>的容器框架。</p></li></ul><h2 id="1-1-Sping-优点"><a href="#1-1-Sping-优点" class="headerlink" title="1.1.Sping 优点"></a>1.1.Sping 优点</h2><ul><li><p>方便解耦，简化开发</p><ul><li>Spring就是一个大工厂，专门负责生成<code>Bean</code>，可以将所有对象创建和依赖关系维护由<code>Spring</code>管理</li></ul></li><li><p>提供面向切面编程</p><ul><li>方便的实现对程序进行<strong>权限拦截</strong>、运行监控等功能</li></ul></li><li><p>声明式事务的支持</p><ul><li>只需要通过配置就可以完成对事务的管理，而无需手动编程</li></ul></li><li><p>方便程序的测试</p><ul><li>Spring对Junit4支持，可以通过注解方便的测试Spring程序</li></ul></li><li><p>方便集成各种优秀框架</p><ul><li>内部提供了对各种优秀框架（如：<code>Struts Hibernate MyBatis Quartz</code>等）的支持</li></ul></li><li><p>降低<code>JavaEE API</code>的使用难度</p><ul><li>对JavaEE开发中一些难用的API（JDBC、JavaMail、远程调webservice用等）都提供了封装，使这些API应用难度大大降低</li></ul></li></ul><h2 id="1-2-体系结构"><a href="#1-2-体系结构" class="headerlink" title="1.2.体系结构"></a>1.2.体系结构</h2><p><img src="1568184874034.png" alt="1568184874034"></p><ul><li><code>Core Container</code>——<strong>其他所有内容</strong>都需要<strong>核心容器（IOC）</strong>支持<ul><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html" target="_blank" rel="noopener">Core technologies</a>: dependency injection, events, resources, i18n, validation, data binding, type conversion, SpEL, AOP.</li></ul></li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/testing.html" target="_blank" rel="noopener">Testing</a>: mock objects, TestContext framework, Spring MVC Test, <code>WebTestClient</code>.</li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html" target="_blank" rel="noopener">Data Access</a>: transactions, DAO support, JDBC, ORM, Marshalling XML.</li><li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html" target="_blank" rel="noopener">Spring MVC</a> and <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html" target="_blank" rel="noopener">Spring WebFlux</a> web frameworks.</li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/integration.html" target="_blank" rel="noopener">Integration</a>: remoting, JMS, JCA, JMX, email, tasks, scheduling, cache.</li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/languages.html" target="_blank" rel="noopener">Languages</a>: Kotlin, Groovy, dynamic languages.</li></ul><h2 id="1-3Spring编程的风格"><a href="#1-3Spring编程的风格" class="headerlink" title="1.3Spring编程的风格"></a>1.3Spring编程的风格</h2><ul><li>可以配合使用<ul><li><code>schemal-based------xml</code></li><li><code>annotation-based----- annotation</code></li><li><code>java-based----java Configuration</code></li></ul></li></ul><h1 id="2-Spring-IOC原理入门"><a href="#2-Spring-IOC原理入门" class="headerlink" title="2.Spring IOC原理入门"></a>2.Spring IOC原理入门</h1><h2 id="2-1-问题：程序间耦合"><a href="#2-1-问题：程序间耦合" class="headerlink" title="2.1.问题：程序间耦合"></a>2.1.问题：程序间耦合</h2><ul><li><p>耦合——程序间的依赖关系</p><ul><li>类（jar包）之间的依赖</li><li>方法之间的依赖</li></ul></li><li><p>实际开发中——<strong>目标：编译期不依赖，运行时依赖（方便动态代理，让Spring返回我们需要的对象【是否添加AOP/事务控制内容】）</strong></p></li><li><p>解耦思路</p><ul><li>步骤一：使用反射创建对象，而避免使用new关键字–&gt;导致字符串写‘死’</li><li>步骤二：通过读取配置文件来获取要创建的对象全限定类名</li></ul></li><li><p>以<code>JDBC</code>为例</p><p><img src="1577606658701.png" alt="1577606658701"></p></li><li><p>以视图层-业务层-表现层为例</p><ul><li>以下两张图耦合性非常强</li></ul><p><img src="1577606531887.png" alt="1577606531887"></p><p><img src="1577606552486.png" alt="1577606552486"></p></li></ul><h2 id="2-2-解决方案"><a href="#2-2-解决方案" class="headerlink" title="2.2.解决方案"></a>2.2.解决方案</h2><ul><li>创建<code>Bean</code>对象工厂<ul><li><code>Bean</code>：可重用组件</li><li>第一步：一个配置文件中<code>唯一标识id=全限定类名(key=value)</code>（配置service和dao对象信息）<ul><li>配置文件种类：<code>xml</code>/<code>properties</code></li></ul></li><li>第二步：通过读取配文件中配的内容，反射创建对象</li></ul></li></ul><p><img src="1577629887742.png" alt="1577629887742"></p><ul><li><code>bean.properties</code></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">accountService</span>=<span class="string">top.carpenter.service.impl.AccountServiceImpl</span></span><br></pre></td></tr></table></figure><ul><li><code>IAccountService.java</code> &amp; <code>AccountServiceImpl.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> top.carpenter.service.impl;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"save ok"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>BeanFactory.java</code>多例版本</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义个Properties对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties props;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用静态代码块为Properties对象赋值</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化对象</span></span><br><span class="line">            props = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="comment">// 获取properties文件的流对象，获取编译后classes下资源文件</span></span><br><span class="line">            InputStream in = BeanFactory.class.getPropertiesClassLoader().getResourceAsStream("bean.properties");</span><br><span class="line">            props.load(in);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(<span class="string">"系统初始化失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Bean名称获取Bean对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Object bean;</span><br><span class="line">        String beanPath = props.getProperty(beanName);</span><br><span class="line">        bean = Class.forName(beanPath).newInstance();</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>BeanFactory.java</code>单例版本</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个Properties对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties props;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个Map 用于存放我们要创建的对象 即容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; beans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用静态代码块为Properties对象赋值</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化对象</span></span><br><span class="line">            props = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="comment">// 获取properties文件的流对象，获取编译后classes下资源文件</span></span><br><span class="line">            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream("bean.properties");</span><br><span class="line">            props.load(in);</span><br><span class="line">            <span class="comment">// 实例化容器</span></span><br><span class="line">            beans = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">            <span class="comment">// 取出配置文件中所有key</span></span><br><span class="line">            Enumeration keys = props.keys();</span><br><span class="line">            <span class="comment">// 遍历枚举</span></span><br><span class="line">            <span class="keyword">while</span> (keys.hasMoreElements())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 取出每一个key</span></span><br><span class="line">                String key = keys.nextElement().toString();</span><br><span class="line">                <span class="comment">// 根据key值获取value</span></span><br><span class="line">                String beanPath = props.getProperty(key);</span><br><span class="line">                <span class="comment">// 反射创建对象</span></span><br><span class="line">                Object value = Class.forName(beanPath).newInstance();</span><br><span class="line">                <span class="comment">// 把key值放入容器</span></span><br><span class="line">                beans.put(key,value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(<span class="string">"系统初始化失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Bean名称获取Bean对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beans.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Client.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.ui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.carpenter.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        IAccountService accountService =(IAccountService)BeanFactory.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">        accountService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1577630112947.png" alt="1577630112947"></p><h1 id="3-控制反转-IOC"><a href="#3-控制反转-IOC" class="headerlink" title="3.控制反转(IOC)"></a>3.控制反转(IOC)</h1><ul><li>控制反转：把创建对象的权利交给框架，由框架控制对象的生命周期，是框架的重要特征</li><li>IOC作用：<strong>削减计算机程序的耦合，降低程序间的依赖关系</strong></li></ul><p><img src="1577632805455.png" alt="1577632805455"></p><h2 id="3-1-Spring-IOC容器构建"><a href="#3-1-Spring-IOC容器构建" class="headerlink" title="3.1.Spring IOC容器构建"></a>3.1.Spring IOC容器构建</h2><ul><li><code>pom.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--这个依赖可以解决Spring IOC 90%功能--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="1577671311771.png" alt="1577671311771"></p><blockquote><p><strong>核心容器本质是个Map</strong></p></blockquote><ul><li><code>applicationContext.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置文件中`唯一标识==全限定类名(key=value)`--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.service.impl.AccountServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Client.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.ui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Spring容器</span></span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);<span class="comment">//显现类选择见下图</span></span><br><span class="line">        <span class="comment">// 从容器中提取Bean</span></span><br><span class="line">        IAccountService accountService = (IAccountService) ac.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">        <span class="comment">// 或：IAccountService accountService1 = ac.getBean("accountService", IAccountService.class);</span></span><br><span class="line">        accountService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Spring工厂类结构图</p><p><img src="1577673600316.png" alt="1577673600316"></p><ul><li><p><code>BeanFactory</code>是<strong>核心容器</strong>的顶层接口</p></li><li><p>三个常用实现类</p><ul><li><code>ClassPathXmlApplicationContext</code>——可以<strong>加载类路径</strong>下的<strong>配置文件</strong>，要求配置文件必须在类路径下，否则加载不了。</li><li><code>FileSystemXmlApplicationContext</code>——可以加载磁盘任意路径下的配置文件(必须有访问权限)</li><li><code>AnnotationConfigApplicationContext</code>——用于读取注解创建容器的</li></ul></li><li><p>两个常用接口</p><ul><li><code>BeanFactory</code>——构建核心容器时，创建对象采取的策略是采用延迟加载的方式。即根据id获取对象时才创建对象</li><li><code>ApplicationContext</code>——构建核心容器时，创建对象采取的策略是采用立即加载的方式。即只要读取完配置文件马上就创建配置文件中配置的对象</li></ul></li></ul></li></ul><h2 id="3-2-Bean的三种创建方式"><a href="#3-2-Bean的三种创建方式" class="headerlink" title="3.2.Bean的三种创建方式"></a>3.2.Bean的三种创建方式</h2><h3 id="3-2-1-使用默认构造函数创建，并存入spring容器"><a href="#3-2-1-使用默认构造函数创建，并存入spring容器" class="headerlink" title="3.2.1.使用默认构造函数创建，并存入spring容器"></a>3.2.1.使用默认构造函数创建，并存入spring容器</h3><ul><li><p>在spring的配置文件中使用<code>bean</code>标签，配以<code>id</code>和<code>class</code>属性之后，且没有其他属性和标签</p></li><li><p>构造函数创建<code>bean</code>对象，<strong>此时如果类中没有默认构造函数，则对象无法创建</strong></p></li><li><p><code>applicationContext.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.service.impl.AccountServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-2-使用普通工厂中的方法创建对象-使用某个类中的方法创建对象，并存入spring容器"><a href="#3-2-2-使用普通工厂中的方法创建对象-使用某个类中的方法创建对象，并存入spring容器" class="headerlink" title="3.2.2.使用普通工厂中的方法创建对象/使用某个类中的方法创建对象，并存入spring容器"></a>3.2.2.使用普通工厂中的方法创建对象/使用某个类中的方法创建对象，并存入spring容器</h3><ul><li><p><code>InstanceFactory.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟存在于jar包中的 我们无法修改</span></span><br><span class="line"><span class="keyword">package</span> top.carpenter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.impl.AccountServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IAccountService <span class="title">getIAccountService</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>applicationContext.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instanceFactory"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.InstanceFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">factory-bean</span>=<span class="string">"instanceFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getIAccountService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-3-使用工厂中的静态方法创建对象-使用某个类中的静态方法创建对象，并存入spring容器"><a href="#3-2-3-使用工厂中的静态方法创建对象-使用某个类中的静态方法创建对象，并存入spring容器" class="headerlink" title="3.2.3.使用工厂中的静态方法创建对象/使用某个类中的静态方法创建对象，并存入spring容器"></a>3.2.3.使用工厂中的静态方法创建对象<strong>/</strong>使用某个类中的静态方法创建对象，并存入spring容器</h3><ul><li><p><code>InstanceFactory.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟存在于jar包中的 我们无法修改</span></span><br><span class="line">  <span class="keyword">package</span> top.carpenter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line">  <span class="keyword">import</span> top.carpenter.service.impl.AccountServiceImpl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceStaticFactory</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IAccountService <span class="title">getIAccountService</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>applicationContext.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.InstanceStaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getIAccountService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-3-Bean对象的作用范围"><a href="#3-3-Bean对象的作用范围" class="headerlink" title="3.3.Bean对象的作用范围"></a>3.3.Bean对象的作用范围</h2><ul><li><p>用于指定<code>bean</code>的作用范围</p><ul><li><code>singleton</code>——单例（默认）</li><li><code>prototype</code>——多例</li><li><code>request</code>——作用于web应用的请求范围</li><li><code>session</code>——作用于web应用的会话范围</li><li><code>global-session</code>——作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session</li></ul></li><li><p>在<code>Singleton</code>当中引用了一个<code>Prototype</code>的bean的时候，会使得<code>Prototype</code>失效</p><ul><li><p>容器只创建单例Singleton一次，只有一次机会设置属性值</p></li><li><p>解决问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例的</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService1</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;<span class="comment">//原型的</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-4-Bean对象的生命周期"><a href="#3-4-Bean对象的生命周期" class="headerlink" title="3.4.Bean对象的生命周期"></a>3.4.Bean对象的生命周期</h2><ul><li>单例对象<ul><li>创建：当容器创建时，对象创建</li><li>存活：容器存在，对象一直存在</li><li>销毁：与容器同时销毁</li></ul></li><li>多例对象<ul><li>创建：当使用对象时，容器创建对象</li><li>存活：对象只要使用过程中就一直活着</li><li>销毁：长时间不用，且没有其他对象引用时，由JVM自动回收</li></ul></li></ul><h1 id="4-依赖注入-Dependency-Injection"><a href="#4-依赖注入-Dependency-Injection" class="headerlink" title="4.依赖注入(Dependency Injection)"></a>4.依赖注入(Dependency Injection)</h1><ul><li><code>IoC</code>的作用：降低程序间的耦合<strong>(依赖关系</strong>)</li><li>依赖关系的管理：<ul><li>在当前类需要用到其他类的对象，由<code>spring</code>为我们提供，我们只需要在配置文件中说明</li><li>以后都<strong>交给<code>spring</code>来维护依赖关系，就称之为依赖注入</strong></li></ul></li><li><strong>依赖注入的数据</strong><ul><li><strong>基本类型和<code>String</code></strong></li><li><strong>其他<code>bean</code>类型(在配置文件中或者注解配置过的bean)</strong></li><li><strong>复杂类型/集合类型</strong></li></ul></li></ul><h2 id="4-1-依赖注入的方式"><a href="#4-1-依赖注入的方式" class="headerlink" title="4.1.依赖注入的方式"></a>4.1.依赖注入的方式</h2><h3 id="4-1-1-使用构造函数提供"><a href="#4-1-1-使用构造函数提供" class="headerlink" title="4.1.1.使用构造函数提供"></a>4.1.1.使用构造函数提供</h3><ul><li><p><code>AccountServiceImpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountServiceImpl</span><span class="params">(String name, <span class="keyword">int</span> age, Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.age);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.birthday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>bean.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置文件中`唯一标识==全限定类名(key=value)`--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"yyx"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"date"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用的标签：<code>constructor-arg</code></p></li><li><p>标签出现的位置：<code>bean</code>标签的内部</p></li><li><p>标签中的属性</p><ul><li><code>type</code>：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型（容易混）</li><li><code>index</code>：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始</li><li><code>name</code>：用于指定给构造函数中指定名称的参数赋值【常用】<br>=================以上三个用于指定给构造函数中哪个参数赋值============</li><li><code>value</code>：用于提供基本数据类型和String类型的数据</li><li><code>ref</code>：用于指定其他的bean类型数据。它指的就是在spring的IoC核心容器中出现过的bean对象</li></ul></li><li><p>优势</p><ul><li>在获取<code>bean</code>对象时，注入数据是必须的操作，否则对象无法创建成功</li></ul></li><li><p>劣势</p><ul><li><code>bean</code>对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供</li></ul></li></ul><h3 id="4-1-2-使用set方法提供"><a href="#4-1-2-使用set方法提供" class="headerlink" title="4.1.2.使用set方法提供"></a>4.1.2.使用set方法提供</h3><ul><li><code>AccountServiceImpl.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.age);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.birthday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>bean.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置文件中`唯一标识==全限定类名(key=value)`--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"yyx"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"date"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用的标签：<code>property</code></li><li>标签出现的位置：<code>bean</code>标签的内部</li><li>标签的属性<ul><li><code>name</code>:用于指定注入时所调用的set方法名称</li><li><code>value</code>: 用于提供基本类型和String类型的数据</li><li><code>ref</code>:用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象</li></ul></li><li>优势:<ul><li>创建对象时没有明确的限制，可以直接使用默认构造函数</li></ul></li><li>弊端:<ul><li>如果有某个成员必须有值，则获取对象是有可能set方法没有执行</li></ul></li></ul><h3 id="补充：复杂类型-集合类型注入（set方法-amp-构造函数）"><a href="#补充：复杂类型-集合类型注入（set方法-amp-构造函数）" class="headerlink" title="补充：复杂类型/集合类型注入（set方法 &amp; 构造函数）"></a>补充：复杂类型/集合类型注入（set方法 &amp; 构造函数）</h3><ul><li><p><code>AccountServiceImpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] myStrs;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; myList;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; mySet;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String ,String&gt; myMap;</span><br><span class="line">    <span class="keyword">private</span> Properties myProps;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountServiceImpl</span><span class="params">(String[] myStrs, List&lt;String&gt; myList, Set&lt;String&gt; mySet, Map&lt;String, String&gt; myMap, Properties myProps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myStrs = myStrs;</span><br><span class="line">        <span class="keyword">this</span>.myList = myList;</span><br><span class="line">        <span class="keyword">this</span>.mySet = mySet;</span><br><span class="line">        <span class="keyword">this</span>.myMap = myMap;</span><br><span class="line">        <span class="keyword">this</span>.myProps = myProps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyStrs</span><span class="params">(String[] myStrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myStrs = myStrs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyList</span><span class="params">(List&lt;String&gt; myList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myList = myList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMySet</span><span class="params">(Set&lt;String&gt; mySet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mySet = mySet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyMap</span><span class="params">(Map&lt;String, String&gt; myMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myMap = myMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyProps</span><span class="params">(Properties myProps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myProps = myProps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(myList);</span><br><span class="line">        System.out.println(myMap);</span><br><span class="line">        System.out.println(myProps);</span><br><span class="line">        System.out.println(mySet);</span><br><span class="line">        System.out.println(Arrays.toString(myStrs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>bean.xml</code>（set方法）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置文件中`唯一标识==全限定类名(key=value)`--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myStrs"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>A<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>B<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mySet"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>AA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>BB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myMap"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"AAAA"</span> <span class="attr">value</span>=<span class="string">"BBBB"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"CCCC"</span> <span class="attr">value</span>=<span class="string">"DDDD"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myProps"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"2"</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>        <span class="comment">&lt;!--  没有value属性了  --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>bean.xml</code>（构造函数）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置文件中`唯一标识==全限定类名(key=value)`--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>a<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>b<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"myStrs"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>a<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>b<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"myMap"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"a"</span> <span class="attr">value</span>=<span class="string">"b"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"a"</span> <span class="attr">value</span>=<span class="string">"b"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"myProps"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"a"</span>&gt;</span>b<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"a"</span>&gt;</span>b<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"mySet"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>a<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>b<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用标签：List结构集合</p><ul><li><code>list</code></li><li><code>array</code></li><li><code>set</code></li></ul></li><li><p>使用标签：Map结构集合</p><ul><li><code>map</code>&amp;<code>entry</code></li><li><code>props</code>&amp;<code>prop</code></li></ul></li><li><p><code>set</code>方法标签出现的位置：<code>property</code>标签的内部</p></li><li><p>构造函数标签出现的位置：<code>bean</code>标签的内部</p></li></ul><h3 id="4-1-3-使用注解提供"><a href="#4-1-3-使用注解提供" class="headerlink" title="4.1.3.使用注解提供"></a>4.1.3.使用注解提供</h3><h4 id="1-注解知识引入"><a href="#1-注解知识引入" class="headerlink" title="1. 注解知识引入"></a>1. 注解知识引入</h4><ul><li>曾经的XML配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.service.impl.AccountServiceImpl"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">scope</span>=<span class="string">"..."</span> <span class="attr">init-method</span>=<span class="string">"..."</span> <span class="attr">destroy-method</span>=<span class="string">".."</span> <span class="attr">depends-on</span>=<span class="string">".."</span> <span class="attr">lazy-</span>        <span class="attr">init</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>创建对象的注解</strong></p><ul><li>作用：同在XML配置文件中编写一个<code>&lt;bean&gt;</code>标签</li><li><code>@Component</code><ul><li>把当前类存入Spring容器</li><li>属性<ul><li>value：用于指定<code>bean</code>的<code>id</code>，当不写时，它的<strong>默认是当前类名，且首字母改小写</strong></li></ul></li></ul></li><li><code>@Controller</code>——spring框架明确提供的三层中<strong>表现层</strong>使用的</li><li><code>@Service</code>——spring框架明确提供的三层中<strong>业务层</strong>使用的</li><li><code>@Repository</code>——spring框架明确提供的三层中<strong>持久层</strong>使用的</li></ul></li><li><p><strong>注入数据的注解</strong></p><ul><li><p>作用：同在XML配置文件中的<code>bean</code>标签中写一个<code>&lt;property&gt;</code>标签</p></li><li><p><code>@Autowired</code>——自动按照类型注入</p><ul><li><p>出现位置：</p><ul><li>变量</li><li>方法(<code>比如配合@Bean使用 需要添加属性</code>)</li></ul></li><li><p>只要容器中有唯一一个<strong>bean对象类型</strong>和<strong>要注入的变量类型匹配</strong>，就可以注入成功</p></li><li><p>如果ioc容器中没有任何bean的类型和要注入的变至类型匹配，则报错</p></li><li><p>如果Ioc容器中<strong>有多个类型匹配</strong>时</p><ul><li><strong>如果在多个类型匹配中存在<code>id</code>与变量名称相同，就可以注入成功</strong></li><li><strong>如果在多个类型匹配中不存在<code>id</code>与变量名称相同，则报错</strong></li><li><strong><code>id</code>与变量名称必须相同，存在不方便，引出<code>@Qualifier</code></strong></li></ul></li></ul></li></ul></li></ul><pre><code>![1577891921173](1577891921173.png)* 细节：  * **在使用注解注入时，set方法就不是必须的**  ![1577891716576](1577891716576.png)</code></pre><ul><li><p><code>@Qualifier</code></p><ul><li>按照<strong>数据类型</strong>注入的基础之上再按照名称注入</li><li><strong>它在给类成员注入时配合<code>@Autowired</code>使用，不能单独使用。</strong></li><li><strong>在给方法参数往入时可以单独使用</strong></li><li>属性<ul><li><code>value</code>：用于指定注入<code>bean</code>的<code>id</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"accountServiceImpl1"</span>)</span><br><span class="line"><span class="keyword">private</span> IAccountService accountServiceImpl2;  <span class="comment">// 以注解的名称为准</span></span><br></pre></td></tr></table></figure></li><li><p><code>@Resource</code></p><ul><li>作用：<strong>直接按照<code>bean</code>的<code>id</code>注入，独立使用</strong></li><li>属性：<ul><li><code>name</code>：用于指定<code>bean</code>的<code>id</code></li></ul></li></ul></li><li><p><strong>===============以上三个注入都只能注入其他bean类型的数据==========================</strong></p></li><li><p><strong>===============基本类型和String类型无法使用上述注解实现，使用<code>@Value</code>===============</strong></p></li><li><p><code>@Value</code></p><ul><li>作用：用于注入基本类型和String类型的数据</li><li>属性<ul><li><code>value</code>：用于指定数据的值。它可以使用<code>spring</code>中<code>SpEL</code>（spring的el表达式）</li><li><strong>SpEL的写法: <code>${表达式}</code></strong></li></ul></li></ul></li><li><p><strong>===============集合类型的注入只能通过XML来实现==============================</strong></p></li></ul><ul><li><p>改变作用范围的注解</p><ul><li>作用：同在XML配置文件中的<code>bean</code>标签中使用<code>scope</code></li><li><code>@Scope</code>：<ul><li><code>value</code>属性：<ul><li>单例：<code>singleton</code></li><li>多例：<code>prototype</code></li></ul></li></ul></li></ul></li><li><p>生命周期相关的注解</p><ul><li>作用：同在XML配置文件中的标签中使用<code>init-method</code>和<code>destroy-method</code></li><li><code>@PreDestroy</code>：指定生命周期结束销毁的回调方法</li><li><code>@PostConstruct</code>：指定生命周期初始化的回调方法（在构造方法之后执行）</li></ul></li><li><p>【官网不推荐】还可以使得类实现接口<code>InitializingBean</code>，<code>DisposableBean</code></p><ul><li>Destroy methods are called in the same order<ol><li>Methods annotated with @PreDestroy</li><li>destroy() as defined by the DisposableBean callback interface</li><li>A custom configured destroy() method</li></ol></li></ul></li></ul><h4 id="2-为什么要添加注解扫描"><a href="#2-为什么要添加注解扫描" class="headerlink" title="2.为什么要添加注解扫描"></a>2.为什么要添加注解扫描</h4><ul><li>程序在创建容器的解析配置文件过程中，只读了<code>bean.xml</code>，<strong>并不知道你在哪里使用了注解</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br></pre></td></tr></table></figure><ul><li>故需告知Spring在创建容器时，要扫描的包</li><li>配置所需要的标签不是在beans的约束中，而是在一个名称为<code>context</code>名称空间和约束中</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top.carpenter"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>即开启Spring注解支持，又开启注解扫描</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 已经二合一了 下边这个不用了--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>&gt;</span><span class="tag">&lt;/<span class="name">context:annotation-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-使用注解提供"><a href="#3-使用注解提供" class="headerlink" title="3. 使用注解提供"></a>3. 使用注解提供</h4><ul><li><code>AccountServiceImpl.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"yyx"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"18"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.age);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.birthday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>bean.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top.carpenter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>/&gt;</span><span class="comment">&lt;!--jar包中的类需要在`bean.xml`配置--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-优化-去除配置文件"><a href="#4-优化-去除配置文件" class="headerlink" title="4.优化 去除配置文件"></a>4.优化 去除配置文件</h4><ul><li><p><strong>之前所使用的注解只能使用在自己写的类上，jar包中的类需要在<code>bean.xml</code>配置，导致无法彻底删除<code>bean.xml</code></strong></p></li><li><p>使用<code>top.carpenter.config.SpringConfiguration.java</code>代替<code>bean.xml</code></p><ul><li><code>@Configuration</code>——指定当前类是个配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用注解new AnnotationConfigApplicationContext 但是XML内容还可以用</span></span><br><span class="line"><span class="meta">@ImportResource</span>(<span class="string">"Classpath:spring.xml"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value = &#123;<span class="string">"top.carpenter"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">createDate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@ComponentScan</code>——指定Spring在创建容器时要扫描的包</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- @ComponentScan(value = &#123;"top.carpenter"&#125;)等价于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top.carpenter"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>@EnableAspectJAutoProxy</code>——使用注解开启AOP支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- @EnableAspectJAutoProxy等价于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>@EnableTransactionManagement</code>——开启对事务的支持</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- @EnableTransactionManagement等价于--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>@Bean</code>——用于把当前方法的返回值作为bean对象存入<code>Spring</code>的<code>IOC</code>容器中<ul><li>属性<ul><li><code>name</code>：用于指定<code>bean</code>的<code>id</code>。当不写时，默认值是当前方法的名称</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  @Bean</span></span><br><span class="line"><span class="comment">  public Date createDate()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  return  new Date();</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  等价于--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>@Import</code>——当存在多个配置类时，用于导入其他的配置类</p><ul><li>属性:<ul><li><code>value</code>：用于指定其他配置类的字节码<ul><li>当我们使用<code>@Import</code>的注解之后，有<code>@Import</code>注解的类就父配置类，而导入的都是子配置类<ul><li><code>SpringConfiguration.java</code></li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value = &#123;<span class="string">"top.carpenter"</span>&#125;)</span><br><span class="line"><span class="meta">@Import</span>(DateConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>DateConfiguration.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.config;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">import</span> java.util.Date;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PropertySource</span>(<span class="string">"classpath:dateConfig.properties"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConfiguration</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用EL表达式注入</span></span><br><span class="line">        <span class="meta">@Value</span>(<span class="string">"$&#123;date&#125;"</span>)</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> date;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Date <span class="title">createDate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Date(date);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@PropertySource</code></p><ul><li>作用：用于指定properties文件的位置</li></ul></li><li><p>属性：</p><pre><code>* `value`：指定文件的名称和路径。关键词：classpath 表示类路径下</code></pre><ul><li><code>dateConfig.properties</code></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">date</span>=<span class="string">10000</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Client.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line"><span class="comment">//等价于 </span></span><br><span class="line">ApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure></li></ul><h1 id="5-Spring整合JUnit"><a href="#5-Spring整合JUnit" class="headerlink" title="5.Spring整合JUnit"></a>5.Spring整合JUnit</h1><ul><li><code>junit</code>单元测试内部继承了<code>main</code>方法，该方法就会判断当前测试类中哪些方法有<code>@Test</code>注解，然后让方法执行</li><li><strong><code>junit</code>在执行测试方法时，junit根本不知道是否使用了spring框架，所以也就不会读取配置文件/配置类创建spring核心容器，报空指针异常</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClient</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        accountService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报空指针异常</span></span><br></pre></td></tr></table></figure><ul><li><p>Spring整合JUnit</p><ol><li>导入Spring整合JUnit的jar包</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用JUnit提供的<code>@RunWith(SpringJUnit4ClassRunner.class)</code>注解把原有的main方法替换 换成spring提供的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="3"><li><strong><code>@ContextConfiguration</code>告知Spring运行器，<code>Spring</code>和<code>Ioc</code>创建是基于<code>XML</code>还是注解的</strong><ul><li><strong><code>locations</code>：指定<code>xml</code>文件的位置，加上classpath关键字，表示在类路径下</strong></li><li><strong><code>classes</code>：指定注解类所在位置</strong></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span> </span>= SpringConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">//@<span class="title">ContextConfiguration</span>(<span class="title">locations</span> </span>= <span class="string">"classpath:bean.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="4"><li>注意：<code>Spring5.0.+</code>要求<code>JUnit4.12+</code></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      SpringIOC
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Spring" scheme="http://goldcarpenter.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>多线程编程</title>
    <link href="http://goldcarpenter.github.io/2019/08/31/%E5%A4%9A%E7%BA%BF%E7%A8%8B_Part10/"/>
    <id>http://goldcarpenter.github.io/2019/08/31/%E5%A4%9A%E7%BA%BF%E7%A8%8B_Part10/</id>
    <published>2019-08-30T16:00:00.000Z</published>
    <updated>2020-06-17T07:04:03.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="8-共享模型之并发工具"><a href="#8-共享模型之并发工具" class="headerlink" title="8 共享模型之并发工具"></a>8 共享模型之并发工具</h1><h2 id="8-2-J-U-C"><a href="#8-2-J-U-C" class="headerlink" title="8.2 J.U.C"></a>8.2 J.U.C</h2><h3 id="8-2-1AQS原理"><a href="#8-2-1AQS原理" class="headerlink" title="8.2.1AQS原理"></a>8.2.1AQS原理</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li><p>抽象父类，全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure></li><li><p>特点：</p><ul><li>用<code>private volatile int state;</code>属性来表示资源的状态（独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁<ul><li><code>getState</code> - 获取 state 状态 </li><li><code>setState</code> - 设置 state 状态</li><li><code>compareAndSetState</code> - cas 机制设置 state 状态</li><li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li></ul></li><li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList </li><li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li></ul></li><li><p>子类主要实现这样一些方法（默认抛出UnsupportedOperationException）</p><ul><li>tryAcquire——尝试获取锁</li><li>tryRelease ——尝试释放锁</li><li>tryAcquireShared </li><li>tryReleaseShared </li><li>isHeldExclusively——是否持有独占锁</li></ul></li><li><p>获取锁的姿势</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果获取锁失败 </span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123; </span><br><span class="line"><span class="comment">// 入队, 可以选择阻塞当前线程 park unpark</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>释放锁的姿势</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果释放锁成功 </span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123; </span><br><span class="line"><span class="comment">// 让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="自定义同步器类实现不可重入锁"><a href="#自定义同步器类实现不可重入锁" class="headerlink" title="自定义同步器类实现不可重入锁"></a>自定义同步器类实现不可重入锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j(topic = <span class="string">"MultiThread"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLock lock = <span class="keyword">new</span> MyLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"locking..."</span>);</span><br><span class="line">                Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"unlocking..."</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"locking..."</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"unlocking..."</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义锁（不可重入锁）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 独占锁  ⭐同步器类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MySync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span><span class="comment">//尝试获取锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 加上了锁，并设置 owner 为当前线程 与Monitor相似</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span><span class="comment">//尝试释放锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);        <span class="comment">// state 变量是volatile的 具有写屏障 所以放在set..后边</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">// 是否持有独占锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MySync sync = <span class="keyword">new</span> MySync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁（不成功会进入等待队列）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁，可打断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁（一次）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁，带超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 创建条件变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-2-ReentrantLock-原理"><a href="#8-2-2-ReentrantLock-原理" class="headerlink" title="8.2.2 ReentrantLock 原理"></a>8.2.2 ReentrantLock 原理</h3><p><img src="1582281399064.png" alt="1582281399064"></p><p><img src="1582362743613.png" alt="1582362743613"></p><h4 id="非公平锁实现原理——加锁解锁流程"><a href="#非公平锁实现原理——加锁解锁流程" class="headerlink" title="非公平锁实现原理——加锁解锁流程"></a>非公平锁实现原理——加锁解锁流程</h4><ul><li><p>先从构造器开始看，默认为非公平锁实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1582362617219.png" alt="1582362617219"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;<span class="comment">//和自定义的同步器很像</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);<span class="comment">//尝试加锁失败</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;<span class="comment">/*再尝试一次*/</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<span class="comment">// 失败 创建一个节点对象</span></span><br><span class="line">        selfInterrupt();<span class="comment">// 被打断时可以执行到此处</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>没有竞争时</p><p><img src="1582362454607.png" alt="1582362454607"></p></li><li><p>有竞争时，Thread-1 执行了 </p><ul><li><p>CAS 尝试将 state 由 0 改为 1，结果失败 </p></li><li><p>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败 </p><p><img src="1582362920756.png" alt="1582362920756"></p></li><li><p>接下来进入<code>addWaiter</code>逻辑，构造 Node 队列</p><ul><li>图中黄色三角表示该<code>Node</code>的<code>waitStatus</code>状态，其中 0 为默认正常状态 </li><li>Node 的创建是懒惰的 </li><li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li></ul><p><img src="1582364333577.png" alt="1582364333577"></p></li><li><p>当前线程进入 acquireQueued 逻辑</p><ul><li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞 </li><li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li><li>进入<code>shouldParkAfterFailedAcquire</code>逻辑，将前驱<code>node</code>，即<code>head</code>的 waitStatus 改为 -1，这次返回 false</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())<span class="comment">/*阻塞这了 当被unpark后 从这再来*/</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>  <img src="1582364673702.png" alt="1582364673702"></p><pre><code>* shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败* 当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true  * 进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）![1582364649949](1582364649949.png)* 再次有多个线程经历上述过程竞争失败，变成这个样子![1582365419165](1582365419165.png)* Thread-0 释放锁  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">          unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">      </span><br><span class="line">  Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">      LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">* 进入 tryRelease 流程，如果成功</span><br><span class="line">  </span><br><span class="line">* 设置 exclusiveOwnerThread 为 null </span><br><span class="line">* state &#x3D; 0</span><br><span class="line">  </span><br><span class="line">![1582365023929](1582365023929.png)</span><br><span class="line">  </span><br><span class="line">* 当前队列不为 null，并且 head 的 waitStatus &#x3D; -1，进入 unparkSuccessor 流程 </span><br><span class="line">* 找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1 </span><br><span class="line">* 回到 Thread-1 的 acquireQueued 流程</span><br><span class="line">  </span><br><span class="line">![1582365235446](1582365235446.png)</span><br><span class="line">  </span><br><span class="line">* **如果加锁成功（没有竞争）**，会设置</span><br><span class="line">  * exclusiveOwnerThread 为 Thread-1，state &#x3D; 1 </span><br><span class="line">  * head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread </span><br><span class="line">  * 原本的 head 因为从链表断开，而可被垃圾回收</span><br><span class="line">* **如果这时候有其它线程来竞争（非公平的体现）**，例如这时有 Thread-4 来了</span><br><span class="line">  </span><br><span class="line">![1582365722681](1582365722681.png)</span><br><span class="line">  </span><br><span class="line">* 如果不巧又被 Thread-4 占了先</span><br><span class="line">  * Thread-4 被设置为 exclusiveOwnerThread，state &#x3D; 1 </span><br><span class="line">  * Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</span><br></pre></td></tr></table></figure></code></pre><h4 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h4><ul><li>见单独插页</li></ul><h4 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h4><ul><li>见单独插页</li></ul><h4 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h4><ul><li>见单独插页 </li></ul><h4 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h4><ul><li>见单独插页</li></ul><h3 id="8-2-3-读写锁ReentrantReadWriteLock"><a href="#8-2-3-读写锁ReentrantReadWriteLock" class="headerlink" title="8.2.3 读写锁ReentrantReadWriteLock"></a>8.2.3 读写锁ReentrantReadWriteLock</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><img src="1591194009709.png" alt="1591194009709"></p><ul><li>当读操作远远高于写操作时，这时候使用 读写锁 让 读-读 可以并发，提高性能。 类似于数据库中的 select … from … lock in share mode</li><li>提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j(topic = <span class="string">"MultiThread"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DataContainer dataContainer = <span class="keyword">new</span> DataContainer();</span><br><span class="line">        <span class="keyword">new</span> Thread(dataContainer::read, <span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(dataContainer::read, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j(topic = <span class="string">"c.DataContainer"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rw = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.ReadLock r = rw.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.WriteLock w = rw.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"获取读锁..."</span>);</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"读取"</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"释放读锁..."</span>);</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"获取写锁..."</span>);</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"写入"</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"释放写锁..."</span>);</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">22:18:20.094 [t2] c.DataContainer - 获取读锁...</span></span><br><span class="line"><span class="comment">22:18:20.094 [t1] c.DataContainer - 获取读锁...</span></span><br><span class="line"><span class="comment">22:18:20.098 [t1] c.DataContainer - 读取</span></span><br><span class="line"><span class="comment">22:18:20.101 [t2] c.DataContainer - 读取</span></span><br><span class="line"><span class="comment">22:18:21.102 [t1] c.DataContainer - 释放读锁...</span></span><br><span class="line"><span class="comment">22:18:21.102 [t2] c.DataContainer - 释放读锁...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>读锁不支持条件变量</p></li><li><p>重入时升级不支持【即持有读锁的情况下去获取写锁】会导致获取写锁永久等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r.lock(); </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123; </span><br><span class="line">        w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123; </span><br><span class="line">    r.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重入时降级支持【持有写锁的情况下去获取读锁】</p><p><img src="1582369554434.png" alt="1582369554434"></p></li></ul><h4 id="读写锁应用：缓存更新策略"><a href="#读写锁应用：缓存更新策略" class="headerlink" title="读写锁应用：缓存更新策略"></a>读写锁应用：缓存更新策略</h4><ul><li><p>不加锁更新时，是先清缓存还是先更新数据库</p><ul><li><p>先清缓存【问题更严重】</p><p><img src="1582370147778.png" alt="1582370147778"></p></li><li><p>先更新数据库【有点问题】</p><p><img src="1582370232769.png" alt="1582370232769"></p><blockquote><p>将1 3 锁定 可以适当解决</p></blockquote></li><li><p>数据库读写锁应用</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">GenericDaoCached</span> <span class="keyword">extends</span> <span class="title">GenericDao</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> GenericDao dao = <span class="keyword">new</span> GenericDao();</span><br><span class="line">      <span class="keyword">private</span> Map&lt;SqlPair, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">private</span> ReentrantReadWriteLock rw = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">queryOne</span><span class="params">(Class&lt;T&gt; beanClass, String sql, Object... args)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 先从缓存中找，找到直接返回</span></span><br><span class="line">          SqlPair key = <span class="keyword">new</span> SqlPair(sql, args);</span><br><span class="line">          rw.readLock().lock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              T value = (T) map.get(key);</span><br><span class="line">              <span class="keyword">if</span>(value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span> value;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              rw.readLock().unlock();</span><br><span class="line">          &#125;</span><br><span class="line">          rw.writeLock().lock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 多个查询到为null的线程 双重检查</span></span><br><span class="line">              T value = (T) map.get(key);</span><br><span class="line">              <span class="keyword">if</span>(value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 缓存中没有，查询数据库</span></span><br><span class="line">                  value = dao.queryOne(beanClass, sql, args);</span><br><span class="line">                  map.put(key, value);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> value;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              rw.writeLock().unlock();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String sql, Object... args)</span> </span>&#123;</span><br><span class="line">          rw.writeLock().lock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 先更新库</span></span><br><span class="line">              <span class="keyword">int</span> update = dao.update(sql, args);</span><br><span class="line">              <span class="comment">// 清空缓存</span></span><br><span class="line">              map.clear();</span><br><span class="line">              <span class="keyword">return</span> update;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              rw.writeLock().unlock();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">SqlPair</span> </span>&#123;</span><br><span class="line">          <span class="keyword">private</span> String sql;</span><br><span class="line">          <span class="keyword">private</span> Object[] args;</span><br><span class="line">  </span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="title">SqlPair</span><span class="params">(String sql, Object[] args)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">this</span>.sql = sql;</span><br><span class="line">              <span class="keyword">this</span>.args = args;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>适合读多写少，如果写操作比较频繁，性能较低</p><p>没有考虑缓存容量</p><p>没有考虑缓存过期</p></blockquote></li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>见单独插页</li></ul><h3 id="8-2-4-StampedLock"><a href="#8-2-4-StampedLock" class="headerlink" title="8.2.4 StampedLock"></a>8.2.4 StampedLock</h3><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><ul><li><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p></li><li><p><strong>加解读锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.readLock(); </span><br><span class="line">lock.unlockRead(stamp);</span><br></pre></td></tr></table></figure></li><li><p><strong>加解写锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.writeLock(); </span><br><span class="line">lock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure></li><li><p>乐观读，<code>StampedLock</code>支持<code>tryOptimisticRead()</code>方法（乐观读），读取完毕后需要做一次戳校验。如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.tryOptimisticRead(); <span class="comment">// 验戳</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123; </span><br><span class="line">    <span class="comment">// 锁升级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DataContainer dataContainer = <span class="keyword">new</span> DataContainer();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> read = dataContainer.read(<span class="number">1</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        sleep(<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; dataContainer.write()).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j(topic = <span class="string">"c.DataContainerStamped"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataContainerStamped</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock lock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataContainerStamped</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> readTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = lock.tryOptimisticRead();</span><br><span class="line">        log.debug(<span class="string">"optimistic read locking...&#123;&#125;"</span>, stamp);</span><br><span class="line">        sleep(readTime);</span><br><span class="line">        <span class="keyword">if</span> (lock.validate(stamp)) &#123; <span class="comment">//戳验证成功</span></span><br><span class="line">            log.debug(<span class="string">"read finish...&#123;&#125;, data:&#123;&#125;"</span>, stamp, data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验戳失败 锁升级 乐观读 -&gt; 读锁</span></span><br><span class="line">        log.debug(<span class="string">"updating to read lock... &#123;&#125;"</span>, stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp = lock.readLock();</span><br><span class="line">            log.debug(<span class="string">"read lock &#123;&#125;"</span>, stamp);</span><br><span class="line">            sleep(readTime);</span><br><span class="line">            log.debug(<span class="string">"read finish...&#123;&#125;, data:&#123;&#125;"</span>, stamp, data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"read unlock &#123;&#125;"</span>, stamp);</span><br><span class="line">            lock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> newData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = lock.writeLock();</span><br><span class="line">        log.debug(<span class="string">"write lock &#123;&#125;"</span>, stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">this</span>.data = newData;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"write unlock &#123;&#125;"</span>, stamp);</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10:00:51.141 [Thread-0] c.DataContainer - optimistic read locking...256</span></span><br><span class="line"><span class="comment">10:00:51.640 [Thread-1] c.DataContainer - 获取写锁...</span></span><br><span class="line"><span class="comment">10:00:51.640 [Thread-1] c.DataContainer - 写入</span></span><br><span class="line"><span class="comment">10:00:52.155 [Thread-0] c.DataContainer - updating to read lock... 256</span></span><br><span class="line"><span class="comment">10:00:52.640 [Thread-1] c.DataContainer - 释放写锁...</span></span><br><span class="line"><span class="comment">10:00:52.640 [Thread-0] c.DataContainer - read lock 513</span></span><br><span class="line"><span class="comment">10:00:53.640 [Thread-0] c.DataContainer - read finish...513, data:0</span></span><br><span class="line"><span class="comment">10:00:53.640 [Thread-0] c.DataContainer - read unlock 513</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>StampedLock 不支持条件变量 </li><li>StampedLock 不支持可重入</li></ul><h3 id="8-2-5-信号量Semaphore"><a href="#8-2-5-信号量Semaphore" class="headerlink" title="8.2.5 信号量Semaphore"></a>8.2.5 信号量Semaphore</h3><h4 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h4><ul><li>信号量，用来限制能同时访问共享资源的线程上限。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j(topic = <span class="string">"c.TestSemaphore"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建 semaphore 对象</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);<span class="comment">// 参数：最大访问线程数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 10个线程同时运行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();<span class="comment">// ⭐</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">"running..."</span>);</span><br><span class="line">                    sleep(<span class="number">1</span>);</span><br><span class="line">                    log.debug(<span class="string">"end..."</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">11:37:42.736 [Thread-0] MyTest - running...</span></span><br><span class="line"><span class="comment">11:37:42.736 [Thread-1] MyTest - running...</span></span><br><span class="line"><span class="comment">11:37:42.736 [Thread-2] MyTest - running...</span></span><br><span class="line"><span class="comment">11:37:43.746 [Thread-1] MyTest - end...</span></span><br><span class="line"><span class="comment">11:37:43.746 [Thread-0] MyTest - end...</span></span><br><span class="line"><span class="comment">11:37:43.746 [Thread-3] MyTest - running...</span></span><br><span class="line"><span class="comment">11:37:43.746 [Thread-2] MyTest - end...</span></span><br><span class="line"><span class="comment">11:37:43.746 [Thread-4] MyTest - running...</span></span><br><span class="line"><span class="comment">11:37:44.746 [Thread-4] MyTest - end...</span></span><br><span class="line"><span class="comment">11:37:44.746 [Thread-3] MyTest - end...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li>使用Semaphore限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机线程数量，并且<strong>仅是限制线程数</strong>，而不是限制资源数（例如连接数，请对比Tomcat LimitLatch的实现）</li><li>用Semaphore实现简单连接池，对比【享元模式】下的实现(用wait notify) ，性能和可读性显然更好</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5. 借连接</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Connection <span class="title">borrow</span><span class="params">()</span> </span>&#123;<span class="comment">// t1, t2, t3</span></span><br><span class="line">       <span class="comment">// 获取许可</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           semaphore.acquire(); <span class="comment">// 没有许可的线程，在此等待</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">           <span class="comment">// 获取空闲连接</span></span><br><span class="line">           <span class="keyword">if</span>(states.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (states.compareAndSet(i, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                   log.debug(<span class="string">"borrow &#123;&#125;"</span>, connections[i]);</span><br><span class="line">                   <span class="keyword">return</span> connections[i];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 不会执行到这里</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 6. 归还连接</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (connections[i] == conn) &#123;</span><br><span class="line">               states.set(i, <span class="number">0</span>);</span><br><span class="line">               log.debug(<span class="string">"free &#123;&#125;"</span>, conn);</span><br><span class="line">               semaphore.release();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ul><li>见单独插页</li></ul><h3 id="8-2-6倒计时锁CountdownLatch"><a href="#8-2-6倒计时锁CountdownLatch" class="headerlink" title="8.2.6倒计时锁CountdownLatch"></a>8.2.6倒计时锁CountdownLatch</h3><ul><li>用来进行线程同步协作，等待所有线程完成倒计时。 </li><li>其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一</li></ul><ul><li>CountDownLatch能够使<strong>一个或多个线程</strong>等待<strong>其他线程完成各自的工作后再执行</strong>。</li><li>可以理解为一个计数器。在初始化 CountDownLatch 的时候会在类的内部初始化一个int的变量，每当调用 countDownt() 方法的时候这个变量的值减1，而 await() 方法就是去判断这个变量的值是否为0，是则表示所有的操作都已经完成，否则继续等待。</li><li>特有方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定计数的次数，只能被设置1次</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span></span>; </span><br><span class="line"><span class="comment">//调用此方法则计数减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span></span>;          </span><br><span class="line"><span class="comment">//调用此方法会一直阻塞当前线程，直到计时器的值为0，除非线程被中断。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException   </span></span><br><span class="line"><span class="function"><span class="comment">//得到当前的计数</span></span></span><br><span class="line"><span class="function">Public Long <span class="title">getCount</span><span class="params">()</span></span>;           </span><br><span class="line"><span class="comment">//调用此方法会一直阻塞当前线程，直到计时器的值为0，除非线程被中断或者计数器超时，返回false代表计数器超时。</span></span><br><span class="line"><span class="function">Public <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span></span><br><span class="line"><span class="function">From Object Inherited：</span></span><br><span class="line"><span class="function">Clone、equals、hashCode、notify、notifyALL、wait等</span></span><br></pre></td></tr></table></figure><ul><li>使用场景<ul><li>开启多个线程分块下载一个大文件，每个线程只下载固定的一截，最后由另外一个线程来拼接所有的分段。</li><li>应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</li><li>确保一个计算不会执行，直到所需要的资源被初始化。</li></ul></li><li>实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">static</span>  <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"don't let run yet"</span>);</span><br><span class="line">        System.out.println(<span class="string">"主线程喊开始..."</span>);</span><br><span class="line">        startSignal.countDown();      <span class="comment">// let all threads proceed</span></span><br><span class="line">        </span><br><span class="line">        doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">        System.out.println(<span class="string">"都干完就好..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">    Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">        <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">        <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"准备..."</span>);</span><br><span class="line">            startSignal.await();</span><br><span class="line">            System.out.println(<span class="string">"Working..."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"done..."</span>);</span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">准备...</span></span><br><span class="line"><span class="comment">准备...</span></span><br><span class="line"><span class="comment">准备...</span></span><br><span class="line"><span class="comment">准备...</span></span><br><span class="line"><span class="comment">准备...</span></span><br><span class="line"><span class="comment">准备...</span></span><br><span class="line"><span class="comment">准备...</span></span><br><span class="line"><span class="comment">准备...</span></span><br><span class="line"><span class="comment">准备...</span></span><br><span class="line"><span class="comment">准备...</span></span><br><span class="line"><span class="comment">主线程喊开始...</span></span><br><span class="line"><span class="comment">Working...</span></span><br><span class="line"><span class="comment">Working...</span></span><br><span class="line"><span class="comment">Working...</span></span><br><span class="line"><span class="comment">Working...</span></span><br><span class="line"><span class="comment">Working...</span></span><br><span class="line"><span class="comment">Working...</span></span><br><span class="line"><span class="comment">Working...</span></span><br><span class="line"><span class="comment">Working...</span></span><br><span class="line"><span class="comment">Working...</span></span><br><span class="line"><span class="comment">Working...</span></span><br><span class="line"><span class="comment">Thread-5done...</span></span><br><span class="line"><span class="comment">Thread-2done...</span></span><br><span class="line"><span class="comment">Thread-6done...</span></span><br><span class="line"><span class="comment">Thread-8done...</span></span><br><span class="line"><span class="comment">Thread-3done...</span></span><br><span class="line"><span class="comment">Thread-0done...</span></span><br><span class="line"><span class="comment">Thread-7done...</span></span><br><span class="line"><span class="comment">Thread-4done...</span></span><br><span class="line"><span class="comment">Thread-9done...</span></span><br><span class="line"><span class="comment">Thread-1done...</span></span><br><span class="line"><span class="comment">都干完就好...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="8-2-7-循环栅栏CyclicBarrier"><a href="#8-2-7-循环栅栏CyclicBarrier" class="headerlink" title="8.2.7 循环栅栏CyclicBarrier"></a>8.2.7 循环栅栏CyclicBarrier</h3><ul><li><p>循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行</p></li><li><p>CyclicBarrier 与 CountDownLatch 的主要区别在于 CyclicBarrier 是可以重用的 CyclicBarrier 可以被比喻为『人满发车』</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注意：线程池与Count数一致 否则由于时间不同 导致出发await的不是预期的线程</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, ()-&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"task1, task2 finish..."</span>);</span><br><span class="line">        &#125;);<span class="comment">//第二个参数可以在计数个数到0的时候执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; <span class="comment">// task1  task2  task1</span></span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">"task1 begin..."</span>);</span><br><span class="line">                Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    barrier.await(); <span class="comment">// 2-1=1</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">"task2 begin..."</span>);</span><br><span class="line">                Sleeper.sleep(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    barrier.await(); <span class="comment">// 1-1=0</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    09:43:36.933 [pool-1-thread-1] MultiThread - task1 begin...</span></span><br><span class="line"><span class="comment">09:43:36.933 [pool-1-thread-2] MultiThread - task2 begin...</span></span><br><span class="line"><span class="comment">09:43:38.936 [pool-1-thread-2] MultiThread - task1, task2 finish...</span></span><br><span class="line"><span class="comment">09:43:38.936 [pool-1-thread-1] MultiThread - task1 begin...</span></span><br><span class="line"><span class="comment">09:43:38.936 [pool-1-thread-2] MultiThread - task2 begin...</span></span><br><span class="line"><span class="comment">09:43:40.936 [pool-1-thread-2] MultiThread - task1, task2 finish...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>线程池线程数和CyclicBarrier的参数数量一样</li></ul>]]></content>
    
    <summary type="html">
    
      Java并发工具
    
    </summary>
    
    
      <category term="Java高级" scheme="http://goldcarpenter.github.io/categories/Java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="多线程" scheme="http://goldcarpenter.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程编程</title>
    <link href="http://goldcarpenter.github.io/2019/08/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B_Part9/"/>
    <id>http://goldcarpenter.github.io/2019/08/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B_Part9/</id>
    <published>2019-08-24T14:24:02.000Z</published>
    <updated>2020-06-17T07:04:16.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="8-共享模型之并发工具"><a href="#8-共享模型之并发工具" class="headerlink" title="8 共享模型之并发工具"></a>8 共享模型之并发工具</h1><h2 id="8-1-线程池"><a href="#8-1-线程池" class="headerlink" title="8.1 线程池"></a>8.1 线程池</h2><h3 id="8-1-1-线程池优点"><a href="#8-1-1-线程池优点" class="headerlink" title="8.1.1 线程池优点"></a>8.1.1 线程池优点</h3><ul><li>减少了创建线程的时间，提高响应速度</li><li>重复利用线程池中的线程，避免多次创建</li></ul><ul><li><p>线程数量过多缺点：①每个线程都要分配内存开销②线程上下文切换系统开销</p><p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B4_img/1582178021215.png" alt="1582178021215"></p><ul><li>阻塞队列：平衡生产者和线程池消费者速率不同的消息队列</li></ul></li></ul><h3 id="8-1-2-自定义线程池"><a href="#8-1-2-自定义线程池" class="headerlink" title="8.1.2 自定义线程池"></a>8.1.2 自定义线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j(topic = <span class="string">"MultiThread"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 线程池中执行单元 , 执行单元超时销毁时间, 执行单元超时销毁单位, 阻塞队列长度, 执行单元不足时 策略</span></span><br><span class="line">        ThreadPool threadPool = <span class="keyword">new</span> ThreadPool(<span class="number">1</span>,</span><br><span class="line">                <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">2</span>,</span><br><span class="line">                <span class="keyword">new</span> RejectPolicy&lt;Runnable&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(BlockingQueue&lt;Runnable&gt; queue, Runnable task)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 1. 阻塞队列满后 生产者死等队列空出</span></span><br><span class="line">                        <span class="comment">//queue.put(task);</span></span><br><span class="line">                        <span class="comment">// 2) 阻塞队列满后 生产者带超时等待队列空出</span></span><br><span class="line">                        <span class="comment">//queue.offer(task, 100, TimeUnit.MILLISECONDS);</span></span><br><span class="line">                        <span class="comment">// 3) 没有设计阻塞队列 执行单元不足时让调用者放弃任务执行</span></span><br><span class="line">                        <span class="comment">//log.debug("放弃&#123;&#125;", task);</span></span><br><span class="line">                        <span class="comment">// 4) 没有设计阻塞队列 执行单元不足时让让调用者抛出异常</span></span><br><span class="line">                        <span class="comment">//throw new RuntimeException("任务执行失败 " + task);</span></span><br><span class="line">                        <span class="comment">// 5) 没有设计阻塞队列 让调用者（main)自己执行任务</span></span><br><span class="line">                        <span class="comment">//task.run();</span></span><br><span class="line">                  &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Sleeper.sleep(<span class="number">6</span>);</span><br><span class="line">                    System.out.println(j);</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行单元不足时 策略接口【设计模式:策略模式】</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RejectPolicy</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue, T task)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j(topic = <span class="string">"c.ThreadPool"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span>&#123;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line">    <span class="comment">// 运行单元集合</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> coreSize;</span><br><span class="line">    <span class="comment">// 获取任务时的超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">long</span> timeout, TimeUnit timeUnit,<span class="keyword">int</span> queueCapcity, RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="keyword">this</span>.taskQueue = <span class="keyword">new</span> BlockingQueue&lt;&gt;(queueCapcity);</span><br><span class="line">        <span class="keyword">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//works并非线程安全</span></span><br><span class="line">        <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">            <span class="comment">// 当任务数没有超过 coreSize 时，直接创建线程交给 worker 对象执行</span></span><br><span class="line">            <span class="comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span></span><br><span class="line">            <span class="keyword">if</span> (workers.size() &lt; coreSize)&#123;</span><br><span class="line">                Worker worker = <span class="keyword">new</span> Worker(task);</span><br><span class="line">                log.debug(<span class="string">"新增执行单元worker&#123;&#125;"</span>, worker);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rejectPolicy.reject(taskQueue,task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行单元</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//1）当task不为空 执行任务</span></span><br><span class="line">            <span class="comment">//2) 当task执行完毕 再接着获取任务队列</span></span><br><span class="line">            <span class="comment">//while (task != null ||(task = taskQueue.take()) != null)// 执行单元永不销毁,始终阻塞在任务队列中等待任务</span></span><br><span class="line">            <span class="comment">//没有任务 run执行结束 将worker从线程池移除</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> ||(task = taskQueue.poll(timeout,timeUnit)) != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    log.debug(<span class="string">"执行单元worker执行&#123;&#125;"</span>,task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (workers)</span><br><span class="line">            &#123;</span><br><span class="line">                log.debug(<span class="string">"执行单元&#123;&#125;从集合中退出"</span>,<span class="keyword">this</span>);</span><br><span class="line">                workers.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="comment">//阻塞队列 基于泛型的生产者消费者模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 任务的阻塞双向链表</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 生产者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> Condition fullWaitSet = lock.newCondition();</span><br><span class="line">    <span class="comment">// 消费者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> Condition emptyWaitSet = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capcity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockingQueue</span><span class="params">(<span class="keyword">int</span> capcity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capcity = capcity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T task)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">"task&#123;&#125;加入阻塞队列"</span>,task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时时间阻塞添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(T task,<span class="keyword">long</span> timeout, TimeUnit timeUnit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">long</span> nanos = timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        log.debug(<span class="string">"task&#123;&#125;加入阻塞队列超时丢弃"</span>,task);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;nanos = fullWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">"task&#123;&#125;加入阻塞队列"</span>,task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 带超时阻塞获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将 timeout 统一转换为 纳秒</span></span><br><span class="line">            <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 返回值是剩余时间</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = emptyWaitSet.awaitNanos(nanos);<span class="comment">// 返回值就是剩余时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B4_img/1591168757447.png" alt="1591168757447"></p><h3 id="8-1-3-Executor接口"><a href="#8-1-3-Executor接口" class="headerlink" title="8.1.3 Executor接口"></a>8.1.3 Executor接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executor只是接口 内部只有execute方法</span></span><br><span class="line"><span class="comment">     * 执行给定的命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义Executor接口实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">implements</span> <span class="title">Executor</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new Thread(command).start();</span></span><br><span class="line">        command.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Main().execute(()-&gt;System.out.println(<span class="string">"自定义Executor"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">15:03:14.523 [main] MyTest - 自定义Executor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">15:02:52.026 [Thread-0] MyTest - 自定义Executor</span></span><br><span class="line"><span class="comment">15:02:52.026 [main] MyTest - 自定义Executor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="8-1-4-ExecutorService接口"><a href="#8-1-4-ExecutorService接口" class="headerlink" title="8.1.4 ExecutorService接口"></a>8.1.4 ExecutorService接口</h3><ul><li><p><strong>ExecutorService接口：真正的线程池接口，常用子类ThreadPoolExecutors</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"running..."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(service);</span><br><span class="line">        System.out.println(<span class="string">"================================================"</span>);</span><br><span class="line">        service.shutdown();</span><br><span class="line">        System.out.println(<span class="string">"service.isTerminated():"</span> + service.isTerminated());</span><br><span class="line">        System.out.println(<span class="string">"service.isShutdown():"</span> + service.isShutdown());</span><br><span class="line">        System.out.println(service);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>); <span class="comment">//保证所有线程运行完</span></span><br><span class="line">        System.out.println(<span class="string">"================================================"</span>);</span><br><span class="line">        System.out.println(<span class="string">"service.isTerminated():"</span> + service.isTerminated());</span><br><span class="line">        System.out.println(<span class="string">"service.isShutdown():"</span> + service.isShutdown());</span><br><span class="line">        System.out.println(service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pool-1-thread-1running...</span></span><br><span class="line"><span class="comment">pool-1-thread-3running...</span></span><br><span class="line"><span class="comment">pool-1-thread-2running...</span></span><br><span class="line"><span class="comment">java.util.concurrent.ThreadPoolExecutor@7ba4f24f[Running, pool size = 3, active threads = 3, queued tasks = 7, completed tasks = 0]</span></span><br><span class="line"><span class="comment">================================================</span></span><br><span class="line"><span class="comment">service.isTerminated():false</span></span><br><span class="line"><span class="comment">service.isShutdown():true</span></span><br><span class="line"><span class="comment">java.util.concurrent.ThreadPoolExecutor@7ba4f24f[Shutting down, pool size = 3, active threads = 3, queued tasks = 7, completed tasks = 0]</span></span><br><span class="line"><span class="comment">pool-1-thread-1running...</span></span><br><span class="line"><span class="comment">pool-1-thread-3running...</span></span><br><span class="line"><span class="comment">pool-1-thread-2running...</span></span><br><span class="line"><span class="comment">pool-1-thread-1running...</span></span><br><span class="line"><span class="comment">pool-1-thread-2running...</span></span><br><span class="line"><span class="comment">pool-1-thread-3running...</span></span><br><span class="line"><span class="comment">pool-1-thread-1running...</span></span><br><span class="line"><span class="comment">================================================</span></span><br><span class="line"><span class="comment">service.isTerminated():true</span></span><br><span class="line"><span class="comment">service.isShutdown():true</span></span><br><span class="line"><span class="comment">java.util.concurrent.ThreadPoolExecutor@7ba4f24f[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 10]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="8-1-5-ThreadPoolExecutor"><a href="#8-1-5-ThreadPoolExecutor" class="headerlink" title="8.1.5 ThreadPoolExecutor"></a>8.1.5 ThreadPoolExecutor</h3><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><ul><li><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p><table><thead><tr><th align="center">状态名</th><th align="center">高3位</th><th align="center">接收新任务</th><th align="center">处理阻塞队列任务</th><th>说明</th></tr></thead><tbody><tr><td align="center">RUNNING</td><td align="center">111</td><td align="center">Y</td><td align="center">Y</td><td></td></tr><tr><td align="center">SHUTDOWN</td><td align="center">000</td><td align="center">N</td><td align="center">Y</td><td>不会接收新任务，但会处理阻塞队列剩余任务</td></tr><tr><td align="center">STOP</td><td align="center">001</td><td align="center">N</td><td align="center">N</td><td>会中断正在执行的任务，并抛弃阻塞队列任务</td></tr><tr><td align="center">TIDYING</td><td align="center">010</td><td align="center">-</td><td align="center">-</td><td>任务全执行完毕，活动线程为 0 即将进入终结</td></tr><tr><td align="center">TERMINATED</td><td align="center">011</td><td align="center">-</td><td align="center">-</td><td>终结状态</td></tr></tbody></table></li><li><p>从数字上比较，TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING</p></li><li><p>这些<strong>信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作进行赋值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c 为旧值， ctlOf 返回结果为新值</span></span><br><span class="line">ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));</span><br><span class="line"><span class="comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li>根据这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> maximumPoolSize, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">long</span> keepAliveTime, </span></span></span><br><span class="line"><span class="function"><span class="params">TimeUnit unit, </span></span></span><br><span class="line"><span class="function"><span class="params">BlockingQueue&lt;Runnable&gt; workQueue, </span></span></span><br><span class="line"><span class="function"><span class="params">ThreadFactory threadFactory, </span></span></span><br><span class="line"><span class="function"><span class="params">RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>corePoolSize</code>核心线程数目 (最多保留的线程数)</li><li><code>maximumPoolSize</code>最大线程数目</li><li><code>keepAliveTime</code>救急线程生存时间</li><li><code>unit</code>救急线程时间单位</li><li><code>workQueue</code>阻塞队列</li><li><code>threadFactory</code>线程工厂 - 可以为线程创建时起个好名字 </li><li><code>handler</code>拒绝策略</li></ul><p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B4_img/1582211601375.png" alt="1582211601375"></p><ul><li><p>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。 </p></li><li><p>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程。</p></li><li><p>如果<strong>队列选择了有界队列</strong>，那么任务<strong>超过了队列大小</strong>时，会<strong>创建</strong> maximumPoolSize - corePoolSize 数目的<strong>线程来救急</strong>。 </p></li><li><p>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。</p></li><li><p>jdk 提供了 4 种拒绝策略实现，其它著名框架也提供了拒绝策略实现 </p><p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B4_img/1582212135088.png" alt="1582212135088"></p><ul><li><p>AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略</p></li><li><p>CallerRunsPolicy 让调用者运行任务 </p></li><li><p>DiscardPolicy 放弃本次任务 </p></li><li><p>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之 </p></li><li><p>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题 </p></li><li><p>Netty 的实现，是创建一个新线程来执行任务 </p></li><li><p>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略 </p></li><li><p>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</p></li></ul></li></ul><h4 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 泛型代表了执行任务返回值类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取消任务的执行。参数指定是否立即中断任务执行，或者等等任务结束</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务是否已经取消，任务正常完成前将其取消，则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务是否已经完成。需要注意的是如果任务正常终止、异常或取消，都将返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞直到任务返回结果 InterruptedException 线程被中断异常， ExecutionException任务执行异常，如果任务被取消，还会抛出CancellationException</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多了设置超时时间</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        Future&lt;Integer&gt; task = service.submit(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(task.isDone());</span><br><span class="line">        System.out.println(task.get());</span><br><span class="line">        System.out.println(task.isDone());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">1000</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h4><ul><li>Future接口的一个唯一实现类</li><li>既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     <span class="keyword">this</span>.callable = callable;</span><br><span class="line">     <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">     <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        FutureTask&lt;Boolean&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"running"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"end"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        System.out.print(task.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">running</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="8-1-6-Executors工具类"><a href="#8-1-6-Executors工具类" class="headerlink" title="8.1.6 Executors工具类"></a>8.1.6 Executors工具类</h3><ul><li><p><strong>Executors类：线程池的工具类，用于创建不同的线程池，大多都是静态方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池对象</span></span><br><span class="line">ExecutorService ser = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 执行任务 有返回值 参数一般为Callable接口</span></span><br><span class="line">ser.submit(<span class="comment">/*Callable接口*/</span>);</span><br><span class="line"><span class="comment">// 执行任务 无返回值 参数一般为Runnable接口</span></span><br><span class="line">ser.execute(<span class="comment">/*Runnable接口*/</span>);</span><br><span class="line"><span class="comment">// 关闭连接池</span></span><br><span class="line">ser.shutdown();</span><br></pre></td></tr></table></figure></li></ul><ul><li>executor &amp; submit区别<ul><li>executor <ul><li>Executor接口中的方法</li><li>接受runnable接口</li><li>无返回值</li></ul></li><li>submit<ul><li>ExecutorService接口【Executor接口子接口】中的方法</li><li>runnable &amp; callable接口</li><li>有返回值</li></ul></li></ul></li></ul><h4 id="1-定长线程池newFixedThreadPool"><a href="#1-定长线程池newFixedThreadPool" class="headerlink" title="1 定长线程池newFixedThreadPool"></a>1 定长线程池newFixedThreadPool</h4><ul><li><p>可控制线程最大并发数，超出的线程会在队列中等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads,</span><br><span class="line">    nThreads, </span><br><span class="line">    <span class="number">0L</span>, TimeUnit.MILLISECONDS, </span><br><span class="line">    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>核心线程数 == 最大线程数（没有救急线程被创建）</strong>，因此也无需超时时间 </li><li><strong>阻塞队列是无界的，可以放任意数量的任务</strong></li></ul></li><li><p>适用于任务量已知，相对耗时的任务</p></li></ul><h4 id="2-可缓存线程池newCachedThreadPool"><a href="#2-可缓存线程池newCachedThreadPool" class="headerlink" title="2 可缓存线程池newCachedThreadPool"></a>2 可缓存线程池newCachedThreadPool</h4><ul><li><p>如果线程池长度超过处理需要，若无空闲线程，则新建线程。超过60秒线程未使用则回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着</p><ul><li><strong>全部都是救急线程（60s 后可以回收）</strong></li><li><strong>救急线程可以无限创建</strong></li><li><strong>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; integers = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"putting &#123;&#125; "</span>, <span class="number">1</span>);</span><br><span class="line">                integers.put(<span class="number">1</span>);        <span class="comment">// 要执行完take才会向下运行</span></span><br><span class="line">                log.debug(<span class="string">"&#123;&#125; putted..."</span>, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">5</span>);</span><br><span class="line">        log.debug(<span class="string">"taking &#123;&#125;"</span>, <span class="number">1</span>);</span><br><span class="line">        integers.take();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 </p></li><li><p>适合任务数比较密集，但每个任务执行时间较短的情况</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">            MyTask mytask = <span class="keyword">new</span> MyTask();</span><br><span class="line">            Future task1 = service.submit(mytask);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            System.out.println(service);</span><br><span class="line">            Future task2 = service.submit(mytask);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            System.out.println(service);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            Future task3 = service.submit(mytask);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            System.out.println(service);</span><br><span class="line">            Future task4 = service.submit(mytask);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            System.out.println(service);</span><br><span class="line">            task1.get();</span><br><span class="line">            task2.get();</span><br><span class="line">            task3.get();</span><br><span class="line">            task4.get();</span><br><span class="line"></span><br><span class="line">            System.out.println(service);</span><br><span class="line">            Thread.sleep(<span class="number">80000</span>);</span><br><span class="line">            System.out.println(service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.concurrent.ThreadPoolExecutor@6d6f6e28[Running, pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 0]</span></span><br><span class="line"><span class="comment">java.util.concurrent.ThreadPoolExecutor@6d6f6e28[Running, pool size = 2, active threads = 2, queued tasks = 0, completed tasks = 0]</span></span><br><span class="line"><span class="comment">java.util.concurrent.ThreadPoolExecutor@6d6f6e28[Running, pool size = 2, active threads = 1, queued tasks = 0, completed tasks = 2]</span></span><br><span class="line"><span class="comment">java.util.concurrent.ThreadPoolExecutor@6d6f6e28[Running, pool size = 2, active threads = 2, queued tasks = 0, completed tasks = 2]</span></span><br><span class="line"><span class="comment">java.util.concurrent.ThreadPoolExecutor@6d6f6e28[Running, pool size = 2, active threads = 0, queued tasks = 0, completed tasks = 4]</span></span><br><span class="line"><span class="comment">java.util.concurrent.ThreadPoolExecutor@6d6f6e28[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 4]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="3-单例线程池newSingleThreadExecutor"><a href="#3-单例线程池newSingleThreadExecutor" class="headerlink" title="3 单例线程池newSingleThreadExecutor"></a>3 单例线程池newSingleThreadExecutor</h4><ul><li><p>保证了线程的顺序，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p></li><li><p><strong>希望多个任务排队执行</strong>。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p></li><li><p><strong>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">  executorService.execute(()-&gt;&#123;</span><br><span class="line">      log.debug(<span class="string">"run 1"</span>);</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  executorService.execute(()-&gt;&#123;</span><br><span class="line">      log.debug(<span class="string">"run 2"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  executorService.execute(()-&gt;&#123;</span><br><span class="line">      log.debug(<span class="string">"run 3"</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="Executors-newFixedThreadPool-1-与此区别"><a href="#Executors-newFixedThreadPool-1-与此区别" class="headerlink" title="Executors.newFixedThreadPool(1)与此区别"></a><code>Executors.newFixedThreadPool(1)</code>与此区别</h4><ul><li>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改<ul><li>FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法</li></ul></li><li>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改<ul><li>对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 装饰器模式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>,</span><br><span class="line">                                    TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-任务调度线程池ScheduledExecutorService"><a href="#4-任务调度线程池ScheduledExecutorService" class="headerlink" title="4 任务调度线程池ScheduledExecutorService"></a>4 任务调度线程池ScheduledExecutorService</h4><ul><li><p>在『任务调度线程池』功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，</p><ul><li><p>缺点：同一时间只能有一个任务在执行，前一个任务的<strong>延迟或异常</strong>都将会影响到之后的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        TimerTask task1 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.debug(<span class="string">"task 1"</span>);</span><br><span class="line">                Sleeper.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        TimerTask task2 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.debug(<span class="string">"task 2"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">"start..."</span>);</span><br><span class="line">        timer.schedule(task1, <span class="number">1000</span>);</span><br><span class="line">        timer.schedule(task2, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行 </span></span><br><span class="line"><span class="comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行</span></span><br><span class="line"><span class="number">11</span>:<span class="number">33</span>:<span class="number">03.832</span> [main] MultiThread - start...</span><br><span class="line"><span class="number">11</span>:<span class="number">33</span>:<span class="number">04.840</span> [Timer-<span class="number">0</span>] MultiThread - task <span class="number">1</span></span><br><span class="line"><span class="number">11</span>:<span class="number">33</span>:<span class="number">06.844</span> [Timer-<span class="number">0</span>] MultiThread - task <span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>任务调度线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*public class ScheduledThreadPoolExecutor</span></span><br><span class="line"><span class="comment">    extends ThreadPoolExecutor</span></span><br><span class="line"><span class="comment">    implements ScheduledExecutorService*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>延迟执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">log.debug(<span class="string">"now"</span>);</span><br><span class="line">service.schedule(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">"run"</span>);</span><br><span class="line">&#125;, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    17:15:00.239 [main] MyTest - now</span></span><br><span class="line"><span class="comment">17:15:02.384 [pool-1-thread-1] MyTest - run【隔了2秒】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>延时循环执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService service1 = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">service1.scheduleAtFixedRate(()-&gt;&#123;<span class="comment">//⭐scheduleAtFixedRate</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">"scheduleAtFixedRate run"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);<span class="comment">//任务运行时间大于间隔时间 导致间隔时间被包含 任务不重叠</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">0</span>,<span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">Sleeper.sleep(<span class="number">10</span>);</span><br><span class="line">service1.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">17:27:04.370 [pool-1-thread-1] MyTest - scheduleAtFixedRate run</span></span><br><span class="line"><span class="comment">17:27:05.381 [pool-1-thread-1] MyTest - scheduleAtFixedRate run</span></span><br><span class="line"><span class="comment">17:27:06.382 [pool-1-thread-2] MyTest - scheduleAtFixedRate run</span></span><br><span class="line"><span class="comment">17:27:07.382 [pool-1-thread-2] MyTest - scheduleAtFixedRate run</span></span><br><span class="line"><span class="comment">17:27:08.383 [pool-1-thread-2] MyTest - scheduleAtFixedRate run</span></span><br><span class="line"><span class="comment">17:27:09.384 [pool-1-thread-2] MyTest - scheduleAtFixedRate run</span></span><br><span class="line"><span class="comment">【上一个开始执行计时 开始计时总计隔了1秒】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService service2 = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">service2.scheduleWithFixedDelay(()-&gt;&#123;<span class="comment">//⭐scheduleWithFixedDelay</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">"scheduleWithFixedDelay run"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">0</span>,<span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">16:00:52.942 [pool-3-thread-1] MultiThread - scheduleWithFixedDelay run</span></span><br><span class="line"><span class="comment">16:00:55.943 [pool-3-thread-1] MultiThread - scheduleWithFixedDelay run【要等上一个执行完 存在延时 开始计时总计隔了3秒】</span></span><br><span class="line"><span class="comment">16:00:58.945 [pool-3-thread-2] MultiThread - scheduleWithFixedDelay run*/</span></span><br></pre></td></tr></table></figure><h5 id="如何让每周四-18-00-00-定时执行任务？"><a href="#如何让每周四-18-00-00-定时执行任务？" class="headerlink" title="如何让每周四 18:00:00 定时执行任务？"></a>如何让每周四 18:00:00 定时执行任务？</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  获取当前时间</span></span><br><span class="line">        LocalDateTime now = LocalDateTime.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line">        <span class="comment">// 获取周四时间</span></span><br><span class="line">        LocalDateTime time = now.withHour(<span class="number">18</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>).with(DayOfWeek.THURSDAY);</span><br><span class="line">        <span class="comment">// 如果 当前时间 &gt; 本周周四，必须找到下周周四</span></span><br><span class="line">        <span class="keyword">if</span>(now.compareTo(time) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            time = time.plusWeeks(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(time);</span><br><span class="line">        <span class="comment">// initailDelay 代表当前时间和周四的时间差</span></span><br><span class="line">        <span class="comment">// period 一周的间隔时间</span></span><br><span class="line">        <span class="keyword">long</span> initailDelay = Duration.between(now, time).toMillis();</span><br><span class="line">        <span class="keyword">long</span> period = <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>;</span><br><span class="line">        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"running..."</span>);</span><br><span class="line">        &#125;, initailDelay, period, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-提交任务"><a href="#5-提交任务" class="headerlink" title="5 提交任务"></a>5 提交任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务 task，用返回值 Future 获得任务执行结果 </span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;<span class="comment">//【Future使用了保护性暂停模式 线程间通信获取结果】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务 </span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间 </span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line"><span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消 </span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">       ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">       method1(pool);</span><br><span class="line">       Sleeper.sleep(<span class="number">10</span>);</span><br><span class="line">       method2(pool);</span><br><span class="line">       Sleeper.sleep(<span class="number">10</span>);</span><br><span class="line">       method3(pool);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(ExecutorService pool)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">       Future&lt;String&gt; future = pool.submit(() -&gt; &#123;</span><br><span class="line">           log.debug(<span class="string">"running"</span>);</span><br><span class="line">           Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       log.debug(<span class="string">"&#123;&#125;"</span>, future.get());</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">           00:42:15.410 [pool-1-thread-1] MultiThread - running</span></span><br><span class="line"><span class="comment">           00:42:16.416 [main] MultiThread - ok</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ExecutorService pool)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       List&lt;Future&lt;String&gt;&gt; futures = pool.invokeAll(Arrays.asList(</span><br><span class="line">               () -&gt; &#123;</span><br><span class="line">                   log.debug(<span class="string">"begin"</span>);</span><br><span class="line">                   Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="string">"2"</span>;</span><br><span class="line">               &#125;,</span><br><span class="line">               () -&gt; &#123;</span><br><span class="line">                   log.debug(<span class="string">"begin"</span>);</span><br><span class="line">                   Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="string">"3"</span>;</span><br><span class="line">               &#125;</span><br><span class="line">       ));</span><br><span class="line"></span><br><span class="line">       futures.forEach( f -&gt;  &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               log.debug(<span class="string">"&#123;&#125;"</span>, f.get());</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       00:42:26.425 [pool-1-thread-1] MultiThread - begin</span></span><br><span class="line"><span class="comment">       00:42:26.425 [pool-1-thread-2] MultiThread - begin</span></span><br><span class="line"><span class="comment">       00:42:28.426 [main] MultiThread - 2【要等时间最长的结果返回】</span></span><br><span class="line"><span class="comment">       00:42:28.426 [main] MultiThread - 3</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ExecutorService pool)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">       String result = pool.invokeAny(Arrays.asList(</span><br><span class="line">               () -&gt; &#123;</span><br><span class="line">                   log.debug(<span class="string">"begin 1"</span>);</span><br><span class="line">                   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                   log.debug(<span class="string">"end 1"</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">               &#125;,</span><br><span class="line">               () -&gt; &#123;</span><br><span class="line">                   log.debug(<span class="string">"begin 2"</span>);</span><br><span class="line">                   Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                   log.debug(<span class="string">"end 2"</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="string">"2"</span>;</span><br><span class="line">               &#125;</span><br><span class="line">       ));</span><br><span class="line">       log.debug(<span class="string">"&#123;&#125;"</span>, result);</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">           00:42:38.428 [pool-1-thread-1] MultiThread - begin 2</span></span><br><span class="line"><span class="comment">           00:42:38.428 [pool-1-thread-2] MultiThread - begin 1</span></span><br><span class="line"><span class="comment">           00:42:38.928 [pool-1-thread-1] MultiThread - end 2</span></span><br><span class="line"><span class="comment">           00:42:38.928 [main] MultiThread - 2</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="6-关闭线程池"><a href="#6-关闭线程池" class="headerlink" title="6 关闭线程池"></a>6 关闭线程池</h4><h5 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h5><ul><li><p>线程池状态变为 SHUTDOWN</p></li><li><p><strong>不会接收新任务，但已提交任务会执行完</strong></p></li><li><p>此方法<strong>不会阻塞</strong>调用线程的执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock(); </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess(); </span><br><span class="line">        advanceRunState(SHUTDOWN); <span class="comment">// 修改线程池状态 </span></span><br><span class="line">        interruptIdleWorkers(); <span class="comment">// 仅会打断空闲线程 </span></span><br><span class="line">        onShutdown(); <span class="comment">//扩展点ScheduledThreadPoolExecutor</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会阻塞) </span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h5><ul><li><p>线程池状态变为 STOP，不会接收新任务</p></li><li><p>会将队列中的任务返回</p></li><li><p><strong>用 interrupt 的方式中断正在执行的任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Runnable&gt; tasks;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            advanceRunState(STOP);<span class="comment">// 修改线程池状态</span></span><br><span class="line">            interruptWorkers();<span class="comment">// 打断所有线程</span></span><br><span class="line">            tasks = drainQueue();<span class="comment">// 获取队列中剩余任务</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();<span class="comment">// 尝试终结 所有已经都打断了 肯定被终结</span></span><br><span class="line">        <span class="keyword">return</span> tasks;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-其它方法"><a href="#7-其它方法" class="headerlink" title="7 其它方法"></a>7 其它方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不在 RUNNING 状态的线程池，此方法就返回 true </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 线程池状态是否是 TERMINATED</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待 等所有已提交的任务（包括正在跑的和队列中等待的）执行完或者等超时时间到【不好用 不确定等多久 可以用get返回结果阻塞】</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><h3 id="8-1-7-正确处理执行任务异常"><a href="#8-1-7-正确处理执行任务异常" class="headerlink" title="8.1.7 正确处理执行任务异常"></a>8.1.7 正确处理执行任务异常</h3><h4 id="方法1：主动捉异常"><a href="#方法1：主动捉异常" class="headerlink" title="方法1：主动捉异常"></a>方法1：主动捉异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">1</span>); </span><br><span class="line">pool.submit(() -&gt; &#123; </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">log.debug(<span class="string">"task1"</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        log.error(<span class="string">"error:"</span>, e);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="方法2：使用-Future"><a href="#方法2：使用-Future" class="headerlink" title="方法2：使用 Future"></a>方法2：使用 Future</h4><ul><li>没有异常的就获取结果，有异常就获取异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">1</span>); </span><br><span class="line">Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123; </span><br><span class="line">    log.debug(<span class="string">"task1"</span>); </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line">log.debug(<span class="string">"result:&#123;&#125;"</span>, f.get());</span><br></pre></td></tr></table></figure><h3 id="8-1-8-Tomcat线程池"><a href="#8-1-8-Tomcat线程池" class="headerlink" title="8.1.8 Tomcat线程池"></a>8.1.8 Tomcat线程池</h3><p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B4_img/1582274348565.png" alt="1582274348565"></p><ul><li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲 </li><li>Acceptor 只负责【接收新的 socket 连接】 </li><li>Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】 </li><li>一旦可读，封装一个任务对象（socketProcessor），</li><li>提交给 Executor 线程池处理 Executor 线程池中的工作线程最终负责【处理请求】</li></ul><p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同</p><ul><li><p>如果总线程数达到 maximumPoolSize</p><ul><li>这时不会立刻抛 RejectedExecutionException 异常 </li><li>而是再次尝试将任务放入队列，如果还失败，才抛出RejectedExecutionException 异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">       submittedCount.incrementAndGet();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">super</span>.execute(command);</span><br><span class="line">       <span class="comment">//捕获异常</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (RejectedExecutionException rx) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">super</span>.getQueue() <span class="keyword">instanceof</span> TaskQueue) &#123;</span><br><span class="line">               <span class="keyword">final</span> TaskQueue queue = (TaskQueue)<span class="keyword">super</span>.getQueue();</span><br><span class="line">               <span class="keyword">try</span> &#123;<span class="comment">//再试一次 </span></span><br><span class="line">                  <span class="keyword">if</span> (!queue.force(command, timeout, unit)) &#123;</span><br><span class="line">                      submittedCount.decrementAndGet();</span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Queue capacity is full."</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                   submittedCount.decrementAndGet();</span><br><span class="line">                   Thread.interrupted();</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(x);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               submittedCount.decrementAndGet();</span><br><span class="line">               <span class="keyword">throw</span> rx;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">TaskQueue.java</span><br><span class="line">  </span><br><span class="line">  ~~~java</span><br><span class="line">  public boolean force(Runnable o, long timeout, TimeUnit unit) throws InterruptedException &#123; </span><br><span class="line">  if ( parent.isShutdown() ) throw new RejectedExecutionException(</span><br><span class="line">  &quot;Executor not running, can&#39;t force a command into the queue&quot; ); </span><br><span class="line">  return super.offer(o,timeout,unit); </span><br><span class="line">  &#x2F;&#x2F;forces the item onto the queue, to be used if the task is rejected &#125;</span><br></pre></td></tr></table></figure></li></ul><p>Connector 配置</p><p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B4_img/1582275738120.png" alt="1582275738120"></p><p>Executor 线程配置</p><p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B4_img/1582275776646.png" alt="1582275776646"></p><p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B4_img/1582275543451.png" alt="1582275543451"></p><h3 id="8-1-9异步模式之工作线程"><a href="#8-1-9异步模式之工作线程" class="headerlink" title="8.1.9异步模式之工作线程"></a>8.1.9异步模式之工作线程</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h4><p>让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。也可以将其归类为分工模式，它的典型实现 就是线程池，也体现了经典设计模式中的享元模式</p><h4 id="2-饥饿现象"><a href="#2-饥饿现象" class="headerlink" title="2 饥饿现象"></a>2 饥饿现象</h4><ul><li>固定大小线程池会有饥饿现象</li><li><strong>同一类别任务可以使用同一个线程池，多个任务可以采用多个线程池</strong><ul><li>两个工人是同一个线程池中的两个线程</li><li>他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作</li><li>客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待<ul><li>后厨做菜：没啥说的，做就是了</li><li>比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好 </li><li>但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; MENU = Arrays.asList(<span class="string">"地三鲜"</span>, <span class="string">"宫保鸡丁"</span>, <span class="string">"辣子鸡丁"</span>, <span class="string">"烤鸡翅"</span>);</span><br><span class="line"><span class="keyword">static</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">cooking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MENU.get(RANDOM.nextInt(MENU.size()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ExecutorService waiterPool = Executors.newFixedThreadPool(1);</span></span><br><span class="line">    ExecutorService cookPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        cookPool.execute(() -&gt; &#123;<span class="comment">//使用线程池的一个线程⭐</span></span><br><span class="line">            log.debug(<span class="string">"处理点餐..."</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;<span class="comment">//使用线程池的一个线程⭐</span></span><br><span class="line">                log.debug(<span class="string">"做菜"</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"上菜: &#123;&#125;"</span>, f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    17:08:41.339 c.TestDeadLock [pool-1-thread-2] - 处理点餐... </span></span><br><span class="line"><span class="comment">    17:08:41.339 c.TestDeadLock [pool-1-thread-1] - 处理点餐...</span></span><br><span class="line"><span class="comment">    【饥饿死等】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService waiterPool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    ExecutorService cookPool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        waiterPool.execute(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"处理点餐..."</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">"做菜"</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"上菜: &#123;&#125;"</span>, f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-创建多少线程池合适"><a href="#3-创建多少线程池合适" class="headerlink" title="3 创建多少线程池合适"></a>3 创建多少线程池合适</h4><ul><li>过小会导致程序不能充分地利用系统资源、容易导致饥饿 </li><li>过大会导致更多的线程上下文切换，占用更多内存</li></ul><h5 id="CPU-密集型运算"><a href="#CPU-密集型运算" class="headerlink" title="CPU 密集型运算"></a>CPU 密集型运算</h5><ul><li><strong>通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率</strong><ul><li>+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</li></ul></li></ul><h5 id="I-O-密集型运算"><a href="#I-O-密集型运算" class="headerlink" title="I/O 密集型运算"></a>I/O 密集型运算</h5><ul><li><strong>CPU 不总是处于繁忙状态</strong><ul><li>当你执行业务计算时，这时候会使用 CPU 资源</li><li>当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你<strong>可以利用多线程提高它的利用率。</strong> </li></ul></li><li>经验公式如下 ：<code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code> <ul><li>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式 4 * 100% * 100% / 50% = 8 </li><li>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式 4 * 100% * 100% / 10% = 40</li></ul></li></ul><h3 id="8-1-10-ForkJoinPool"><a href="#8-1-10-ForkJoinPool" class="headerlink" title="8.1.10 ForkJoinPool"></a>8.1.10 ForkJoinPool</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h4><p>Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型 运算<br>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计 算，如归并排序、斐波那契数列、都可以用分治思想进行求解<br>Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运 算效率<br>Fork/Join 默认会创建与 cpu 核心数大小相同的线程池</p><h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h4><p>提交给 Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值），例如下 面定义了一个对 1~n 之间的整数求和的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_NUM = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">10000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = r.nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        out.println(Arrays.stream(nums).sum());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有返回值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTaskWithReturn</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AddTaskWithReturn</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(end - start &lt; MAX_NUM)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">long</span> sum  = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i&lt; end ;i++) &#123;</span><br><span class="line">                    sum += nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> middle = (start+end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            AddTaskWithReturn subTask1 = <span class="keyword">new</span> AddTaskWithReturn(start, middle);</span><br><span class="line">            AddTaskWithReturn subTask2 = <span class="keyword">new</span> AddTaskWithReturn(middle, end);</span><br><span class="line">            subTask1.fork();</span><br><span class="line">            subTask2.fork();</span><br><span class="line">            <span class="keyword">return</span> subTask1.join() + subTask2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//无返回值</span></span><br><span class="line"><span class="comment">//    static class AddTaskWithoutReturn extends RecursiveAction&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int start, end;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        AddTaskWithoutReturn(int start, int end) &#123;</span></span><br><span class="line"><span class="comment">//            this.start = start;</span></span><br><span class="line"><span class="comment">//            this.end = end;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        @Override</span></span><br><span class="line"><span class="comment">//        protected void compute() &#123;</span></span><br><span class="line"><span class="comment">//            if(end - start &lt; MAX_NUM)</span></span><br><span class="line"><span class="comment">//            &#123;</span></span><br><span class="line"><span class="comment">//                long sum  = 0;</span></span><br><span class="line"><span class="comment">//                for(int i = start; i&lt; end ;i++) &#123;</span></span><br><span class="line"><span class="comment">//                    sum = sum + nums[i];</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            else &#123;</span></span><br><span class="line"><span class="comment">//                int middle = (start+end) &gt;&gt; 2;</span></span><br><span class="line"><span class="comment">//                AddTaskWithoutReturn subTask1 = new AddTaskWithoutReturn(start, middle);</span></span><br><span class="line"><span class="comment">//                AddTaskWithoutReturn subTask2 = new AddTaskWithoutReturn(middle, end);</span></span><br><span class="line"><span class="comment">//                subTask1.fork();</span></span><br><span class="line"><span class="comment">//                subTask2.fork();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//无返回值</span></span><br><span class="line"><span class="comment">//        ForkJoinPool pool = new ForkJoinPool();</span></span><br><span class="line"><span class="comment">//        AddTaskWithoutReturn task = new AddTaskWithoutReturn(0, nums.length);</span></span><br><span class="line"><span class="comment">//        pool.execute(task);</span></span><br><span class="line"><span class="comment">//        task.join();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//有返回值</span></span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        AddTaskWithReturn task = <span class="keyword">new</span> AddTaskWithReturn(<span class="number">0</span>, nums.length);</span><br><span class="line">        pool.execute(task);</span><br><span class="line">        Long result = task.join();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Java线程池
    
    </summary>
    
    
      <category term="Java高级" scheme="http://goldcarpenter.github.io/categories/Java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="多线程" scheme="http://goldcarpenter.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis</title>
    <link href="http://goldcarpenter.github.io/2019/08/18/MyBatis_Part3/"/>
    <id>http://goldcarpenter.github.io/2019/08/18/MyBatis_Part3/</id>
    <published>2019-08-17T16:00:00.000Z</published>
    <updated>2020-06-17T08:07:33.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-Mybatis-的动态-SQL-语句"><a href="#7-Mybatis-的动态-SQL-语句" class="headerlink" title="7.Mybatis 的动态 SQL 语句"></a>7.Mybatis 的动态 SQL 语句</h1><h2 id="7-1-lt-if-gt-标签的使用"><a href="#7-1-lt-if-gt-标签的使用" class="headerlink" title="7.1.&lt;if&gt;标签的使用"></a>7.1.<code>&lt;if&gt;</code>标签的使用</h2><ul><li><p>如果需要根据传入的实体类，判断哪些属性不为空，并以此作为查询条件，那么使用<code>&lt;if&gt;&lt;/if&gt;</code> 标签</p><ul><li><code>WHERE 1 =1</code>是防止所有条件都为空时，SQL 语句最后会带有一个 WHERE 关键字而没有条件，不符合 SQL 语法。</li><li><code>&lt;if&gt;&lt;/if&gt;</code>标签中 test 属性是必须的，表示判断的条件。其中有几点需要注意：<ul><li>如果 test 有多个条件，那么必须使用 and 进行连接，而不能使用 Java 中的 &amp;&amp; 运算符。</li><li><code>test</code>中的参数名称必须与实体类的属性保持一致，也就是和<code>#{参数符号}</code>保持一致。</li><li>如果判断条件为字符串，那么除了判断是否为<code>null</code>外，最好也判断一下是否为空字符串<code>&#39;&#39;</code> ，防止 SQL语句将其作为条件查询。</li></ul></li></ul></li><li><p>首先定义接口方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据传入的查询条件，进行多条件查询</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user 包含查询的条件，可能包含 username、sex、birthday、address等条件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">listUsersByCondition</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>接着配置映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根据查询条件进行复合查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listUsersByCondition"</span> <span class="attr">parameterType</span>=<span class="string">"top.carpenter.pojo.User"</span> <span class="attr">resultType</span>=<span class="string">"top.carpenter.pojo.User"</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE 1 = 1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null and username != ''"</span>&gt;</span></span><br><span class="line">        AND username LIKE CONCAT('%',#&#123;username&#125;,'%')</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"sex != null and sex != ''"</span>&gt;</span></span><br><span class="line">        AND sex = #&#123;sex&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"address != null and address != ''"</span>&gt;</span></span><br><span class="line">        AND address = #&#123;address&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"birthday != null"</span>&gt;</span></span><br><span class="line">        AND birthday = #&#123;birthday&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>测试代码及运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListUsersByCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="comment">// 加入查询条件</span></span><br><span class="line">    user.setUsername(<span class="string">"王"</span>);</span><br><span class="line">    user.setSex(<span class="string">"男"</span>);</span><br><span class="line">    <span class="comment">// 查询并展示</span></span><br><span class="line">    List&lt;User&gt; users = mapper.listUsersByCondition(user);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-2-lt-where-gt-标签的使用"><a href="#7-2-lt-where-gt-标签的使用" class="headerlink" title="7.2.&lt;where&gt;标签的使用"></a>7.2.<code>&lt;where&gt;</code>标签的使用</h2><ul><li><p>该标签可以动态添加 WHERE 关键字，并且剔除掉 SQL 语句中多余的 AND 或者 OR，使用<code>&lt;where&gt;&lt;/where&gt;</code> 进一步优化 SQL 语句。</p><ul><li><code>&lt;where&gt;&lt;/where&gt;</code>标签只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入<code>&lt;where&gt;</code>子句。而且，若语句的开头为 AND 或 OR，<code>&lt;where&gt;&lt;/where&gt;</code>标签也会将它们去除。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listUsersByCondition"</span> <span class="attr">parameterType</span>=<span class="string">"cn.ykf.pojo.User"</span> <span class="attr">resultType</span>=<span class="string">"top.carpenter.pojo.User"</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null and username != ''"</span>&gt;</span></span><br><span class="line">            AND username LIKE CONCAT('%',#&#123;username&#125;,'%')</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"sex != null and sex != ''"</span>&gt;</span></span><br><span class="line">            AND sex = #&#123;sex&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"address != null and address != ''"</span>&gt;</span></span><br><span class="line">            AND address = #&#123;address&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"birthday != null"</span>&gt;</span></span><br><span class="line">            AND birthday = #&#123;birthday&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>为了避免 Mybatis 在动态拼接 SQL 语句的时候发生错误，建议在编写 SQL 语句时不要添加分号 ;</strong></p></blockquote></li></ul><h2 id="7-3-lt-set-gt-标签的使用"><a href="#7-3-lt-set-gt-标签的使用" class="headerlink" title="7.3.&lt;set&gt;标签的使用"></a>7.3.<code>&lt;set&gt;</code>标签的使用</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateByPrimaryKeySelective"</span> <span class="attr">parameterType</span>=<span class="string">"top.carpenter.pojo.BlogLink"</span>&gt;</span></span><br><span class="line">       update tb_link</span><br><span class="line">       <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"linkType != null"</span>&gt;</span></span><br><span class="line">               link_type = #&#123;linkType,jdbcType=TINYINT&#125;,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"linkName != null"</span>&gt;</span></span><br><span class="line">               link_name = #&#123;linkName,jdbcType=VARCHAR&#125;,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"linkUrl != null"</span>&gt;</span></span><br><span class="line">               link_url = #&#123;linkUrl,jdbcType=VARCHAR&#125;,</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">       where link_id = #&#123;linkId,jdbcType=INTEGER&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="7-4-foreach-标签的使用"><a href="#7-4-foreach-标签的使用" class="headerlink" title="7.4. foreach 标签的使用"></a>7.4. foreach 标签的使用</h2><ul><li>假如需要根据一个 id 集合，来查询出 id 在该集合中的所有用户，如果使用普通 SQL 语句的话，那么查询语句应该这样写：<code>SELECT * FROM user WHERE id IN(41,42,43);</code></li><li>使用动态 SQL 使用<code>&lt;foreach&gt;&lt;/foreach&gt;</code><strong>遍历集合</strong>拼接上<code>id IN(41,42,43)</code>这一串内容<ul><li><code>collection</code>： 代表要遍历的集合或数组，这个属性是必须的。如果是遍历数组，那么该值只能为 array</li><li><code>open</code>： 代表语句的开始部份</li><li><code>close</code>： 代表语句的结束部份</li><li><code>item</code>： 代表遍历集合时的每个元素，相当于一个临时变量</li><li><code>separator</code>： 代表拼接每个元素之间的分隔符</li></ul></li></ul><ul><li><p>首先修改 QueryVo 类，增加一个成员变量用于存放 id 集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryVo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="comment">// 如果还有其他的查询条件，就可以一并封装进来</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; ids;</span><br><span class="line">    <span class="comment">//get set function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来添加接口方法，并配置映射文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id集合，查询用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">listUsersByIds</span><span class="params">(QueryVo vo)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根据id集合查询用户 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listUsersByIds"</span> <span class="attr">parameterType</span>=<span class="string">"top.carpenter.pojo.QueryVo"</span> <span class="attr">resultType</span>=<span class="string">"top.carpenter.pojo.User"</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ids != null and ids.size &gt; 0"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">open</span>=<span class="string">"AND id IN ("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">                #&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象传递给 foreach 作为集合参数。<ul><li>当使用可迭代对象或者数组时，index 是当前迭代的次数，item 的值是本次迭代获取的元素。</li><li>当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</li></ul></li><li>注意：SQL 语句中的参数符号 #{id} 应该与 item=”id” 保持一致，也就是说，item 属性如果把临时变量声明为 uid 的话，那么使用时就必须写成 #{uid}</li></ul></li></ul><h2 id="7-5-定义-SQL-片段"><a href="#7-5-定义-SQL-片段" class="headerlink" title="7.5.定义 SQL 片段"></a>7.5.定义 SQL 片段</h2><ul><li><p>我们可以把<code>SELECT * FROM user</code>定义为 SQL 片段，以供复用，减少工作量。</p></li><li><p>首先在映射文件中定义代码片段</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义代码片段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"defaultSql"</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在需要的地方引用该片段</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根据id集合查询用户 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listUsersByIds"</span> <span class="attr">parameterType</span>=<span class="string">"top.carpenter.pojo.QueryVo"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引用代码片段 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"defaultSql"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ids != null and ids.size &gt; 0"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">open</span>=<span class="string">"AND id IN ("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">                #&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="8-Mybatis-多表查询"><a href="#8-Mybatis-多表查询" class="headerlink" title="8.Mybatis 多表查询"></a>8.Mybatis 多表查询</h1><ul><li>表之间的关系共有以下几种<ul><li>一对一 ： 人和身份证就是一对一的关系。一个人只能有一个身份证号，而一个身份证号只能属于一个人。</li><li>多对一（一对多）：学生和班级就是多对一（一对多）的关系。一个班级有多个学生，而一个学生只属于一个班级。</li><li>多对多 ： 学生和任课老师就是多对多的关系。一个学生可以有多个任课老师，而一个任课老师可以有多个学生。</li></ul></li></ul><h2 id="8-1-环境搭建"><a href="#8-1-环境搭建" class="headerlink" title="8.1.环境搭建"></a>8.1.环境搭建</h2><ul><li><p>现在以用户和账户为例子，一个用户可以有多个账户，一个账户只能属于一个用户。</p></li><li><p>数据库表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`user`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名称'</span>,</span><br><span class="line">  <span class="string">`birthday`</span> datetime <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'生日'</span>,</span><br><span class="line">  <span class="string">`sex`</span> <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'性别'</span>,</span><br><span class="line">  <span class="string">`address`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'地址'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>  (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="comment"># 导入用户数据</span></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> <span class="string">`user`</span>(<span class="string">`id`</span>,<span class="string">`username`</span>,<span class="string">`birthday`</span>,<span class="string">`sex`</span>,<span class="string">`address`</span>) <span class="keyword">values</span> (<span class="number">41</span>,<span class="string">'老王'</span>,<span class="string">'2018-02-27 17:47:08'</span>,<span class="string">'男'</span>,<span class="string">'北京'</span>),(<span class="number">42</span>,<span class="string">'小二王'</span>,<span class="string">'2018-03-02 15:09:37'</span>,<span class="string">'女'</span>,<span class="string">'北京金燕龙'</span>),(<span class="number">43</span>,<span class="string">'小二王'</span>,<span class="string">'2018-03-04 11:34:34'</span>,<span class="string">'女'</span>,<span class="string">'北京金燕龙'</span>),(<span class="number">45</span>,<span class="string">'传智播客'</span>,<span class="string">'2018-03-04 12:04:06'</span>,<span class="string">'男'</span>,<span class="string">'北京金燕龙'</span>),(<span class="number">46</span>,<span class="string">'老王'</span>,<span class="string">'2018-03-07 17:37:26'</span>,<span class="string">'男'</span>,<span class="string">'北京'</span>),(<span class="number">48</span>,<span class="string">'小马宝莉'</span>,<span class="string">'2018-03-08 11:44:00'</span>,<span class="string">'女'</span>,<span class="string">'北京修正'</span>);</span><br><span class="line"><span class="comment"># 创建账户表，外键为uid，关联用户表的id</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`account`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`account`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'编号'</span>,</span><br><span class="line">  <span class="string">`uid`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户编号'</span>,</span><br><span class="line">  <span class="string">`money`</span> <span class="keyword">double</span> <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'金额'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>  (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`FK_Reference_8`</span> (<span class="string">`uid`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`FK_Reference_8`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`uid`</span>) <span class="keyword">REFERENCES</span> <span class="string">`user`</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="comment"># 导入账户数据</span></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> <span class="string">`account`</span>(<span class="string">`id`</span>,<span class="string">`uid`</span>,<span class="string">`money`</span>) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">46</span>,<span class="number">1000</span>),(<span class="number">2</span>,<span class="number">45</span>,<span class="number">1000</span>),(<span class="number">3</span>,<span class="number">46</span>,<span class="number">2000</span>);</span><br></pre></td></tr></table></figure></li><li><p>添加账户实体类 Account</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set get function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加账户实体类对应的 Mapper 接口 AccountMapper 以及映射文件 AccountMapper.xml</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有账户，带有用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">listAllAcounts</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.carpenter.dao.IAccountDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置查询所有账户 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listAllAccounts"</span> <span class="attr">resultType</span>=<span class="string">"top.carpenter.pojo.Account"</span>&gt;</span></span><br><span class="line">        SELECT * FROM account</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>记得在 Mybatis 配置文件中<ul><li>加入新的映射文件：<code>&lt;mapper resource=&quot;AccountMapper.xml&quot;/&gt;</code> </li><li>直接配置整个包：<code>&lt;package name=&quot;top.carperter.dao&quot;/&gt;</code></li></ul></li></ul></blockquote></li></ul><ul><li><p>测试一下查询账户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListAllAccounts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 5. 使用代理对象执行查询</span></span><br><span class="line">        List&lt;Account&gt; accounts = mapper.listAllAccounts();</span><br><span class="line">        accounts.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1582517868538.png" alt="1582517868538"></p></li><li><p>虽然可以查询出账户信息，<strong>但是这个结果并没有和用户产生关联</strong>，而我们想要的效果是查询出账户信息的同时，把所属用户信息也一并展示。那么我们该如何修改呢？</p></li></ul><h2 id="8-2-多表查询之【一对一】"><a href="#8-2-多表查询之【一对一】" class="headerlink" title="8.2.多表查询之【一对一】"></a>8.2.多表查询之【一对一】</h2><ul><li><p>首先编写 SQL 语句，如果想要达到上述效果，那么 SQL 语句可以这样写</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> U.*, a.id <span class="keyword">AS</span> aid, a.uid, a.money <span class="keyword">from</span> <span class="keyword">account</span> a, <span class="keyword">user</span> u <span class="keyword">WHERE</span> a.uid = u.id;</span><br></pre></td></tr></table></figure></li><li><p>为了可以接收这条语句的查询结果，对账户实体类 Account 进行修改，为其增加成员变量 User 来接收查询出的用户信息<strong>（从表实体应该包含一个主表实体的对象引用）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他成员不展示...</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账户对应的用户信息,从表实体应该包含一个主表实体的对象引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="comment">// 其他setter()/getter()不展示...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>因为此时账户实体类 Account 已经发生了变化，所以我们应该在映射文件定义用于封装带有 User 信息的 Account 的映射集合resultMap</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.carpenter.dao.IAccountDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义可以封装带有User的Account的 resultMap --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"AccountWithUserMap"</span> <span class="attr">type</span>=<span class="string">"top.carpenter.pojo.Account"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"aid"</span>/&gt;</span><span class="comment">&lt;!--***注意aid 与SQL相同**--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"money"</span> <span class="attr">column</span>=<span class="string">"money"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 关联 User 对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">javaType</span>=<span class="string">"top.carpenter.pojo.User"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置查询所有账户，带有用户信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listAllAccounts"</span> <span class="attr">resultMap</span>=<span class="string">"AccountWithUserMap"</span>&gt;</span></span><br><span class="line">        SELECT U.*, a.id AS aid, a.uid, a.money from account a, user u WHERE a.uid = u.id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注意：</strong></p><ul><li><p><strong><code>&lt;association&gt;&lt;/association&gt;</code>用于一对一映射，其中的 property 属性表示要关联的属性，javaType 表示待关联的实体类的全限定类名</strong>。</p></li><li><p><strong>因为 SQL 语句中为 account 表的 id 字段起了别名 aid ，所以在定义 resultMap 的时候，记得主字段写 column=”aid”，而不是 column=”id”</strong>。</p></li></ul></li><li><p><strong>此处重新运行测试代码，可以发现查询的账户已经带有了用户信息</strong></p></li></ul><h2 id="8-3-多表查询之【一对多】"><a href="#8-3-多表查询之【一对多】" class="headerlink" title="8.3.多表查询之【一对多】"></a>8.3.多表查询之【一对多】</h2><ul><li><p>假如需要查询用户的时候，如果用户拥有账户，那么也要把账户信息展示出来。那么又该如何实现？</p></li><li><p><strong>首先SQL语句如何编写，由于有的用户并没有账户，所以如果采用内连接的方式查询（也就是上面的查询方式），那么会把没有账户的用户筛选掉，像下面这样：</strong></p><p><img src="1582518339901.png" alt="1582518339901"></p></li><li><p>因此，我们应该采用外连接的方式，使得没有账户的用户也可以查询出来：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> u.*, a.id <span class="keyword">AS</span> aid, a.uid, a.money <span class="keyword">FROM</span> <span class="keyword">user</span> u <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> <span class="keyword">account</span> a <span class="keyword">ON</span> u.id = a.uid;</span><br></pre></td></tr></table></figure><p><img src="1582518354811.png" alt="1582518354811"></p></li></ul><ul><li><p>为了可以接收这条语句的查询结果，那么我们应该对用户实体类 User 进行修改，为其增加成员变量 accounts 来接收查询出的账户信息<strong>（主表实体应该包含从表实体的集合引用）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他成员省略不展示...</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一对多关系映射：主表实体应该包含从表实体的集合引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Account&gt; accounts;</span><br><span class="line"><span class="comment">// 其他setter()/getter()省略不展示...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>修改映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.carpenter.dao.IUserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置 resultMap ，完成实体类与数据库表的映射 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"UserWithAccountsMap"</span> <span class="attr">type</span>=<span class="string">"top.carpenter.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置user对象中accounts集合的映射 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"accounts"</span> <span class="attr">ofType</span>=<span class="string">"top.carpenter.pojo.Account"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"aid"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"money"</span> <span class="attr">column</span>=<span class="string">"money"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置查询所有用户，并且带有账户信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listAllUsers"</span> <span class="attr">resultMap</span>=<span class="string">"UserWithAccountsMap"</span>&gt;</span></span><br><span class="line">        SELECT u.*, a.id AS aid, a.uid, a.money FROM user u LEFT OUTER JOIN account a ON u.id = a.uid;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>&lt;collection &gt;&lt;/collection&gt;</code>用于一对多映射，其中的 property 属性表示要关联的集合，<code>ofType</code>表示集合中的实体类的全限定类名</strong></p></li><li><p>测试代码及运行结果如下</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListAllUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 5. 使用代理对象执行查询</span></span><br><span class="line">    List&lt;User&gt; users = accountDao.listAllUsers();</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1582518511355.png" alt="1582518511355"></p><h2 id="8-4-环境搭建"><a href="#8-4-环境搭建" class="headerlink" title="8.4.环境搭建"></a>8.4.环境搭建</h2><ul><li><p>现在以用户和角色为例子，一个用户可以有多个角色，一个角色可以赋予多个用户。</p></li><li><p>需求：</p><ul><li><strong>查询用户的时候可以把用户所拥有的角色信息展示出来。</strong></li><li><strong>查询角色的时候可以把角色所赋予的用户信息展示出来。</strong></li></ul></li><li><p>先搭建相关环境，由于是多对多关系，所以需要借助第三张表，导入所需数据库表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建角色表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`role`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`role`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'编号'</span>,</span><br><span class="line">  <span class="string">`role_name`</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色名称'</span>,</span><br><span class="line">  <span class="string">`role_desc`</span> <span class="built_in">varchar</span>(<span class="number">60</span>) <span class="keyword">default</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色描述'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>  (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="comment"># 添加角色数据</span></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> <span class="string">`role`</span>(<span class="string">`ID`</span>,<span class="string">`ROLE_NAME`</span>,<span class="string">`ROLE_DESC`</span>) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">'院长'</span>,<span class="string">'管理整个学院'</span>),(<span class="number">2</span>,<span class="string">'总裁'</span>,<span class="string">'管理整个公司'</span>),(<span class="number">3</span>,<span class="string">'校长'</span>,<span class="string">'管理整个学校'</span>);</span><br><span class="line"><span class="comment"># 创建用户角色表，也就是中间表</span></span><br><span class="line"><span class="comment"># uid 和 rid是复合主键，同时也是外键</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`user_role`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_role`</span> (</span><br><span class="line">  <span class="string">`uid`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户编号'</span>,</span><br><span class="line">  <span class="string">`rid`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色编号'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>  (<span class="string">`uid`</span>,<span class="string">`rid`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`FK_Reference_10`</span> (<span class="string">`rid`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`FK_Reference_10`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`rid`</span>) <span class="keyword">REFERENCES</span> <span class="string">`role`</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`FK_Reference_9`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`uid`</span>) <span class="keyword">REFERENCES</span> <span class="string">`user`</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="comment"># 添加用户角色数据</span></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> <span class="string">`user_role`</span>(<span class="string">`uid`</span>,<span class="string">`rid`</span>) <span class="keyword">values</span> (<span class="number">41</span>,<span class="number">1</span>),(<span class="number">45</span>,<span class="number">1</span>),(<span class="number">41</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="8-5-多表查询之【多对多】"><a href="#8-5-多表查询之【多对多】" class="headerlink" title="8.5.多表查询之【多对多】"></a>8.5.多表查询之【多对多】</h2><h3 id="8-5-1-查询用户并展示角色"><a href="#8-5-1-查询用户并展示角色" class="headerlink" title="8.5.1.查询用户并展示角色"></a>8.5.1.查询用户并展示角色</h3><ul><li>修改用户实体类 User ，并添加角色实体类 Role，为了能体现出多对多的关系，两个实体类都必须包含对方的一个集合引用<strong>（多对多关系其实看成是双向的一对多关系）</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多对多关系映射：包含对方的集合引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Role&gt; roles;</span><br><span class="line">    <span class="comment">//  get set 方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer roleId;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String roleDesc;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多对多关系映射：持有对方集合引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; users;</span><br><span class="line">    <span class="comment">//  get set 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>编写 SQL 语句在查询用户的时候可以把用户所拥有的角色信息展示出来，为了确保所有用户（无论是否具有角色）都可以被查询出来，应该使用左连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> u.*, r.id <span class="keyword">as</span> rid, r.role_name, r.role_desc <span class="keyword">FROM</span> <span class="keyword">user</span> u</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> user_role ur <span class="keyword">ON</span> u.id = ur.uid</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> <span class="keyword">role</span> r <span class="keyword">ON</span> ur.rid = r.id;</span><br></pre></td></tr></table></figure><p><img src="1582526539590.png" alt="1582526539590"></p></li></ul><ul><li>编写接口层和映射文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**查询所有用户信息，包含用户所拥有的角色信息 */</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">listUsersWithRoles</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.carpenter.dao.IUserDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"UserWithRolesMap"</span> <span class="attr">type</span>=<span class="string">"top.carpenter.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置user对象中roles集合的映射 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"roles"</span> <span class="attr">ofType</span>=<span class="string">"top.carpenter.pojo.Role"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"roleId"</span> <span class="attr">column</span>=<span class="string">"rid"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleName"</span> <span class="attr">column</span>=<span class="string">"role_name"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleDesc"</span> <span class="attr">column</span>=<span class="string">"role_desc"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 查询所有用户，并且带有角色信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listUsersWithRoles"</span> <span class="attr">resultMap</span>=<span class="string">"UserWithRolesMap"</span>&gt;</span></span><br><span class="line">        SELECT u.*, r.id as rid, r.role_name, r.role_desc FROM user u</span><br><span class="line">        LEFT OUTER JOIN user_role ur ON u.id = ur.uid</span><br><span class="line">        LEFT OUTER JOIN role r ON ur.rid = r.id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试代码和运行结果如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试查询带有角色的用户信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListUsersWithRoles</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;User&gt; users = userDao.listUsersWithRoles();</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1582526590576.png" alt="1582526590576"></p><h3 id="8-5-2-查询角色并展示用户"><a href="#8-5-2-查询角色并展示用户" class="headerlink" title="8.5.2.查询角色并展示用户"></a>8.5.2.查询角色并展示用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> u.*, r.id <span class="keyword">as</span> rid, r.role_name, r.role_desc <span class="keyword">FROM</span> <span class="keyword">role</span> r </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> user_role ur <span class="keyword">ON</span> r.id = ur.rid </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> <span class="keyword">user</span> u <span class="keyword">ON</span> ur.uid = u.id;</span><br></pre></td></tr></table></figure><p><strong>接口层代码及映射文件如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRoleDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**查询所有角色，带有用户信息*/</span></span><br><span class="line">    <span class="function">List&lt;Role&gt; <span class="title">listAllRoles</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.carpenter.dao.IRoleDao"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"RoleWithUsersMap"</span> <span class="attr">type</span>=<span class="string">"top.carpenter.pojo.Role"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"roleId"</span> <span class="attr">column</span>=<span class="string">"rid"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleName"</span> <span class="attr">column</span>=<span class="string">"role_name"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleDesc"</span> <span class="attr">column</span>=<span class="string">"role_desc"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置role对象中users集合的映射 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"users"</span> <span class="attr">ofType</span>=<span class="string">"top.carpenter.pojo.User"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 查询所有角色，并且带有用户信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listAllRoles"</span> <span class="attr">resultMap</span>=<span class="string">"RoleWithUsersMap"</span>&gt;</span></span><br><span class="line">        SELECT u.*, r.id as rid, r.role_name, r.role_desc FROM role r</span><br><span class="line">            LEFT OUTER JOIN user_role ur ON r.id = ur.rid</span><br><span class="line">            LEFT OUTER JOIN user u ON ur.uid = u.id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="1582526643119.png" alt="1582526643119"></p><h1 id="9-Mybatis-中的延迟加载"><a href="#9-Mybatis-中的延迟加载" class="headerlink" title="9.Mybatis 中的延迟加载"></a>9.Mybatis 中的延迟加载</h1><h2 id="9-1-延迟加载和立即加载"><a href="#9-1-延迟加载和立即加载" class="headerlink" title="9.1 延迟加载和立即加载"></a>9.1 延迟加载和立即加载</h2><ul><li>假如此时我们有 1 个用户，该用户拥有 100 个账户，那么问题来了：<ul><li>当我们查询该用户的时候，要不要把关联的账户也一起查询出来？</li><li>当我们查询某个账户的时候，要不要把关联的用户一起查询出来？</li></ul></li><li>答案很简单。在查询用户的时候，用户所拥有的账户信息应该是<strong>需要使用的时候才去查询</strong>，不然每次查询该用户的时候，都要查询他拥有的账户，那么开销无疑是比较大的；而在查询账户的时候，由于每个账户对应一个用户，所以应该让用户信息<strong>随账户信息一并查询出来</strong>，否则别人不知道该账户属于谁。</li><li>延迟加载<ul><li>延迟加载就是在<strong>需要用到数据时才进行加载，不需要用到数据时就不加载数据</strong>，延迟加载也称懒加载。</li><li>在<strong>一对多</strong>或<strong>多对多</strong>的表关系中，通常情况下我们都是采用延迟加载。</li></ul></li><li>立即加载<ul><li>立即加载就是不管是否需要数据，只要<strong>一进行查询，就会把相关联的数据一并查询出来</strong>。</li><li>在<strong>多对一</strong>或<strong>一对一</strong>的表关系中，通常情况下我们都是采用立即加载</li></ul></li></ul><h2 id="9-2-一对一实现延迟加载"><a href="#9-2-一对一实现延迟加载" class="headerlink" title="9.2.一对一实现延迟加载"></a>9.2.一对一实现延迟加载</h2><ul><li><p>实现以下需求：</p><ul><li>如果不需要使用用户信息的话，那么只查询账户信息；只有当需要使用用户信息时，才去关联查询</li></ul></li><li><p>首先在 Mybatis 的配置文件中开启延迟加载</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 开启延迟加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>账户映射文件 <code>AccountMapper.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.carpenter.dao.IAccountDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义可以封装带有User的Account的 resultMap --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"AccountWithUserMap"</span> <span class="attr">type</span>=<span class="string">"top.carpenter.pojo.Account"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"money"</span> <span class="attr">column</span>=<span class="string">"money"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 关联 User 对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">javaType</span>=<span class="string">"user"</span> <span class="attr">select</span>=<span class="string">"top.carpenter.dao.IUserDao.findById"</span> <span class="attr">column</span>=<span class="string">"uid"</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置查询所有账户，延迟加载用户信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultMap</span>=<span class="string">"AccountWithUserMap"</span>&gt;</span></span><br><span class="line">        select * from  account</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAccountByUid"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"top.carpenter.pojo.Account"</span>&gt;</span></span><br><span class="line">        SELECT * FROM account WHERE uid = #&#123;uid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;association&gt;&lt;/association&gt;</code> 标签中的 <code>select</code> 属性表示我们<strong>要调用的映射语句的 ID</strong>，它会<strong>从 column 属性指定的列中检索数据，作为参数传递给目标 select 语句</strong>。</li><li><code>column</code> 属性指定传递给我们要调用的映射语句的<strong>参数</strong>。</li></ul></li><li><p><code>top.carpenter.dao.IUserDao.findById</code> 的映射文件如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.carpenter.dao.IUserDao"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 查询单个用户 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="1582530177388.png" alt="1582530177388"></p><ul><li>不会把所有的账户信息连同用户信息一并查询出来。而是打印Account 对象，其中调用了 User 对象，才会进行查询。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestAccount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;Account&gt; all = accountDao.findAll();</span><br><span class="line"><span class="comment">//      all.forEach(System.out::println);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="1582565457675.png" alt="1582565457675"></p></li></ul><h2 id="9-3-一对多实现立即加载"><a href="#9-3-一对多实现立即加载" class="headerlink" title="9.3 一对多实现立即加载"></a>9.3 一对多实现立即加载</h2><ul><li>实现以下需求：</li><li>当查询用户信息时使用延迟加载。也就是说，如果不需要使用账户信息的话，那么只查询用户信息；只有当需要使用账户信息时，才去关联查询</li><li>还是一样先修改 账户 的映射文件，不同的是现在是使用 <code>&lt;collection&gt;&lt;/collection&gt;</code> 进行延迟加载</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.carpenter.dao.IUserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置 resultMap ，完成实体类与数据库表的映射 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"UserWithAccountsMap"</span> <span class="attr">type</span>=<span class="string">"top.carpenter.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"birthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置user对象中accounts集合的映射 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"accounts"</span> <span class="attr">ofType</span>=<span class="string">"Account"</span> <span class="attr">select</span>=<span class="string">"top.carpenter.dao.IAccountDao.getAccountByUid"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置查询所有用户，延迟加载账户信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultMap</span>=<span class="string">"UserWithAccountsMap"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在账户实体类对应的接口层及配置文件中添加对应的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据用户id查询账户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Account <span class="title">getAccountByUid</span><span class="params">(Integer uid)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.carpenter.dao.IAccountDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据用户id查询账户 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAccountByUid"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"top.carpenter.pojo.Account"</span>&gt;</span></span><br><span class="line">        SELECT * FROM account WHERE uid = #&#123;uid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>运行结果</li></ul><p><img src="1582566695495.png" alt="1582566695495"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestUser</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;User&gt; all = userDao.findAll();</span><br><span class="line"><span class="comment">//      all.forEach(System.out::println);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="1582566741572.png" alt="1582566741572"></p><h1 id="10-Mybatis-中的缓存"><a href="#10-Mybatis-中的缓存" class="headerlink" title="10.Mybatis 中的缓存"></a>10.Mybatis 中的缓存</h1><ul><li>什么是缓存？<ul><li>缓存就是<strong>存在于内存中的临时数据</strong>。</li></ul></li><li>为什么要使用缓存？<ul><li>为了<strong>减少和数据库交互的次数，提高执行效率</strong>。</li></ul></li><li>适用于缓存的数据<ul><li>经常查询并且不经常改变的数据。</li><li>数据的<strong>正确与否对最终结果影响不大的</strong>。</li></ul></li><li>不适用于缓存的数据<ul><li>经常改变的数据。</li><li>数据的<strong>正确与否对最终结果影响很大的</strong>。例如：商品的库存、银行的汇率、股市的牌价等。</li></ul></li></ul><h2 id="10-1Mybatis-的一级缓存"><a href="#10-1Mybatis-的一级缓存" class="headerlink" title="10.1Mybatis 的一级缓存"></a>10.1Mybatis 的一级缓存</h2><ul><li><p>一级缓存是 <strong>SqlSession</strong> 级别的缓存，只要 SqlSession 没有 <strong>flush</strong> 或 <strong>close</strong>，它就会存在。</p></li><li><p>Mybatis 默认就是使用一次缓存的，不需要配置。</p></li><li><p>一级缓存中存放的是<strong>对象</strong>。（一级缓存其实就是 Map 结构，直接存放对象）</p></li><li><p>当调用 SqlSession 的<strong>修改、添加、删除、commit()、close()、clearCache()</strong> 等方法时，就会清空一级缓存。</p></li><li><p>一级缓存流程如下图</p><p><img src="1582597526937.png" alt="1582597526937"></p><ul><li>第一次发起查询用户 id 为 1 的用户信息，Mybatis 会先去找缓存中是否有 id 为 1 的用户信息，如果没有，从数据库查询用户信息。</li><li>得到用户信息，<strong>将用户信息存储到一级缓存中</strong>。</li><li>如果 <code>sqlSession</code> 去执行 commit 操作（执行插入、更新、删除），那么 Mybatis 就会清空 SqlSession 中的一级缓存，这样做的目的为了<strong>让缓存中存储的是最新的信息，避免脏读</strong>。</li><li>第二次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，缓存中有，直接从缓存中获取用户信息。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"======================================="</span>);</span><br><span class="line">List&lt;User&gt; all = userDao.findAll();</span><br><span class="line">System.out.println(<span class="string">"======================================="</span>);</span><br><span class="line">List&lt;User&gt; all1 = userDao.findAll();</span><br><span class="line">System.out.println(all == all1);</span><br></pre></td></tr></table></figure><p><img src="1582597816448.png" alt="1582597816448"></p></li></ul><h2 id="10-2-Mybatis-的二级缓存"><a href="#10-2-Mybatis-的二级缓存" class="headerlink" title="10.2.Mybatis 的二级缓存"></a>10.2.Mybatis 的二级缓存</h2><ul><li><p>二级缓存是 <strong>Mapper</strong> 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 SQL 语句，多个SqlSession 可以共用二级缓存，<strong>二级缓存是跨 SqlSession 的</strong>。</p></li><li><p>当我们使用二级缓存的时候，所缓存的类一定要<strong>实现 java.io.Serializable 接口</strong>，这样才可以使用序列化的方式来保存对象。</p></li><li><p>由于是序列化保存对象，所以二级缓存中存放的是数据，而不是整个对象。</p></li><li><p>二级缓存流程如下图</p><p><img src="1582597981317.png" alt="1582597981317"></p><ul><li>当 sqlSession1 去查询用户信息的时候，Mybatis 会将查询数据存储到二级缓存中。</li><li>如果 sqlSession3 去执行相同 Mapper 映射下的 SQL 语句，并且执行 commit 提交，那么 Mybatis 将会清空该 Mapper 映射下的二级缓存区域的数据。</li><li>sqlSession2 去查询与 sqlSession1 相同的用户信息，Mybatis 首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据。</li></ul></li><li><p>如果想使用 Mybatis 的二级缓存，那么应该做以下配置</p><ul><li><p>让Mybatis框架支持二级缓存(在SqlMapConfig. xml中配置)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启缓存 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>让当前的映射文件支持二级缓存(在IUserDao. xml中配置)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.carpenter.dao.IUserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用缓存 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>让当前的操作支持二级缓存<strong>（针对每次查询都需要最新数据的操作，要设置成 useCache=”false”，禁用二级缓存）</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listAllUsers"</span> <span class="attr">resultMap</span>=<span class="string">"UserWithAccountsMap"</span> <span class="attr">useCache</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"===================================="</span>);</span><br><span class="line">SqlSession session = factory.openSession();</span><br><span class="line">IUserDao userDao = session.getMapper(IUserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">List&lt;User&gt; all = userDao.findAll();</span><br><span class="line">session.close();</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"===================================="</span>);</span><br><span class="line">SqlSession session1 = factory.openSession();</span><br><span class="line">IUserDao userDao1 = session1.getMapper(IUserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">List&lt;User&gt; all1 = userDao1.findAll();</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"===================================="</span>);</span><br><span class="line">System.out.println(all == all1);</span><br><span class="line"></span><br><span class="line">session1.close();</span><br></pre></td></tr></table></figure><p><img src="../1582599967134.png" alt="1582599967134"></p></li></ul><h1 id="11-Mybatis-中的注解开发"><a href="#11-Mybatis-中的注解开发" class="headerlink" title="11.Mybatis 中的注解开发"></a>11.Mybatis 中的注解开发</h1><ul><li><p>在 Mybatis 的注解开发中，常用的注解如下表所示：</p><table><thead><tr><th align="center">注解</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><strong>@Intsert</strong></td><td align="center"><strong>实现新增</strong></td></tr><tr><td align="center"><strong>@Update</strong></td><td align="center"><strong>实现更新</strong></td></tr><tr><td align="center"><strong>@Delete</strong></td><td align="center"><strong>实现删除</strong></td></tr><tr><td align="center"><strong>@Select</strong></td><td align="center"><strong>实现查询</strong></td></tr><tr><td align="center"><strong>@Results</strong></td><td align="center"><strong>实现结果集封装</strong></td></tr><tr><td align="center"><strong>@ResultMap</strong></td><td align="center"><strong>实现引用 @Results 定义的封装</strong></td></tr><tr><td align="center"><strong>@One</strong></td><td align="center"><strong>实现一对一结果集封装</strong></td></tr><tr><td align="center"><strong>@Many</strong></td><td align="center"><strong>实现一对多结果集封装</strong></td></tr><tr><td align="center"><strong>@SelectProvider</strong></td><td align="center"><strong>实现动态 SQL 映射</strong></td></tr><tr><td align="center"><strong>@CacheNamespace</strong></td><td align="center"><strong>实现注解二级缓存的使用</strong></td></tr></tbody></table></li></ul><h2 id="11-1-Mybatis-使用注解实现单表-CURD"><a href="#11-1-Mybatis-使用注解实现单表-CURD" class="headerlink" title="11.1.Mybatis 使用注解实现单表 CURD"></a>11.1.Mybatis 使用注解实现单表 CURD</h2><ul><li><p>用户实体类接口层 <code>IUserDao</code>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM user"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">listAllUsers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功返回1，失败返回0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"INSERT INTO user(username,birthday,sex,address) VALUES(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)"</span>)</span><br><span class="line">    <span class="meta">@SelectKey</span>(keyProperty = <span class="string">"id"</span>, keyColumn = <span class="string">"id"</span>, statement = <span class="string">"SELECT LAST_INSERT_ID()"</span>, resultType = Integer<span class="class">.<span class="keyword">class</span>, <span class="title">before</span> </span>= <span class="keyword">false</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">saveUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id删除用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功返回1，失败返回0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">"DELETE FROM user WHERE id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeUserById</span><span class="params">(Integer userId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功返回1，失败返回0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"UPDATE user SET username = #&#123;username&#125;, birthday = #&#123;birthday&#125;, sex = #&#123;sex&#125;, address = #&#123;address&#125; WHERE id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询单个用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM user WHERE id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(Integer userId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据姓名模糊查询多个用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM user WHERE username LIKE CONCAT('%',#&#123;username&#125;,'%')"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">listUsersByName</span><span class="params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户总数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT COUNT(id) FROM user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果此时<strong>实体类的属性与数据库表列名不一致</strong>，那么我们应该使用<code>@Results、@Result、@ResultMap</code> 等注解</p><ul><li><code>@Results</code> 注解：定义映射结果集【<strong>等价<code>xml</code>标签 <code>&lt;resultMap&gt;&lt;/resultMap&gt;</code></strong>】<ul><li><code>id</code>属性为唯一标识。</li><li><code>value</code>属性用于接收 <code>@Result[]</code>注解类型的数组。</li></ul></li><li><code>@Result</code> 注解：定义映射关系【<strong>等价<code>xml</code>标签 <code>&lt;id/&gt; &lt;result/&gt;</code></strong>】<ul><li><code>id</code>属性指定主键</li><li><code>property</code>属性指定实体类的属性名</li><li><code>column</code>属性指定数据库表中对应的列</li></ul></li><li><code>@ResultMap</code> 注解：引用 <code>@Results</code> 定义的映射结果集，避免了重复定义映射结果集。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户</span></span><br><span class="line"><span class="comment">     * User类中已经将属性修改 此时与数据库无法对于</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM user"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(id = <span class="string">"UserMap"</span>,value = &#123;</span><br><span class="line">            <span class="meta">@Result</span>(id = <span class="keyword">true</span>,property = <span class="string">"userId"</span>,column = <span class="string">"id"</span>),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"userName"</span>,column = <span class="string">"username"</span>),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"userBirthday"</span>,column = <span class="string">"birthday"</span>),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"userSex"</span>,column = <span class="string">"sex"</span>),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"userAddress"</span>,column = <span class="string">"address"</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">listAllUsers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"INSERT INTO user(username,birthday,sex,address) VALUES(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)"</span>)</span><br><span class="line">    <span class="meta">@ResultMap</span>(<span class="string">"UserMap"</span>)<span class="comment">// ****</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">saveUser</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-2-Mybatis-使用注解实现多对一（一对一）"><a href="#11-2-Mybatis-使用注解实现多对一（一对一）" class="headerlink" title="11.2.Mybatis 使用注解实现多对一（一对一）"></a>11.2.Mybatis 使用注解实现多对一（一对一）</h2><ul><li><p><strong>账户实体类和用户实体类与xml配置相同</strong></p><ul><li><code>@One</code>注解：在注解中用来指定子查询返回单一对象【<strong>等价<code>xml</code>标签<code>&lt;association&gt;&lt;/association&gt;</code></strong>】<ul><li><code>select</code>属性指定用于查询的接口方法</li><li><code>fetchType</code>属性用于指定立即加载或延迟加载<ul><li><code>FetchType.EAGER</code></li><li><code>FetchType.LAZY</code></li></ul></li></ul></li><li>在包含<code>@one</code>注解的<code>@Result</code>中，<code>column</code>属性用于指定将要作为参数进行查询的数据库表列。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有账户，并查询所属用户，采用立即加载</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM account"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(id = <span class="string">"AccountMap"</span>, value = &#123;</span><br><span class="line">            <span class="meta">@Result</span>(id = <span class="keyword">true</span>, property = <span class="string">"id"</span>, column = <span class="string">"id"</span>),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"uid"</span>, column = <span class="string">"uid"</span>),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"user"</span>, column = <span class="string">"uid"</span>,</span><br><span class="line">                    one = <span class="meta">@One</span>(select = <span class="string">"top.carpenter.dao.IUserDao.getUserById"</span>, fetchType = FetchType.EAGER))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">listAllAccounts</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM user WHERE id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(Integer userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-3-Mybatis-使用注解实现一对多"><a href="#11-3-Mybatis-使用注解实现一对多" class="headerlink" title="11.3.Mybatis 使用注解实现一对多"></a>11.3.Mybatis 使用注解实现一对多</h2><ul><li><p>为用户实体类添加包含账户实体类的集合引用</p><ul><li><code>@Many</code> 注解相当于标签 <code>&lt;collection&gt;&lt;/collection&gt;</code>，是多表查询的关键，在注解中用来<strong>指定子查询返回对象集合</strong>。</li><li>其中，<code>select</code> 属性指定用于查询的接口方法，<code>fetchType</code> 属性用于指定立即加载或延迟加载，分别对应 <code>FetchType.EAGER</code> 和 <code>FetchType.LAZY</code></li><li>在包含 <code>@Many</code> 注解的 <code>@Result</code> 中，<code>column</code> 属性用于指定将要作为参数进行查询的数据库表列。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户，并且查询拥有账户，采用延迟加载</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM user"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(id = <span class="string">"UserMap"</span>, value = &#123;</span><br><span class="line">            <span class="meta">@Result</span>(id = <span class="keyword">true</span>, property = <span class="string">"userId"</span>, column = <span class="string">"id"</span>),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"userName"</span>, column = <span class="string">"username"</span>),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"userBirthday"</span>, column = <span class="string">"birthday"</span>),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"userSex"</span>, column = <span class="string">"sex"</span>),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"userAddress"</span>, column = <span class="string">"address"</span>),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"accounts"</span>, column = <span class="string">"id"</span>,</span><br><span class="line">                    many = <span class="meta">@Many</span>(select = <span class="string">"top.carpenter.dao.IAccountDao.getAccountByUid"</span>, fetchType = FetchType.LAZY))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">listAllUsers</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户id查询账户列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM account WHERE uid = #&#123;uid&#125;"</span>)</span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">listAccountsByUid</span><span class="params">(Integer uid)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-4-Mybatis-使用注解实现二级缓存"><a href="#11-4-Mybatis-使用注解实现二级缓存" class="headerlink" title="11.4.Mybatis 使用注解实现二级缓存"></a>11.4.Mybatis 使用注解实现二级缓存</h2><ul><li><p>如果使用注解时想开启二级缓存，那么首先应该在 Mybatis 配置文件中开启全局配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;!-- 开启缓存 --&gt;</span><br><span class="line">    &lt;setting name=<span class="string">"cacheEnabled"</span> value=<span class="string">"true"</span>/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure></li><li><p>在持久层接口中使用注解即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace</span>(blocking = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line"><span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      动态SQL语句 多表查询 延迟加载 多级缓存
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="MyBatis" scheme="http://goldcarpenter.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>多线程编程</title>
    <link href="http://goldcarpenter.github.io/2019/08/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B_Part8/"/>
    <id>http://goldcarpenter.github.io/2019/08/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B_Part8/</id>
    <published>2019-08-14T16:00:00.000Z</published>
    <updated>2020-06-17T03:46:27.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-共享模型之不可变"><a href="#7-共享模型之不可变" class="headerlink" title="7. 共享模型之不可变"></a>7. 共享模型之不可变</h1><ul><li><strong>对象内有成员变量处于共享代码中，但是其不可改变，依然是线程安全的</strong></li></ul><h2 id="7-1-日期转换的问题"><a href="#7-1-日期转换的问题" class="headerlink" title="7.1 日期转换的问题"></a>7.1 日期转换的问题</h2><h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"&#123;&#125;"</span>, sdf.parse(<span class="string">"1951-04-21"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"&#123;&#125;"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很大几率出现java.lang.NumberFormatException 或者出现不正确的日期解析结果</p><h3 id="解决思路-同步锁"><a href="#解决思路-同步锁" class="headerlink" title="解决思路 - 同步锁"></a>解决思路 - 同步锁</h3><p>这样虽能解决问题，但带来的是性能上的损失，并不算很好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sdf) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"&#123;&#125;"</span>, sdf.parse(<span class="string">"1951-04-21"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"&#123;&#125;"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决思路-不可变对象【另一种避免竞争的方式】"><a href="#解决思路-不可变对象【另一种避免竞争的方式】" class="headerlink" title="解决思路 - 不可变对象【另一种避免竞争的方式】"></a>解决思路 - 不可变对象【另一种避免竞争的方式】</h3><p>如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改啊！这样的对象在 Java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter stf = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        TemporalAccessor parse = stf.parse(<span class="string">"1951-04-21"</span>);</span><br><span class="line">        log.debug(<span class="string">"&#123;&#125;"</span>, parse);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2-不可变设计-（String-类为例）"><a href="#7-2-不可变设计-（String-类为例）" class="headerlink" title="7.2 不可变设计 （String 类为例）"></a>7.2 不可变设计 （String 类为例）</h2><p>另一个大家更为熟悉的 String 类也是不可变的，以它为例，说明一下不可变设计的要素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><h3 id="7-2-1-使用-final"><a href="#7-2-1-使用-final" class="headerlink" title="7.2.1 使用 final"></a>7.2.1 使用 final</h3><ul><li><p>发现类中所有属性都是 final </p><ul><li>属性用 final 修饰保证了该属性是只读的，不能修改 </li></ul></li><li><p>类用 final 修饰保证了该类中的方法不能被覆盖</p></li><li><p>防止子类无意间破坏不可变性</p></li><li><p>针对数组采用复制新的数组的方式【对于数组 final关键字仅仅对引用地址有效】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(arr);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">// 依然可以修改</span></span><br><span class="line">arr[<span class="number">3</span>]  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// arr = ints;         ✖</span></span><br><span class="line">System.out.println(ints);</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-2-2-保护性拷贝"><a href="#7-2-2-保护性拷贝" class="headerlink" title="7.2.2 保护性拷贝"></a>7.2.2 保护性拷贝</h3><ul><li><p>使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//有效性判断...</span></span><br><span class="line">        <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//有效性判断...</span></span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive copy）】</p></li><li><p>数组创建——保证了不与传入的数组对象指向同一引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-2-3-享元模式"><a href="#7-2-3-享元模式" class="headerlink" title="7.2.3 享元模式"></a>7.2.3 享元模式</h3><ul><li><strong>原因：保护性拷贝导致对象创建频繁，对象个数较多</strong></li><li><strong>目的：当需要重用数量有限的同一类对象</strong></li></ul><h4 id="2-1-包装类"><a href="#2-1-包装类" class="headerlink" title="2.1 包装类"></a>2.1 包装类</h4><ul><li><p>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的 valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Byte, Short, Long</strong> 缓存的范围都是 -128~127 </p><p><strong>Character</strong> 缓存的范围是 0~127</p><p><strong>Integer</strong>的默认范围是 -128~127 最小值不能变<br>但最大值可以通过调整虚拟机参数 <code>-Djava.lang.Integer.IntegerCache.high</code> 来改变</p><p><strong>Boolean</strong> 缓存了 TRUE 和 FALSE</p></li></ul><h4 id="2-2-String-串池"><a href="#2-2-String-串池" class="headerlink" title="2.2 String 串池"></a>2.2 String 串池</h4><h4 id="2-3-BigDecimal-BigInteger"><a href="#2-3-BigDecimal-BigInteger" class="headerlink" title="2.3 BigDecimal BigInteger"></a>2.3 BigDecimal BigInteger</h4><h4 id="2-4-实例-自定义数据库连接池"><a href="#2-4-实例-自定义数据库连接池" class="headerlink" title="2.4[实例]自定义数据库连接池"></a>2.4[实例]自定义数据库连接池</h4><p>仅使用乐观锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j(topic = <span class="string">"MultiThread"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pool pool = <span class="keyword">new</span> Pool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                Connection conn = pool.borrow();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                pool.free(conn);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j(topic = <span class="string">"c.Pool"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 连接池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> poolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接对象数组</span></span><br><span class="line">    <span class="keyword">private</span> Connection[] connections;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray states;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 构造方法初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">(<span class="keyword">int</span> poolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.poolSize = poolSize;</span><br><span class="line">        <span class="keyword">this</span>.connections = <span class="keyword">new</span> Connection[poolSize];</span><br><span class="line">        <span class="keyword">this</span>.states = <span class="keyword">new</span> AtomicIntegerArray(<span class="keyword">new</span> <span class="keyword">int</span>[poolSize]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            connections[i] = <span class="keyword">new</span> MyConnection(<span class="string">"连接"</span> + (i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 借连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">borrow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取空闲连接</span></span><br><span class="line">                <span class="keyword">if</span>(states.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (states.compareAndSet(i, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        log.debug(<span class="string">"borrow &#123;&#125;"</span>, connections[i]);</span><br><span class="line">                        <span class="keyword">return</span> connections[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 优化：如果没有空闲连接，当前线程进入等待 synchronized配合cas防止CPU长时间空转 可以打开注释</span></span><br><span class="line"><span class="comment">/*            synchronized (this) &#123;</span></span><br><span class="line"><span class="comment">                try &#123;</span></span><br><span class="line"><span class="comment">                    log.debug("wait...");</span></span><br><span class="line"><span class="comment">                    this.wait();</span></span><br><span class="line"><span class="comment">                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 归还连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connections[i] == conn) &#123;</span><br><span class="line">                states.set(i, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">/*synchronized (this) &#123;</span></span><br><span class="line"><span class="comment">                    log.debug("free &#123;&#125;", conn);</span></span><br><span class="line"><span class="comment">                    this.notifyAll();</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅使用悲观锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j(topic = <span class="string">"c.Pool"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 连接池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> poolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接对象数组</span></span><br><span class="line">    <span class="keyword">private</span> Connection[] connections;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] states;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 构造方法初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">(<span class="keyword">int</span> poolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.poolSize = poolSize;</span><br><span class="line">        <span class="keyword">this</span>.connections = <span class="keyword">new</span> Connection[poolSize];</span><br><span class="line">        <span class="keyword">this</span>.states = <span class="keyword">new</span> <span class="keyword">int</span>[poolSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            connections[i] = <span class="keyword">new</span> MockConnection(<span class="string">"连接"</span> + (i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 借连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">borrow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (states)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (connection==<span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">                    <span class="comment">// 获取空闲连接</span></span><br><span class="line">                    <span class="keyword">if</span>(states[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                        states[i]=<span class="number">1</span>;</span><br><span class="line">                        connection = connections[i];</span><br><span class="line">                        log.debug(<span class="string">"borrow &#123;&#125;"</span>, connection);</span><br><span class="line">                        <span class="keyword">return</span> connection;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">"wait..."</span>);</span><br><span class="line">                    states.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 归还连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connections[i] == conn) &#123;</span><br><span class="line">                states[i] =  <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (states) &#123;</span><br><span class="line">                    log.debug(<span class="string">"free &#123;&#125;"</span>, conn);</span><br><span class="line">                    states.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3-无状态"><a href="#7-3-无状态" class="headerlink" title="7.3 无状态"></a>7.3 无状态</h2><ul><li>在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这种<strong>没有任何成员变量的类是线程安全的</strong></li><li>因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】</li></ul>]]></content>
    
    <summary type="html">
    
      不可变类
    
    </summary>
    
    
      <category term="Java高级" scheme="http://goldcarpenter.github.io/categories/Java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="多线程" scheme="http://goldcarpenter.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
