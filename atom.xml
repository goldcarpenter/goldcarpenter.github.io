<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>掘金木匠</title>
  
  <subtitle>懂金融的软件工程师一定是一个合格的吃货</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://goldcarpenter.github.io/"/>
  <updated>2020-06-17T07:24:10.991Z</updated>
  <id>http://goldcarpenter.github.io/</id>
  
  <author>
    <name>掘金木匠</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis</title>
    <link href="http://goldcarpenter.github.io/2020/04/17/Redis_Part3/"/>
    <id>http://goldcarpenter.github.io/2020/04/17/Redis_Part3/</id>
    <published>2020-04-16T16:00:00.000Z</published>
    <updated>2020-06-17T07:24:10.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7高级数据类型"><a href="#7高级数据类型" class="headerlink" title="7高级数据类型"></a>7高级数据类型</h1><h2 id="7-1Bitmaps"><a href="#7-1Bitmaps" class="headerlink" title="7.1Bitmaps"></a>7.1Bitmaps</h2><ul><li><p>获取指定key对应偏移量上的bit值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset</span><br></pre></td></tr></table></figure></li><li><p>设置指定key对应偏移量上的bit值，value只能是1或0 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure></li><li><p>对指定key按位进行交、并、非、异或操作，并将结果保存到destKey中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitop op destKey key1 [key2...]</span><br></pre></td></tr></table></figure><ul><li>and：交 </li><li>or：并 </li><li>not：非</li><li>xor：异或</li></ul></li><li><p>统计指定key中1的数量 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount key [start end]</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用场景13"><a href="#应用场景13" class="headerlink" title="应用场景13"></a>应用场景13</h3><ul><li>统计每天某一部电影是否被点播</li><li>统计每天有多少部电影被点播</li><li>统计每周/月/年有多少部电影被点播</li><li>统计年度哪部电影没有被点播</li><li><strong>答：redis 应用于信息状态统计</strong></li></ul><h2 id="7-2HyperLogLog"><a href="#7-2HyperLogLog" class="headerlink" title="7.2HyperLogLog"></a>7.2HyperLogLog</h2><ul><li><p>HyperLogLog 是用来做基数统计的，运用了LogLog的算法</p></li><li><p>基数是数据集去重后元素个数</p><p><img src="1588695761826.png" alt="1588695761826"></p></li><li><p>添加数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element [element ...]</span><br></pre></td></tr></table></figure></li><li><p>统计数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfcount key [key ...]</span><br></pre></td></tr></table></figure></li><li><p>合并数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfmerge destkey sourcekey [sourcekey...]</span><br></pre></td></tr></table></figure></li><li><p>相关说明</p><ul><li>用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据</li><li>核心是基数估算算法，最终数值存在一定误差<ul><li>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值</li></ul></li><li>耗空间极小，每个hyperloglog key占用了12K的内存用于标记基数</li><li>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存逐渐增大 </li><li>Pfmerge命令合并后占用的存储空间为12K，无论合并之前数据量多少</li></ul></li></ul><h3 id="应用场景15"><a href="#应用场景15" class="headerlink" title="应用场景15"></a>应用场景15</h3><ul><li>统计独立UV</li><li><strong>答：redis 应用于独立信息统计</strong></li></ul><h2 id="7-3GEO"><a href="#7-3GEO" class="headerlink" title="7.3GEO"></a>7.3GEO</h2><ul><li><p>添加坐标点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude member [longitude latitude member ...]</span><br></pre></td></tr></table></figure></li><li><p>获取坐标点 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geopos key member [member ...]</span><br></pre></td></tr></table></figure></li><li><p>计算坐标点距离</p></li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geodist key member1 member2 [unit]</span><br></pre></td></tr></table></figure><ul><li><p>根据坐标求范围内的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">georadius key longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br></pre></td></tr></table></figure></li><li><p>根据点求范围内数据.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">georadiusbymember key member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br></pre></td></tr></table></figure></li><li><p>获取指定点对应的坐标hash值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geohash key member [member ...]</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用场景15-1"><a href="#应用场景15-1" class="headerlink" title="应用场景15"></a>应用场景15</h3><ul><li>统计独立UV</li><li><strong>答：redis 应用于地理位置计算</strong></li></ul><h1 id="8主从复制"><a href="#8主从复制" class="headerlink" title="8主从复制"></a>8主从复制</h1><h2 id="8-1主从复制简介"><a href="#8-1主从复制简介" class="headerlink" title="8.1主从复制简介"></a>8.1主从复制简介</h2><ul><li><p>单机redis的风险与问题 </p><ul><li>机器故障【硬盘故障、系统崩溃】，数据丢失，很可能对业务造成灾难性打击 </li><li>容量瓶颈【内存不足】，硬件条件跟不上</li></ul></li><li><p>为了避免单点Redis服务器故障，准备多台服务器，<strong>互相连通</strong>。</p></li><li><p>将数据复制多个副本保存在不同的服务器上，连接在一起，并<strong>保证数据是同步</strong>的。即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时实现数据<strong>冗余备份</strong>。</p><ul><li>提供数据方：master 主服务器，主节点，主库，主客户端</li><li>接收数据方：slave 从服务器，从节点，从库，从客户端</li><li>需要解决的问题： 数据同步</li><li>核心工作： master的数据复制到slave中</li></ul><p><img src="1588729303276.png" alt="1588729303276"></p></li><li><p>主从复制</p><ul><li>主从复制即将master中的数据即时、有效的复制到slave中</li><li>特征：一个master可以拥有多个slave，一个slave只对应一个master </li><li>职责：<ul><li>master:①写数据 ②执行写操作时，将出现变化的数据自动同步到slave ③读数据（可忽略）</li><li>slave:①读数据 ②写数据（禁止）</li></ul></li><li>作用<ul><li>读写分离：master写、slave读，提高服务器的读写负载能力</li><li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li><li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li><li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li><li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</li></ul></li></ul></li></ul><h2 id="8-2主从复制工作流程"><a href="#8-2主从复制工作流程" class="headerlink" title="8.2主从复制工作流程"></a>8.2主从复制工作流程</h2><ul><li><p>主从复制过程大体可以分为3个阶段 </p><ul><li>建立连接阶段（即准备阶段）</li><li>数据同步阶段</li><li>命令传播阶段</li></ul><p><img src="1588730469479.png" alt="1588730469479"></p></li></ul><h3 id="8-2-1阶段一：建立连接阶段"><a href="#8-2-1阶段一：建立连接阶段" class="headerlink" title="8.2.1阶段一：建立连接阶段"></a>8.2.1阶段一：建立连接阶段</h3><p><img src="1588730888782.png" alt="1588730888782"></p><ul><li><p>建立slave到master的连接，使master能够识别slave，并保存slave端口号</p></li><li><p>主从连接（slave连接master）</p><ul><li><p>方式一：客户端发送命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure></li><li><p>方式二：启动服务器参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server -slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure></li><li><p>方式三：服务器配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>主从断开连接</p><ul><li><p>客户端发送命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure></li><li><p>说明： slave断开连接后，不会删除已有数据，只是不再接受master发送的数据</p></li></ul></li><li><p>slave启动服务器设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server –a &lt;password&gt;</span><br></pre></td></tr></table></figure></li><li><p>slave配置文件设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info</span><br></pre></td></tr></table></figure><p><img src="1588733018080.png" alt="1588733018080"></p></li></ul><h3 id="8-2-2阶段二：数据同步阶段工作流程"><a href="#8-2-2阶段二：数据同步阶段工作流程" class="headerlink" title="8.2.2阶段二：数据同步阶段工作流程"></a>8.2.2阶段二：数据同步阶段工作流程</h3><ul><li><p>在slave初次连接master后，复制master中的所有数据到slave</p></li><li><p>将slave的数据库状态更新成master当前的数据库状态</p><p><img src="1588735501655.png" alt="1588735501655"></p><blockquote><p>步骤1：请求同步数据</p><p>步骤2：创建RDB同步数据</p><p>步骤3：恢复RDB同步数据</p><p>步骤4：请求部分同步数据</p><p>步骤5：恢复部分同步数据 至此，数据同步工作完成！</p></blockquote></li><li><p>状态： </p><ul><li>slave： 具有master端全部数据，包含RDB过程接收的数据</li><li>master： 保存slave当前数据同步的位置</li></ul></li><li><p>总体： 之间完成了数据克隆</p></li></ul><p><img src="1588752186549.png" alt="1588752186549"></p><h4 id="8-2-2-1部分复制的三个核心要素——服务器的运行-id（run-id）"><a href="#8-2-2-1部分复制的三个核心要素——服务器的运行-id（run-id）" class="headerlink" title="8.2.2.1部分复制的三个核心要素——服务器的运行 id（run id）"></a>8.2.2.1部分复制的三个核心要素——服务器的运行 id（run id）</h4><ul><li>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id</li><li>组成：运行id由40位字符组成，是一个随机的十六进制字符 例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce</li><li>作用：运行id被用于在服务器间进行传输，识别身份 如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别</li><li>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发 送给slave，slave保存此ID，通过info Server命令，可以查看节点的runid</li></ul><h4 id="8-2-2-2部分复制的三个核心要素——主服务器的复制积压缓冲区"><a href="#8-2-2-2部分复制的三个核心要素——主服务器的复制积压缓冲区" class="headerlink" title="8.2.2.2部分复制的三个核心要素——主服务器的复制积压缓冲区"></a>8.2.2.2部分复制的三个核心要素——主服务器的复制积压缓冲区</h4><ul><li>概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命 令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区</li><li>复制缓冲区默认数据存储空间大小是1M，由于存储空间大小是固定的，当入队元素的数量大于队 列长度时，最先入队的元素会被弹出，而新元素会被放入队列</li><li>由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区 </li><li>作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select）</li><li>数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中</li></ul><p><img src="../../%E5%AF%92%E5%81%87%E5%8C%85/Q&A/1588737306352.png" alt="1588737306352"></p><h4 id="8-2-2-3部分复制的三个核心要素——主从服务器的复制偏移量"><a href="#8-2-2-3部分复制的三个核心要素——主从服务器的复制偏移量" class="headerlink" title="8.2.2.3部分复制的三个核心要素——主从服务器的复制偏移量"></a>8.2.2.3部分复制的三个核心要素——主从服务器的复制偏移量</h4><ul><li>概念：一个数字，描述复制缓冲区中的指令字节位置</li><li>分类： <ul><li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）</li><li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）</li></ul></li><li>数据来源： master端：发送一次记录一次 slave端：接收一次记录一次</li><li>作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用</li></ul><h4 id="8-2-2-4数据同步阶段master"><a href="#8-2-2-4数据同步阶段master" class="headerlink" title="8.2.2.4数据同步阶段master"></a>8.2.2.4数据同步阶段master</h4><ul><li><p>如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行</p></li><li><p>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-backlog-size 1mb</span><br></pre></td></tr></table></figure></li><li><p>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执行bgsave命令和创建复制缓冲区</p><p><img src="1588737389244.png" alt="1588737389244"></p></li></ul><h4 id="8-2-2-5数据同步阶段slave"><a href="#8-2-2-5数据同步阶段slave" class="headerlink" title="8.2.2.5数据同步阶段slave"></a>8.2.2.5数据同步阶段slave</h4><ul><li><p>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的写数据功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave-serve-stale-data yes|no</span><br></pre></td></tr></table></figure></li><li><p>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</p></li><li><p>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果 master带宽不足，因此数据同步需要根据业务需求，适量错峰</p></li><li><p>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟 较大，数据一致性变差，应谨慎选择</p></li></ul><h3 id="8-2-3阶段三：命令传播阶段"><a href="#8-2-3阶段三：命令传播阶段" class="headerlink" title="8.2.3阶段三：命令传播阶段"></a>8.2.3阶段三：命令传播阶段</h3><ul><li><p>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的 状态，同步的动作称为命令传播</p></li><li><p>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令</p><p><img src="1588750683337.png" alt="1588750683337"></p></li><li><p>命令传播阶段出现了断网现象</p><ul><li>网络闪断闪连——忽略</li><li>短时间网络中断——部分复制</li><li>长时间网络中断——全量复制</li></ul></li></ul><p><img src="1588752840834.png" alt="1588752840834"></p><h4 id="8-2-3-1心跳机制"><a href="#8-2-3-1心跳机制" class="headerlink" title="8.2.3.1心跳机制"></a>8.2.3.1心跳机制</h4><ul><li>进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线</li><li>master心跳：<ul><li>指令：PING </li><li>周期：由repl-ping-slave-period决定，默认10秒</li><li>作用：判断slave是否在线 </li><li>查询：INFO replication    获取slave最后一次连接时间间隔，lag项维持在0或1视为正常</li></ul></li><li>slave心跳任务<ul><li>指令：REPLCONF ACK {offset} </li><li>周期：1秒</li><li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li><li>作用2：判断master是否在线</li></ul></li></ul><h4 id="8-2-3-2心跳阶段注意事项"><a href="#8-2-3-2心跳阶段注意事项" class="headerlink" title="8.2.3.2心跳阶段注意事项"></a>8.2.3.2心跳阶段注意事项</h4><ul><li><p>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write [2] </span><br><span class="line">min-slaves-max-lag [8]</span><br></pre></td></tr></table></figure></li><li><p>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步</p></li><li><p>slave数量由slave发送REPLCONF ACK命令做确认</p></li><li><p>slave延迟由slave发送REPLCONF ACK命令做确认</p></li></ul><h2 id="9主从复制常见问题"><a href="#9主从复制常见问题" class="headerlink" title="9主从复制常见问题"></a>9主从复制常见问题</h2><h3 id="9-1频繁的全量复制一"><a href="#9-1频繁的全量复制一" class="headerlink" title="9.1频繁的全量复制一"></a>9.1频繁的全量复制一</h3><ul><li><p>伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的 全量复制操作</p></li><li><p>内部优化调整方案：</p><ul><li>master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave </li><li>在master关闭时执行命令 shutdown save，进行RDB持久化,将runid与offset保存到RDB文件中</li><li>repl-id repl-offset </li><li>通过redis-check-rdb命令可以查看该信息</li></ul></li><li><p>master重启后加载RDB文件，恢复数据重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master_repl_id &#x3D; repl master_repl_offset &#x3D; repl-offset</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>通过info命令可以查看该信息</p></li><li><p>*<em>作用： 本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master *</em></p></li></ul><h3 id="9-2频繁的全量复制二"><a href="#9-2频繁的全量复制二" class="headerlink" title="9.2频繁的全量复制二"></a>9.2频繁的全量复制二</h3><ul><li><p>问题现象：网络环境不佳，出现网络中断，slave不提供服务</p></li><li><p>问题原因：复制缓冲区过小，断网后slave的offset越界，触发全量复制</p></li><li><p>最终结果：slave反复进行全量复制</p></li><li><p>解决方案：修改复制缓冲区大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-backlog-size</span><br></pre></td></tr></table></figure></li><li><p>建议设置如下：</p><ul><li>测算从master到slave的重连平均时长second</li><li>获取master平均每秒产生写命令数据总量write_size_per_second</li><li>最优复制缓冲区空间 = 2 * second * write_size_per_second</li></ul></li></ul><h3 id="9-3频繁的网络中断一"><a href="#9-3频繁的网络中断一" class="headerlink" title="9.3频繁的网络中断一"></a>9.3频繁的网络中断一</h3><ul><li><p>问题现象：master的CPU占用过高 或 slave频繁断开连接</p></li><li><p>问题原因：</p><ul><li>slave每1秒发送REPLCONF ACK命令到master，当slave接到了慢查询时（keys * ，hgetall等），会大量占用CPU性能，master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应</li></ul></li><li><p>最终结果：master各种资源（输出缓冲区、带宽、连接等）被严重占用</p></li><li><p>解决方案：通过设置合理的超时时间，确认是否释放slave</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-timeout</span><br></pre></td></tr></table></figure><blockquote><p>该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave</p></blockquote></li></ul><h3 id="9-4频繁的网络中断二"><a href="#9-4频繁的网络中断二" class="headerlink" title="9.4频繁的网络中断二"></a>9.4频繁的网络中断二</h3><ul><li><p>问题现象：slave与master连接断开</p></li><li><p>问题原因 </p><ul><li>master发送ping指令频度较低 </li><li>master设定超时时间较短</li><li>ping指令在网络中存在丢包</li></ul></li><li><p>解决方案：提高ping指令发送的频度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-ping-slave-period</span><br></pre></td></tr></table></figure><blockquote><p> 超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时</p></blockquote></li></ul><h3 id="9-5数据不一致"><a href="#9-5数据不一致" class="headerlink" title="9.5数据不一致"></a>9.5数据不一致</h3><ul><li>问题现象：多个slave获取相同数据不同步</li><li>问题原因：网络信息不同步，数据发送有延迟</li><li>解决方案 <ul><li>优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象  </li><li>监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问</li></ul></li></ul><h1 id="10哨兵模式"><a href="#10哨兵模式" class="headerlink" title="10哨兵模式"></a>10哨兵模式</h1><h2 id="10-1哨兵简介"><a href="#10-1哨兵简介" class="headerlink" title="10.1哨兵简介"></a>10.1哨兵简介</h2><ul><li><p>引入——主机“宕机”</p><ul><li>关闭master和所有slave</li><li>找一个slave作为master</li><li>修改其他slave的配置，连接新的主</li><li>启动新的master与slave </li></ul><p><img src="1588756296796.png" alt="1588756296796"></p></li><li><p><strong>哨兵(sentinel) 是一个分布式系统</strong>，用于对主从结构中的每台服务器进行<strong>监控</strong>，当出现故障时通过投票机制<strong>选择</strong>新的 master并将所有slave连接到新的master。</p></li><li><p>哨兵的作用</p><ul><li><strong>监控</strong>：不断的检查master和slave是否正常运行。 master存活检测、master与slave运行情况检测</li><li><strong>通知（提醒）</strong>：当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。</li><li>自动故障转移：断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服 务器地址</li></ul></li><li><p>注意：</p><ul><li>哨兵也是一台redis服务器，只是不提供数据服务</li><li>通常哨兵配置数量为单数</li></ul></li></ul><h2 id="10-2启用哨兵模式"><a href="#10-2启用哨兵模式" class="headerlink" title="10.2启用哨兵模式"></a>10.2启用哨兵模式</h2><ul><li><p>配置一拖二的主从结构</p></li><li><p>配置三个哨兵（配置相同，端口不同） </p><ul><li><code>sentinel.conf</code>文件</li></ul></li><li><p>启动哨兵</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel [sentinel-端口号.conf]</span><br></pre></td></tr></table></figure></li></ul><h2 id="10-3哨兵工作原理"><a href="#10-3哨兵工作原理" class="headerlink" title="10.3哨兵工作原理"></a>10.3哨兵工作原理</h2><ul><li><p>监控阶段</p><p><img src="1588813168115.png" alt="1588813168115"></p></li><li><p>通知阶段</p><p><img src="1588813289351.png" alt="1588813289351"></p></li><li><p>故障转移阶段</p><ul><li><p>发现问题</p><p><img src="1588813971869.png" alt="1588813971869"></p></li><li><p><strong>竞选负责人，优选新master</strong></p><p><img src="1588814022315.png" alt="1588814022315"></p></li><li><p><strong>新master上任，其他slave切换master，原master作为slave故障恢复后连接</strong></p></li></ul><p><img src="1588814072747.png" alt="1588814072747"></p></li></ul><h1 id="11集群"><a href="#11集群" class="headerlink" title="11集群"></a>11集群</h1><h2 id="11-1集群简介"><a href="#11-1集群简介" class="headerlink" title="11.1集群简介"></a>11.1集群简介</h2><ul><li>集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果</li><li>作用<ul><li>分散单台服务器的访问压力，实现负载均衡</li><li>分散单台服务器的存储压力，实现可扩展性</li><li>降低单台服务器宕机带来的业务灾难</li></ul></li></ul><h2 id="11-2Redis集群结构设计"><a href="#11-2Redis集群结构设计" class="headerlink" title="11.2Redis集群结构设计"></a>11.2Redis集群结构设计</h2><p><img src="1588768233155.png" alt="1588768233155"></p><ul><li><p>增减节点就是改变槽的位置</p><p><img src="1588768368813.png" alt="1588768368813"></p><p><img src="1588768577301.png" alt="1588768577301"></p></li></ul><h2 id="11-3cluster集群结构搭建"><a href="#11-3cluster集群结构搭建" class="headerlink" title="11.3cluster集群结构搭建"></a>11.3cluster集群结构搭建</h2><h3 id="11-3-1Cluster配置"><a href="#11-3-1Cluster配置" class="headerlink" title="11.3.1Cluster配置"></a>11.3.1Cluster配置</h3><ul><li><p>添加节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-enabled yes|no</span><br></pre></td></tr></table></figure></li><li><p>cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-config-file &lt;filename&gt;</span><br></pre></td></tr></table></figure></li><li><p>节点服务响应超时时间，用于判定该节点是否下线或切换为从节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-node-timeout &lt;milliseconds&gt;</span><br></pre></td></tr></table></figure></li><li><p>master连接的slave最小数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-migration-barrier &lt;count&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="11-3-2Cluster节点操作命令"><a href="#11-3-2Cluster节点操作命令" class="headerlink" title="11.3.2Cluster节点操作命令"></a>11.3.2Cluster节点操作命令</h3><ul><li><p>查看集群节点信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure></li><li><p>进入一个从节点 redis，切换其主节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster replicate &lt;master-id&gt;</span><br></pre></td></tr></table></figure></li><li><p>发现一个新节点，新增主节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster meet ip:port</span><br></pre></td></tr></table></figure></li><li><p>忽略一个没有solt的节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster forget &lt;id&gt;</span><br></pre></td></tr></table></figure></li><li><p>手动故障转移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster failover</span><br></pre></td></tr></table></figure></li></ul><h1 id="12企业级解决方案"><a href="#12企业级解决方案" class="headerlink" title="12企业级解决方案"></a>12企业级解决方案</h1><h2 id="12-1缓存预热"><a href="#12-1缓存预热" class="headerlink" title="12.1缓存预热"></a>12.1缓存预热</h2><ul><li>缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓 存的问题！用户直接查询事先被预热的缓存数据！</li><li>现象：服务器启动后迅速宕机</li><li>问题排查：<ul><li>请求数量较高</li><li>主从之间数据吞吐量较大，数据同步操作频度较高</li></ul></li><li>解决方案<ul><li>前置准备工作<ul><li>日常例行统计数据访问记录，统计访问频度较高的热点数据 </li><li>利用LRU数据删除策略，构建数据留存队列 例如：storm与kafka配合</li></ul></li><li>准备工作<ul><li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</li><li>利用分布式多服务器同时进行数据读取，提速数据加载过程</li><li>热点数据主从同时预热</li></ul></li><li>实施<ul><li>使用脚本程序固定触发数据预热过程</li><li>如果条件允许，使用了CDN（内容分发网络），效果会更好</li></ul></li></ul></li></ul><h2 id="12-2缓存雪崩"><a href="#12-2缓存雪崩" class="headerlink" title="12.2缓存雪崩"></a>12.2缓存雪崩</h2><ul><li><p>缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现 （约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p><p><img src="1588776662147.png" alt="1588776662147"></p></li><li><p>现象</p><ul><li>系统平稳运行过程中，忽然数据库连接量激增</li><li>应用服务器无法及时处理请求</li><li>大量408，500错误页面出现</li><li>客户反复刷新页面获取数据</li><li>数据库崩溃</li><li>应用服务器崩溃</li><li>重启应用服务器无效</li><li>Redis服务器崩溃</li><li>Redis集群崩溃</li><li>重启数据库后再次被瞬间流量放倒</li></ul></li><li><p>问题排查</p><ul><li>在一个<strong>较短的</strong>时间内，缓存中较多的<strong>key集中过期</strong></li><li>此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</li><li>数据库同时接收到大量的请求无法及时处理</li><li>Redis大量请求被积压，开始出现超时现象</li><li>数据库流量激增，数据库崩溃</li><li>重启后仍然面对缓存中无数据可用</li><li>Redis服务器资源被严重占用，Redis服务器崩溃</li><li>Redis集群呈现崩塌，集群瓦解</li><li>应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</li><li>应用服务器，redis，数据库全部重启，效果不理想</li></ul></li><li><p>问题分析</p><ul><li>短时间范围内</li><li>大量key集中过期</li></ul></li><li><p>解决方案（道）</p><ul><li>更多的页面静态化处理</li><li>构建多级缓存架构【Nginx缓存+redis缓存+ehcache缓存】</li><li>检测Mysql严重耗时业务进行优化【对数据库的瓶颈排查：例如超时查询、耗时较高事务等】</li><li>灾难预警机制<ul><li>监控redis服务器性能指标</li><li>CPU占用、CPU使用率</li><li>内存容量</li><li>查询平均响应时间</li><li>线程数</li></ul></li><li>限流、降级 短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</li></ul></li><li><p>解决方案（术）</p><ul><li>LRU与LFU切换 </li><li>数据有效期策略调整<ul><li>根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟</li><li>过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量</li></ul></li><li>超热数据使用永久key </li><li>定期维护（自动+人工） 对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时</li><li>加锁 慎用！</li></ul></li></ul><h2 id="12-3缓存击穿"><a href="#12-3缓存击穿" class="headerlink" title="12.3缓存击穿"></a>12.3缓存击穿</h2><ul><li><p>缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服 务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度 较高，配合雪崩处理策略即可</p></li><li><p>现象</p><ul><li>系统平稳运行过程中</li><li>数据库连接量瞬间激增</li><li>Redis服务器无大量key过期</li><li>Redis内存平稳，无波动</li><li>Redis服务器CPU正常</li><li>数据库崩溃</li></ul></li><li><p>问题排查</p><ul><li>Redis中某个key过期，该key访问量巨大</li><li>多个数据请求从服务器直接压到Redis后，均未命中</li><li>Redis在短时间内发起了大量对数据库中同一数据的访问</li></ul></li><li><p>问题分析</p><ul><li>单个key高热数据</li><li>key过期</li></ul></li><li><p>解决方案（术）</p><ul><li>预先设定 以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长 注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</li><li>现场调整 监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</li><li>后台刷新数据 启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</li><li>二级缓存 设置不同的失效时间，保障不会被同时淘汰就行</li><li>加锁 分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！</li></ul></li></ul><h2 id="12-4缓存穿透"><a href="#12-4缓存穿透" class="headerlink" title="12.4缓存穿透"></a>12.4缓存穿透</h2><ul><li><p>缓存击穿访问了<strong>根本</strong>不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。</p></li><li><p>通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。</p></li><li><p>无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。</p></li><li><p>现象</p><ul><li>系统平稳运行过程中</li><li>应用服务器流量随时间增量较大</li><li>Redis服务器命中率随时间逐步降低</li><li>Redis内存平稳，内存无压力</li><li>Redis服务器CPU占用激增</li><li>数据库服务器压力激增</li><li>数据库崩溃</li></ul></li><li><p>问题排查</p><ul><li>获取的数据在数据库中也不存在，数据库查询未得到对应数据</li><li>Redis获取到null数据未进行持久化，直接返回</li><li>下次此类数据到达重复上述过程 </li><li>出现黑客攻击服务器</li></ul></li><li><p>问题分析</p><ul><li>Redis中大面积出现未命中</li><li>出现非正常URL访问</li></ul></li><li><p>解决方案（术）</p><ul><li>缓存null【对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟】</li><li>白名单策略<ul><li>提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放 行，加载异常数据时直接拦截（效率偏低）</li><li>使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）</li></ul></li><li>实施监控【实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比】<ul><li>非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象 </li><li>活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象</li><li>根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）</li></ul></li><li>key加密<ul><li>问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验 </li><li>例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问</li></ul></li></ul></li></ul><h2 id="12-5性能指标监控"><a href="#12-5性能指标监控" class="headerlink" title="12.5性能指标监控"></a>12.5性能指标监控</h2><ul><li><p>性能指标：Performance</p><table><thead><tr><th align="center">Name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">latency</td><td align="center">Redis响应一个请求的时间</td></tr><tr><td align="center">instantaneous_ ops_per_sec</td><td align="center">平均每秒处理请求总数</td></tr><tr><td align="center">hit rate (calculated)</td><td align="center">缓存命中率(计算出来的)</td></tr></tbody></table></li><li><p>内存指标：Memory </p><table><thead><tr><th align="center">Name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">used_memory</td><td align="center">已使用内存</td></tr><tr><td align="center">mem_fragmentation_ratio</td><td align="center">内存碎片率</td></tr><tr><td align="center">evicted_keys</td><td align="center">由于最大内存限制被移除的key的数量</td></tr><tr><td align="center">blocked_clients</td><td align="center">由于BLPOP, BRPOP, or BRPOPLPUSH而备阻塞的客户端</td></tr></tbody></table></li><li><p>基本活动指标：Basic activity </p><table><thead><tr><th align="center">Name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">connected_clients</td><td align="center">客户端连接数</td></tr><tr><td align="center">connected_slaves</td><td align="center">Slave数量</td></tr><tr><td align="center">master_last_io_seconds_ago</td><td align="center">最近一次主从交互之后的秒数</td></tr><tr><td align="center">keyspace</td><td align="center">数据库中的key值总数</td></tr></tbody></table></li><li><p>持久性指标：Persistence </p><table><thead><tr><th align="center">Name</th><th align="center">description</th></tr></thead><tbody><tr><td align="center">rdb_last_save_time</td><td align="center">最后一次持久化保存到磁盘的时间戳</td></tr><tr><td align="center">rdb_changes_since_last_save</td><td align="center">自最后一次持久化以来数据库的更改数</td></tr></tbody></table></li><li><p>错误指标：Error</p><table><thead><tr><th align="center">Name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">rejected_ connections</td><td align="center">由于达到maxclient限制而被拒绝的连接数</td></tr><tr><td align="center">keyspace_misses</td><td align="center">Key值查找失败(没有命中)次数</td></tr><tr><td align="center">master_ link_down_since_seconds</td><td align="center">主从断开的持续时间(以秒为单位)</td></tr></tbody></table></li><li><p>监控方式</p><ul><li>工具<ul><li>Cloud Insight Redis</li><li>Prometheus</li><li>Redis-stat</li><li>Redis-faina</li><li>RedisLive</li><li>zabbix</li></ul></li><li>命令<ul><li>benchmark【指令】</li><li>monitor【redis cli指令】</li><li>showlog【redis cli指令】</li></ul></li></ul></li></ul><p>179.redis 是什么？都有哪些使用场景？</p><ul><li>redis用于控制数据库表主键id ,为数据库表主键提供生成策略,保障数据库表的主键唯一性</li><li>redis 控制数据的生命周期,通过数据是否失效控制业务行为,适用于所有具有时效性限定控制的操作——setex</li><li>redis应用于各种结构型和非结构型高热度数据访问加速——String</li><li>redis应用于购物车数据存储设计——hash</li><li>redis应用于抢购,限购类、限量发放优惠卷、激活码等业务的数据存储设计——hash</li><li>redis应用于具有操作先后顺序的数据控制——list</li><li>redis应用于最新消息展示——list</li><li>redis应用于随机推荐类信息检索,例如热点歌单推荐,热点新闻推荐,热卖旅游线路,应用APP推荐,大V推荐等——set</li><li>redis应用于同类信息的关联搜索,二度关联搜索,深度关联搜索——set</li><li>redis应用于同类型不重复数据的合并操作——set</li><li>redis应用于计数器组合排序功能对应的排名——sorted_set</li><li>redis应用于定时任务执行顺序管理或任务过期管理</li><li>redis应用于即时任务/消息队列执行管理</li><li>redis应用于按次结算的服务控制</li><li>redis应用于基于时间顺序的数据操作,而不关注具体时间</li></ul><p>180.redis 有哪些功能？</p><p>181.redis 和 memecache 有什么区别？</p><p>182.redis 为什么是单线程的？</p><p>183.什么是缓存穿透？怎么解决？</p><p>184.redis 支持的数据类 型有哪些？</p><p>185.redis 支持的 java 客户端都有哪些？</p><p>186.jedis 和 redisson 有哪些区别？</p><p>187.怎么保证缓存和数据库数据的一致性？</p><p>188.redis 持久化有几种方式？</p><p>189.redis 怎么实现分布式锁？</p><p>190.redis 分布式锁有什么缺陷？</p><p>191.redis 如何做内存优化？ </p><p>192.redis 淘汰策略有哪些？</p><p>193.redis 常见的性能问题有哪些？该如何解决？</p>]]></content>
    
    <summary type="html">
    
      高级数据类型 主从复制 哨兵模式 集群
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Redis" scheme="http://goldcarpenter.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://goldcarpenter.github.io/2020/04/04/Redis_Part2/"/>
    <id>http://goldcarpenter.github.io/2020/04/04/Redis_Part2/</id>
    <published>2020-04-03T16:00:00.000Z</published>
    <updated>2020-06-17T07:22:44.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-Jedis"><a href="#2-Jedis" class="headerlink" title="2.Jedis"></a>2.Jedis</h1><ul><li>Java程序操作Redis的工具<ul><li>Jedis</li><li>SpringData Redis</li><li>Lettuce</li></ul></li></ul><h2 id="2-1Jedis入门程序"><a href="#2-1Jedis入门程序" class="headerlink" title="2.1Jedis入门程序"></a>2.1Jedis入门程序</h2><ul><li><p>pom.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>JedisTest</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package top.carpenter;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">public class JedisTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.连接Redis</span><br><span class="line">        Jedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line">        &#x2F;&#x2F; 2.操作Redis——与终端操作方法一致</span><br><span class="line">        jedis.set(&quot;name&quot;,&quot;carpenter&quot;);</span><br><span class="line">        System.out.println(jedis.get(&quot;name&quot;));</span><br><span class="line">        &#x2F;&#x2F; 3.关闭连接</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2Jedis读写redis数据"><a href="#2-2Jedis读写redis数据" class="headerlink" title="2.2Jedis读写redis数据"></a>2.2Jedis读写redis数据</h2><ul><li>案例：服务调用次数控制<ul><li>服务免费开放给企业试用，对试用用户的使用行为进行限速，限制每个用户每分钟最多发起10次调用</li></ul></li><li>案例要求<br>①设定A、B三个用户<br>②A用户限制10次/分调用, B用户限制30次/分调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.exceptions.JedisDataException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer EXPAIRTIME = <span class="number">300</span>;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt1 = <span class="keyword">new</span> MyThread(<span class="string">"初级用户"</span>,<span class="keyword">new</span> Integer(<span class="number">10</span>));</span><br><span class="line">        MyThread mt2 = <span class="keyword">new</span> MyThread(<span class="string">"高级用户"</span>,<span class="number">30</span>);</span><br><span class="line">        mt1.start() ;</span><br><span class="line">        mt2.start() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String id,Integer num)</span></span>&#123;</span><br><span class="line">        service = <span class="keyword">new</span> Service(id,num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            service.service();</span><br><span class="line">             <span class="keyword">try</span>&#123;</span><br><span class="line">                Random r = <span class="keyword">new</span> Random();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>+ r.nextInt(<span class="number">200</span>));</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> Integer num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Service</span><span class="params">(String id, Integer num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 模拟服务内容</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">business</span> <span class="params">(String id, <span class="keyword">long</span> num)</span></span>&#123;</span><br><span class="line">        System.out.println (<span class="string">"用户"</span>+id+<span class="string">"发起业务调用,当前第"</span>+num+<span class="string">"次"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line">        String value = jedis.get(<span class="string">"compid:"</span> + id);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断值是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 不存在 则创建该值</span></span><br><span class="line">                jedis.setex(<span class="string">"compid:"</span> + <span class="keyword">this</span>.id,JedisTest.EXPAIRTIME, <span class="string">""</span>+(Long.MAX_VALUE-<span class="keyword">this</span>.num));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 存在 自增 调用业务</span></span><br><span class="line">                Long val = jedis.incr(<span class="string">"compid:"</span> + id);</span><br><span class="line">                business(id, <span class="keyword">this</span>.num + val - Long.MAX_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisDataException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"用户: "</span> + id + <span class="string">"使用次数已达上限，请稍后再试或升级VIP会员"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3Jedis连接池"><a href="#2-3Jedis连接池" class="headerlink" title="2.3Jedis连接池"></a>2.3Jedis连接池</h2><ul><li><p><code>JedisPool</code>: Jedis提供的连接池技术</p><ul><li><code>poolConfig</code>:连接池配置对象</li><li><code>host</code>:redis服务地址</li><li><code>port</code>:redis服务端口号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public JedisPool (GenericObjectPoolConfig poolConfig, String host,int port) &#123;</span><br><span class="line">this(poolConfig, host, port, 2000，(String)null, 0,(String) null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String host = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxTotal ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ResourceBundle rb = ResourceBundle.getBundle(<span class="string">"redis"</span> );</span><br><span class="line">        host = rb. getString(<span class="string">"redis.host"</span>);</span><br><span class="line">        port = Integer.parseInt(rb. getString(<span class="string">"redis.port"</span>));</span><br><span class="line">        maxTotal = Integer.parseInt(rb. getString( <span class="string">"redis.maxTotal"</span>));</span><br><span class="line">        maxIdle = Integer. parseInt(rb. getString( <span class="string">"redis.maxIdle"</span>));</span><br><span class="line"></span><br><span class="line">        JedisPoolConfig jpc = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jpc.setMaxTotal (maxTotal);</span><br><span class="line">        jpc.setMaxIdle(maxIdle);</span><br><span class="line">        jp = <span class="keyword">new</span> JedisPool(jpc ,host,port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jp.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="3-基于Linux的Redis"><a href="#3-基于Linux的Redis" class="headerlink" title="3.基于Linux的Redis"></a>3.基于Linux的Redis</h1><h2 id="3-1Redis启动"><a href="#3-1Redis启动" class="headerlink" title="3.1Redis启动"></a>3.1Redis启动</h2><ul><li><p>默认配置启动【企业开发不用】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br><span class="line">redis-server --port 6380[更换端口启动]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli </span><br><span class="line">redis-cli -p 6380[更换端口启动]</span><br><span class="line">redis-cli -h 127.0.0.1[更换host]</span><br></pre></td></tr></table></figure></li><li><p>使用配置文件启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server config&#x2F;redis-6380.conf</span><br></pre></td></tr></table></figure></li><li><p><code>redis.conf</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以守护进程方式启动，redis将以服务的形式存在，日志不再打印到命令窗口</span></span><br><span class="line">daemonize yes </span><br><span class="line"><span class="meta">#</span><span class="bash"> 设定当前服务启动端口号</span></span><br><span class="line">port 6380</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设定当前服务文件保存位置，包含日志文件、持久化文件(后面详细讲解)等</span></span><br><span class="line">dir "/[自定义目录]/redis/data"</span><br><span class="line"><span class="meta">#</span><span class="bash">设定日志文件名，便于查阅</span></span><br><span class="line">logfile "***.log ”</span><br></pre></td></tr></table></figure></li><li><p>配置文件</p><ul><li><code>dbfilename dump.rdb</code>说明：设置本地数据库文件名，默认值为 dump.rdb <ul><li>经验：通常设置为<code>dump-端口号.rdb</code></li></ul></li><li><code>dir</code>说明：设置存储.rdb文件的路径 <ul><li>经验：通常设置成存储空间较大的目录中，目录名称data</li></ul></li><li><code>rdbcompression yes</code> 说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩 <ul><li>经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大）</li></ul></li><li><code>rdbchecksum yes</code>说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行<ul><li>经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险</li></ul></li><li><code>stop-writes-on-bgsave-error yes</code>说明：后台存储过程中如果出现错误现象，是否停止保存操作 <ul><li>经验：通常默认为开启状态</li></ul></li><li><code>appendonly yes|no</code>说明：是否开启AOF持久化功能<ul><li>默认为不开启状态</li></ul></li><li><code>appendfsync always|everysec|no</code> 说明：AOF写数据策略</li><li><code>appendfilename filename</code>说明：AOF持久化文件名，默认文件名<code>appendonly.aof</code><ul><li>建议配置为<code>appendonly-端口号.aof</code></li></ul></li></ul></li></ul><h1 id="4-Redis持久化"><a href="#4-Redis持久化" class="headerlink" title="4.Redis持久化"></a>4.Redis持久化</h1><ul><li><p>什么是持久化</p><ul><li><strong>利用永久性存储介质将数据进行保存</strong>，在特定的时间<strong>将保存的数据进行恢复</strong>的工作机制称为持久化</li></ul></li><li><p>为什么要进行持久化</p></li><li><p>防止数据的意外丢失，确保数据安全性</p></li><li><p>持久化过程保存什么</p><ul><li>将<strong>当前数据状态进行保存</strong>，快照形式，存储数据结果，存储格式简单，关注点在数据</li><li>将数据的<strong>操作过程进行保存</strong>，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程</li></ul><p><img src="1580311093979.png" alt="1580311093979"></p></li></ul><h2 id="4-1RDB方案"><a href="#4-1RDB方案" class="headerlink" title="4.1RDB方案"></a>4.1RDB方案</h2><h3 id="4-1-1RDB启动方式——save指令"><a href="#4-1-1RDB启动方式——save指令" class="headerlink" title="4.1.1RDB启动方式——save指令"></a>4.1.1RDB启动方式——save指令</h3><ul><li><p>手动执行一次保存操作</p><p><img src="1588579168526.png" alt="1588579168526"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save</span><br></pre></td></tr></table></figure><blockquote><p>本地生成<code>***.rdb</code>的文件，保存生产的快照信息</p></blockquote></li><li><p>注意: save指令的执行会阻塞当前Redis服务器，直到当前RDB过程完成为止，有可能会造成长时间阻塞，<strong>线上环境不建议使用。</strong></p></li></ul><h3 id="4-1-2RDB启动方式-——-bgsave指令命令"><a href="#4-1-2RDB启动方式-——-bgsave指令命令" class="headerlink" title="4.1.2RDB启动方式 —— bgsave指令命令"></a>4.1.2RDB启动方式 —— bgsave指令命令</h3><ul><li><p>手动启动后台保存操作，但不是立即执行</p><p><img src="1588580713240.png" alt="1588580713240"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgsave</span><br></pre></td></tr></table></figure></li><li><p>注意: bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式，s<strong>ave命令可以放弃使用</strong>。</p></li></ul><h3 id="4-1-3RDB启动方式——save配置"><a href="#4-1-3RDB启动方式——save配置" class="headerlink" title="4.1.3RDB启动方式——save配置"></a>4.1.3RDB启动方式——save配置</h3><ul><li><p>满足限定时间范围内key的变化数量达到指定数量即进行持久化</p><p><img src="1588582081351.png" alt="1588582081351"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save second changes</span><br></pre></td></tr></table></figure><blockquote><p>second：监控时间范围</p><p>changes：监控key的变化量</p></blockquote></li><li><p>位置：在conf文件中进行配置</p></li><li><p>注意：</p><ul><li>save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的 </li><li>save配置中对于second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系</li><li>save配置启动后执行的是bgsave操作</li></ul></li></ul><h3 id="4-1-4对比"><a href="#4-1-4对比" class="headerlink" title="4.1.4对比"></a>4.1.4对比</h3><table><thead><tr><th align="center">方式</th><th align="center">save指令</th><th align="center">bgsave指令</th></tr></thead><tbody><tr><td align="center">读写</td><td align="center">同步</td><td align="center">异步</td></tr><tr><td align="center">阻塞客户端指令</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">额外内存消耗</td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">启动新进程</td><td align="center">否</td><td align="center">是</td></tr></tbody></table><h3 id="4-1-5RDB特殊启动形式"><a href="#4-1-5RDB特殊启动形式" class="headerlink" title="4.1.5RDB特殊启动形式"></a>4.1.5RDB特殊启动形式</h3><ul><li><p>全量复制</p><ul><li>在主从复制中详细讲解 </li></ul></li><li><p>服务器运行过程中重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug reload</span><br></pre></td></tr></table></figure></li><li><p>关闭服务器时指定保存数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown save</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-1-6优点-amp-缺点"><a href="#4-1-6优点-amp-缺点" class="headerlink" title="4.1.6优点 &amp; 缺点"></a>4.1.6优点 &amp; 缺点</h3><ul><li><p>RDB优点</p><ul><li>RDB是一个紧凑压缩的二进制文件，<strong>存储效率较高</strong></li><li>RDB内部存储的是redis在某个时间点的数据快照，<strong>非常适合用于数据备份，全量复制等场景</strong> </li><li>RDB<strong>恢复数据</strong>的<strong>速度要比AOF快很多</strong> </li><li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。</li></ul></li><li><p>Rdb缺点</p><ul><li>RDB方式无论是执行指令还是利用配置，无法做到实时持久化，<strong>具有较大的可能性丢失数据</strong> </li><li>bgsave指令每次运行<strong>要执行fork操作创建子进程，要牺牲掉一些性能</strong></li><li>Redis的<strong>众多版本中未进行RDB文件格式的版本统一</strong>，有可能出现各版本服务之间数据格式无法兼容现象</li></ul></li></ul><h2 id="4-2AOF方案"><a href="#4-2AOF方案" class="headerlink" title="4.2AOF方案"></a>4.2AOF方案</h2><h3 id="4-2-1引入"><a href="#4-2-1引入" class="headerlink" title="4.2.1引入"></a>4.2.1引入</h3><ul><li>RDB存储的弊端<ul><li>存储数据量较大，效率较低【基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低】</li><li>大数据量下的IO性能较低</li><li>基于fork创建子进程，内存产生额外消耗</li><li>宕机带来的数据丢失风险</li></ul></li><li>解决思路<ul><li><strong>写全数据，仅记录部分数据</strong></li><li><strong>改记录数据为记录操作过程</strong></li><li><strong>对所有操作均进行记录，排除丢失数据的风险</strong></li></ul></li></ul><h3 id="4-2-2AOF概念"><a href="#4-2-2AOF概念" class="headerlink" title="4.2.2AOF概念"></a>4.2.2AOF概念</h3><ul><li><p>以独立日志的方式记录每次写命令，<strong>重启时再重新执行AOF文件中命令达到恢复数据的目的</strong>。与RDB相比可以简单描述为改记录数据为记录数据产生的过程</p></li><li><p>作用：解决了数据持久化的实时性，<strong>目前已经是Redis持久化的主流方式</strong></p><p><img src="1588584037410.png" alt="1588584037410"></p></li><li><p>AOF写数据三种策略(appendfsync)</p><ul><li><code>always(每次）</code>每次写入操作均同步到AOF文件中，<strong>数据零误差，性能较低</strong>，不建议使用。</li><li><code>everysec（每秒）</code>每秒将缓冲区中的指令同步到AOF文件中，<strong>数据准确性较高，性能较高</strong>，建议使用，也是默认配置 在系统突然宕机的情况下丢失1秒内的数据</li><li><code>no（系统控制）</code>由操作系统控制每次同步到AOF文件的周期，整体过程<strong>不可控</strong></li></ul></li></ul><h3 id="4-2-3AOF重写"><a href="#4-2-3AOF重写" class="headerlink" title="4.2.3AOF重写"></a>4.2.3AOF重写</h3><p><img src="1588584845063.png" alt="1588584845063"></p><ul><li>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了<strong>AOF重写机制压缩文件体积</strong>。</li><li>AOF文件重写：将<strong>Redis进程内的数据</strong>转化为<strong>写命令同步到新AOF文件的过程</strong>。【将对同一个数据的若干个条命令执行结果转化成最终结果数据对应的指令进行记录。】</li><li>作用<ul><li>降低磁盘占用量，提高磁盘利用率</li><li>提高持久化效率，降低持久化写时间，提高IO性能</li><li>降低数据恢复用时，提高数据恢复效率</li></ul></li></ul><h3 id="4-2-4AOF重写规则"><a href="#4-2-4AOF重写规则" class="headerlink" title="4.2.4AOF重写规则"></a>4.2.4AOF重写规则</h3><ul><li><strong>进程内已超时的数据不再写入文件</strong></li><li><strong>忽略无效指令，重写时使用进程内数据直接生成</strong>，这样新的AOF文件只保留最终数据的写入命令 <ul><li>如<code>del key1、 hdel key2、srem key3、set key4 111、set key4 222</code>等</li></ul></li><li>对同一数据的多条写命令合并为一条命令<ul><li>如<code>lpush list1 a、lpush list1 b、 lpush list1 c</code>可以转化为：<code>lpush list1 a b c</code>。</li><li>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</li></ul></li></ul><h3 id="4-2-5AOF重写方式"><a href="#4-2-5AOF重写方式" class="headerlink" title="4.2.5AOF重写方式"></a>4.2.5AOF重写方式</h3><ul><li><p>手动重写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgrewriteaof</span><br></pre></td></tr></table></figure><ul><li><p>bgrewriteaof指令工作原理</p><p><img src="1588584827646.png" alt="1588584827646"></p></li></ul></li><li><p>自动重写</p><ul><li><p>自动重写触发条件设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size [size] </span><br><span class="line">auto-aof-rewrite-percentage [percentage]</span><br></pre></td></tr></table></figure></li><li><p>自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aof_current_size</span><br><span class="line">aof_base_size</span><br></pre></td></tr></table></figure></li><li><p>自动重写触发条件</p><p><img src="1588585553364.png" alt="1588585553364"></p></li></ul></li></ul><h3 id="4-2-6AOF工作流程"><a href="#4-2-6AOF工作流程" class="headerlink" title="4.2.6AOF工作流程"></a>4.2.6AOF工作流程</h3><p><img src="1588586007153.png" alt="1588586007153"></p><p><img src="1588586438267.png" alt="1588586438267"></p><h2 id="4-3AOF-amp-RDB对比"><a href="#4-3AOF-amp-RDB对比" class="headerlink" title="4.3AOF &amp; RDB对比"></a>4.3AOF &amp; RDB对比</h2><p><img src="1588586605001.png" alt="1588586605001"></p><ul><li><strong>对数据非常敏感，建议使用默认的AOF持久化方案</strong><ul><li>AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。</li><li>注意：由于AOF文件存储体积较大，且恢复速度较慢</li></ul></li><li><strong>数据呈现阶段有效性，建议使用RDB持久化方案</strong><ul><li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段 点数据恢复通常采用RDB方案</li><li>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重总结：</li></ul></li><li>综合比对<ul><li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li><li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF </li><li>如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB</li><li>灾难恢复选用RDB</li><li>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量</li></ul></li></ul><h2 id="4-4持久化应用场景"><a href="#4-4持久化应用场景" class="headerlink" title="4.4持久化应用场景"></a>4.4持久化应用场景</h2><ul><li><del>Tips 1：redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性</del>【从DB读取最大】</li><li><del>Tips 3：redis应用于各种结构型和非结构型高热度数据访问加速</del>【从DB读取】</li><li><del>Tips 4：redis 应用于购物车数据存储设计</del>【从DB读取】</li><li>Tips 5：redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计</li><li><del>Tips 6：redis 应用于具有操作先后顺序的数据控制</del>【用MQ】</li><li><del>Tips 7：redis 应用于最新消息展示</del>【用RQ】</li><li><del>Tips 9：redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索</del>【从DB读取】</li><li><del>Tips 12：redis 应用于基于黑名单与白名单设定的服务控制【长期】</del>【从DB读取】</li><li>Tips 12：redis 应用于基于黑名单设定的服务控制【短期】</li><li>Tips 13：redis 应用于计数器组合排序功能对应的排名</li><li><del>Tips 15：redis 应用于即时任务/消息队列执行管理</del>【用MQ】</li><li>Tips 16：redis 应用于按次结算的服务控制</li></ul><h1 id="5-Redis事务"><a href="#5-Redis事务" class="headerlink" title="5.Redis事务"></a>5.Redis事务</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性 按照添加顺序依次执行，中间不会被打断或者干扰。</li><li>一个队列中，一次性、顺序性、排他性的执行一系列命令</li></ul><p><img src="1588599302710.png" alt="1588599302710"></p><h2 id="事务的基本操作"><a href="#事务的基本操作" class="headerlink" title="事务的基本操作"></a>事务的基本操作</h2><ul><li><p>开启事务</p><ul><li><p>设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multi</span><br></pre></td></tr></table></figure></li></ul></li><li><p>执行事务 </p><ul><li><p>设定事务的结束位置，同时执行事务。与multi成对出现，成对使用 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec</span><br></pre></td></tr></table></figure></li></ul></li><li><p>取消事务</p><ul><li><p>终止当前事务的定义，发生在multi之后，exec之前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discard</span><br></pre></td></tr></table></figure></li></ul></li><li><p>注意：加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行</p></li></ul><h2 id="事务的工作流程"><a href="#事务的工作流程" class="headerlink" title="事务的工作流程"></a>事务的工作流程</h2><p><img src="1588599890428.png" alt="1588599890428"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>定义事务的过程中，<strong>命令格式输入错误</strong>怎么办？ </p><ul><li>语法错误：命令书写格式有误</li><li>处理结果 如果定义的事务中所包含的命令存在语法错误，整体事务中所有命令均不会执行。包括那些语法正确的命令。</li></ul><p><img src="1588600366786.png" alt="1588600366786"></p></li><li><p>定义事务的过程中，<strong>命令执行出现错误</strong>怎么办？ </p><ul><li>运行错误：命令格式正确，但是无法正确的执行。例如对list进行incr操作 </li><li>能够正确运行的命令会执行，运行错误的命令不会被执行 </li></ul><p><img src="1588600336265.png" alt="1588600336265"></p></li><li><p><strong>已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚。</strong></p></li></ul><h2 id="基于特定条件的事务执行"><a href="#基于特定条件的事务执行" class="headerlink" title="基于特定条件的事务执行"></a>基于特定条件的事务执行</h2><ul><li><p>多个客户端有可能同时操作同一组数据，并且该数据一旦被操作修改后，将不适用于继续操作</p></li><li><p>在操作之前锁定要操作的数据，一旦发生变化，终止当前操作</p></li><li><p>对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch key1 [key2……]</span><br></pre></td></tr></table></figure><blockquote><p>watch 不能在multi命令之后</p></blockquote></li><li><p>取消对所有 key 的监视 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unwatch</span><br></pre></td></tr></table></figure></li></ul><h3 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h3><ul><li>redis 应用基于状态控制的批量任务执行</li></ul><h1 id="6-Redis-删除策略"><a href="#6-Redis-删除策略" class="headerlink" title="6.Redis 删除策略"></a>6.Redis 删除策略</h1><h2 id="6-1过期数据"><a href="#6-1过期数据" class="headerlink" title="6.1过期数据"></a>6.1过期数据</h2><ul><li>Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态<ul><li>XX ：具有时效性的数据</li><li>-1 ：永久有效的数据 ：已经过期的数</li><li>-2 ：<strong>已经过期的数据</strong> 或 被删除的数据 或 未定义的数据</li></ul></li></ul><h2 id="6-2数据删除策略"><a href="#6-2数据删除策略" class="headerlink" title="6.2数据删除策略"></a>6.2数据删除策略</h2><h3 id="6-2-1时效性数据的存储结构"><a href="#6-2-1时效性数据的存储结构" class="headerlink" title="6.2.1时效性数据的存储结构"></a>6.2.1时效性数据的存储结构</h3><p><img src="1588602997289.png" alt="1588602997289"></p><h3 id="6-2-2数据删除策略的目标"><a href="#6-2-2数据删除策略的目标" class="headerlink" title="6.2.2数据删除策略的目标"></a>6.2.2数据删除策略的目标</h3><p>在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露</p><h3 id="6-2-3定时删除"><a href="#6-2-3定时删除" class="headerlink" title="6.2.3定时删除"></a>6.2.3定时删除</h3><ul><li>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作<ul><li>优点：节约内存，到时就删除，快速释放掉不必要的内存占用 </li><li>缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量 </li><li>总结：用处理器性能换取存储空间 （拿时间换空间）</li></ul></li></ul><p><img src="1588603340595.png" alt="1588603340595"></p><p><img src="1588603390266.png" alt="1588603390266"></p><h3 id="6-2-4惰性删除"><a href="#6-2-4惰性删除" class="headerlink" title="6.2.4惰性删除"></a>6.2.4惰性删除</h3><ul><li><p>数据到达过期时间，不做处理。等下次访问该数据时</p><ul><li>如果未过期，返回数据</li><li>发现已过期，删除，返回不存在</li></ul></li><li><p>优点：节约CPU性能，发现必须删除的时候才删除</p></li><li><p>缺点：内存压力很大，出现长期占用内存的数据</p></li><li><p>总结：用存储空间换取处理器性能 （拿时间换空间）</p><p><img src="1588603547170.png" alt="1588603547170"></p><p><img src="1588603606205.png" alt="1588603606205"></p></li></ul><h3 id="6-2-5定期删除"><a href="#6-2-5定期删除" class="headerlink" title="6.2.5定期删除"></a>6.2.5定期删除</h3><ul><li><p>Redis启动服务器初始化时，读取配置server.hz的值，默认为10</p></li><li><p>每秒钟执行server.hz次<code>serverCron()</code></p><p>​                                                —-&gt;<code>databasesCron()</code></p><p>​                                                     —-&gt;<code>activeExpireCycle()</code></p></li><li><p><code>activeExpireCycle()</code>对每个<code>expires[*]</code>逐一进行检测，每次执行<code>250/server.hz</code>ms</p></li><li><p>对某个<code>expires[*]</code>检测时，随机挑选W个key检测 </p><ul><li>如果key超时，删除key </li><li>如果一轮中<code>删除的key的数量&gt;W*25%</code>，循环该过程</li><li>如果一轮中<code>删除的key的数量≤W*25%</code>，检查下一个<code>expires[\*]</code>，0-15循环</li></ul></li><li><p><code>W=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP</code>属性值</p></li><li><p>参数<code>current_db</code>用于记录<code>activeExpireCycle()</code>进入哪个<code>expires[*]</code>执行。如果activeExpireCycle()执行时间到期，下次从<code>current_db</code>继续向下执行</p></li><li><p>周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度</p><ul><li>特点1：CPU性能占用设置有峰值，检测频度可自定义设置</li><li>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理 </li></ul></li><li><p>总结：周期性抽查存储空间（随机抽查，重点抽查）</p></li></ul><p><img src="1588603704644.png" alt="1588603704644"></p><p><img src="1588604972997.png" alt="1588604972997"></p><h2 id="6-3逐出算法"><a href="#6-3逐出算法" class="headerlink" title="6.3逐出算法"></a>6.3逐出算法</h2><ul><li><p>Redis使用内存存储数据，在执行每一个命令前，会调用<code>freeMemoryIfNeeded()</code>检测内存是否充足。</p></li><li><p>逐出算法：<strong>如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略即为逐出算法。</strong></p></li><li><p>注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。</p><p><img src="1588606582199.png" alt="1588606582199"></p></li><li><p>最大可使用内存，占用物理内存的比例，默认值为0，表示不限制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory []</span><br></pre></td></tr></table></figure><blockquote><p>生产环境中根据需求设定，通常设置在50%以上。</p></blockquote></li><li><p>每次选取待删除数据的个数，选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-samples []</span><br></pre></td></tr></table></figure></li><li><p>删除策略，达到最大内存后的，对被挑选出来的数据进行删除的策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy []</span><br></pre></td></tr></table></figure><ul><li>检测易失数据（可能会过期的数据集server.db[i].expires ）<ul><li>① volatile-lru：挑选最近最少使用的数据淘汰</li><li>② volatile-lfu：挑选最近使用次数最少的数据淘汰 </li><li>③ volatile-ttl：挑选将要过期的数据淘汰 </li><li>④ volatile-random：任意选择数据淘汰 </li></ul></li><li>检测全库数据（所有数据集server.db[i].dict ）<ul><li>⑤ allkeys-lru：挑选最近最少使用的数据淘汰 </li><li>⑥ allkeys-lfu：挑选最近使用次数最少的数据淘汰 </li><li>⑦ allkeys-random：任意选择数据淘汰 </li></ul></li><li>放弃数据驱逐 <ul><li>⑧ no-enviction（驱逐）：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out Of Memory）</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Jedis Redis持久化 Redis事务 删除策略
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Redis" scheme="http://goldcarpenter.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Nginx</title>
    <link href="http://goldcarpenter.github.io/2020/03/29/Nginx%E5%9F%BA%E7%A1%80/"/>
    <id>http://goldcarpenter.github.io/2020/03/29/Nginx%E5%9F%BA%E7%A1%80/</id>
    <published>2020-03-28T16:00:00.000Z</published>
    <updated>2020-06-17T07:06:28.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h1 id="1-Nginx简介"><a href="#1-Nginx简介" class="headerlink" title="1 Nginx简介"></a>1 Nginx简介</h1><ul><li>Nginx是<strong>开源</strong>，<strong>高性能</strong>，<strong>高可靠的</strong>Http Web服务、代理服务、负载均衡<ul><li>高性能：支持海量并发，有报告表明能支持高达50, 000个并发连接数</li><li>可靠：服务稳定 </li><li>轻量：占用内存资源少</li></ul></li><li>Nginx优点<ul><li>轻量级<ul><li>功能模块少（源代码仅保留http与核心模块代码,其余不够核心代码会作为插件来安装）</li><li>代码模块化（易读，便于二次开发，对于开发人员非常友好）</li></ul></li><li>技术成熟，国内公司基本大规模使用<ul><li>适合当前主流架构趋势，微服务、云架构、中间层</li><li>统一技术栈，降低维护成本，降低技术更新成本</li></ul></li><li>Nginx采用Epoll网络模型，Apache 采用select模型<ul><li>select：当用户发起一次请求，select模型就会进行一次遍历扫描， 从而导致性能低下</li><li>Epoll：当用户发起请求，epool模型会直接进行处理，效率高效，并无连接限制</li></ul></li></ul></li><li>常用的HTTP Web服务<ul><li>Httpd——Apache基金会</li><li>IIS——微软服务器版</li><li>GWS——Google开发</li><li>Openrestry——基于Nginx+lua</li><li>Tengline——淘宝基于Nginx开发</li></ul></li></ul><h1 id="2-Nginx应用场景"><a href="#2-Nginx应用场景" class="headerlink" title="2 Nginx应用场景"></a>2 Nginx应用场景</h1><p><img src="1575686992791.png" alt="1575686992791"></p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><ul><li>正向代理：在客户端(浏览器)配置代理服务器，通过代理服务器进行互联网访问</li></ul><p><img src="1575687744434.png" alt="1575687744434"></p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><ul><li><p>我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据<br>返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器， 暴露的是<br>代理服务器地址,隐藏了真实服务器IP地址</p><p><img src="1588901698779.png" alt="1588901698779"></p></li></ul><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li><p>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器。</p><p><img src="1588902037728.png" alt="1588902037728"></p></li></ul><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><ul><li><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。</p><p><img src="1588903187825.png" alt="1588903187825"></p></li></ul><h2 id="Nginx安装方式"><a href="#Nginx安装方式" class="headerlink" title="Nginx安装方式"></a>Nginx安装方式</h2><ul><li><p>官方源 ——官方编译好的，封装成rpm包，并提供yum源【推荐】</p><ul><li><p>nginx.org 官网有详细过程[<a href="http://nginx.org/en/download.html]" target="_blank" rel="noopener">http://nginx.org/en/download.html]</a></p></li><li><p>配置Nginx官方yum仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@web01 ~]# vim /etc/yum.repos.d/nginx.repo</span><br><span class="line">    [nginx]</span><br><span class="line">    name=nginx repo</span><br><span class="line">    baseurl=http://nginx.org/packages/centos/7/$basearch/</span><br><span class="line">    gpgcheck=0</span><br><span class="line">    enabled=1</span><br></pre></td></tr></table></figure></li><li><p>安装nginx，必须安装官方源的nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@web01 ~]# yum install -y nginx</span><br><span class="line">[root@web01 ~]# nginx -v# 查询是否成功</span><br><span class="line">    nginx version: nginx/1.14.0</span><br></pre></td></tr></table></figure></li><li><p>访问网址 查询是否成功</p></li></ul></li><li><p>EPEL源——版本低，功能少</p></li><li><p>源代码——自己下载源代码，安装复杂，费时</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果企业之前的Nginx都是通过源码安装，这时需要我们部署新的Nginx服务器，怎么接手通过源代码方式安装</span><br><span class="line">通过nginx -v获得版本</span><br><span class="line">通过nginx -V查看配置选项</span><br></pre></td></tr></table></figure><h2 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h2><ul><li><p>查看nginx的版本号    </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -v</span><br></pre></td></tr></table></figure></li><li><p>启动nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure></li><li><p>关闭nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop</span><br></pre></td></tr></table></figure></li><li><p>重新加载nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></li><li><p>配置文件语法检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure></li></ul><p>  ​    </p><h2 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h2><ul><li>Nginx主配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;conf.d</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf</span><br></pre></td></tr></table></figure><ul><li>Cgi、Fastcgi、 Uwcgi配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx&#x2F;fastcgi_params</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;scgi_params</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;uwsgi_params</span><br></pre></td></tr></table></figure><ul><li>Nginx编码转换映射文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx&#x2F;win-utf</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;koi-utf</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;koi-win</span><br></pre></td></tr></table></figure><ul><li>http协议的Content-Type与扩展名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx&#x2F;mime.types</span><br></pre></td></tr></table></figure><ul><li>配置系统守护进程管理器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;1ib&#x2F;systemd&#x2F;system&#x2F;nginx.service</span><br></pre></td></tr></table></figure><ul><li>Nginx日志轮询，日志切割</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;logrotate.d&#x2F;nginx</span><br></pre></td></tr></table></figure><ul><li>Nginx终端管理命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;nginx</span><br><span class="line">&#x2F;usr&#x2F;sbin&#x2F;nginx-debug</span><br></pre></td></tr></table></figure><ul><li>Nginx模块目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx&#x2F;modules</span><br><span class="line">&#x2F;usr&#x2F;1ib64&#x2F;nginx</span><br><span class="line">&#x2F;usr&#x2F;1ib64&#x2F;nginx&#x2F;modules</span><br></pre></td></tr></table></figure><ul><li>Nginx默认站点目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;50x.html</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure><ul><li>Nginx的帮助手册</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.14.0</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;man&#x2F;man8&#x2F;nginx.8.gz</span><br></pre></td></tr></table></figure><ul><li>Nginx的缓存目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;cache&#x2F;nginx</span><br></pre></td></tr></table></figure><ul><li>Nginx的日志目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;log&#x2F;nginx</span><br></pre></td></tr></table></figure><h2 id="Nginx主配置文件"><a href="#Nginx主配置文件" class="headerlink" title="Nginx主配置文件"></a>Nginx主配置文件</h2><ul><li><p><code>nginx.conf</code>是一个纯文本类型的文件，整个配置文件是以区块的形式组织的。每个区块以一对大括号{}来表示开始与结束</p><p><img src="1575703052492.png" alt="1575703052492"></p></li></ul><h3 id="CoreModule核心模块"><a href="#CoreModule核心模块" class="headerlink" title="CoreModule核心模块"></a>CoreModule核心模块</h3><ul><li>从<strong>配置文件开始</strong>到<strong>events块</strong>之间的内容</li><li>主要会<strong>设置一些影响nginx服务器整体运行的配置指令</strong>，主要包括配置运行Nginx服务器的用户(组)、允许生成的worker process数，进程PID存放路径、日志存放路径和类型以及配置文件的引入等。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user nginx;#Nginx进程所使用的用户</span><br><span class="line">worker_processes 1;#Nginx运行的work进程数量(建议与CPU数量一致或auto)</span><br><span class="line">error_log &#x2F;1og&#x2F;nginx&#x2F;error.1og; #Nginx错误日志存放路径</span><br><span class="line">pid &#x2F;var&#x2F;run&#x2F;nginx.pid;#Nginx服务运行后产生的pid进程号</span><br></pre></td></tr></table></figure><h3 id="EventModule-事件驱动模块"><a href="#EventModule-事件驱动模块" class="headerlink" title="EventModule    事件驱动模块"></a>EventModule    事件驱动模块</h3><ul><li><p>影响Nginx服务器与用户的网络连接</p></li><li><p>常用的设置包括是否开启对多work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个word process可以同时支持的最大连接数等。</p></li><li><p><strong>对Nginx的性能影响较大，在实际中应该灵活配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;#每个worker进程支持的最大连接数</span><br><span class="line">    use epool;#事件驱动模型，epoll默认</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="HttpCoreModule-http内核模块"><a href="#HttpCoreModule-http内核模块" class="headerlink" title="HttpCoreModule http内核模块"></a>HttpCoreModule http内核模块</h3><ul><li><p>Nginx服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。</p></li><li><p>http内核模块</p><ul><li>http全局块</li><li>server 块</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">http &#123; </span><br><span class="line"><span class="meta">#</span><span class="bash"> http全局块</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#</span><span class="bash">使用server配置网站，每个Server&#123;&#125;代表一个网站(简称虛拟主机)</span></span><br><span class="line">server&#123;</span><br><span class="line">listen80;#监听端口，默认80</span><br><span class="line">server_namelocalhost; #提供服务的域名或主机名</span><br><span class="line">access_log host.access.1og  #访问日志</span><br><span class="line"><span class="meta">#</span><span class="bash">控制网站访问路径</span></span><br><span class="line">location / &#123;</span><br><span class="line">root/usr/share/nginx/html; //存放网站 代码路径</span><br><span class="line">index index.php index.html index.htm;</span><br><span class="line">//服务器返回的默认页面文件</span><br><span class="line">//指定错误代码，统一定义错误页面，错误代码重定向到新的Locaiton</span><br><span class="line">error_page500 502 503 504 /50x.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">第二个虚拟主机配置</span></span><br><span class="line">server&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">include /etc/nginx/conf.d/*.conf; #其他附加配置文件</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="http全局块"><a href="#http全局块" class="headerlink" title="http全局块"></a>http全局块</h4><ul><li>http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</li></ul><h4 id="server-块"><a href="#server-块" class="headerlink" title="server 块"></a>server 块</h4><ul><li><p>HTTP模块层允许有多个Server块  Server主要 用于配置多个网站</p></li><li><p>Server块又允许有多个Location Location主要用于定义网站访问路径</p><p><img src="1575703252359.png" alt="1575703252359"></p></li></ul><h4 id="location指令详解"><a href="#location指令详解" class="headerlink" title="location指令详解"></a>location指令详解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location [ &#x3D; | ~ | ~* | ^~ ] uri&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>没有修饰符：必须以指定模式开始，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">　　server_name baidu.com;</span><br><span class="line">　　location &#x2F;abc &#123;</span><br><span class="line">　　　　……</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">那么，如下是对的：</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc?p1</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abcde</span><br></pre></td></tr></table></figure></li><li><p><code>=</code>：用于不含正则表达式的uri前，要求请求字符串与uri严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">server_name sish</span><br><span class="line">　　location &#x3D; &#x2F;abc &#123;</span><br><span class="line">　　　　……</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">那么，如下是对的：</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc?p1</span><br><span class="line">如下是错的：</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abcde</span><br></pre></td></tr></table></figure></li><li><p><code>~</code> ： 用于表示uri包含正则表达式，并且区分大小写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name baidu.com;</span><br><span class="line">    location ~^ &#x2F;abc$ &#123;</span><br><span class="line">        ……</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">那么，如下是对的：</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc?p1&#x3D;11&amp;p2&#x3D;22</span><br><span class="line">如下是错的：</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;ABC</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abcde</span><br></pre></td></tr></table></figure></li><li><p><code>~*</code>：用于表示uri包含正则表达式，并且不区分大小写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">server_name baidu.com;</span><br><span class="line">location ~* ^&#x2F;abc$ &#123;</span><br><span class="line">　　　　……</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">那么，如下是对的：</span><br><span class="line">http:&#x2F;&#x2F;baidu.com&#x2F;abc</span><br><span class="line">http:&#x2F;&#x2F;baidu..com&#x2F;ABC</span><br><span class="line">http:&#x2F;&#x2F;baidu..com&#x2F;abc?p1&#x3D;11&amp;p2&#x3D;22</span><br><span class="line">如下是错的：</span><br><span class="line">http:&#x2F;&#x2F;baidu..com&#x2F;abc&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;baidu..com&#x2F;abcde</span><br></pre></td></tr></table></figure></li><li><p><code>^~</code>：用于不含正则表达式的 uri前，无修饰符的行为，也是以指定模式开始，不同的是，如果模式匹配，那么就停止搜索其他模式了。</p></li><li><p>注意：如果uri包含正则表达式，则必须要有<code>~</code>或者<code>~*</code>标识</p></li></ul><h4 id="root-amp-alias指令区别"><a href="#root-amp-alias指令区别" class="headerlink" title="root &amp; alias指令区别"></a><strong>root &amp; alias指令区别</strong></h4><ul><li><p><strong>alias是一个目录别名的定义，root则是最上层目录的定义。</strong></p></li><li><p>若按照上述配置的话，则访问/img/目录里面的文件时，ningx会自动去/var/www/image/目录找文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;img&#x2F; &#123;</span><br><span class="line">    alias &#x2F;var&#x2F;www&#x2F;image&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>#若按照这种配置的话，则访问/img/目录下的文件时，nginx会去/var/www/image/img/目录下找文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;img&#x2F; &#123;</span><br><span class="line">    root &#x2F;var&#x2F;www&#x2F;image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还有一个重要的区别是alias后面必须要用“/”结束，否则会找不到文件，而root则可有可无</p></li></ul><h2 id="Nginx搭建Web服务器"><a href="#Nginx搭建Web服务器" class="headerlink" title="Nginx搭建Web服务器"></a>Nginx搭建Web服务器</h2><ul><li><strong>Nginx可以作为静态页面的web服务器</strong>，同时还支持CGI协议的动态语言，比如perl、php等。但是<strong>不支持Java，Java程序只能通过与tomcat配合完成</strong></li></ul><ul><li><p>Nginx配置Web服务器网站【功能同Apache的Tomcat】——接收客户请求端请求，并响应</p><ul><li>功能：当我们访问game.oldboy.com的时候，访问/oldboy_code/里面的页面代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name yangyuxin.top;</span><br><span class="line">    index index.php index.html index.htm default.php default.htm default.html;</span><br><span class="line">    root &#x2F;www&#x2F;wwwroot&#x2F;yangyuxin.top;# 静态页面所在目录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h2><ul><li><p>功能：使用Nginx从<strong>80端口跳转到8080端口</strong>的Tomcat主页</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">    &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name yangyuxin.top;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">          root html;</span><br><span class="line">          proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;&#x2F;&#x2F;⭐</span><br><span class="line">          index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>功能：使用 nginx 反向代理，根据访问的路径跳转到不同端口的服务中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">    &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name yangyuxin.top;</span><br><span class="line">        location ~/hello/ &#123;</span><br><span class="line">          root html;</span><br><span class="line">          proxy_pass http://127.0.0.1:8080;</span><br><span class="line">          index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        location ~/world/ &#123;</span><br><span class="line">          root html;</span><br><span class="line">          proxy_pass http://127.0.0.1:8081;</span><br><span class="line">          index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="1588928819346.png" alt="1588928819346"></p><p><img src="1588928842462.png" alt="1588928842462"></p></li></ul><h2 id="Nginx负载均衡"><a href="#Nginx负载均衡" class="headerlink" title="Nginx负载均衡"></a>Nginx负载均衡</h2><ul><li><p>实现效果：浏览器地址栏输入地址负载均衡，按比例均衡到8080和8081端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">upstream myservername&#123;&#x2F;&#x2F;⭐</span><br><span class="line">    # ip_hash&#x2F;&#x2F; 每个请求按访问ip的hash结果分配，访客固定访问一个后端服务器,可以解决session的问题。</span><br><span class="line">    server 47.92.38.57:8080 weight&#x3D;2; &#x2F;&#x2F;⭐</span><br><span class="line">    server 47.92.38.57:8081 weight&#x3D;4;    &#x2F;&#x2F;⭐</span><br><span class="line">    # fair&#x2F;&#x2F; 按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server</span><br><span class="line">    &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name yangyuxin.top;</span><br><span class="line">        location ~&#x2F;hello&#x2F; &#123;</span><br><span class="line">          root html;</span><br><span class="line">          proxy_pass http:&#x2F;&#x2F;myservername;&#x2F;&#x2F;⭐</span><br><span class="line">          index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Nginx高可用"><a href="#Nginx高可用" class="headerlink" title="Nginx高可用"></a>Nginx高可用</h2><p><img src="1588955148812.png" alt="1588955148812"></p><ul><li>准备<ul><li>两台nginx服务器</li><li>分别安装keepalived</li><li>虚拟ip</li></ul></li></ul><h3 id="Keepalived实现高可用"><a href="#Keepalived实现高可用" class="headerlink" title="Keepalived实现高可用"></a>Keepalived实现高可用</h3><ul><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install keepalived -y</span><br></pre></td></tr></table></figure></li><li><p>安装之后，在<code>etc</code>里面生成目录<code>keepalived</code>, 有文件<code>keepalived.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;# 全局配置</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 192.168.200.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL# ⭐通过这个名字可以访问主机&#x2F;服务器 &#x2F;etc&#x2F;hosts文件下配置这个名字</span><br><span class="line">   vrrp_skip_check_adv_addr</span><br><span class="line">   vrrp_strict</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_http_port &#123;# 脚本配置</span><br><span class="line">script &quot;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_check.sh&quot;</span><br><span class="line">interval 2#(检测脚本执行的间隔)</span><br><span class="line">weight 2# 设置当前服务器权重</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;# 虚拟IP配置</span><br><span class="line">    state MASTER# 备份服务器改为BACKUP</span><br><span class="line">    interface eth0# 网卡</span><br><span class="line">    virtual_router_id 51# 主、备机的virtual_ router_ id必须相同</span><br><span class="line">    priority 100#主、备机取不同的优先级，主机值较大，备份机值较小</span><br><span class="line">    advert_int 1# 心跳时间</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.200.16#VRRP H虚拟IP</span><br><span class="line">        192.168.200.17</span><br><span class="line">        192.168.200.18</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>检测脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line">A&#x3D; &#96;ps -C nginx -no-header| wc -l&#96;</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br><span class="line">sleep 2</span><br><span class="line">if [&#96;ps -C nginx --no-header| wc -l&#96; -eq 0];</span><br><span class="line">killall keepalived</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><p>把两台服务器上nginx和keepalived启动。</p><ul><li><p>启动nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>启动keepalived</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start keepalived.services</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Nginx目录索引模块"><a href="#Nginx目录索引模块" class="headerlink" title="Nginx目录索引模块"></a>Nginx目录索引模块</h2><ul><li><p>官方文档使用说明</p><p><img src="1575780742140.png" alt="1575780742140"></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Nginx 默认是不允许列出整个目录浏览下载</span><br><span class="line">Syntax: autoindex on | off;</span><br><span class="line">Default: autoindex off;</span><br><span class="line">Context: http, server, location</span><br><span class="line"></span><br><span class="line"># autoindex常用参数</span><br><span class="line">autoindex_exact_size off;# 默认为on 显示出文件的确切大小 单位是bytes</span><br><span class="line"># 修改为off 显示出文件的大概大小 单位是kB或者MB或者GB</span><br><span class="line">autoindex_localtime on;# 默认为off 显示的文件时间为GMT时间</span><br><span class="line"># 修改为on 显示的文件时间为文件的服务器时间</span><br><span class="line">charset utf-8,gbk;# 默认中文目录乱码 添加解决乱码</span><br></pre></td></tr></table></figure><ul><li><p>访问game.oldboy.com/download，打开目录索引列表</p><ul><li>在配置文件中添加</li></ul><p><img src="1575783147690.png" alt="1575783147690"></p><p><img src="1575785803803.png" alt="1575785803803"></p></li></ul><h2 id="Nginx状态监控模块"><a href="#Nginx状态监控模块" class="headerlink" title="Nginx状态监控模块"></a>Nginx状态监控模块</h2><ul><li><p>ngx_http_stub_status_module用于展示Nginx连接状态信息</p><ul><li><p>需要–with-http_stub_status_module配置参数启用【nginx -V 查看】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Syntax:stub_status;</span><br><span class="line">Default:—</span><br><span class="line">Context:    server, location</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">- 如果使用restart重置服务，会清空所有的连接数</span><br><span class="line">- reload重载不会清空之前的连接数</span><br><span class="line">- 通过状态监控，可以区分长连接和短连接</span><br><span class="line">vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf#修改下面参数</span><br><span class="line">keepalive_timeout 0; #将长连接变为短连接</span><br></pre></td></tr></table></figure></li></ul><p><img src="1575786624450.png" alt="1575786624450"></p><p><img src="1575785770881.png" alt="1575785770881"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Active connections # 当前活动的连接数</span><br><span class="line">accepts4# 当前的总连接数TCP</span><br><span class="line">handled4# 成功的连接数TCP</span><br><span class="line">requests 61# 总的http请求数</span><br></pre></td></tr></table></figure></li></ul><h2 id="Nginx访问控制"><a href="#Nginx访问控制" class="headerlink" title="Nginx访问控制"></a>Nginx访问控制</h2><ul><li><p>访问控制分类</p><ul><li><p>基于IP的访问控制http_access_modul</p><ul><li>只允许10.0.0.1访问nginx_status,其他都拒绝</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">应用——网站后台</span><br><span class="line"></span><br><span class="line"># 从上往下依次匹配 满足则停止</span><br><span class="line"># 允许配置语法</span><br><span class="line">Syntax:allow address | CIDR | unix: | all;</span><br><span class="line">Default: —</span><br><span class="line">Context: http, server, location, limit_except</span><br><span class="line"># 拒绝配置语法</span><br><span class="line">Syntax:deny address | CIDR | unix: | all;</span><br><span class="line">Default:—</span><br><span class="line">Context: http, server, location, limit_except</span><br></pre></td></tr></table></figure><p><img src="1575791192758.png" alt="1575791192758"></p></li><li><p>基于用户登陆认证http_auth_basic_module</p><ul><li>身份认证后才可以登录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;配置语法</span><br><span class="line">Syntax: auth_basic string | off;</span><br><span class="line">Default:auth_basic off;</span><br><span class="line">Context:http, server, location, limit_except</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;配置语法 用户密码记录配置文件</span><br><span class="line">Syntax: auth_basic_user_file file;</span><br><span class="line">Default:-</span><br><span class="line">Context:http，server, location, limit_except</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;需要安装依赖组件</span><br><span class="line">[root@web01 ~]# yum install httpd-too1s</span><br><span class="line">[root@web01 ~]# htpasswd -b -c &#x2F;etc&#x2F;nginx&#x2F;.auth_conf username 123456</span><br></pre></td></tr></table></figure><p><img src="1575794573505.png" alt="1575794573505"></p></li></ul></li></ul><h2 id="Nginx访问限制"><a href="#Nginx访问限制" class="headerlink" title="Nginx访问限制"></a>Nginx访问限制</h2><ul><li>经常会遇到这种情况， 服务器流量异常，负载过大等等。</li><li>对于大流量恶意的攻击访问，会带来带宽的浪费， 服务器压力，影响业务，往往考虑对同一个IP的连接数，并发数进行限制</li><li>ngx_http_limit_conn_module 模块可以根据定义的key来限制每个键值的连接数，如同一个IP来源的连接数</li></ul><h3 id="limit-conn-module连接频率限制"><a href="#limit-conn-module连接频率限制" class="headerlink" title="limit_conn_module连接频率限制"></a>limit_conn_module连接频率限制</h3><ul><li>同一IP同一时间只允许有一个连接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$binary_remote_addr 变量的长度是固定的4字节</span><br><span class="line">$remote_addr变量的长度是7-15字节</span><br><span class="line"></span><br><span class="line">Syntax: limit_conn_zone key zone&#x3D;name:size;</span><br><span class="line">Default: -</span><br><span class="line">Context: http;</span><br><span class="line"></span><br><span class="line">Syntax:limit_conn zone number;</span><br><span class="line">Default: —</span><br><span class="line">Context: http, server, location</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;压力测试</span><br><span class="line">yum install -y httpd-tools</span><br><span class="line">ab -n 50 -c 20 http:&#x2F;&#x2F;127.0.0.1&#x2F;index.html# 一次50个请求 20个并发</span><br></pre></td></tr></table></figure><p><img src="1575797185873.png" alt="1575797185873"></p><h3 id="limit-req-module请求频率限制"><a href="#limit-req-module请求频率限制" class="headerlink" title="limit_req_module请求频率限制"></a>limit_req_module请求频率限制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Syntax: limit_req_zone key zone&#x3D;name:size rate&#x3D;rate;</span><br><span class="line">Default: -</span><br><span class="line">Context: http</span><br><span class="line"></span><br><span class="line">Syntax:limit_req zone&#x3D;name [burst&#x3D;number] [nodelay | delay&#x3D;number];</span><br><span class="line">Default:—</span><br><span class="line">Context:http, server, location </span><br><span class="line"></span><br><span class="line">Syntax: limit_req_status code;</span><br><span class="line">Default: 503</span><br><span class="line">Context: http, server, location</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义的区域名称为req_zone（zone&#x3D;req_zone） 分配内存大小为10m（如果限制域的存储空间耗尽了 对于后续所有请求 服务器都会返回503） </span><br><span class="line">同一个ip（$binary_remote_addr）平均处理的请求频率不能超过每秒1次（rate&#x3D;1r&#x2F;s）； 如果超过每秒1次但超过的请求数量小于等于3（burst&#x3D;3）时，会延迟请求。</span><br><span class="line">如果超过每秒1次的请求数超过3，则立即返回503（limit_req_status 503）给客户端</span><br></pre></td></tr></table></figure><p><img src="1575799641241.png" alt="1575799641241"></p><h3 id="请求-连接限制对比"><a href="#请求-连接限制对比" class="headerlink" title="请求/连接限制对比"></a>请求/连接限制对比</h3><ul><li>多个请求可以建立在一次的TCP连接之上，那么我们对请求的精度限制，当然比对一个连接的限制会更加的有效，因为同- -时刻只允许一个连接请求进入。但是同一 时刻多个请求可以通过一个 连接进入。所以<strong>请求限制才是比较优的解决方案</strong></li></ul><h1 id="Nginx原理"><a href="#Nginx原理" class="headerlink" title="Nginx原理"></a>Nginx原理</h1><ul><li><p><code>master &amp; worker</code></p><ul><li>master进程主要负责对外接收客户端的请求，并将活儿合理的分配给多个worker，每个worker进程主要负责处理请求。</li></ul><p><img src="1589002067112.png" alt="1589002067112"></p><p><img src="1589002116526.png" alt="1589002116526"></p></li><li><p><code>master-workers</code>的机制的优点</p><ul><li>可以使用 <code>nginx –s reload</code>热部署，利用 nginx进行热部署操作</li><li>每个worker进程是独立的进程，不需要加锁，节省锁带来的开销。</li><li>每个worker进程互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的worker进程。</li></ul></li><li><p>设置多少个 woker 合适</p><ul><li>Nginx同redis类似都采用了io 多路复用机制，每个worker都是一个独立的进程， 但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求，即使是千上万个请求也不在话下。每个worker的线程可以把一个cpu的性能发挥到极致。所以<strong>worker数和服务器的cpu数相等是最为适宜的</strong>。设少了会浪费qpu，设多了会造成cgpu频繁切换上下文带来的损耗。</li></ul><p><img src="1589002735126.png" alt="1589002735126"></p></li><li><p>发送请求，占用了 woker 的几个连接数？</p><ul><li><p>从用户的角度，http 1.1协议下，由于浏览器默认使用两个并发连接,因此计算方法：</p><ul><li>nginx作为http服务器的时候</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_clients &#x3D; worker_processes * worker_connections&#x2F;2</span><br></pre></td></tr></table></figure><ul><li>nginx作为反向代理服务器的时候：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_clients &#x3D; worker_processes * worker_connections&#x2F;4</span><br></pre></td></tr></table></figure></li><li><p>从一般建立连接的角度：客户并发连接为1.</p><ul><li><p>nginx作为http服务器的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_clients &#x3D; worker_processes * worker_connections</span><br></pre></td></tr></table></figure></li><li><p>nginx作为反向代理服务器的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_clients &#x3D; worker_processes * worker_connections&#x2F;2</span><br></pre></td></tr></table></figure><blockquote><p>nginx做反向代理时，和客户端之间保持一个连接，和后端服务器保持一个连接。  </p></blockquote></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Nginx简介 配置 应用场景
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Nginx" scheme="http://goldcarpenter.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://goldcarpenter.github.io/2020/03/26/Redis_Part1/"/>
    <id>http://goldcarpenter.github.io/2020/03/26/Redis_Part1/</id>
    <published>2020-03-26T00:56:17.000Z</published>
    <updated>2020-06-17T07:20:53.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-架构"><a href="#0-架构" class="headerlink" title="0.架构"></a>0.架构</h1><ul><li>Redis基础<ul><li>Redis 入门</li><li>数据类型</li><li>通用命令</li><li>Jedis</li></ul></li><li>Redis高级<ul><li>持久化</li><li>redis.conf</li><li>事务</li><li>集群</li></ul></li><li>Redis应用<ul><li>企业级解决方案</li></ul></li></ul><h1 id="1-Redis"><a href="#1-Redis" class="headerlink" title="1.Redis"></a>1.Redis</h1><h2 id="1-1NoSQL介绍"><a href="#1-1NoSQL介绍" class="headerlink" title="1.1NoSQL介绍"></a>1.1NoSQL介绍</h2><ul><li>网站崩溃现象来源：①海量用户②高并发</li><li>罪魁祸首——关系型数据库<ul><li>性能瓶颈：磁盘IO性能低下</li><li>扩展瓶颈：数据关系复杂,扩展性差,不便于大规模集群</li></ul></li><li>解决思路<ul><li>降低磁盘IO次数,越低越好——内存存储</li><li>去除数据间关系，越简单越好——不存储关系，仅存储数据</li></ul></li><li><strong><code>NoSQL</code>：即<code>Not-OnlySQL</code>(泛指非关系型的数据库）</strong></li><li><strong>定位：作为关系型数据库的补充</strong></li><li>作用：应对基于<strong>海量用户和海量数据</strong>前提下的数据处理问题。</li><li>特征：<ul><li>可扩容，可伸缩</li><li>大数据量下高性能</li><li>灵活的数据模型</li><li>高可用</li></ul></li><li>常见Nosql数据库：<ul><li>Redis</li><li>memcache</li><li>HBase</li><li>MongoDB</li></ul></li><li>电商场景解决方案<img src="1580133771032.png" alt="1580133771032"></li></ul><p><img src="1580133718517.png" alt="1580133718517"></p><h2 id="1-2Redis简介"><a href="#1-2Redis简介" class="headerlink" title="1.2Redis简介"></a>1.2Redis简介</h2><ul><li><p>Redis (Remote Dictionary Server)是一个<strong>开源</strong>的高性能<strong>键值对(key-value) 数据库</strong></p></li><li><p>特征</p><ul><li>数据间没有必然的关联关系</li><li>内部<strong>采用单线程机制</strong>进行工作</li><li>高性能。官方提供测试数据, 50个并发执行100000个请求读的速度是110000次/s，写的速度是81000次/s。</li><li>多数据类型支持<ul><li>字符串类型——string</li><li>列表类型——list</li><li>散列类型——hash</li><li>集合类型——set</li><li>有序集合类型——sorted_set</li></ul></li><li>持久化支持。可以进行数据灾难恢复（不是主要功能）</li></ul></li><li><p>应用</p><ul><li>为<strong>热点数据加速查询</strong>(主要场景)， 如热点商品、热点新闻、热点资讯、推广类等高访问量信息等</li><li>任务队列，如秒杀、抢购、购票排队等</li><li>即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息(聊天室、网站)、设备信号等</li><li>时效性信息控制，如验证码控制、投票控制等</li><li>分布式数据共享，如分布式集群架构中的session分离</li><li>消息队列</li><li>分布式锁</li></ul></li></ul><h2 id="1-3Redis下载-安装"><a href="#1-3Redis下载-安装" class="headerlink" title="1.3Redis下载/安装"></a>1.3Redis下载/安装</h2><ul><li><p>Windows：<code>Redis-x64-3.2.100.zip</code></p></li><li><p>绿色版，解压即可</p></li><li><p>解压文件</p><ul><li>核心文件<ul><li><code>redis-server.exe</code>——服务器启动命令</li><li><code>redis-cli.exe</code>——命令行客户端</li><li><code>redis.windows.conf</code>——redis核心配置文件</li><li><code>redis-benchmarkexe</code>——性能测试工具</li><li><code>redis-check- aof.exe</code>——AOF文件修复工具</li><li><code>redis-check-dump.exe</code>——RDB文件检查工具(快照持久化文件)</li></ul></li></ul><p><img src="1580178215132.png" alt="1580178215132"></p></li><li><p>Redis启动</p><p><img src="1580178483039.png" alt="1580178483039"></p></li></ul><h2 id="1-4Redis的基本操作"><a href="#1-4Redis的基本操作" class="headerlink" title="1.4Redis的基本操作"></a>1.4Redis的基本操作</h2><h3 id="1-4-1信息添加"><a href="#1-4-1信息添加" class="headerlink" title="1.4.1信息添加"></a>1.4.1信息添加</h3><ul><li><p>功能:设置key，value数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-4-2信息添加"><a href="#1-4-2信息添加" class="headerlink" title="1.4.2信息添加"></a>1.4.2信息添加</h3><ul><li><p>功能:根据key查询对应的value,如果不存在,返回空(nil)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-4-3清除屏幕信息"><a href="#1-4-3清除屏幕信息" class="headerlink" title="1.4.3清除屏幕信息"></a>1.4.3清除屏幕信息</h3><ul><li><p>功能:清除屏幕中的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-4-4帮助信息"><a href="#1-4-4帮助信息" class="headerlink" title="1.4.4帮助信息"></a>1.4.4帮助信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help [CMD]</span><br></pre></td></tr></table></figure><p><img src="1580179481797.png" alt="1580179481797"></p><h3 id="1-4-5退出客户端命令行模式"><a href="#1-4-5退出客户端命令行模式" class="headerlink" title="1.4.5退出客户端命令行模式"></a>1.4.5退出客户端命令行模式</h3><ul><li><p>功能:退出客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br><span class="line">exit </span><br><span class="line">&lt;ESC&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-5Redis数据类型"><a href="#1-5Redis数据类型" class="headerlink" title="1.5Redis数据类型"></a>1.5Redis数据类型</h2><ul><li><code>Redis</code>自身是一个Map，其中所有的数据都是采用<code>key：value</code>的形式存储</li><li><strong>数据类型</strong>指的是<strong>value的类型【存储的数据类型】</strong>，<strong>key部分永远都是字符串</strong></li></ul><p><img src="1580180268005.png" alt="1580180268005"></p><ul><li>Redis数据类型(5种常用）</li></ul><table><thead><tr><th>Redis</th><th>类比Java</th></tr></thead><tbody><tr><td>string</td><td>String</td></tr><tr><td>hash</td><td>HashMap</td></tr><tr><td>list</td><td>LinkedList</td></tr><tr><td>set</td><td>HashSet</td></tr><tr><td>sorted_set</td><td>TreeSet</td></tr></tbody></table><h3 id="1-5-1String类型"><a href="#1-5-1String类型" class="headerlink" title="1.5.1String类型"></a>1.5.1String类型</h3><ul><li>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型</li><li>存储数据的格式：一个存储空间保存一个数据</li><li>存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用</li></ul><p><img src="1580205552862.png" alt="1580205552862"></p><ul><li><p>添加/修改数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br></pre></td></tr></table></figure></li><li><p>获取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br><span class="line"># (integer) 0 删除失败</span><br><span class="line"># (integer) 1 删除成功</span><br></pre></td></tr></table></figure></li><li><p>添加/修改多个数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key1 value1 key2 value2 ..</span><br></pre></td></tr></table></figure></li><li><p>获取多个数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key1 key2 ..</span><br></pre></td></tr></table></figure><p><img src="1588406142155.png" alt="1588406142155"></p></li><li><p>获取数据字符个数（字符串长度）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strlen key</span><br><span class="line"># (integer) [N长度]</span><br></pre></td></tr></table></figure><p><img src="1588406184745.png" alt="1588406184745"></p></li><li><p>追加信息到原始信息后部（如果原始信息存在则追加，否则新建）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append key value</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li><p>数据操作不成功的反馈与数据正常操作之间的差异<br>①表示运行结果是否成功</p><ul><li>(integer)0 →false 失败</li><li>(integer)1 →true成功</li></ul><p>②表示运行结果值</p><ul><li>(integer)3 →3    3个</li><li>(integer)1 →1    1个</li></ul></li><li><p>数据未获取到——(nil)等同于null</p></li><li><p>数据最大存储量——512MB</p></li></ul></li></ul><h4 id="应用场景1"><a href="#应用场景1" class="headerlink" title="应用场景1"></a>应用场景1</h4><ul><li><p>大型企业级应用中，分表操作是基本操作，使用多张表存储同类型数据，但是对应的主键id必须保证统一性, 不能重复。MySQL数据库并不具有类似的机制，那么如何解决?</p><p><img src="1588408646800.png" alt="1588408646800"></p><ul><li><p><strong>答：Redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性。此方案适用于所有数据库，且支持数据库集群</strong></p><ul><li><p>设置数值数据增加指定范围的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">incr key</span><br><span class="line">incrby key increment[increment可以为负]</span><br><span class="line">incrbyfloat key increment</span><br></pre></td></tr></table></figure></li><li><p>设置数值数据减少指定范围的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decr key</span><br><span class="line">decrby key increment</span><br></pre></td></tr></table></figure><blockquote><ul><li>String在Redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算</li><li>redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。</li><li>注意:按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis数值上限范围，将报错。【9223372036854775807（Java中Long型数据最大值，Long.MAX_VALUE）】</li></ul></blockquote></li></ul></li></ul></li></ul><h4 id="应用场景2"><a href="#应用场景2" class="headerlink" title="应用场景2"></a>应用场景2</h4><ul><li><p>微信每4小时只能投1票/商品热门期维持3天自动取消热门/自动控制热点新闻的时效性</p><ul><li><p><strong>答：Redis控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作</strong></p></li><li><p>设置数据具有指定的生命周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setex key seconds value</span><br><span class="line">psetex key milliseconds value</span><br></pre></td></tr></table></figure><blockquote><p> 超时则抹去Id，存在则禁止重复投票</p></blockquote></li></ul><p><img src="1588409243264.png" alt="1588409243264"></p></li></ul><h4 id="应用场景3"><a href="#应用场景3" class="headerlink" title="应用场景3"></a>应用场景3</h4><ul><li><p>高频访问信息显示控制，例如新浪微博大V主页显示粉丝数与微博数量</p><ul><li><p>在redis中为大V用户设定用户信息，以用户主键和属性值作为key，后台设定定时刷新策略即可</p><ul><li>数据库中的热点数据命名惯例【大部分数据还是从数据库中来】</li></ul><p><img src="1580214221673.png" alt="1580214221673"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set user:id:3506728370:fans  12210947</span><br><span class="line">set user:id:3506728370:blogs 6164</span><br><span class="line">set user:id:3506728370:focus 83</span><br></pre></td></tr></table></figure></li><li><p>在redis中以json格式存储大V用户信息，定时刷新(也可以使用hash类型)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set user:id:3506728370 &#123;id:3506728370, fans:12210862, blogs:6164, focus:83&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>答：redis应用于各种结构型和非结构型高热度数据访问加速</strong></p></li></ul><h3 id="1-5-2Hash类型"><a href="#1-5-2Hash类型" class="headerlink" title="1.5.2Hash类型"></a>1.5.2Hash类型</h3><ul><li><p><strong>对象类数据用String类型以json格式存储，如果具有较频繁的更新需求操作会显得笨重</strong></p><p><img src="1588411271044.png" alt="1588411271044"></p></li><li><p>新的存储需求：对一系列存储的数据进行编组，方便管理，<strong>典型应用是存储对象信息</strong></p></li><li><p>需要的存储结构: <strong>一个存储空间保存多个键值对数据</strong>【感觉就像是Map套Map】</p><p><img src="1580214384748.png" alt="1580214384748"></p></li><li><p>hash类型：底层使用<strong>哈希表</strong>结构实现数据存储</p><p> <img src="1580214490752.png" alt="1580214490752"></p><blockquote><ul><li>如果field数量较少，存储结构优化为类数组结构</li><li>如果field数量较多，存储结构使用HashMap结构</li></ul></blockquote></li><li><p>添加/修改数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hset key field value</span><br></pre></td></tr></table></figure></li><li><p>获取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hget key field</span><br><span class="line">hgetall key</span><br><span class="line">hkeys key[获取的到的field字段]</span><br><span class="line">hvals key[获取的到的value字段]</span><br></pre></td></tr></table></figure><p><img src="1588411695151.png" alt="1588411695151"></p></li><li><p>删除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdel key field1 [field2]</span><br></pre></td></tr></table></figure></li><li><p>添加/修改多个数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset key field1 value1 field2 val</span><br></pre></td></tr></table></figure></li><li><p>获取多个数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmget key field1 field2</span><br></pre></td></tr></table></figure></li><li><p>获取哈希表中字段的数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure></li><li><p>获取哈希表中是否存在指定的字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexists key field</span><br></pre></td></tr></table></figure><p><img src="1588411806322.png" alt="1588411806322"></p></li><li><p>设置指定字段的数值数据增加指定范围的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hincrby key field increment</span><br><span class="line">hincrbyfloat key field increment</span><br></pre></td></tr></table></figure></li><li><p>不存在则添加，否则不变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hsetnx key field value</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为(nil)</li><li>每个hash可以存储23^2-1个键值对</li><li><strong>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性</strong>。但hash设计初衷不是为了存储大量对象而设计的，切记不可滥用，不可以将hash作为对象列表使用</li><li>hgetall操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈</li></ul></li></ul><h4 id="应用场景4"><a href="#应用场景4" class="headerlink" title="应用场景4"></a>应用场景4</h4><ul><li><p>电商网站购物车设计与实现</p><p><img src="1580216111249.png" alt="1580216111249"></p><ul><li><p><strong>问题：</strong>当前仅仅是将数据存储到了redis中，并没有起到加速的作用，商品信息还需要根据商品id二次查询商品信息的数据库</p></li><li><p><strong>方案：</strong>每条购物车中的商品记录保存成两条field</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">field1专用于保存购买数量</span><br><span class="line">命名格式:商品id:nums</span><br><span class="line">保存数据:数值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">field2专用于保存购物车中显示的信息，包含文字描述，图片地址，所属商家信息等</span><br><span class="line">命名格式:商品id:info</span><br><span class="line">保存数据: json</span><br></pre></td></tr></table></figure></li><li><p><strong>问题：</strong>商品id:info将因为用户购买相同商品，而重复大量的商品信息</p></li><li><p><strong>方案：</strong>将商品信息单独做成hash</p></li><li><p><strong>问题：</strong>我们一开始不能将所有商品信息都导入Redis，但是用一个加一个则与之前没有区别</p></li><li><p>方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hsetnx key field value</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>答：应用于购物车数据存储设计</strong></p></li></ul><h4 id="应用场景5"><a href="#应用场景5" class="headerlink" title="应用场景5"></a>应用场景5</h4><ul><li><p>双11活动日,销售手机充值卡的商家对移动、联通、电信的30元、50元、 100元商品推出抢购活动，每种商<br>品抢购上限1000张</p><p><img src="1588413458917.png" alt="1588413458917"></p></li><li><p><strong>答：redis应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计</strong></p></li></ul><h4 id="补充：String存储对象（Json）-VS-Hash存储对象"><a href="#补充：String存储对象（Json）-VS-Hash存储对象" class="headerlink" title="补充：String存储对象（Json） VS Hash存储对象"></a>补充：String存储对象（Json） VS Hash存储对象</h4><ul><li><p>String存在对象讲究整体性，以读为主</p></li><li><p>Hash存储对象讲究分散性，以写为主</p></li></ul><h3 id="1-5-3List类型"><a href="#1-5-3List类型" class="headerlink" title="1.5.3List类型"></a>1.5.3List类型</h3><ul><li><p>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</p></li><li><p>需要的存储结构：一个存储空间保存够个数据，且通过数据可以体现进入顺序</p></li><li><p>list类型：保存多个数据，底层使用<strong>双向链表存储结构</strong>实现</p><p><img src="1580217854615.png" alt="1580217854615"></p><p><img src="1588414055584.png" alt="1588414055584"></p></li><li><p>添加/修改数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpush key value1 [value2] ....</span><br><span class="line">rpush key value1 [value2] ....</span><br></pre></td></tr></table></figure></li><li><p>获取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lrange key start stop</span><br><span class="line">lindex key index</span><br><span class="line">llen key</span><br></pre></td></tr></table></figure><p><img src="1588413931788.png" alt="1588413931788"></p></li><li><p>获取并移除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpop key</span><br><span class="line">rpop key</span><br></pre></td></tr></table></figure></li><li><p>规定时间内获取并移除数据【规定时间内阻塞 队列中有就移除 没有就算了】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blpop key1 [key2] timeout[block]</span><br><span class="line">brpop key1 [key2] timeout</span><br></pre></td></tr></table></figure></li><li><p>移除指定数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrem key count value</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>list中保存的数据都是string类型的，数据总容量是有限的，最多23^2- 1个元素(4294967295)</li><li>list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作</li><li>获取全部数据操作结束索引设置为-1</li><li>list可以对数据进行分页操作，通常第一页的信息来自于list, 第2页及更多的信息通过数据库的形式加载</li></ul></li></ul><h4 id="应用场景6"><a href="#应用场景6" class="headerlink" title="应用场景6"></a>应用场景6</h4><ul><li>微信朋友圈点赞，要求按照点赞顺序显示点赞好友信息如果取消点赞，移除对应好友信息</li><li><strong>答：redis应用于具有操作先后顺序的数据控制</strong></li></ul><h4 id="应用场景7"><a href="#应用场景7" class="headerlink" title="应用场景7"></a>应用场景7</h4><ul><li>twitter、新浪微博、腾讯微博中个人用户的关注列表需要按照用户的关注顺序进行展示,粉丝列表需要将最近关注的粉丝列在前面</li><li>新闻、资讯类网站如何将最新的新闻或资讯按照发生的时间顺序展示</li><li>企业运营过程中,系统将产生出大量的运营数据,如何保障多台服务器操作日志的统一顺序输出</li><li><strong>答：redis应用于依赖list的数据具有顺序的特征对信息进行管理，使用队列模型解决多路信息汇总合并的问题，使用栈模型解决最新消息的问题</strong></li></ul><h3 id="1-5-5Set类型"><a href="#1-5-5Set类型" class="headerlink" title="1.5.5Set类型"></a>1.5.5Set类型</h3><ul><li>新的存储需求：存储大量的数据，<strong>在查询方面提供更高的效率</strong></li><li>需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</li><li>set类型：与hash存储结构完全相同，仅存储键，不存储值(nil) ，且值不允许重复的</li></ul><p><img src="1580219557499.png" alt="1580219557499"></p><ul><li><p>添加数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd key member1 [member2]</span><br></pre></td></tr></table></figure></li><li><p>获取全部数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem key member1 [member2]</span><br></pre></td></tr></table></figure></li><li><p>获取集合数据总量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scard key</span><br></pre></td></tr></table></figure></li><li><p>判断集合中是否包含指定数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sismember key member</span><br></pre></td></tr></table></figure><p><img src="1588432636898.png" alt="1588432636898"></p></li><li><p>随机获取集合中指定数量的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srandmember key [count]</span><br></pre></td></tr></table></figure></li><li><p>随机获取集合中的某个数据并将该数据移出集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spop key</span><br></pre></td></tr></table></figure></li><li><p>求两个集合的交、并、差集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinter key1 [key2]</span><br><span class="line">sunion key1 [key2]</span><br><span class="line">sdiff key1 [key2]</span><br></pre></td></tr></table></figure></li><li><p>求两个集合的交、并、差集并存储到指定集合中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinterstore destination key1 [key2]</span><br><span class="line">sunionstore destination key1 [key2]</span><br><span class="line">sdiffstore destination key1 [key2]</span><br></pre></td></tr></table></figure></li><li><p>将指定数据从原始集合中移动到目标集合中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smove source destination member</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>set类型不允许数据重复，如果添加的数据在set中已经存在，将只保留一份</li><li>set虽然与hash的存储结构相同，但是无法启用hash中存储值的空间</li></ul></li></ul><h4 id="应用场景8"><a href="#应用场景8" class="headerlink" title="应用场景8"></a>应用场景8</h4><ul><li>后期为了增加用户的活跃度、兴趣点，必须让用户 对其他信息类别逐渐产生兴趣，增加客户留存度，实现随机推送</li><li><strong>答：redis应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等</strong></li></ul><h4 id="应用场景9"><a href="#应用场景9" class="headerlink" title="应用场景9"></a>应用场景9</h4><ul><li><strong>答：redis应用于同类信息的关联搜索，二度关联搜索，深度关联搜索</strong><ul><li>显示共同关注(一度)</li><li>显示共同好友(一度)</li><li>由用户A出发，获取到好友用户B的好友信息列表(一度)</li><li>由用户A出发，获取到好友用户B的购物清单列表(二度)</li><li>由用户A出发，获取到好友用户B的游戏充值列表(二度)</li></ul></li></ul><h4 id="应用场景10"><a href="#应用场景10" class="headerlink" title="应用场景10"></a>应用场景10</h4><ul><li>PV:网站被访问次数，可通过刷新页面提高访问量</li><li>UV:网站被不同用户访问的次数,可通过cookie统计访问量, 相同用户切换IP地址，UV不变</li><li>IP:网站被不同IP地址访问的总次数，可通过IP地址统计访问量，相同IP不同用户访问，IP不变</li><li>建立string类型数据，利用incr统计日访问量(PV)</li><li>建立set模型，记录不同cookie数量(UV)</li><li>建立set模型，记录不同IP数量(IP)</li><li><strong>答：redis应用于同类型数据的快速去重</strong></li></ul><h3 id="1-5-6Sorted-set类型"><a href="#1-5-6Sorted-set类型" class="headerlink" title="1.5.6Sorted_set类型"></a>1.5.6Sorted_set类型</h3><ul><li><p>新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式</p></li><li><p>需要的存储结构：新的存储模型，<strong>可以保存可排序的数据</strong></p></li><li><p>sorted_set类型：在set的存储结构基础上添加可排序字段</p><p><img src="1580223454856.png" alt="1580223454856"></p></li><li><p>添加数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd key score1 memberl [score2 member2 ]</span><br></pre></td></tr></table></figure></li><li><p>获取全部数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrange key start stop [WITHSCORES]</span><br><span class="line">zrevrange key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><p><img src="1588470818167.png" alt="1588470818167"></p></li><li><p>删除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key member [member ...]</span><br></pre></td></tr></table></figure></li><li><p>按条件获取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore key min max [WITHSCORES] [LIMIT OFFSET COUNT]</span><br><span class="line">zrevrangebyscore key max min [WITHSCORES]</span><br></pre></td></tr></table></figure></li><li><p>条件删除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyrank key start stop</span><br><span class="line">zremrangebyscore key min max</span><br></pre></td></tr></table></figure></li><li><p>注意:</p><ul><li>min与max用于限定搜索查询的条件</li><li>start与stop用于限定查询范围，作用于索引，表示开始和结束索引</li><li>offset与count用于限定查询范围，作用于查询结果，表示开始位置和数据总量</li></ul></li><li><p>获取集合数据总量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zcard key</span><br><span class="line">zcount key min max</span><br></pre></td></tr></table></figure></li><li><p>集合交、并操作【默认合并相加】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zinterstore destination numkeys key [key ...]</span><br><span class="line">zunionstore destination numkeys key [key . ..]</span><br></pre></td></tr></table></figure></li><li><p>获取数据对应的索引(排名)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrank key member</span><br><span class="line">zrevrank key member</span><br></pre></td></tr></table></figure></li><li><p>score值获取与修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zscore key member</span><br><span class="line">zincrby key increment member</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li><li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，使用时候要慎重</li><li>sorted_set底层存储还是基于set结构的，因此<strong>数据不能重复</strong>，如果重复添加相同的数据，score值将被反复覆盖，保留最后一次修改的结果</li></ul></li></ul><h4 id="业务场景11"><a href="#业务场景11" class="headerlink" title="业务场景11"></a>业务场景11</h4><ul><li>票选广东十大杰出青年，各类综艺选秀海选投票</li><li>各类资源网站TOP10(电影，歌曲，文档，电商，游戏等)</li><li>聊天室活跃度统计</li><li>游戏好友亲密度</li><li><strong>答：redis应用于计数器组合排序功能对应的排名</strong></li></ul><h4 id="业务场景12"><a href="#业务场景12" class="headerlink" title="业务场景12"></a>业务场景12</h4><ul><li><p>网站会定期开启投票、讨论，限时进行，逾期作废。如何有效管理此类过期信息。</p></li><li><p><strong>答：redis 应用于定时任务执行顺序管理或任务过期管理</strong></p></li></ul><h2 id="1-6Redis通用命令"><a href="#1-6Redis通用命令" class="headerlink" title="1.6Redis通用命令"></a>1.6Redis通用命令</h2><h3 id="1-6-1Key通用命令"><a href="#1-6-1Key通用命令" class="headerlink" title="1.6.1Key通用命令"></a>1.6.1Key通用命令</h3><ul><li><p><strong>key是一个字符串</strong>， 通过key获取redis中保存的数据</p></li><li><p>获取key的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure></li><li><p>获取key是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure></li><li><p>删除指定key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure></li><li><p>为指定key设置有效期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expire key seconds</span><br><span class="line">pexpire key milliseconds</span><br><span class="line">expireat key timestamp [时间戳的形式 time命令获取]</span><br><span class="line">pexpireat key milliseconds-timestamp</span><br></pre></td></tr></table></figure></li><li><p>获取key的有效时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br><span class="line"># (integer) -2 过期</span><br><span class="line"># (integer) -1 没设置有效期</span><br><span class="line"># (integer) N  有效期</span><br><span class="line">pttl key</span><br></pre></td></tr></table></figure></li><li><p>切换key从时效性转换为永久性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">persist key</span><br><span class="line"># (integer) 0  失败</span><br><span class="line"># (integer) 1  成功</span><br></pre></td></tr></table></figure></li><li><p>查询key</p><blockquote><p>* 匹配任意数量的任意符号<br>? 配合一个任意符号<br>[] 匹配个指定符</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys [pattern]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">keys * 查询所有</span><br><span class="line">keys it *查询所有以it开头</span><br><span class="line">keys *heima查询所有以he ima结尾</span><br><span class="line">keys ??heima查 询所有前面两个字符任意，后面以he ima结尾</span><br><span class="line">keys user:?查询所有以user:开头，最后一个字符任意</span><br><span class="line">keys u[st]er:1 查询所有以u开头，以er:1结尾， 中间包含一个字母，s或t</span><br></pre></td></tr></table></figure></li><li><p>为key改名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rename key newkey[可能覆盖同名key]</span><br><span class="line">renamenx key newkey[不会覆盖同名key]</span><br></pre></td></tr></table></figure></li><li><p>对所有key排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort key[只排序不保存]</span><br></pre></td></tr></table></figure></li><li><p>其他key通用操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help @generic</span><br></pre></td></tr></table></figure></li><li><p>配置文件设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config set requirepass &lt;password&gt; </span><br><span class="line">config get requirepass</span><br></pre></td></tr></table></figure></li><li><p>客户端发送命令设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass &lt;password&gt;</span><br></pre></td></tr></table></figure></li><li><p>启动客户端设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli –a &lt;password&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-6-2数据库通用命令"><a href="#1-6-2数据库通用命令" class="headerlink" title="1.6.2数据库通用命令"></a>1.6.2数据库通用命令</h3><ul><li><p>redis为<strong>每个服务提供有16个数据库，编号从0到15</strong>【默认使用select 0】</p></li><li><p>每个数据库之间的数据相互独立</p><p><img src="1580294591592.png" alt="1580294591592"></p><blockquote><p>没有大小 共有同一空间</p></blockquote></li><li><p>测试服务器是否连通</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping</span><br></pre></td></tr></table></figure><p><img src="1588477361997.png" alt="1588477361997"></p></li><li><p>切换数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select [index]</span><br></pre></td></tr></table></figure><p><img src="1588477302443.png" alt="1588477302443"></p></li><li><p>数据移动</p><ul><li>目标数据库必须不存在才能成功</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move key dbindex</span><br></pre></td></tr></table></figure></li><li><p>数据清除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbsize[查看key数量]</span><br><span class="line">flushdb[删除本库]</span><br><span class="line">flushall[删除所有0-15库]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>自动重写</p><ul><li><p>自动重写触发条件设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size [size] </span><br><span class="line">auto-aof-rewrite-percentage [percentage]</span><br></pre></td></tr></table></figure></li><li><p>自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aof_current_size</span><br><span class="line">aof_base_size</span><br></pre></td></tr></table></figure></li><li><p>自动重写触发条件</p><p><img src="1588585553364.png" alt="1588585553364"></p></li></ul></li></ul><ul><li><p>s的高可用，同时实现数据<strong>冗余备份</strong>。</p><ul><li>提供数据方：master 主服务器，主节点，主库，主客户端</li><li>接收数据方：slave 从服务器，从节点，从库，从客户端</li><li>需要解决的问题： 数据同步</li><li>核心工作： master的数据复制到slave中</li></ul><p><a href="1588729303276.png">1588729303276</a></p></li><li><p>主从复制</p><ul><li>主从复制即将master中的数据即时、有效的复制到slave中</li><li>特征：一个master可以拥有多个slave，一个slave只对应一个master </li><li>职责：<ul><li>master:①写数据 ②执行写操作时，将出现变化的数据自动同步到slave ③读数据（可忽略）</li><li>slave:①读数据 ②写数据（禁止）</li></ul></li><li>作用<ul><li>读写分离：master写、slave读，提高服务器的读写负载能力</li><li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li><li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li><li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li><li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Redis架构 简介 Redis数据类型
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Redis" scheme="http://goldcarpenter.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>JDK8新特性</title>
    <link href="http://goldcarpenter.github.io/2020/03/10/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part3/"/>
    <id>http://goldcarpenter.github.io/2020/03/10/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part3/</id>
    <published>2020-03-09T16:00:00.000Z</published>
    <updated>2020-06-17T08:12:05.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><ul><li>在Java 8中，得益于Lambda所带来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。</li></ul><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><h4 id="传统集合循环遍历的弊端"><a href="#传统集合循环遍历的弊端" class="headerlink" title="传统集合循环遍历的弊端"></a>传统集合循环遍历的弊端</h4><ul><li><p>几乎所有的集合（如 Collection 接口或 Map 接口等）都支持直接或间接的遍历操作</p></li><li><p><code>Java 8</code>循环遍历的弊端的<code>Lambda</code>让我们可以更加专注于<strong>做什么</strong>（What），而不是<strong>怎么做</strong>（How）</p><ul><li>for循环的语法就是<strong>“怎么做”</strong> </li><li>for循环的循环体才是<strong>“做什么”</strong></li></ul></li><li><p>为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，<strong>而并不是从第一个到最后一个顺次处理的循环</strong>。前者是目的，后者是方式。</p></li></ul><p>在Java 8之前的做法可能为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"张无忌"</span>);</span><br><span class="line">list.add(<span class="string">"周芷若"</span>);</span><br><span class="line">List&lt;String&gt; zhangList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line"><span class="keyword">for</span> (String name : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.startsWith(<span class="string">"张"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        zhangList.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; shortList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line"><span class="keyword">for</span> (String name : zhangList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.length() == <span class="number">3</span>) &#123;</span><br><span class="line">        shortList.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line"><span class="keyword">for</span> (String name : shortList) &#123; </span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。循环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使用另一个循环从头开始。</p><h4 id="Stream的更优写法"><a href="#Stream的更优写法" class="headerlink" title="Stream的更优写法"></a>Stream的更优写法</h4><p>下面来看一下借助Java 8的Stream API，什么才叫优雅：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> list.add(<span class="string">"张无忌"</span>);</span><br><span class="line"> list.add(<span class="string">"周芷若"</span>);</span><br><span class="line"><span class="comment">//       list.stream().filter(new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//           @Override</span></span><br><span class="line"><span class="comment">//           public boolean test(String s) &#123;</span></span><br><span class="line"><span class="comment">//               return s.startsWith("张");</span></span><br><span class="line"><span class="comment">//           &#125;</span></span><br><span class="line"><span class="comment">//       &#125;)</span></span><br><span class="line"> list.stream().filter(name-&gt;name.startsWith(<span class="string">"张"</span>))</span><br><span class="line">               .filter(name-&gt;name.length()==<span class="number">3</span>)</span><br><span class="line">               .forEach(System.out::println);       <span class="comment">//方法引用</span></span><br></pre></td></tr></table></figure><p>直接阅读代码的字面意思即可<strong>完美展示</strong>无关逻辑方式的<strong>语义</strong>：<strong>获取流、过滤姓张、过滤长度为3、逐一打印</strong>。</p><p>代码中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。</p><h3 id="1-2-流式思想概述"><a href="#1-2-流式思想概述" class="headerlink" title="1.2 流式思想概述"></a>1.2 流式思想概述</h3><ul><li><p>注意：<strong>暂时忘记对传统IO流的固有印象</strong>！ 整体来看，流式思想类似于工厂车间的“生产流水线”。</p></li><li><p>当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先<strong>拼好一个“模型”步骤方案</strong>，然后再按照方案去执行它。</p><p><img src="1580898920476.png" alt="1580898920476"></p><p>这张图中展示了过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种“函数模型”。图中的<strong>每一个方框都是一个“流”</strong>，调用指定的方法，可以<strong>从一个流模型转换为另一个流模型</strong>。而最右侧的数字 3是最终结果。</p></li><li><p>这里的<code>filter</code>、<code>map</code> 、<code>skip</code>都是在对函数模型进行操作，集合元素并没有真正被处理。<strong>只有当终结方法 count 执行</strong>的时候，<strong>整个模型才会按照指定策略执行操作</strong>。而这得<strong>益于Lambda的延迟执行特性。</strong></p></li></ul><blockquote><p>备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。</p></blockquote><p>Stream（流）是一个来自数据源的元素队列</p><ul><li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li><li><strong>数据源</strong>/流的来源。 可以是<strong>集合，数组</strong>等。</li></ul><p>和以前的<code>Collection</code>操作不同， Stream操作还有两个基础的特征：</p><ul><li><code>Pipelining</code>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路(short-circuiting)。 </li><li>内部迭代： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。</li></ul><p>当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结果</p><h3 id="1-3-获取流"><a href="#1-3-获取流" class="headerlink" title="1.3 获取流"></a>1.3 获取流</h3><ul><li><p><code>java.util.stream.Stream&lt;T&gt;</code>是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。）</p></li><li><p>获取一个流非常简单，有以下几种常用的方式：</p><ul><li><p><strong>所有的<code>Collection</code>集合都可以通过<code>stream</code>默认方法获取流；</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default Stream&lt;E&gt; stream()</span><br></pre></td></tr></table></figure></li><li><p><strong><code>Stream</code>接口的静态方法<code>of</code>可以获取数组对应的流。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; Stream&lt;T&gt; of(T... values) 参数是一个可变参数,那么我们就可以传递一个数组</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="根据Collection获取流"><a href="#根据Collection获取流" class="headerlink" title="根据Collection获取流"></a>根据Collection获取流</h4><ul><li>首先，<code>java.util.Collection</code>接口中加入了<code>default</code>方法 stream 用来获取流，所以其所有实现类均可获取流。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;把集合转换为Stream流</span><br><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream1 &#x3D; list.stream();</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream2 &#x3D; set.stream();</span><br></pre></td></tr></table></figure><h4 id="根据Map获取流"><a href="#根据Map获取流" class="headerlink" title="根据Map获取流"></a>根据Map获取流</h4><p>java.util.Map 接口不是 Collection 的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F;获取键,存储到一个Set集合中</span><br><span class="line">Set&lt;String&gt; keySet &#x3D; map.keySet();</span><br><span class="line">Stream&lt;String&gt; stream3 &#x3D; keySet.stream();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取值,存储到一个Collection集合中</span><br><span class="line">Collection&lt;String&gt; values &#x3D; map.values();</span><br><span class="line">Stream&lt;String&gt; stream4 &#x3D; values.stream();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取键值对(键与值的映射关系 entrySet)</span><br><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entries &#x3D; map.entrySet();</span><br><span class="line">Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream5 &#x3D; entries.stream();</span><br></pre></td></tr></table></figure><h4 id="根据数组获取流"><a href="#根据数组获取流" class="headerlink" title="根据数组获取流"></a>根据数组获取流</h4><ul><li>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法 of ，使用很简单：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;把数组转换为Stream流</span><br><span class="line">Stream&lt;Integer&gt; stream6 &#x3D; Stream.of(1, 2, 3, 4, 5);</span><br><span class="line">&#x2F;&#x2F;可变参数可以传递数组</span><br><span class="line">Integer[] arr &#x3D; &#123;1,2,3,4,5&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream7 &#x3D; Stream.of(arr);</span><br><span class="line">String[] arr2 &#x3D; &#123;&quot;a&quot;,&quot;bb&quot;,&quot;ccc&quot;&#125;;</span><br><span class="line">Stream&lt;String&gt; stream8 &#x3D; Stream.of(arr2);</span><br></pre></td></tr></table></figure><blockquote><p>备注： of 方法的参数其实是一个可变参数，所以支持数组。</p></blockquote><h3 id="1-4-常用方法"><a href="#1-4-常用方法" class="headerlink" title="1.4 常用方法"></a>1.4 常用方法</h3><p><img src="1580899952784.png" alt="1580899952784"></p><ul><li><p>流模型的操作很丰富，这里介绍一些常用的API。</p></li><li><p>这些方法可以被分成两种： </p><ul><li>延迟方法：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方 法均为延迟方法。） </li><li>终结方法：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调 用。本小节中，终结方法包括 count 和 forEach 方法。</li></ul></li></ul><h4 id="逐一处理：forEach"><a href="#逐一处理：forEach" class="headerlink" title="逐一处理：forEach"></a>逐一处理：forEach</h4><p>虽然方法名字叫 forEach ，但是与for循环中的“for-each”昵称不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void forEach(Consumer&lt;? super T&gt; action);</span><br></pre></td></tr></table></figure><p>该方法接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理。 </p><h4 id="复习Consumer接口"><a href="#复习Consumer接口" class="headerlink" title="复习Consumer接口"></a>复习Consumer接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.function.Consumer&lt;T&gt;接口是一个消费型接口。</span><br><span class="line">Consumer接口中包含抽象方法void accept(T t)，意为消费一个指定泛型的数据。</span><br></pre></td></tr></table></figure><h4 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); </span><br><span class="line">stream.forEach(name‐&gt; System.out.println(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="过滤：filter"><a href="#过滤：filter" class="headerlink" title="过滤：filter"></a>过滤：filter</h4><p>可以通过 filter 方法将一个流转换成另一个子集流。方法签名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</span><br></pre></td></tr></table></figure><p>该接口接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</p><p><img src="1580899980697.png" alt="1580899980697"></p><h4 id="复习Predicate接口"><a href="#复习Predicate接口" class="headerlink" title="复习Predicate接口"></a>复习Predicate接口</h4><p>此前我们已经学习过 java.util.stream.Predicate 函数式接口，其中唯一的抽象方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean test(T t);</span><br></pre></td></tr></table></figure><p>该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的 filter 方法 将会留用元素；如果结果为false，那么 filter 方法将会舍弃元素。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p> Stream流中的 filter 方法基本使用的代码如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); </span><br><span class="line">Stream&lt;String&gt; result &#x3D; original.filter(s ‐&gt; s.startsWith(&quot;张&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里通过Lambda表达式来指定了筛选的条件：必须姓张。</p><h4 id="映射：map"><a href="#映射：map" class="headerlink" title="映射：map"></a>映射：map</h4><p>如果需要将流中的元素映射到另一个流中，可以使用 map 方法。方法签名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</span><br></pre></td></tr></table></figure><p>该接口需要一个 Function 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p><p><img src="1580899926624.png" alt="1580899926624"></p><h4 id="复习Function接口"><a href="#复习Function接口" class="headerlink" title="复习Function接口"></a>复习Function接口</h4><p>此前我们已经学习过 java.util.stream.Function 函数式接口，其中唯一的抽象方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R apply(T t);</span><br></pre></td></tr></table></figure><p>这可以将一种T类型转换成为R类型，而这种转换的动作，就称为“映射”。 </p><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p> Stream流中的 map 方法基本使用的代码如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Stream&lt;String&gt; original &#x3D; Stream.of(&quot;10&quot;, &quot;12&quot;, &quot;18&quot;); Stream&lt;Integer&gt; result &#x3D; original.map(str‐&gt;Integer.parseInt(str));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="统计个数：count"><a href="#统计个数：count" class="headerlink" title="统计个数：count"></a>统计个数：count</h4><p>正如旧集合 Collection 当中的 size 方法一样，流提供 count 方法来数一数其中的元素个数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long count();</span><br></pre></td></tr></table></figure><p>该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); </span><br><span class="line">Stream&lt;String&gt; result &#x3D; original.filter(s ‐&gt; s.startsWith(&quot;张&quot;)); </span><br><span class="line">System.out.println(result.count()); &#x2F;&#x2F; 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="取用前几个：limit"><a href="#取用前几个：limit" class="headerlink" title="取用前几个：limit"></a>取用前几个：limit</h4><p>limit 方法可以对流进行截取，只取用前n个。方法签名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; limit(long maxSize);</span><br></pre></td></tr></table></figure><p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用</p><p><img src="1580900011097.png" alt="1580900011097"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); </span><br><span class="line">Stream&lt;String&gt; result &#x3D; original.limit(2); </span><br><span class="line">System.out.println(result.count()); &#x2F;&#x2F; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="跳过前几个：skip"><a href="#跳过前几个：skip" class="headerlink" title="跳过前几个：skip"></a>跳过前几个：skip</h4><p>如果希望跳过前几个元素，可以使用 skip 方法获取一个截取之后的新流：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; skip(long n);</span><br></pre></td></tr></table></figure><p>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用：</p><p><img src="1580900027816.png" alt="1580900027816"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);</span><br><span class="line">    Stream&lt;String&gt; result &#x3D; original.skip(2); </span><br><span class="line">    System.out.println(result.count()); &#x2F;&#x2F; 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合：concat"><a href="#组合：concat" class="headerlink" title="组合：concat"></a>组合：concat</h4><p>如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span><br></pre></td></tr></table></figure><blockquote><p>备注：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。 </p></blockquote><p>该方法的基本使用代码如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       Stream&lt;String&gt; stream1 &#x3D; Stream.of(&quot;张三丰&quot;, &quot;张翠山&quot;);</span><br><span class="line">       String[] arr &#x3D; &#123;&quot;美羊羊&quot;,&quot;喜洋洋&quot;&#125;;</span><br><span class="line">       Stream&lt;String&gt; stream2 &#x3D; Stream.of(arr);</span><br><span class="line">       Stream&lt;String&gt; concat &#x3D; Stream.concat(stream1, stream2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="JDK5新特性"><a href="#JDK5新特性" class="headerlink" title="JDK5新特性"></a>JDK5新特性</h1><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><ul><li>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：<ul><li><strong>…</strong> 用在参数上，称之为可变参数。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure><ul><li>其实这个书写完全等价与</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure><p><strong>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可【简单之处】。</strong></p><p>如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，<strong>可变参数一定要写在参数列表的末尾位置。</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">62</span>, <span class="number">431</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = getSum(arr);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="comment">//  6  7  2 12 2121</span></span><br><span class="line">        <span class="comment">// 求 这几个元素和 6  7  2 12 2121</span></span><br><span class="line">        <span class="keyword">int</span> sum2 = getSum(<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">2121</span>);</span><br><span class="line">        System.out.println(sum2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可变参数写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JDK9新特性"><a href="#JDK9新特性" class="headerlink" title="JDK9新特性"></a>JDK9新特性</h1><h2 id="对集合添加的优化"><a href="#对集合添加的优化" class="headerlink" title="对集合添加的优化"></a>对集合添加的优化</h2><p>通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用，使得代码重复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"abc"</span>);</span><br><span class="line">        list.add(<span class="string">"def"</span>);</span><br><span class="line">        list.add(<span class="string">"ghi"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJDK9</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Set&lt;String&gt; str1=Set.of(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);  </span><br><span class="line">        <span class="comment">//str1.add("c");这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合  </span></span><br><span class="line">        System.out.println(str1);  </span><br><span class="line">        Map&lt;String,Integer&gt; str2=Map.of(<span class="string">"a"</span>,<span class="number">1</span>,<span class="string">"b"</span>,<span class="number">2</span>);  </span><br><span class="line">        System.out.println(str2);  </span><br><span class="line">        List&lt;String&gt; str3=List.of(<span class="string">"a"</span>,<span class="string">"b"</span>);  </span><br><span class="line">        System.out.println(str3);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意以下两点：</p><blockquote><ol><li><p>of方法只适用于List接口,Set接口,Map接口,不适用于接接口的实现类</p></li><li><p>of方法的返回值是一个不能改变的集合,集合不能再使用add,put方法添加元素,会抛出异常</p></li><li><p>Set接口和Map接口在调用of方法的时候,不能有重复的元素,否则会抛出异常</p></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      Stream流 JDK5新特性 JDK9新特性
    
    </summary>
    
    
      <category term="Java高级" scheme="http://goldcarpenter.github.io/categories/Java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="Java" scheme="http://goldcarpenter.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDK8新特性</title>
    <link href="http://goldcarpenter.github.io/2020/02/29/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part2/"/>
    <id>http://goldcarpenter.github.io/2020/02/29/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part2/</id>
    <published>2020-02-28T16:00:00.000Z</published>
    <updated>2020-06-17T08:11:25.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK8新特性"><a href="#JDK8新特性" class="headerlink" title="JDK8新特性"></a>JDK8新特性</h1><h1 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3.函数式接口"></a>3.函数式接口</h1><h3 id="3-1概念"><a href="#3-1概念" class="headerlink" title="3.1概念"></a>3.1概念</h3><ul><li>函数式接口在Java中是指：<strong>有且仅有一个抽象方法的接口</strong></li><li>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。</li><li>只有确保接口中<strong>有且仅有一个抽象方法</strong> , Java中的Lambda才能顺利地进行推导。</li></ul><h3 id="3-2格式"><a href="#3-2格式" class="headerlink" title="3.2格式"></a>3.2格式</h3><ul><li><p>只要确保接口中有且仅有一个抽象方法【可以同时有默认方法、静态方法】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface [接口名称] &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名称(可选参数信息);</span><br><span class="line">    <span class="comment">//其他非抽象方法内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3-FunctionalInterface注解"><a href="#3-3-FunctionalInterface注解" class="headerlink" title="3.3@FunctionalInterface注解"></a>3.3<code>@FunctionalInterface</code>注解</h3><ul><li><p><code>Java 8</code>中专门为函数式接口引入了一个新的注解<code>@FunctionalInterface</code></p></li><li><p><strong>作用</strong>：编译阶段可以<strong>检测</strong>接口是否是一个函数式接口，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionalInterface</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4自定义函数式编程"><a href="#3-4自定义函数式编程" class="headerlink" title="3.4自定义函数式编程"></a>3.4自定义函数式编程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用自定义的函数式接口作为方法参数 其实就是传入一个接口作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(MyFunctionalInterface inter)</span> </span>&#123; </span><br><span class="line">inter.myMethod(); <span class="comment">// 调用自定义的函数式接口方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//传递接口的实现类对象</span></span><br><span class="line">       show(<span class="keyword">new</span> MyFunctionalInterfaceImpl());</span><br><span class="line"></span><br><span class="line">       <span class="comment">//传递接口的匿名内部类</span></span><br><span class="line">       show(<span class="keyword">new</span> MyFunctionalInterface() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"使用匿名内部类重写接口中的抽象方法"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//Lambda表达式</span></span><br><span class="line">       show(()-&gt;&#123;</span><br><span class="line">           System.out.println(<span class="string">"使用Lambda表达式重写接口中的抽象方法"</span>);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//简化Lambda表达式【去掉&#123;&#125; ; return】</span></span><br><span class="line">       show(()-&gt; System.out.println(<span class="string">"使用Lambda表达式重写接口中的抽象方法"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-函数式编程"><a href="#2-函数式编程" class="headerlink" title="2.函数式编程"></a>2.函数式编程</h2><h3 id="2-1Lambda的延迟执行"><a href="#2-1Lambda的延迟执行" class="headerlink" title="2.1Lambda的延迟执行"></a>2.1Lambda的延迟执行</h3><ul><li>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以作为解决方案，提升性能。</li></ul><h4 id="性能浪费的日志案例"><a href="#性能浪费的日志案例" class="headerlink" title="性能浪费的日志案例"></a>性能浪费的日志案例</h4><ul><li>典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> level, String msg)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (level == <span class="number">1</span>) &#123; </span><br><span class="line">System.out.println(msg);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">String msgA = <span class="string">"Hello"</span>; </span><br><span class="line">String msgB = <span class="string">"World"</span>; </span><br><span class="line">String msgC = <span class="string">"Java"</span>;</span><br><span class="line">log(<span class="number">1</span>, msgA + msgB + msgC); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>问题：无论级别是否满足要求，作为 log 方法的第二个参数，三个字符串<strong>一定会首先被拼接</strong>并传入方法内，然后才会进行级别判断。如果<strong>级别不符合</strong>要求，那么字符串的<strong>拼接操作就白做了</strong>，存在性能浪费。</li></ul><blockquote><p>备注：SLF4J是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行字符串的拼接，而是将字符串的若干部分作为可变参数传入方法中，仅在日志级别满足要求的情况下才会进行字符串拼接。</p><p>例如： LOGGER.debug(“变量{}的取值为{}。”, “os”, “macOS”) ，其中的大括号 {} 为占位符。如果满足日志级别要求，则会将“os”和“macOS”两个字符串依次拼接到大括号的位置；否则不会进行字符串拼接。这也是一种可行解决方案，但Lambda可以做到更好。</p></blockquote><h4 id="Lambda的更优写法"><a href="#Lambda的更优写法" class="headerlink" title="Lambda的更优写法"></a>Lambda的更优写法</h4><ul><li>使用Lambda必然需要一个函数式接口：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MessageBuilder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">buildMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后对<code>log</code>方法进行改造：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> level, MessageBuilder messageBuilder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(messageBuilder.buildMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String msgA = <span class="string">"Hello"</span>; String msgB = <span class="string">"World"</span>; String msgC = <span class="string">"Java"</span>;</span><br><span class="line">    log(<span class="number">0</span>,()-&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"Lambda执行！"</span>);</span><br><span class="line">        <span class="keyword">return</span> msgA+msgB+msgC;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有当级别满足要求的时候，才会进行三个字符串的拼接；否则三个字符串将不会进行拼接。</p><blockquote><p>扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的。</p></blockquote><h3 id="2-2-使用Lambda作为参数和返回值"><a href="#2-2-使用Lambda作为参数和返回值" class="headerlink" title="2.2 使用Lambda作为参数和返回值"></a>2.2 使用Lambda作为参数和返回值</h3><ul><li><p>使用<strong>Lambda表达式作为方法参数</strong>，其实就是<strong>使用函数式接口作为方法参数</strong>。</p><ul><li><code>java.lang.Runnable</code>接口就是一个函数式接口，<code>Thread</code>类的构造方法参数使用该接口作为参数，那么就可以使用Lambda进行传参。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">(Runnable task)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    startThread(() ‐&gt; System.out.println(<span class="string">"线程任务执行！"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用<strong>Lambda表达式作为返回值类型</strong>，实就是返回一个函数式接口</p><ul><li>当需要通过一个方法来获取一个<code>java.util.Comparator</code>接口类型的对象作为排序器时，就可以调该方法获取。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个方法,方法的返回值类型使用函数式接口Comparator</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title">getComparator</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法的返回值类型是一个接口,返回这个接口的匿名内部类</span></span><br><span class="line">    <span class="comment">/*return new Comparator&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">        public int compare(String o1, String o2) &#123;</span></span><br><span class="line"><span class="comment">            //按照字符串的降序排序</span></span><br><span class="line"><span class="comment">            return o2.length()-o1.length();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;;*/</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//方法的返回值类型是一个函数式接口,返回一个Lambda表达式</span></span><br><span class="line">    <span class="comment">/*return (String o1, String o2)-&gt;&#123;</span></span><br><span class="line"><span class="comment">        //按照字符串的降序排序</span></span><br><span class="line"><span class="comment">        return o2.length()-o1.length();</span></span><br><span class="line"><span class="comment">    &#125;;*/</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//Lambda表达式</span></span><br><span class="line">    <span class="keyword">return</span> (o1, o2)-&gt;o2.length()-o1.length();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    String[] arr = &#123;<span class="string">"aaa"</span>,<span class="string">"b"</span>,<span class="string">"cccccc"</span>,<span class="string">"dddddddddddd"</span>&#125;;</span><br><span class="line">    System.out.println(Arrays.toString(arr));<span class="comment">//[aaa, b, cccccc, dddddddddddd]</span></span><br><span class="line">    <span class="comment">//调用Arrays中的sort方法,对字符串数组进行排序</span></span><br><span class="line">    Arrays.sort(arr,getComparator());</span><br><span class="line">    <span class="comment">//输出排序后的数组</span></span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">    <span class="comment">//[dddddddddddd, cccccc, aaa, b]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h1><p>JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在 <code>java.util.function</code>包中被提供。 下面是最简单的几个接口及使用示例。</p><h2 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h2><ul><li><code>java.util.comparator</code>能实现比较器功能，即比较两个对象谁排在前谁排在后<ul><li><code>public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</li></ul></li></ul><blockquote><p>两个对象比较的结果有三种：大于，等于，小于。</p><p><strong>如果要按照升序排序：o1 - o2 &lt; 0 参数列表o1在左侧</strong></p><p>则o1 小于o2，返回（负数），相等返回0，o1大于o2返回（正数）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"cba"</span>);</span><br><span class="line">        list.add(<span class="string">"aba"</span>);</span><br><span class="line">        list.add(<span class="string">"sba"</span>);</span><br><span class="line">        list.add(<span class="string">"nba"</span>);</span><br><span class="line">        <span class="comment">//排序方法  按照第一个单词的降序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.charAt(<span class="number">0</span>) - o1.charAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="对比补充：Comparable-普通接口"><a href="#对比补充：Comparable-普通接口" class="headerlink" title="对比补充：Comparable[普通接口]"></a>对比补充：Comparable[普通接口]</h3><ul><li>采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了<strong>被排序的类</strong>型需要<strong>实现</strong>Comparable<strong>接口</strong>完成比较的<strong>功能</strong>，在String类型上如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span></span><br></pre></td></tr></table></figure><p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则固定写死了，那比如我想要字符串按照第一个字符降序排列[默认升序]，那么这样就要修改String的源代码，这是不可能的了，那么这个时候提出了上述的Comparator接口</p><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要写在对比的Pojo类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age-o.age;<span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写在main业务代码中</span></span><br><span class="line">ArrayList&lt;Student&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arrayList.add(stu1);</span><br><span class="line"> arrayList.add(stu2);</span><br><span class="line">    Collections.sort(arrayList);</span><br></pre></td></tr></table></figure><p>对比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写在main业务代码中</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.getAge()-o1.getAge();<span class="comment">//以学生的年龄降序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Comparable-普通接口-和Comparator-函数式接口-区别"><a href="#Comparable-普通接口-和Comparator-函数式接口-区别" class="headerlink" title="Comparable[普通接口]和Comparator[函数式接口]区别"></a>Comparable[普通接口]和Comparator[函数式接口]区别</h3><p><strong>Comparable：</strong>强行对实现它的每个类的对象进行整体排序。<strong>这种排序被称为类的自然排序</strong>，类的compareTo方法被称为它的自然比较方法。<strong>只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序</strong>。实现此接口的对象列表（和数组）<strong>可以通过<code>Collections.sort（和Arrays.sort）</code>进行自动排序</strong>，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p><p><strong>Comparator：</strong>强行对某个对象进行整体排序。<strong>可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制</strong>。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p><p>用</p><h2 id="Supplier接口"><a href="#Supplier接口" class="headerlink" title="Supplier接口"></a>Supplier接口</h2><ul><li><p><strong>获取一个泛型参数指定类型的对象数据。</strong></p></li><li><p><code>java.util.function.Supplier&lt;T&gt;</code>接口仅包含一个无参的方法：<code>T get()</code>。</p></li><li><p><code>Supplier&lt;T&gt;</code>接口被称之为生产型接口，指定接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个方法,方法的参数传递Supplier&lt;T&gt;接口,泛型执行String,get方法就会返回一个String</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(Supplier&lt;String&gt; sup)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sup.get();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//调用getString方法,方法的参数Supplier是一个函数式接口,所以可以传递Lambda表达式</span></span><br><span class="line">      String s = getString(()-&gt;&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"掘金木匠"</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">      System.out.println(s);<span class="comment">//掘金木匠</span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">//Lambda表达式</span></span><br><span class="line">      String s2 = getString(()-&gt;<span class="string">"掘金木匠"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(Supplier&lt;Integer&gt; sup)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sup.get();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">100</span>,<span class="number">0</span>,-<span class="number">50</span>,<span class="number">880</span>,<span class="number">99</span>,<span class="number">33</span>,-<span class="number">30</span>&#125;;</span><br><span class="line">        <span class="comment">//调用getMax方法,方法的参数Supplier是一个函数式接口,所以可以传递Lambda表达式</span></span><br><span class="line">        <span class="keyword">int</span> maxValue = getMax(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//获取数组的最大值,并返回</span></span><br><span class="line">            <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;     </span><br><span class="line">                <span class="keyword">if</span>(i&gt;max)&#123;</span><br><span class="line">                    <span class="comment">//如果i大于max,则替换max作为最大值</span></span><br><span class="line">                    max = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"数组中元素的最大值是:"</span>+maxValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer接口</h2><ul><li><code>java.util.function.Consumer&lt;T&gt;</code>接口则正好与Supplier接口相反，它不是生产一个数据，而是<strong>消费一个数据</strong>，其数据类型由泛型决定。 </li><li><code>Consumer</code>接口是一个消费型接口,泛型执行什么类型,就可以使用<code>accept</code>方法消费什么类型的数据，至于具体怎么消费(使用),需要自定义(输出,计算….)</li></ul><h3 id="抽象方法：accept"><a href="#抽象方法：accept" class="headerlink" title="抽象方法：accept"></a>抽象方法：accept</h3><ul><li><p><code>Consumer</code>接口中包含抽象方法<code>void accept(T t)</code> ，意为消费一个指定泛型的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        方法的参数传递Consumer接口,泛型使用String</span></span><br><span class="line"><span class="comment">        可以使用Consumer接口消费字符串的姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String name, Consumer&lt;String&gt; con)</span></span>&#123;</span><br><span class="line">        con.accept(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用method方法,传递字符串姓名,方法的另一个参数是Consumer接口,是一个函数式接口,所以可以传递Lambda表达式</span></span><br><span class="line">        method(<span class="string">"赵丽颖"</span>,(String name)-&gt;&#123;</span><br><span class="line">            <span class="comment">//消费方式:把字符串进行反转输出</span></span><br><span class="line">            String reName = <span class="keyword">new</span> StringBuffer(name).reverse().toString();</span><br><span class="line">            System.out.println(reName);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="默认方法：andThen"><a href="#默认方法：andThen" class="headerlink" title="默认方法：andThen"></a>默认方法：andThen</h3><ul><li><p>如果一个方法的参数和返回值全都是<code>Consumer</code>类型，那么就可以实现效果：消费数据的时候，首先做一个操作， 然后再做一个操作，实现组合。而这个方法就是<code>Consumer</code>接口中的<code>default</code>方法<code>andThen</code>。下面是JDK的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123; </span><br><span class="line">    Objects.requireNonNull(after); </span><br><span class="line">    <span class="keyword">return</span> (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>java.util.Objects 的 requireNonNull 静态方法将会在参数为null时主动抛出 NullPointerException 异常。这省去了重复编写if语句和抛出空指针异常的麻烦。</p></blockquote></li><li><p>要想实现组合，需要两个或多个Lambda表达式即可，而 andThen 的语义正是“一步接一步”操作。例如两个步骤组 合的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个方法,方法的参数传递一个字符串和两个Consumer接口,Consumer接口的泛型使用字符串</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String s, Consumer&lt;String&gt; con1 ,Consumer&lt;String&gt; con2)</span></span>&#123;</span><br><span class="line">       <span class="comment">//con1.accept(s);</span></span><br><span class="line">       <span class="comment">//con2.accept(s);</span></span><br><span class="line">       <span class="comment">//使用andThen方法,把两个Consumer接口连接到一起,在消费数据</span></span><br><span class="line">       con1.andThen(con2).accept(s);<span class="comment">//con1连接con2,先执行con1消费数据,在执行con2消费数据</span></span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//调用method方法,传递一个字符串,两个Lambda表达式</span></span><br><span class="line">          method(<span class="string">"Hello"</span>,</span><br><span class="line">               (t)-&gt; System.out.println(t.toUpperCase()), <span class="comment">//消费方式:把字符串转换为大写</span></span><br><span class="line">               (t)-&gt; System.out.println(t.toLowerCase()));<span class="comment">//消费方式:把字符串转换为小写</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h2><ul><li>有时候我们<strong>需要对某种类型的数据进行判断，从而得到一个boolean值结果</strong>。这时可以使用<code>java.util.function.Predicate&lt;T&gt;</code>接口。</li></ul><h3 id="抽象方法：test"><a href="#抽象方法：test" class="headerlink" title="抽象方法：test"></a>抽象方法：test</h3><ul><li><p>Predicate 接口中包含一个抽象方法：<code>boolean test(T t)</code> 。用于条件判断的场景：</p><ul><li>结果：符合条件，返回true </li><li>结果：不符合条件，返回false</li></ul></li><li><p>条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     参数传递一个String类型的字符串</span></span><br><span class="line"><span class="comment">     传递一个Predicate接口,泛型使用String</span></span><br><span class="line"><span class="comment">     使用Predicate中的方法test对字符串进行判断,并把判断的结果返回</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span>  pre.test(s);</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//定义一个字符串</span></span><br><span class="line">     String s = <span class="string">"abcdef"</span>;</span><br><span class="line">     <span class="comment">//Lambda表达式</span></span><br><span class="line">     <span class="keyword">boolean</span> b = checkString(s,str-&gt;str.length()&gt;<span class="number">5</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="默认方法：and"><a href="#默认方法：and" class="headerlink" title="默认方法：and"></a>默认方法：and</h3><ul><li><p>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个 Predicate 条件使用“与”逻辑连接起来实现“并且”的效果时，可以使用default方法 and 。其JDK源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123; </span><br><span class="line">Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (t) ‐&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断一个字符串<strong>既要</strong>长度是否大于52，<strong>又要</strong>判断字符串中是否包含a</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre1,Predicate&lt;String&gt; pre2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//return pre1.test(s) &amp;&amp; pre2.test(s);</span></span><br><span class="line">    <span class="keyword">return</span> pre1.and(pre2).test(s);<span class="comment">//等价于return pre1.test(s) &amp;&amp; pre2.test(s);</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"abcdef"</span>;</span><br><span class="line">    <span class="comment">//调用checkString方法,参数传递字符串和两个Lambda表达式</span></span><br><span class="line">    <span class="keyword">boolean</span> b = checkString(s,(str)-&gt; str.length()&gt;<span class="number">5</span>,(str)-&gt; str.contains(<span class="string">"a"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="默认方法：or"><a href="#默认方法：or" class="headerlink" title="默认方法：or"></a>默认方法：or</h3><ul><li><p>与 and 的“与”类似，默认方法 or 实现逻辑关系中的“或”。JDK源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123; </span><br><span class="line">Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (t) ‐&gt; test(t) || other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断一个字符串<strong>满足</strong>长度是否大于52，<strong>或</strong>判断字符串中是否包含a</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//return pre1.test(s) || pre2.test(s);</span></span><br><span class="line">    <span class="keyword">return</span>  pre1.or(pre2).test(s);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"bc"</span>;</span><br><span class="line">    <span class="comment">//调用checkString方法,参数传递字符串和两个Lambda表达式</span></span><br><span class="line">    <span class="keyword">boolean</span> b = checkString(s,(String str)-&gt; str.length()&gt;<span class="number">5</span>,(String str)-&gt; str.contains(<span class="string">"a"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="默认方法：negate"><a href="#默认方法：negate" class="headerlink" title="默认方法：negate"></a>默认方法：negate</h3><ul><li><p>“与”、“或”已经了解了，剩下的“非”（取反）也会简单。默认方法 negate 的JDK源代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default Predicate&lt;T&gt; negate() &#123; </span><br><span class="line">return (t) ‐&gt; !test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从实现中很容易看出，它是执行了test方法之后，对结果boolean值进行“!”取反而已。<strong>一定要在 test 方法调用之前调用 negate 方法，正如 and 和 or 方法一样</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Predicate接口判断字符串的长度是否大于5</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">       <span class="comment">//return !pre.test(s);</span></span><br><span class="line">       <span class="keyword">return</span>  pre.negate().test(s);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String s = <span class="string">"abc"</span>;</span><br><span class="line">       <span class="comment">//调用checkString方法,参数传递字符串和Lambda表达式</span></span><br><span class="line">       <span class="keyword">boolean</span> b = checkString(s,(String str)-&gt; str.length()&gt;<span class="number">5</span>);</span><br><span class="line">       System.out.println(b);<span class="comment">//true</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-7-Function接口"><a href="#3-7-Function接口" class="headerlink" title="3.7 Function接口"></a>3.7 Function接口</h2><ul><li><code>java.util.function.Function&lt;T,R&gt;</code>接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</li></ul><h3 id="抽象方法：apply"><a href="#抽象方法：apply" class="headerlink" title="抽象方法：apply"></a>抽象方法：apply</h3><ul><li><p><code>Function</code>接口中最主要的抽象方法为：<code>R apply(T t)</code>，根据类型T的参数获取类型R的结果。</p></li><li><p>使用的场景例如：将 String 类型转换为 Integer 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       方法的参数传递一个Function接口,泛型使用&lt;String,Integer&gt;</span></span><br><span class="line"><span class="comment">       使用Function接口中的方法apply,把字符串类型的整数,转换为Integer类型的整数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String s, Function&lt;String,Integer&gt; fun)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> in = fun.apply(s);</span><br><span class="line">       System.out.println(in);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//定义一个字符串类型的整数</span></span><br><span class="line">       String s = <span class="string">"1234"</span>;</span><br><span class="line">       <span class="comment">//调用change方法,传递字符串类型的整数,方法引用</span></span><br><span class="line">       change(s, Integer::parseInt); <span class="comment">//把字符串类型的整数,转换为Integer类型的整数返回</span></span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="默认方法：andThen-1"><a href="#默认方法：andThen-1" class="headerlink" title="默认方法：andThen"></a>默认方法：andThen</h3><ul><li><p><code>Function</code>接口中有一个默认的<code>andThen</code>方法，用来进行组合操作。JDK源代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123; </span><br><span class="line">Objects.requireNonNull(after); </span><br><span class="line">    <span class="keyword">return</span> (T t) ‐&gt; after.apply(apply(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法同样用于“先做什么，再做什么”的场景，和 Consumer 中的 andThen 差不多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        参数串一个字符串类型的整数</span></span><br><span class="line"><span class="comment">        参数再传递两个Function接口</span></span><br><span class="line"><span class="comment">            一个泛型使用Function&lt;String,Integer&gt;</span></span><br><span class="line"><span class="comment">            一个泛型使用Function&lt;Integer,String&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String s, Function&lt;String,Integer&gt; fun1,Function&lt;Integer,String&gt; fun2)</span></span>&#123;</span><br><span class="line">        String ss = fun1.andThen(fun2).apply(s);</span><br><span class="line">        System.out.println(ss);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"123"</span>;</span><br><span class="line">        <span class="comment">//调用change方法,传递字符串和两个Lambda表达式</span></span><br><span class="line">        <span class="comment">//把整数转换为字符串</span></span><br><span class="line">        change(s,str-&gt; parseInt(str)+<span class="number">10</span>,  </span><br><span class="line">                String::valueOf);    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      函数式接口 常用函数式接口
    
    </summary>
    
    
      <category term="Java高级" scheme="http://goldcarpenter.github.io/categories/Java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="Java" scheme="http://goldcarpenter.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDK8新特性</title>
    <link href="http://goldcarpenter.github.io/2020/02/25/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part1/"/>
    <id>http://goldcarpenter.github.io/2020/02/25/jdk8%E6%96%B0%E7%89%B9%E6%80%A7_Part1/</id>
    <published>2020-02-24T16:00:00.000Z</published>
    <updated>2020-06-17T08:10:23.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK8新特性"><a href="#JDK8新特性" class="headerlink" title="JDK8新特性"></a>JDK8新特性</h1><h1 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1.Lambda表达式"></a>1.Lambda表达式</h1><h2 id="函数式编程思想概述"><a href="#函数式编程思想概述" class="headerlink" title="函数式编程思想概述"></a>函数式编程思想概述</h2><ul><li>相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。<ul><li>面向对象的思想:<ul><li>做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</li></ul></li><li>函数式编程思想:<ul><li>只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</li></ul></li></ul></li></ul><h2 id="编程思想转换"><a href="#编程思想转换" class="headerlink" title="编程思想转换"></a>编程思想转换</h2><p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code>run</code>方法体内的代码传递给<code>Thread</code>类知晓。</p><p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p><p>Java 8（JDK 1.8）中，加入了<strong>Lambda表达式</strong>的重量级新特性，为我们打开了新世界的大门。</p><h2 id="回顾匿名内部类"><a href="#回顾匿名内部类" class="headerlink" title="回顾匿名内部类"></a>回顾匿名内部类</h2><h3 id="使用实现类"><a href="#使用实现类" class="headerlink" title="使用实现类"></a>使用实现类</h3><p>要启动一个线程，需要创建一个<code>Thread</code>类的对象并调用<code>start</code>方法。而为了指定线程执行的内容，需要调用<code>Thread</code>类的构造方法：</p><ul><li><code>public Thread(Runnable target)</code></li></ul><p>为了获取<code>Runnable</code>接口的实现对象，可以为该接口定义一个实现类<code>RunnableImpl</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"多线程任务执行！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建该实现类的对象作为<code>Thread</code>类的构造参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03ThreadInitParam</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Runnable task = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line"><span class="keyword">new</span> Thread(task).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h3><p>这个<code>RunnableImpl</code>类只是为了实现<code>Runnable</code>接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04ThreadNameless</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"多线程任务执行！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类的好处与弊端"><a href="#匿名内部类的好处与弊端" class="headerlink" title="匿名内部类的好处与弊端"></a>匿名内部类的好处与弊端</h4><p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p><ul><li><p>仔细分析该代码中的语义，<code>Runnable</code>接口只有一个<code>run</code>方法的定义：</p></li><li><p><code>public abstract void run();</code></p></li><li><p>即制定了一种做事情的方案（其实就是一个函数）：</p><ul><li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li><li><strong>无返回值</strong>：该方案不产生任何结果。</li><li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li></ul></li><li><p>同样的语义体现在<code>Lambda</code>语法中，要更加简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">"多线程任务执行！"</span>)</span><br></pre></td></tr></table></figure><ul><li>前面的一对小括号即<code>run</code>方法的参数（无），代表不需要任何条件；</li><li>中间的一个箭头代表将前面的参数传递给后面的代码；</li><li>后面的输出语句即业务逻辑代码。</li></ul></li></ul><h2 id="Lambda标准格式"><a href="#Lambda标准格式" class="headerlink" title="Lambda标准格式"></a>Lambda标准格式</h2><ul><li><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p><ul><li>一些参数</li><li>一个箭头</li><li>一段代码</li></ul></li><li><p>Lambda表达式的<strong>标准格式</strong>为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数类型 参数名称) -&gt; &#123; 代码语句 &#125;</span><br></pre></td></tr></table></figure></li><li><p>格式说明：</p><ul><li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li><li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li><li>大括号内的语法与传统方法体要求基本一致。</li></ul></li></ul><h2 id="Lambda省略格式"><a href="#Lambda省略格式" class="headerlink" title="Lambda省略格式"></a>Lambda省略格式</h2><h4 id="可推导即可省略"><a href="#可推导即可省略" class="headerlink" title="可推导即可省略"></a>可推导即可省略</h4><p>Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。</p><h4 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h4><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p><ol><li>小括号内参数的类型可以省略；</li><li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li><li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li></ol><h2 id="Lambda的使用前提"><a href="#Lambda的使用前提" class="headerlink" title="Lambda的使用前提"></a>Lambda的使用前提</h2><ol><li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li><li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li></ol><blockquote><p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p></blockquote><h1 id="2-方法引用"><a href="#2-方法引用" class="headerlink" title="2.方法引用"></a>2.方法引用</h1><ul><li>在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑 一种情况：<strong>如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？</strong></li></ul><h2 id="2-1-冗余的Lambda场景"><a href="#2-1-冗余的Lambda场景" class="headerlink" title="2.1 冗余的Lambda场景"></a>2.1 冗余的Lambda场景</h2><ul><li><p>来看一个简单的函数式接口以应用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printable</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printout</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Printable</code>接口当中唯一的抽象方法<code>printout</code>接收一个字符串参数，目的就是为了打印显示它。那么通过<code>Lambda</code>来使用它的代码很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(Printable p)</span> </span>&#123;</span><br><span class="line">       p.printout(<span class="string">"HelloWorld"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//调用printString方法,方法的参数Printable是一个函数式接口,所以可以传递Lambda</span></span><br><span class="line">       printString((s) -&gt; &#123;</span><br><span class="line">           System.out.println(s);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-问题分析"><a href="#2-2-问题分析" class="headerlink" title="2.2 问题分析"></a>2.2 问题分析</h2><ul><li>这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是<code>System.out</code>对象中的<code>println(String)</code>方法。既然Lambda希望做的事情就是调用<code>println(String)</code>方法，那何必自己手动调用呢？</li></ul><h3 id="2-3-用方法引用改进代码"><a href="#2-3-用方法引用改进代码" class="headerlink" title="2.3 用方法引用改进代码"></a>2.3 用方法引用改进代码</h3><ul><li><p>能否省去Lambda的语法格式（尽管它已经相当简洁）呢？只要“引用”过去就好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       分析:</span></span><br><span class="line"><span class="comment">       Lambda表达式的目的,打印参数传递的字符串</span></span><br><span class="line"><span class="comment">       把参数s,传递给了System.out对象,调用out对象中的方法println对字符串进行了输出</span></span><br><span class="line"><span class="comment">       注意:</span></span><br><span class="line"><span class="comment">       1.System.out对象是已经存在的</span></span><br><span class="line"><span class="comment">       2.println方法也是已经存在的</span></span><br><span class="line"><span class="comment">       所以我们可以使用方法引用来优化Lambda表达式</span></span><br><span class="line"><span class="comment">       可以使用System.out方法直接引用(调用)println方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">printString(System.out::println);</span><br></pre></td></tr></table></figure><p>请注意其中的双冒号<code>::</code>写法，这被称为“方法引用”，而双冒号是一种新的语法。</p></li></ul><h2 id="2-4-方法引用符"><a href="#2-4-方法引用符" class="headerlink" title="2.4 方法引用符"></a>2.4 方法引用符</h2><p>双冒号<code>::</code>为引用运算符，而它所在的表达式被称为<strong>方法引用</strong>。<strong>如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。</strong> </p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><ul><li>例如上例中， <code>System.out</code>对象中有一个重载的<code>println(String)</code>方法恰好就是我们所需要的。那么对于<code>printString</code>方法的函数式接口参数，对比下面两种写法，完全等效： <ul><li>Lambda表达式写法：<code>s -&gt; System.out.println(s);</code>——拿到参数之后经<code>Lambda</code>之手，继而传递给 <code>System.out.println</code>方法去处理。</li><li>方法引用写法： <code>System.out::println</code>——复用了已有方案</li></ul></li><li>Lambda 中 <strong>传递的参数</strong> <strong>一定</strong>是方法引用中 的那个方法<strong>可以接收的类型</strong>,否则会抛出异常 </li></ul><h3 id="推导与省略"><a href="#推导与省略" class="headerlink" title="推导与省略"></a>推导与省略</h3><ul><li><p>如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式——它们都 将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。</p></li><li><p>函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。</p></li></ul><h3 id="通过对象名引用成员方法"><a href="#通过对象名引用成员方法" class="headerlink" title="通过对象名引用成员方法"></a>通过对象名引用成员方法</h3><ul><li><p>最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodRerObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个成员方法,传递字符串,把字符串按照大写输出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUpperCaseString</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        System.out.println(str.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    通过对象名引用成员方法</span></span><br><span class="line"><span class="comment">    使用前提是对象名是已经存在的,成员方法也是已经存在</span></span><br><span class="line"><span class="comment">    就可以使用对象名来引用成员方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01ObjectMethodReference</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个方法,方法的参数传递Printable接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(Printable p)</span></span>&#123;</span><br><span class="line">        p.printout(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用printString方法,方法的参数Printable是一个函数式接口,所以可以传递Lambda表达式</span></span><br><span class="line">        printString((s)-&gt;&#123;</span><br><span class="line">            <span class="comment">//创建MethodRerObject对象</span></span><br><span class="line">            MethodRerObject obj = <span class="keyword">new</span> MethodRerObject();</span><br><span class="line">            <span class="comment">//调用MethodRerObject对象中的成员方法printUpperCaseString,把字符串按照大写输出</span></span><br><span class="line">            obj.printUpperCaseString(s);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用方法引用优化Lambda</span></span><br><span class="line"><span class="comment">            对象是已经存在的MethodRerObject</span></span><br><span class="line"><span class="comment">            成员方法也是已经存在的printUpperCaseString</span></span><br><span class="line"><span class="comment">            所以我们可以使用对象名引用成员方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//创建MethodRerObject对象</span></span><br><span class="line">        MethodRerObject obj = <span class="keyword">new</span> MethodRerObject();</span><br><span class="line">        printString(obj::printUpperCaseString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="通过类名称引用静态方法"><a href="#通过类名称引用静态方法" class="headerlink" title="通过类名称引用静态方法"></a>通过类名称引用静态方法</h3><ul><li><p>由于在<code>java.lang.Math</code>类中已经存在了静态方法<code>abs</code>，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calcable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个抽象方法,传递一个整数,对整数进行绝对值计算并返回</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calsAbs</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    通过类名引用静态成员方法</span></span><br><span class="line"><span class="comment">    类已经存在,静态成员方法也已经存在</span></span><br><span class="line"><span class="comment">    就可以通过类名直接引用静态成员方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01StaticMethodReference</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个方法,方法的参数传递要计算绝对值的整数,和函数式接口Calcable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> number,Calcable c)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> c.calsAbs(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用method方法,传递计算绝对值得整数,和Lambda表达式</span></span><br><span class="line">        <span class="keyword">int</span> number = method(-<span class="number">10</span>,(n)-&gt;&#123;</span><br><span class="line">            <span class="comment">//对参数进行绝对值得计算并返回结果</span></span><br><span class="line">            <span class="keyword">return</span> Math.abs(n);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(number);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用方法引用优化Lambda表达式</span></span><br><span class="line"><span class="comment">            Math类是存在的</span></span><br><span class="line"><span class="comment">            abs计算绝对值的静态方法也是已经存在的</span></span><br><span class="line"><span class="comment">            所以我们可以直接通过类名引用静态方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> number2 = method(-<span class="number">10</span>,Math::abs);</span><br><span class="line">        System.out.println(number2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="通过super引用成员方法"><a href="#通过super引用成员方法" class="headerlink" title="通过super引用成员方法"></a>通过super引用成员方法</h3><ul><li><p>如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Greetable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个见面的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类<code>Human</code>的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo07.SuperMethodReference;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个sayHello的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello 我是Human!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是子类<code>Man</code>的内容，其中使用了Lambda的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo07.SuperMethodReference;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="comment">//子类重写父类sayHello的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello 我是Man!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法参数传递Greetable接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Greetable g)</span></span>&#123;</span><br><span class="line">        g.greet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//调用method方法,方法的参数Greetable是一个函数式接口,所以可以传递Lambda</span></span><br><span class="line">        <span class="comment">/*method(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">            //创建父类Human对象</span></span><br><span class="line"><span class="comment">            Human h = new Human();</span></span><br><span class="line"><span class="comment">            //调用父类的sayHello方法</span></span><br><span class="line"><span class="comment">            h.sayHello();</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为有子父类关系,所以存在的一个关键字super,代表父类,所以我们可以直接使用super调用父类的成员方法</span></span><br><span class="line">       <span class="comment">/* method(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">            super.sayHello();</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">           使用super引用类的成员方法</span></span><br><span class="line"><span class="comment">           super是已经存在的</span></span><br><span class="line"><span class="comment">           父类的成员方法sayHello也是已经存在的</span></span><br><span class="line"><span class="comment">           所以我们可以直接使用super引用父类的成员方法</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      method(<span class="keyword">super</span>::sayHello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Man().show(); <span class="comment">//Hello 我是Human!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="通过this引用成员方法"><a href="#通过this引用成员方法" class="headerlink" title="通过this引用成员方法"></a>通过this引用成员方法</h3><ul><li>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“this::成员方法”的格式来使用方 法引用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用this引用本类的成员方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello 我是Man!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法参数传递Greetable接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Greetable g)</span></span>&#123;</span><br><span class="line">        g.greet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//调用method方法,方法的参数Greetable是一个函数式接口,所以可以传递Lambda</span></span><br><span class="line">        <span class="comment">/*method(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">           // 使用this.成员方法,调用父类的sayHello方法</span></span><br><span class="line"><span class="comment">            this.sayHello();</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用方法引用优化Lambda表达式</span></span><br><span class="line"><span class="comment">            this是已经存在的</span></span><br><span class="line"><span class="comment">            本类的成员方法sayHello也是已经存在的</span></span><br><span class="line"><span class="comment">            所以我们可以直接使用this引用本类的成员方法buyHouse</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        method(<span class="keyword">this</span>::sayHello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Human().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="类的构造器引用"><a href="#类的构造器引用" class="headerlink" title="类的构造器引用"></a>类的构造器引用</h3><ul><li><p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 类名称::new 的格式表示。创建 Person 对象的函数式接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个方法,根据传递的姓名,创建Person对象返回</span></span><br><span class="line">    <span class="function">Person <span class="title">builderPerson</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo09.ConstructorMethodReference;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    类的构造器(构造方法)引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个方法,参数传递姓名和PersonBuilder接口,方法中通过姓名创建Person对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">(String name,PersonBuilder pb)</span></span>&#123;</span><br><span class="line">        Person person = pb.builderPerson(name);</span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用printName方法,方法的参数PersonBuilder接口是一个函数式接口,可以传递Lambda</span></span><br><span class="line">        printName(<span class="string">"迪丽热巴"</span>,(String name)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用方法引用优化Lambda表达式</span></span><br><span class="line"><span class="comment">            构造方法new Person(String name) 已知</span></span><br><span class="line"><span class="comment">            创建对象已知 new</span></span><br><span class="line"><span class="comment">            就可以使用Person引用new创建对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        printName(<span class="string">"古力娜扎"</span>,Person::<span class="keyword">new</span>);<span class="comment">//使用Person类的带参构造方法,通过传递的姓名创建对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数组的构造器引用"><a href="#数组的构造器引用" class="headerlink" title="数组的构造器引用"></a>数组的构造器引用</h3><ul><li><p>数组也是 Object 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时， 需要一个函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArrayBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个创建int类型数组的方法,参数传递数组的长度,返回创建好的int类型数组</span></span><br><span class="line">    <span class="keyword">int</span>[] builderArray(<span class="keyword">int</span> length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    数组的构造器引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个方法</span></span><br><span class="line"><span class="comment">        方法的参数传递创建数组的长度和ArrayBuilder接口</span></span><br><span class="line"><span class="comment">        方法内部根据传递的长度使用ArrayBuilder中的方法创建数组并返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] createArray(<span class="keyword">int</span> length, ArrayBuilder ab)&#123;</span><br><span class="line">        <span class="keyword">return</span>  ab.builderArray(length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用createArray方法,传递数组的长度和Lambda表达式</span></span><br><span class="line">        <span class="keyword">int</span>[] arr1 = createArray(<span class="number">10</span>,(len)-&gt;&#123;</span><br><span class="line">            <span class="comment">//根据数组的长度,创建数组并返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(arr1.length);<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用方法引用优化Lambda表达式</span></span><br><span class="line"><span class="comment">            已知创建的就是int[]数组</span></span><br><span class="line"><span class="comment">            数组的长度也是已知的</span></span><br><span class="line"><span class="comment">            就可以使用方法引用</span></span><br><span class="line"><span class="comment">            int[]引用new,根据参数传递的长度来创建数组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span>[] arr2 =createArray(<span class="number">10</span>,<span class="keyword">int</span>[]::<span class="keyword">new</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line">        System.out.println(arr2.length);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      Lambda表达式 方法引用
    
    </summary>
    
    
      <category term="Java高级" scheme="http://goldcarpenter.github.io/categories/Java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="Java" scheme="http://goldcarpenter.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat</title>
    <link href="http://goldcarpenter.github.io/2020/02/14/Tomcat_Part4/"/>
    <id>http://goldcarpenter.github.io/2020/02/14/Tomcat_Part4/</id>
    <published>2020-02-13T16:00:00.000Z</published>
    <updated>2020-06-19T14:07:58.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tomcat源码包安装"><a href="#Tomcat源码包安装" class="headerlink" title="Tomcat源码包安装"></a>Tomcat源码包安装</h1><ul><li>官方下载source</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;tomcat.apache.org&#x2F;download-80.cgi</span><br></pre></td></tr></table></figure><ul><li><p>IDEA创建新空工程</p><p><img src="1575879034915.png" alt="1575879034915"></p></li></ul><p><img src="1575879072288.png" alt="1575879072288"></p><p><img src="1575879144042.png" alt="1575879144042"></p><ul><li>进入下载的解压目录，并创建一个目录，命名为home并将conf，webapps目录移入home 目录中</li></ul><p><img src="1575879188112.png" alt="1575879188112"></p><ul><li><p>在源码目录下创建pom.xml文件,引入tomcat的依赖包</p><p><img src="1575879652842.png" alt="1575879652842"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line"></span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line"></span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;Tomcat8.5&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;name&gt;Tomcat8.5&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;version&gt;8.5&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;Tomcat8.5&lt;&#x2F;finalName&gt;</span><br><span class="line">        &lt;sourceDirectory&gt;java&lt;&#x2F;sourceDirectory&gt;</span><br><span class="line">        &lt;testSourceDirectory&gt;test&lt;&#x2F;testSourceDirectory&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;java&lt;&#x2F;directory&gt;</span><br><span class="line">            &lt;&#x2F;resource&gt;</span><br><span class="line">        &lt;&#x2F;resources&gt;</span><br><span class="line"></span><br><span class="line">        &lt;testResources&gt;</span><br><span class="line">           &lt;testResource&gt;</span><br><span class="line">                &lt;directory&gt;test&lt;&#x2F;directory&gt;</span><br><span class="line">           &lt;&#x2F;testResource&gt;</span><br><span class="line">        &lt;&#x2F;testResources&gt;</span><br><span class="line"></span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.3&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;&#x2F;encoding&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">     &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.easymock&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easymock&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;wsdl4j&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;wsdl4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.xml&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jaxrpc&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ecj&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.5.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;    </span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure></li><li><p>确认maven</p><p><img src="1575879759066.png" alt="1575879759066"></p><p><img src="1575879869171.png" alt="1575879869171"></p><p><img src="1575879799816.png" alt="1575879799816"></p></li><li><p>配置idea的启动类， 配置Mainclass，并配置VM参数</p><p><img src="1575881232307.png" alt="1575881232307"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.startup.Bootstrap</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Dcatalina.home&#x3D;E:&#x2F;Tomcat_Source&#x2F;apache-tomcat-8.5.49-src&#x2F;home</span><br><span class="line">-Dcatalina.base&#x3D;E:&#x2F;Tomcat_Source&#x2F;apache-tomcat-8.5.49-src&#x2F;home</span><br><span class="line">-Djava.util.logging.manager&#x3D;org.apache.juli.ClassLoaderLogManager</span><br><span class="line">-Djava.util.logging.config.file&#x3D;E:&#x2F;Tomcat_Source&#x2F;apache-tomcat-8.5.49-src&#x2F;home&#x2F;conf&#x2F;logging.properties</span><br></pre></td></tr></table></figure></li><li><p>Debug运行</p><p><img src="1575881282335.png" alt="1575881282335"></p></li><li><p>原因是我们直接启动org.apache.catalina.startup.Bootstrap的时候没有加载org.apache.jasper.servlet.JasperInitializer，从而无法编译JSP</p></li><li><p>解决办法是在tomcat的源码org.apache.catalina.startup.ContextConfig中的configureStart函数中手动将JSP解析器初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Shift+Alt+N</span><br><span class="line">查找 ContextConfig类</span><br></pre></td></tr></table></figure><p><img src="1575881374160.png" alt="1575881374160"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.addServletContainerInitializer(new JasperInitializer(), null);</span><br></pre></td></tr></table></figure></li><li><p>成功</p><p><img src="1575881407558.png" alt="1575881407558"></p></li></ul>]]></content>
    
    <summary type="html">
    
      Tomcat源码包安装
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Tomcat" scheme="http://goldcarpenter.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat</title>
    <link href="http://goldcarpenter.github.io/2020/02/07/Tomcat_Part3/"/>
    <id>http://goldcarpenter.github.io/2020/02/07/Tomcat_Part3/</id>
    <published>2020-02-06T16:00:00.000Z</published>
    <updated>2020-06-19T14:07:19.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="9-Tomcat安全"><a href="#9-Tomcat安全" class="headerlink" title="9.Tomcat安全"></a>9.Tomcat安全</h2><h3 id="9-1配置安全【运维人员】"><a href="#9-1配置安全【运维人员】" class="headerlink" title="9.1配置安全【运维人员】"></a>9.1配置安全【运维人员】</h3><ul><li><p>删除webapps目录下的所有文件，禁用tomcat管理界面</p></li><li><p>注释或删除tomcat-users.xml文件内的所有用户权限</p></li><li><p>更改关闭tomcat指令或禁用 </p><ul><li><p>Tomcat的server.xml中定义了可以直接关闭Tomcat实例的管理端口(默认8005)</p></li><li><p>由于默认关闭Tomcat 的端口和指令都很简单。默认端口为8005 ,指令为SHUTDOWN。</p></li><li><p>可以通过telnet连接上该端口之后，输入SHUTDOWN (此为默认关闭指令)即可关闭Tomcat 实例（注意,此时虽然实例关闭了,但是进程还是存在的）</p><p><img src="1576138153004.png" alt="1576138153004"></p><p><img src="1576138208587.png" alt="1576138208587"></p></li><li><p>方案一：更改端口号和指令</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Server port&#x3D;&quot;8456&quot; shutdown&#x3D;&quot;server_shut&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>方案二：禁用8005端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Server port&#x3D;&quot;-1&quot; shutdown&#x3D;&quot;SHUTDOWN&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>定义错误页面</p><ul><li>在webapps/ROOT目录下错误页面404.html，500.html</li></ul></li></ul><h3 id="9-2应用安全"><a href="#9-2应用安全" class="headerlink" title="9.2应用安全"></a>9.2应用安全</h3><ul><li>在大部分的web应用中，特别是一些<strong>后台应用系统</strong>，都会实现自己的<strong>安全管理模块</strong>(权限模块) , 用于控制应用系统的安全访问。</li><li>基本包含两个部分：<strong>认证(登录/单点登录)</strong>和<strong>授权(功能权限、数据权限)</strong>两个部分</li><li>对于当前的业务系统,可以自己做一套适用于自己业务系统的权限模块，也有很多的应用系统直接使用一些功能完善的安全框架 ,将其集成到我们的web应用中,如: SpringSecurity. Apache Shiro等。</li></ul><h3 id="9-3传输安全"><a href="#9-3传输安全" class="headerlink" title="9.3传输安全"></a>9.3传输安全</h3><h4 id="9-3-1-HTTPS介绍"><a href="#9-3-1-HTTPS介绍" class="headerlink" title="9.3.1 HTTPS介绍"></a>9.3.1 HTTPS介绍</h4><ul><li><p>Https的全称是超文本传输安全协议( Hypertext Transfer Protocol Secure) , 是一种网络安全传输协议。在HTTP的基础上加入SSL/TLS来进行数据加密，保护交换数据不被泄露、窃取。</p></li><li><p>SSL和TLS是用于网络通信安全的加密协议,它允许客户端和服务器之间通过安全链接通信。ssL协议的3个特性:</p><ul><li>保密 :通过ssL链接传输的数据时加密的。</li><li>鉴别:通信双方的身份鉴别,通常是可选的,单至少有一方需要验证。</li><li>完整性:传输数据的完整性检查。</li></ul></li><li><p>从性能角度考虑,加解密是一项计算昂贵的处理,因为尽量不要将整个web应用采用SSL链接，实际部署过程中，选择有必要进行安全加密的页面(存在敏感信息传输的页面)采用SSL通信。</p></li><li><p>HTTPs和HTTP的区别</p><ul><li>HTTPs协议需要到证书颁发机构cA申请ssL证书，然后与域名进行绑定, HTTP不用申请证书;</li><li>HTTP是超文本传输协议,属于应用层信息传输, HTTPS则是具有ss加密传安全性传输协议,对数据的传输进行加密,相当于HTTP的升级版;</li><li>HTTp和HTTps使用的是完全不同的连接方式 ,用的端口也不一-样 ,前者是8080,后者是8443。</li><li>HTTP的连接很简单 。是无状态的; HTTPs协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议,比HTTp协议安全</li></ul></li><li><p>HTTPs协议优势:</p><ul><li>提高网站排名。有利于搜索引擎优化(SEO)。谷歌已经公开声明两个网站在搜索结果方面相同。如果一个网站启用了 ssL。它可能会获得略高于没有ssL网站的等级，而且百度也表明对安装了ssI的网站表示友好。因此,网站上的内容中启用ssI都有明显的sEo优势。</li><li>隐私信息加密,防止流量劫持。特别是涉及到隐私信息的网站,互联网大型的数据泄露的事件频发发生,网站进行信息加密势在必行。</li><li>浏览器受信任。自从各大主流浏览器大力支持Https协议之后 ,访问Http的网站都会提示”不安全”的警告信息。</li></ul></li></ul><h4 id="9-3-2-Tomcat支持HTTPs"><a href="#9-3-2-Tomcat支持HTTPs" class="headerlink" title="9.3.2.Tomcat支持HTTPs"></a>9.3.2.Tomcat支持HTTPs</h4><ul><li><p>不向CA进行申请，构建Https</p><ul><li>生成秘钥库文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -alias tomcat -keyalg RSA -Keystore tomcatkey.keystose</span><br></pre></td></tr></table></figure><p><img src="1576140985324.png" alt="1576140985324"></p><p><img src="1576140994603.png" alt="1576140994603"></p><p>输入对应的密钥库密码，秘钥密码等信息之后 .会在当前文件夹中出现一个秘钥库文件: tomcatkey.keystore</p></li><li><p>将秘钥库文件tomcatkey . keystore复制到tomcat/conf目录下</p></li><li><p>配置tomcat/conf/server.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8443&quot; protocol&#x3D;&quot;org.apache.coyote.http11. Http11NioProtocol&quot; maxThreads&#x3D;&quot;150&quot; schema&#x3D;&quot;https&quot; secure&#x3D;&quot;true&quot; SSLEnabled&#x3D;&quot;true&quot;&gt;</span><br><span class="line">&lt;SSLHostConfig certificateVerification&#x3D;&quot;false&quot;&gt;</span><br><span class="line">&lt;Certificate certificateKeystoreFile&#x3D;&quot;[...]&#x2F;conf&#x2F;tomcatkey. keystore&quot; certificateKeystorePassword&#x3D;&quot;itcast&quot; type&#x3D;&quot;RSA&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;SSLHostConfig&gt;</span><br><span class="line">&lt;&#x2F;Connector&gt;</span><br></pre></td></tr></table></figure></li><li><p>结果</p><p><img src="1576141270073.png" alt="1576141270073"></p></li></ul><h2 id="10-Tomcat-性能调优"><a href="#10-Tomcat-性能调优" class="headerlink" title="10.Tomcat 性能调优"></a>10.Tomcat 性能调优</h2><h3 id="10-1-Tomcat-性能测试"><a href="#10-1-Tomcat-性能测试" class="headerlink" title="10.1. Tomcat 性能测试"></a>10.1. Tomcat 性能测试</h3><ul><li>对于系统性能,用户最直观的感受就是<strong>系统的加载</strong>和<strong>操作时间</strong>，即用户执行某项操作的耗时。</li><li>从更为专业的角度上讲,性能测试可以从以下两个指标量化。<ul><li>响应时间：为执行某个操作的耗时。大多数情况下,我们需要针对同一一个操作测试多次，以获取操作的平均响应时间</li><li>吞吐量:即在给定的时间内，系统支持的事务数量，一秒内可以处理多少请求，计算单位为TPS。</li></ul></li><li>通常情况下,我们需要借助于一些自动化工具来进行性能测试，因为手动模拟大量用户的并发访问几乎是不可行的。而且现在市面上也有很多的性能测试工具可以使用,如: ApacheBench，ApacheJMeter， WCAT、 WebPolygraph、 LoadRunner</li></ul><h4 id="10-1-1-ApacheBench"><a href="#10-1-1-ApacheBench" class="headerlink" title="10.1.1 ApacheBench"></a>10.1.1 ApacheBench</h4><ul><li><p>ApacheBench (ab)是一款Apacheserver基准的测试工具 ，用户测试Apache server的服务能力(每秒处理请求数) ,它不仅可以用户Apache的测试,还可以用于测试Tomcat、Nginx、 lighthttp、 IIS等服务器</p></li><li><p>安装</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install httpd-tools</span><br></pre></td></tr></table></figure><ul><li>部署Tomcat</li></ul><p><img src="1576141888598.png" alt="1576141888598"></p><p><img src="1576141902505.png" alt="1576141902505"></p><ul><li>上传War，删除原始项目</li></ul><p><img src="1576141834930.png" alt="1576141834930"></p><p><img src="1576141939077.png" alt="1576141939077"></p><ul><li>数据库环境准备</li></ul><p><img src="1576141980618.png" alt="1576141980618"></p><p><img src="1576142030109.png" alt="1576142030109"></p><p><img src="1576142005185.png" alt="1576142005185"></p><ul><li>启动Tomcat</li></ul><p><img src="1576142289502.png" alt="1576142289502"></p><ul><li>性能测试</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 1000 -c 100 -p data.json -T application&#x2F;json http:&#x2F;&#x2F; localhost:9000&#x2F;course&#x2F;search.do?page&#x3D;1spageSize&#x3D;10</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义描述</th></tr></thead><tbody><tr><td>-n</td><td>在测试会话中所执行的请求个数,默认只执行一次请求</td></tr><tr><td>-c</td><td>一次产生的请求个数， 默认一次一个</td></tr><tr><td>-p</td><td>包含了需要POST的数据文件</td></tr><tr><td>-t</td><td>测试所进行的最大秒数,默认没有时间限制</td></tr><tr><td>-T</td><td>POST数据所需要使用的Content-Type头信息</td></tr><tr><td>-v</td><td>设置显示信息的详细程度</td></tr><tr><td>-w</td><td>以HTML表的格式输出结果,默认是白色背景的两列宽度的一张表</td></tr></tbody></table><ul><li>结果说明</li></ul><table><thead><tr><th>指标</th><th></th></tr></thead><tbody><tr><td>Server Software</td><td>服务器软件</td></tr><tr><td>Server Hostname</td><td>主机名</td></tr><tr><td>Server Port</td><td>端口号</td></tr><tr><td>Document Path</td><td>测试的页面</td></tr><tr><td>Document Length</td><td>测试的页面大小</td></tr><tr><td>Concurrency Level</td><td>并发数</td></tr><tr><td>Time taken for tests</td><td>整个测试持续的时间</td></tr><tr><td>Complete requests</td><td>完成的请求数量</td></tr><tr><td>Failed requests</td><td>失败的请求数量,这里的失败是指请求的连接服务器、发送数据、接收数据等环节发生异</td></tr><tr><td>Write errors</td><td>输出错误数量</td></tr><tr><td>Total transferred</td><td>整个场景中的网络传输量,表示所有请求的响应数据长度总和,包括每个http响应数据的头信息和正文数据的长度</td></tr><tr><td>THL transferred</td><td>整个场景中的HTML内容传输最，表示所有请求的响应数据中正文数据的总和</td></tr><tr><td><strong>Requests per second</strong></td><td>每秒钟平均处理的请求数(相当于LR中的每秒事务数)这便是我们重点关注的吞吐率 ==Complete requests / Time taken for tests</td></tr><tr><td>Time per request</td><td>每个线程处理请求平均消耗时间(相当于LR中的平均事务响应时间)用户平均请求等待时间</td></tr><tr><td>Transfer  rate</td><td>平均每秒网络上的流量</td></tr><tr><td>Percentage of the requeste served within a certain time (ms)</td><td>指定时间里，执行的请求百分比</td></tr></tbody></table><table><thead><tr><th align="left">参数</th><th align="center">指标说明</th></tr></thead><tbody><tr><td align="left"><strong>Requests per second</strong></td><td align="center"><strong>吞吐率</strong>：服务器并发处理能力的量化描述,单位是reqs/s。指的是在某个并发用户数下单位时间内处理的请求数，某个并发用户数下单位时间内能处理的最大请求数。称之为最大吞吐率。这个数值表示当前机器的整体性能,值越大越好</td></tr><tr><td align="left"><strong>Time per request</strong></td><td align="center"><strong>用户平均请求等待时间</strong>：从用户角度看，完成一个请求所需要的时间</td></tr><tr><td align="left"><strong>Time per request</strong></td><td align="center"><strong>服务器平均请求等待时间</strong>服务器完成一个请求的时间</td></tr><tr><td align="left">Concurrency Level</td><td align="center">并发用户数</td></tr></tbody></table><h3 id="10-2-JVM参数调优"><a href="#10-2-JVM参数调优" class="headerlink" title="10.2. JVM参数调优"></a>10.2. JVM参数调优</h3><ul><li>Tomcat是一款Java应用，那么JVM的配置便与其运行性能密切相关</li><li>JVM优化的重点集中在<strong>内存分配</strong>和<strong>GC策略</strong>的调整上<ul><li>内存会直接影响服务的运行效率和吞吐量</li><li>JVM垃圾回收机制则会不同程度地导致程序运行中断，调整JVM垃圾回收策略，可以极大减少垃圾回收次数，提升垃圾回收效率，改善程序运行性能</li></ul></li></ul><table><thead><tr><th align="center"></th><th></th><th></th></tr></thead><tbody><tr><td align="center">-server</td><td>启动Server，以服务端模式运行</td><td>服务端模式建议<br/>开启</td></tr><tr><td align="center">-Xms</td><td>最小堆内存</td><td>建议与-Xmx设置相同</td></tr><tr><td align="center">-Xmx</td><td>最大堆内存</td><td>建议设置为<strong>可用内存</strong>(排除系统和其他服务)的80%</td></tr><tr><td align="center">-XX:MetaspaceSize</td><td>元空间初始值</td><td></td></tr><tr><td align="center">-XX:MaxMetaspaceSize</td><td>元空间最大内存</td><td>默认无限</td></tr><tr><td align="center">-XX:MaxNewSize</td><td>新生代最大内存</td><td>默认16M</td></tr><tr><td align="center">-XX:NewRatio</td><td>年轻代和老年代大小比值，取值为整数，默认为2</td><td>不建议修改</td></tr><tr><td align="center">-XX:SurvivorRatio</td><td>Eden区与Survivor区大小的比值，取值为整数，默认为8</td><td>不建议修改</td></tr></tbody></table><ul><li>修改catalina.sh</li></ul><p><img src="1576462400042.png" alt="1576462400042"></p><ul><li>查看Tomcat内存占用情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap [Tomcat pid]</span><br></pre></td></tr></table></figure><h3 id="10-3-JVMGC策略"><a href="#10-3-JVMGC策略" class="headerlink" title="10.3.JVMGC策略"></a>10.3.JVMGC策略</h3><ul><li><p>JVM垃圾回收性能有以下两个主要的指标</p><ul><li>吞吐量:工作时间(排除GC时间)占总时间的百分比，工作时间并不仅是程序运行的时间 ,还包含内存分配时间。</li><li>暂停时间:测试时间段内，由垃圾回收导致的应用程序停止响应次数/时间</li></ul></li><li><p>查看Tomcat默认垃圾回收器</p><ul><li><p>在bin/catalina.sh的配置中，加入如下配置</p><p><img src="1576464026852.png" alt="1576464026852"></p></li><li><p>打开jconsole</p><p><img src="1576464098139.png" alt="1576464098139"></p><p><img src="1576464222102.png" alt="1576464222102"></p><ul><li>上面<strong>新生代垃圾收集器</strong>，下面<strong>老年代垃圾收集器</strong></li></ul></li><li><p>修改catalina.sh</p><p><img src="1576464357851.png" alt="1576464357851"></p></li></ul></li></ul><h3 id="10-4-Tomcat配置调优"><a href="#10-4-Tomcat配置调优" class="headerlink" title="10.4.Tomcat配置调优"></a>10.4.Tomcat配置调优</h3><ul><li>调整tomcat/conf/server.xml中关干链接器的配置可以提升应用服务器的性能</li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>maxConnections</td><td><strong>最大连接数</strong>，当到达该值后，服务器接收但不会处理更多的请求，额外的请求将会阻塞直到连接数低于maxConnections。可通过ulimit -a查看服务器限制。对于cpu要求更高(计算型)时,建议不要配置过大；对于CPU要求不是特别高时，建议配置在2000左右(受服务器性能影响)。当然这个需 要服务器硬件的支持</td></tr><tr><td>maxThreads</td><td><strong>最大线程数</strong>，需要根据服务器的硬件情况，进行一个合理的设置</td></tr><tr><td>acceptCount</td><td><strong>最大排队等待数</strong>，当服务器接收的请求数量到达maxConnections , 此时Tomcat会将后面的请求,存放在任务队列中进行排序，acceptCount指的就是任务队列中排队等待的请求数 。一台Tomcat的最大的请求处理数量是maxConnections+acceptCount</td></tr></tbody></table><p><img src="1576466074693.png" alt="1576466074693"></p><h2 id="11-Tomcat附加功能"><a href="#11-Tomcat附加功能" class="headerlink" title="11.Tomcat附加功能"></a>11.Tomcat附加功能</h2><h3 id="11-1-WebSocket"><a href="#11-1-WebSocket" class="headerlink" title="11.1.WebSocket"></a>11.1.WebSocket</h3><ul><li><p>websocket是HTML5新增的协议,它的目的是在浏览器和服务器之间建立一个<strong>不受限的双向通信</strong>的通道，比如说，服务器可以在任意时刻发送消息给浏览器。</p></li><li><p>为什么传统的HTTP协议不能做到websocket实现的功能?</p><ul><li>这是因为HTTp协议是一个<strong>请求-响应</strong>协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求,再把数据发送给浏览器。换句话说，浏览器不主动请求,服务器是没法主动发数据给浏览器的。</li><li>这样一来,要在浏览器中搞一个实时聊天,或者在线多人游戏的话就没法实现了,只能借助Flash这些插件。</li><li>HTTP协议其实也能实现啊,比如用轮询或者comet。<ul><li>轮询是指浏览器通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求,询问服务器有没有新消息。这个机制的缺点一是实时性不够,二是频繁的请求会给服务器带来极大的压力。</li><li>Comet本质上也是轮询,但是在没有消息的情况下,服务器先拖一段时间,等到有消息了再回复。这个机制暂时地解决了实时性问题,但是它带来了新的问题:以多线程模式运行的服务器会让大部分线程大部分时间都处于挂起状态,极大地浪费服务器资源。另外,一个HTTP连接在长时间没有数据传输的情况下,链路上的任何一一个网关都可能关闭这个连接,而网关是我们不可控的,这就要求Comet连接必须定期发一些ping数据表示连接“正常工作”。</li></ul></li></ul></li><li><p>以上两种机制都治标不治本。所以，HTML5推出了Websocket标准,让浏览器和服务器之间可以建立无限制的全双工通信，任何一方都可以主动发消息给对方。</p></li><li><p><strong>WebSocket并不是全新的协议,而是利用了HTTP协议来建立连接。</strong></p><p><img src="1576149368308.png" alt="1576149368308"></p></li><li><p>首先, Websocket连接必须由浏览器发起,因为请求协议是一个标准的HTTp请求 ,格式如下</p><p><img src="1576149932095.png" alt="1576149932095"></p></li><li><p>WebSocket请求和普通的HTTP请求有几点不同</p><ul><li>GET请求的地址不是类似http:// ,而是以ws://开头的地址</li><li>请求头Connection: Upgrade和请求头Upgrade: websocket表示这个连接将要被转换为Websocket连接</li><li>Sec-Websocket-Key是用于标识这个连接，是一个BASE64编码的密文，要求服务端响应一个对应加密的Sec-WebSocket-Accept头信息作为应答</li><li>Sec-WebSocket-Version 指定了Websocket的协议版本;</li><li>101状态码表明服务端已经识别并切换为websocket协议</li><li>Sec-Websocket-Accept是服务端与客户端致的秘钥计算出来的信息</li></ul></li></ul><h3 id="11-2Tomcat的Websocket"><a href="#11-2Tomcat的Websocket" class="headerlink" title="11.2Tomcat的Websocket"></a>11.2Tomcat的Websocket</h3><ul><li><p>Tomcat的7.0.5版本开始支持Websocket, 并且实现了Java Websocket规范(JSR356)，而在7.0.5版本之前(7.0.2之后)则采用自义API，即webSocketServlet实现。</p></li><li><p>Java WebSocket应用由一系列的WebSocketEndpoint组成。Endpoint 是一个java对象，代表WebSocket链接的一端,对于服务端,我们可以视为处理具体Websocket消息的接口，就像servlet之与http请求一样</p></li><li><p>我们可以通过两种方式定义Endpoint</p><ul><li>第一种是编程式，即继承类javax.websocket.Endpoint并实现其方法</li><li>第二种是注解式，即定义一-个POJO,并添加@ServerEndpoint相关注解</li></ul></li><li><p>Endpoint实例在WebSocket握手时创建，并在客户端与服务端链接过程中有效,最后在链接关闭时结束。在Endpoint接口中明确定义了与其生命周期相关的方法，规范实现者确保生命周期的各个阶段调用实例的相关方法。生命周期方法如下:</p><table><thead><tr><th>方法</th><th align="center">含义描述</th><th align="center">注解</th></tr></thead><tbody><tr><td>onOpen</td><td align="center">当开启一个新的会话时调用，该访法是客户端与服务端握手成功后调用的方法</td><td align="center">@OnOpen</td></tr><tr><td>onClose</td><td align="center">当会话关闭时调用</td><td align="center">@OnClose</td></tr><tr><td>onError</td><td align="center">当连接过程中异常时调用</td><td align="center">@OnError</td></tr></tbody></table></li><li><p>通过为Session添加MessageHandler消息处理器来接收消息，当采用注解方式定义Endpoint时，我们还可以通过@onMessage注解指定接收消息的方法。发送消息则由RemoteEndpoint完成，其实例由Session维护，根据使用情况，我们可以通过session. getBasicRemote获取同步消息发送的实例，然后调用其sendXxx()方法就可以发送消息，可以通过session. getAsyncRemote获取异步消息发送实例。</p></li></ul><h3 id="11-3-WebSocket-Demo"><a href="#11-3-WebSocket-Demo" class="headerlink" title="11.3.WebSocket Demo"></a>11.3.WebSocket Demo</h3><ul><li>实现简易网络聊天室</li></ul><h4 id="11-3-1-实现流程"><a href="#11-3-1-实现流程" class="headerlink" title="11.3.1.实现流程"></a>11.3.1.实现流程</h4><p><img src="1576204060195.png" alt="1576204060195"></p><h4 id="11-3-2-数据格式"><a href="#11-3-2-数据格式" class="headerlink" title="11.3.2. 数据格式"></a>11.3.2. 数据格式</h4><ul><li><p>客户端–&gt;服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;fromName&quot;:&quot;Deng&quot;,&quot;toName&quot;:&quot;HEIMA&quot;,&quot;content&quot;:&quot;约会呀&quot;&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务端–&gt;客户端:</p><ul><li>如果type为user， 则说明返回的是用户列表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;data&quot;:&quot;HEIMA,Deng,ITCAST&quot;,&quot;toName&quot;:&quot;&quot;,&quot;fromName&quot;:”&quot;,&quot;type&quot;: &quot;user&quot;&#125;</span><br></pre></td></tr></table></figure><ul><li>如果type为message ，则说明返回的是消息内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;data&quot;:&quot;你好&quot;,&quot;toName&quot;:&quot;HEIMA&quot;,&quot;fromName&quot;:&quot;Deng&quot;,&quot;type&quot;:&quot;message&quot;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Tomcat–Q-amp-A"><a href="#Tomcat–Q-amp-A" class="headerlink" title="Tomcat–Q&amp;A"></a>Tomcat–Q&amp;A</h2><h3 id="CATALINA-HOME和CATALINA-BASE区别？"><a href="#CATALINA-HOME和CATALINA-BASE区别？" class="headerlink" title="CATALINA_HOME和CATALINA_BASE区别？"></a>CATALINA_HOME和CATALINA_BASE区别？</h3><ul><li>CATALINA_HOME是Tomcat的安装目录</li><li>CATALINA_BASE是Tomcat的工作目录</li><li>Tomcat安装目录中<ul><li>/conf，/logs，/temp，/work，/webapps是实例私有的</li><li>/lib和/bin是实例共享的</li></ul></li><li>需要在一台机器上面部署多个Tomcat实例，但是又不想创建多个Tomcat软件——Tomcat副本拥有自己的工作目录但是共享Tomcat的代码</li></ul>]]></content>
    
    <summary type="html">
    
      Tomcat安全 Tomcat性能调优 Websocket
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Tomcat" scheme="http://goldcarpenter.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>JavaIO</title>
    <link href="http://goldcarpenter.github.io/2020/02/02/javaIO/"/>
    <id>http://goldcarpenter.github.io/2020/02/02/javaIO/</id>
    <published>2020-02-02T09:55:36.000Z</published>
    <updated>2020-06-17T07:16:32.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-File类"><a href="#1-File类" class="headerlink" title="1.File类"></a>1.File类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ul><li><code>java.io.File</code> 类是<strong>文件和目录</strong>路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作</li><li>File类是一个与系统无关的类，任何的操作系统都可以使用这个类中的方法</li></ul><h2 id="1-2静态成员变量"><a href="#1-2静态成员变量" class="headerlink" title="1.2静态成员变量"></a>1.2静态成员变量</h2><ul><li><code>static String pathSeparator</code>：与系统有关的路径分隔符，为了方便，它被表示为一个字符串。</li><li><code>static char pathSeparatorChar</code>：与系统有关的路径分隔符。</li><li><code>static string separator</code>：与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。</li><li><code>static char separatorChar：</code>与系统有关的默认名称分隔符。</li></ul><h2 id="1-3-构造方法"><a href="#1-3-构造方法" class="headerlink" title="1.3 构造方法"></a>1.3 构造方法</h2><ul><li><code>public File(String pathname)</code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的File实例。  </li><li><code>public File(String parent, String child)</code> ：拼接 <strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</li><li><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。  </li><li>构造举例，代码如下：</li></ul><blockquote><ol><li>无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li><li>路径可以是以文件结尾，也可以是以文件夹结尾</li><li>路径可以是相对路径,也可以是绝对路径</li><li>路径可以是存在，也可以是不存在</li><li>创建File对象，只是把字符串路径封装为File对象，不考虑路径的真假情况</li></ol></blockquote><h2 id="1-4-常用方法"><a href="#1-4-常用方法" class="headerlink" title="1.4 常用方法"></a>1.4 常用方法</h2><h3 id="1-4-1获取功能的方法"><a href="#1-4-1获取功能的方法" class="headerlink" title="1.4.1获取功能的方法"></a>1.4.1获取功能的方法</h3><ul><li><code>public String getAbsolutePath()</code> ：返回此File的<strong>绝对路径名字</strong>符串。</li><li><code>public String getPath()</code> ：将此File转换为<strong>绝对/相对路径名字</strong>符串，<code>toString</code>调用此方法实现。 </li><li><code>public String getName()</code>  ：返回由此File表示的<strong>文件或目录的名称</strong>。  </li><li><code>public long length()</code>  ：返回由此File表示的<strong>文件的大小</strong>，字节单位。 </li></ul><blockquote><p>API中说明：length()——表示文件的大小。但是File对象表示目录，则返回值0。</p></blockquote><h3 id="1-4-2绝对路径和相对路径"><a href="#1-4-2绝对路径和相对路径" class="headerlink" title="1.4.2绝对路径和相对路径"></a>1.4.2绝对路径和相对路径</h3><ul><li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li><li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilePath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// D盘下的bbb.java文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"D:\\bbb.java"</span>);</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 项目下的bbb.java文件</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"bbb.java"</span>);</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">D:\bbb.java</span><br><span class="line">D:\idea_project_test4\bbb.java</span><br></pre></td></tr></table></figure><h3 id="1-4-3判断功能的方法"><a href="#1-4-3判断功能的方法" class="headerlink" title="1.4.3判断功能的方法"></a>1.4.3判断功能的方法</h3><ul><li><code>public boolean exists()</code> ：此File表示的<strong>文件或目录是否实际存在</strong>。</li><li><code>public boolean isDirectory()</code> ：此File表示的<strong>是否为目录</strong>。</li><li><code>public boolean isFile()</code> ：此File表示的<strong>是否为文件</strong>。</li></ul><blockquote><p>isFile() &amp; isDirectory() 使用前提，路径必须是存在的，否则都返回false</p></blockquote><h3 id="1-4-4创建删除功能的方法"><a href="#1-4-4创建删除功能的方法" class="headerlink" title="1.4.4创建删除功能的方法"></a>1.4.4创建删除功能的方法</h3><ul><li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，<strong>创建一个新的空文件</strong>。 <ul><li>只能创建文件，不能创建文件夹</li><li>创建文件的路径必须存在，否则会抛出异常</li><li>文件存在，不会创建，返回false</li></ul></li><li><code>public boolean delete()</code> ：<strong>删除</strong>由此File表示的<strong>文件或目录</strong>。  <ul><li>如果此File表示目录，文件夹中有内容，不会删除返回false，目录必须为空才能删除</li><li>构造方法中路径不存在，返回false</li><li>直接在硬盘删除文件/文件夹，不走回收站，删除要谨慎</li></ul></li><li><code>public boolean mkdir()</code> 【不常用】：<strong>创建</strong>由此File表示的<strong>单级目录</strong>。<ul><li>文件夹存在，不会创建，返回false</li><li>构造方法中给出的路径不存在，返回false</li></ul></li><li><code>public boolean mkdirs()</code> 【常用】：创建由此File表示的目录，<strong>包括任何必需但不存在的父目录</strong>。<ul><li>既可以创建单级文件夹，也可以创建多级文件夹</li></ul></li></ul><h2 id="1-5目录的遍历"><a href="#1-5目录的遍历" class="headerlink" title="1.5目录的遍历"></a>1.5目录的遍历</h2><ul><li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li><li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">"d:\\java_code"</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取当前目录下的文件以及文件夹的名称。</span></span><br><span class="line">String[] names = dir.list();</span><br><span class="line"><span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>调用遍历方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</li><li>可以遍历到隐藏的文件夹</li></ol></blockquote><h2 id="1-6文件过滤器实现"><a href="#1-6文件过滤器实现" class="headerlink" title="1.6文件过滤器实现"></a>1.6文件过滤器实现</h2><ul><li><code>java.io.FileFilter</code>是一个接口，File过滤器。 该接口的对象可以传递给File类<code>listFiles(FileFilter)</code> 作为参数， 接口中只有一个方法。</li><li><code>boolean accept(File pathname)</code> ：测试pathname是否应该包含在当前File目录中，符合则返回true。</li></ul><p><strong>分析</strong>：</p><ol><li>接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。</li><li><code>accept</code>方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则：<ol><li>要么是.java文件。</li><li>要么是目录，用于继续遍历。</li></ol></li><li>通过过滤器的作用，<code>listFiles(FileFilter)</code>返回的数组元素中，子文件对象都是符合条件的，可以直接打印。</li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">"D:\\aaa"</span>);</span><br><span class="line">        printDir2(dir);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDir2</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 匿名内部类方式,创建过滤器子类对象</span></span><br><span class="line">        File[] files = dir.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pathname.getName().endsWith(<span class="string">".java"</span>)||pathname.isDirectory();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="comment">// 循环打印</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"文件名:"</span> + file.getAbsolutePath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                printDir2(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-7文件过滤器实现Lambda优化"><a href="#1-7文件过滤器实现Lambda优化" class="headerlink" title="1.7文件过滤器实现Lambda优化"></a>1.7文件过滤器实现Lambda优化</h2><p><strong>分析：</strong><code>FileFilter</code>是只有一个方法的接口，因此可以用lambda表达式简写。</p><p>lambda格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()-&gt;&#123; &#125;</span><br></pre></td></tr></table></figure><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDir3</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// lambda的改写</span></span><br><span class="line">    File[] files = dir.listFiles(f -&gt;&#123; </span><br><span class="line">      <span class="keyword">return</span> f.getName().endsWith(<span class="string">".java"</span>) || f.isDirectory(); </span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 循环打印</span></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"文件名:"</span> + file.getAbsolutePath());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        printDir3(file);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-IO流"><a href="#2-IO流" class="headerlink" title="2.IO流"></a>2.IO流</h1><h2 id="2-1IO的分类"><a href="#2-1IO的分类" class="headerlink" title="2.1IO的分类"></a>2.1IO的分类</h2><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p><ul><li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </li><li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li></ul><p>格局数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p><ul><li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li><li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li></ul><h2 id="2-2顶级父类"><a href="#2-2顶级父类" class="headerlink" title="2.2顶级父类"></a>2.2顶级父类</h2><table><thead><tr><th align="center"></th><th align="center"><strong>输入流</strong></th><th align="center">输出流</th></tr></thead><tbody><tr><td align="center"><strong>字节流</strong></td><td align="center">字节输入流<br/><strong>InputStream</strong></td><td align="center">字节输出流<br/><strong>OutputStream</strong></td></tr><tr><td align="center"><strong>字符流</strong></td><td align="center">字符输入流<br/><strong>Reader</strong></td><td align="center">字符输出流<br/><strong>Writer</strong></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      File类 IO流结构
    
    </summary>
    
    
      <category term="Java基础" scheme="http://goldcarpenter.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://goldcarpenter.github.io/tags/Java/"/>
    
      <category term="IO" scheme="http://goldcarpenter.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat</title>
    <link href="http://goldcarpenter.github.io/2020/01/20/Tomcat_Part2/"/>
    <id>http://goldcarpenter.github.io/2020/01/20/Tomcat_Part2/</id>
    <published>2020-01-19T16:00:00.000Z</published>
    <updated>2020-06-19T14:06:18.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="4-Tomcat服务器配置"><a href="#4-Tomcat服务器配置" class="headerlink" title="4. Tomcat服务器配置"></a>4. Tomcat服务器配置</h2><h3 id="4-1-server-xml"><a href="#4-1-server-xml" class="headerlink" title="4.1.server.xml"></a>4.1.server.xml</h3><ul><li>server.xml是tomcat服务器的核心配置文件。包含了Tomcat的servlet容器( Catalina )的所有配置</li></ul><h4 id="4-1-1-Server"><a href="#4-1-1-Server" class="headerlink" title="4.1.1.Server"></a>4.1.1.Server</h4><ul><li><code>Server</code>是server.xml的根元素。用于创建一个Server实例，默认使用的实现类是<code>org.apache.catalina.core.Standardserver</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8005"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>port : Tomcat 监听的关闭服务器的端口。<br>shutdown:关闭服务器的指令字符串。</p><ul><li><p>Server内嵌的子元素为Listener, GlobaINamingResources，Service</p><ul><li>Listener</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 用于以日志形式输出服务器 操作系统 JVM的版本信息</span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"># 用于加载(服务器启动)和销毁(服务器停止) APP如果找不到APP库 则会输出日志，并不影响Tomcat启动 </span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> <span class="attr">SSLEngine</span>=<span class="string">"on"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"># 用于避免JRE内存泄漏问题</span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"># 用户加载(服务器启动)和销照(服务器停止) 全局命名服务</span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"># 用于在Context停止时重建Executor池中的线程，以避免Threedlocal 相关的内存泄漏</span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>GlobalNamingResources中定义了全局命名服务</p></li><li><p>Service：一个server服务器.可以包含多个service服务</p></li></ul></li></ul><h4 id="4-1-2-Service"><a href="#4-1-2-Service" class="headerlink" title="4.1.2.Service"></a>4.1.2.Service</h4><ul><li>该元素用于创建<code>service</code>实例，默认使用<code>org.apache.catalina.core.StandardService</code>.默认情况下 , Tomcat仅指定了Service的名称，值为”Catalina”。</li><li>Service 可以内嵌的元素为: Listener，Executor，Connector，Engine <ul><li>Listener用于为Service添加生命周期监听器</li><li>Executor 用于配置Service共享线程池</li><li>Connector用于配置service包含的链接器</li><li>Engine用于配置Service中链接器对应的Servlet容器引擎</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-1-3-Executor"><a href="#4-1-3-Executor" class="headerlink" title="4.1.3.Executor"></a>4.1.3.Executor</h4><ul><li>默认情况下, Service并未添加共享线程池配置。如果我们想<strong>添加一个线程池</strong>，可以在&lt;Service&gt; 添加如下配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">"tomcatThreadPool"</span></span></span><br><span class="line"><span class="tag"><span class="attr">namePrefix</span>=<span class="string">"catalina-exec-"</span></span></span><br><span class="line"><span class="tag"><span class="attr">maxThreads</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag"><span class="attr">minSpareThreads</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag"><span class="attr">maxIdleTime</span>=<span class="string">" 60000"</span></span></span><br><span class="line"><span class="tag"><span class="attr">maxQueueSize</span>=<span class="string">"Integer.MAX_VALUE"</span></span></span><br><span class="line"><span class="tag"><span class="attr">prestartminSpareThreads</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag"><span class="attr">threadPriority</span>=<span class="string">"5"</span></span></span><br><span class="line"><span class="tag"><span class="attr">className</span>=<span class="string">"org.apache.catalina.core.StandardThreadExecutor"</span>/&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">属性</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">线程池名称,用于Connector中指定</td></tr><tr><td align="center">namePrefix</td><td align="center">所创建的每个线程的名称前缀，一个单独的线程名称为namePrefix+threadNumber</td></tr><tr><td align="center">maxThreads</td><td align="center">池中最大线程数</td></tr><tr><td align="center">minSpareThreads</td><td align="center">活跃线程数/核心池线程数,这些线程不会被销毁会直存在</td></tr><tr><td align="center">maxIdleTime</td><td align="center">线程空闲时间,超过该时间后,空闲线程会被销毁,默认值为6000 ( 1分钟) , 单位毫秒。</td></tr><tr><td align="center">maxQueueSize</td><td align="center">在被执行前最大线程排队数目，默认为Int的最大值，也就是广义的无限。除非特殊情况,这个值不需要更改 否则会有请求不会被处理的情况发生</td></tr><tr><td align="center">prestartminSpareThreads</td><td align="center">启动线程池时是否启动minSpareThreads部分线程。默认值为false ,即不启动</td></tr><tr><td align="center">threadPriority</td><td align="center">线程池中线程优先级,默认值为5 ,值从1到10</td></tr><tr><td align="center">className</td><td align="center">线程池实现类,未指定情况下,默认实现类为org.apache.catalina.core.StandardThreadexecutor.如果想使用自定义线程池首先需要实现org.apache.catalina.Executor接口</td></tr></tbody></table><ul><li>如果不配置共享线程池，那么catalina各组件在用到线程池时会独立创建</li></ul><h4 id="4-1-4-Connector"><a href="#4-1-4-Connector" class="headerlink" title="4.1.4 Connector"></a>4.1.4 Connector</h4><ul><li>Connector用于创建链接器实例。默认情况下, server.xml配置了两个链接器, 一个支持Http协议，一个支持AJP协议。因此大多数情况下,我们并不需要新增链接器配置,只是根据需要对已有链接器进行优化。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> <span class="attr">executor</span>=<span class="string">"tomcatThreadPool"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>属性说明:</p><ul><li>port: 端口号, Connector用于创建服务端Socket并进行监听，以等待客户端请求链接。 如果该属性设置为0 , Tomcat将会随机选择一个可用的端口号给当前Connector使用</li><li>connectionTimeout: connector 接收链接后的等待超时时间，单位为毫秒。-1 表示不超时。</li><li>redirectPort: 当前connector不支持ssl请求，接收到了一个请求，并且也符合security-constraint约束，需要ssl传输，Catalina自动将请求重定向到指定的端口</li><li>executor :指定共享线程池的名称，也可以通过maxThreads，minSpareThreads 等属性配置内部线程池。</li><li>URIEncoding :用于指定编码URI的字符编码， Tomcat8.x版本默认的编码为UTF-8</li><li>protocol :当前Connector支持的访问协议。默认为HTTP/1.1，并采用自动切换机制选择一个基于JAVA NIO的链接器或者基于本地APR的链接器(根据本地是否含有Tomcat的本地库判定)。</li></ul></li><li><p>如果不希望采用上述自动切换的机制，而是明确指定协议 ，可以使用以下值</p><ul><li>Http协议</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.apache.coyote.http11.Http11NioProtocol   非阻塞式Java NIO链接器</span><br><span class="line">org.apache.coyote.http1l.Http11Nio2Protocol  非阻塞式JAVA NIO2链掖器</span><br><span class="line">org.apache.coyote.httpll.Http11AprProtocol  APR链接器</span><br></pre></td></tr></table></figure><ul><li>AJP协议</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.apache.coyote.ajp.AjpNioProtocol   非阻塞式Java NIO链按器</span><br><span class="line">org.apeche.coyote.ajp.AjpNio2Protocol 非阻塞式JAVA NI02链接器</span><br><span class="line">org.apache.coyote.ajp.AjpAprprotocolAPR链接器</span><br></pre></td></tr></table></figure></li><li><p>完整配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">executor</span>=<span class="string">"tomcatThreadPool"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">maxThreads</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">minSpareThreads</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">acceptCount</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">maxConnections</span>=<span class="string">"1000”</span></span></span><br><span class="line"><span class="tag"><span class="string">    connectionTimeout="</span><span class="attr">20000</span>"</span></span><br><span class="line"><span class="tag">    <span class="attr">compression</span>=<span class="string">"on"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">compreae1onM1n512e</span>=<span class="string">"2048"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">disableUplondT</span> <span class="attr">imeout</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">redirectPort</span>=<span class="string">"8443"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">URIEncoding</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-1-5-Engine"><a href="#4-1-5-Engine" class="headerlink" title="4.1.5 Engine"></a>4.1.5 Engine</h4><ul><li>Engine作为Servlet引擎的顶级元素,内部可以嵌入: Cluster，Listener，Realm, Valve和Host</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Engine name&#x3D;&quot;Catalina&quot; defaultHost&#x3D;&quot;localhost&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;&#x2F;Engine&gt;</span><br></pre></td></tr></table></figure><ul><li>属性说明:<ul><li>name: 用于指定Engine的名称，默认为catalina 。该名称会影响一部分Tomcat的存储路径 (如临时文件)</li><li>defaultHost :默认使用的虚拟主机名称，当客户端请求指向的主机无效时，将交由默认的虚拟主机处理， 默认为loalhost。</li></ul></li></ul><h4 id="4-1-6-Host"><a href="#4-1-6-Host" class="headerlink" title="4.1.6 Host"></a>4.1.6 Host</h4><ul><li>Host元素用于配置一个虚拟主机，它支持以下嵌入元素: Alias、Cluster、 Listener、 Valve、 Realm, Context。 </li><li>如果在Engine下配置Realm，那么此配置将在当前Engine 下的所有Host中共享。</li><li>同样 。如果在Host中配置Realm，则在当前Host 下的所有Context中共享。</li><li>Context中的Realm优先級&gt; Host的Realm优先级&gt; Engine中的Realm优先级。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Host name&#x3D;&quot;localhost&quot;  appBase&#x3D;&quot;webapps&quot; unpackWARs&#x3D;&quot;true&quot; autoDeploy&#x3D;&quot;true&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;\Host&gt;</span><br></pre></td></tr></table></figure><ul><li><p>属性说明:</p><ul><li>name:当前Host通用的网络名称，必须与DNS服务器 上的注册信息一致。Engine中包含的Host必须存在一个名称与Engine的defaultHost设置一致</li><li>appBase: 当前Host的应用基础目录，当前Host上部署的web应用均在该目录下(可以是绝对目录,相对路径)。默认为webapps。</li><li>unpackWARs: 设置为true，Host在启动时会将appBase目录下war包解压为目录。设置为false, Host将直接从war文件启动。</li><li>autoDeploy :控制tomcat是否在运行时定期检测并自动部署新增或变更的web应用。</li></ul></li><li><p>通过给Host添加别名。我们可以实现同-个Host拥有多个网络名称,配置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Host name&#x3D;&quot;www.web1.com&quot;  appBase&#x3D;&quot;webapps&quot; unpackWARs&#x3D;&quot;true&quot; autoDeploy&#x3D;&quot;true&quot;&gt;</span><br><span class="line">&lt;Alias&gt;www.web1.com&lt;&#x2F;Alias&gt;</span><br><span class="line">&lt;\Host&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-1-7-Context"><a href="#4-1-7-Context" class="headerlink" title="4.1.7 Context"></a>4.1.7 Context</h4><ul><li>Context用于配置一个Web应用 。默认的配置如下:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context docBase&#x3D;&quot;myApp&quot; path&#x3D;&quot;&#x2F;myApp&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;\Context&gt;</span><br></pre></td></tr></table></figure><ul><li>属性描述:<ul><li>docBase : web应用目录或者war包的部署路径。可以是绝对路径,也可以是相对于Host appBase的相对路径。</li><li>path : web应用的Context路径。如果我们Host名为localhost，则该web应用访问的根路径为 : <a href="http://localhost:8080/myApp" target="_blank" rel="noopener">http://localhost:8080/myApp</a></li></ul></li><li>它支持的内嵌元索为: CookieProcessor, Loader, Manager , Realm, Resources , WatchedResource，JarScanner , VaIve</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Host name&#x3D;&quot;www.tomcat.com&#39; appBase&#x3D;&quot;webapps&quot; unpackWARs&#x3D;&quot;true&quot; autoDeploy&#x3D;&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;Context docBase&#x3D;&quot;D:\servlet_project03&quot; path&#x3D;&quot;&#x2F;myApp&quot;&gt;&lt;&#x2F;Context&gt;</span><br><span class="line"></span><br><span class="line">&lt;Valve className&#x3D;&quot;org.apache.catalina.valves.AccessLogValve&quot; directory&#x3D;&quot;logs&quot; prefix&#x3D;&quot;localhost_access_log&quot; suffix&#x3D;&quot;.txt&quot;</span><br><span class="line">pattern&#x3D;&quot;&amp;h %l %u %t &quot;%r%quot; %s &amp;b&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;Host&gt;</span><br></pre></td></tr></table></figure><h3 id="4-2-tomcat-users-xml"><a href="#4-2-tomcat-users-xml" class="headerlink" title="4.2. tomcat-users.xml"></a>4.2. tomcat-users.xml</h3><ul><li>该配置文件中。主要配置的是Tomcat的用户，角色等信息。用来控制Tomcat中manager，host-manager的访问权限。</li></ul><h2 id="5-Web配置文件"><a href="#5-Web配置文件" class="headerlink" title="5.Web配置文件"></a>5.Web配置文件</h2><ul><li><code>web.xml</code>是web应用的描述文件，它支持的元素及属性来自于Servlet规范定义。</li><li>在Tomcat中，web应用的描述信息包括<strong>tomcat/conf/web.xml</strong>中默认配置以及Web应用<strong>WEB-INF/web. xml下</strong>的定制配置</li></ul><h3 id="5-1-ServletContext初始化参数"><a href="#5-1-ServletContext初始化参数" class="headerlink" title="5.1.ServletContext初始化参数"></a>5.1.ServletContext初始化参数</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>project_param_01<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String value &#x3D; req.getServletContext().getInitParameter(&quot;project_param_01&quot;);</span><br></pre></td></tr></table></figure><h3 id="5-2会话配置"><a href="#5-2会话配置" class="headerlink" title="5.2会话配置"></a>5.2会话配置</h3><p><code>&lt;session-config&gt;</code>用于配置web应用会话,包括超时时间，Cookie配置以及会话追踪模式。它将覆盖server.xml和context.xml中的配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cookie-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>JESSIONID<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">domain</span>&gt;</span>www.itcast.cn<span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">comment</span>&gt;</span>Session Cookie<span class="tag">&lt;/ <span class="attr">comment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">http-only</span>&gt;</span>true<span class="tag">&lt;/<span class="name">http-only</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">secure</span>&gt;</span>false<span class="tag">&lt;/<span class="name">secure</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">max-age</span>&gt;</span>3600<span class="tag">&lt;/<span class="name">max-age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cookie-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tracking-mode</span>&gt;</span>COOKIE<span class="tag">&lt;/<span class="name">tracking-mode</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1) session-timeout 会话超时时间,单位分钟</span><br><span class="line">2) cookie-config用于配置会话追踪Cookie</span><br><span class="line">3) name Cookie的名称</span><br><span class="line">4) domain  Cookie的域名</span><br><span class="line">5) path  Cookie的路径</span><br><span class="line">6) comment 注释</span><br><span class="line">7) http-only  cookie只能通过HTTP方式进行访问，Js无法读取或修改，此项可以增加网站访问的安全性</span><br><span class="line">8) secure 此cookie只能通过HTTPs连接传递到服务器,而HTTP连接则不会传递该信息。注意是从浏览器传递到服务器，服务器端的Cookie对象不受此项影响</span><br><span class="line">9) max-age 以秒为单位表示cookie的生存期，默认为-1表示是会话Cookie ,浏览器关闭时就会消失</span><br><span class="line">10) tracking-mode 用于配置会话追踪模式，Servlet3.0版本中支持的追踪模式 COOKIE、 URL、 SSL</span><br><span class="line">1.COOKIE——通过HTTP Cookie 追踪会话是最常用的会话追踪机制，而且servlet规范也要求所有的Servlet规范都需要支持Cookie追踪。</span><br><span class="line">    2.URL——URL重写是最基本的会话追踪机制。当客户端不支持Cookie时，可以采用URI重写的方式。当采用URL追踪模式时,请求路径需要包含会话标识信息，Servlet容器会根据路径中的会话标识设置请求的会话信息。如:</span><br><span class="line">    http:&#x2F;&#x2F;www.myserver.com&#x2F;user&#x2F;index.html;jessionid&#x3D;1234567890</span><br><span class="line">    3.SSL——对于ssL请求，通过ssl会话标识确定请求会话标识</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String session &#x3D; req.getSession().getId()</span><br></pre></td></tr></table></figure><h3 id="5-3-Servlet配置"><a href="#5-3-Servlet配置" class="headerlink" title="5.3. Servlet配置"></a>5.3. Servlet配置</h3><ul><li>Servlet的配置主要是两部分，servlet 和servlet-mapping</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-c1ass</span>&gt;</span>cn.itcast.web.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span>此处的初始化参数只对本Servlet有效</span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>fileName<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">value</span>&gt;</span>init.conf<span class="tag">&lt;/<span class="name">param</span> <span class="attr">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ur1-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ur1-pattern</span>&gt;</span>/myservet/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) servlet-name  指定servlet的名称 该属性在web.xml中唯一</span><br><span class="line">2) servlet-class用于指定servlet类名</span><br><span class="line">3) init-param用于指定servlet的初始化参数，在应用中可以通过HttpServlet.getInitParameter获取</span><br><span class="line">4) load-on-startup  用于控制在Web应用启动时，Servlet的加载顺序 值小于0第一次访问时加载</span><br><span class="line">5) enabled:true&#x2F;false 若为false 表示servlet不处理任何请求</span><br></pre></td></tr></table></figure><h3 id="5-4-Listener配置"><a href="#5-4-Listener配置" class="headerlink" title="5.4 Listener配置"></a>5.4 Listener配置</h3><ul><li><p>Listener用于监听servlet中的事件，例如context，request，session对象的创建、修改、删除，并触发响应事件。</p></li><li><p>Listener是<strong>观察者模式</strong>的实现，在Servlet中主要用于对context、request、 session对象的生命周期进行监控。在servlet2.5规范中共定义了8种Listener。</p></li><li><p>在启动时, servletContextListener的执行顺序与web.xml中的配置顺序一致，停止时执行顺序相反</p></li></ul><h3 id="5-5-Filter配置"><a href="#5-5-Filter配置" class="headerlink" title="5.5 Filter配置"></a>5.5 Filter配置</h3><ul><li>Filter用于配置web应用过滤器，用来过滤资源请求及响应。经常用于认证、日志、加密、数据转换等操作，配置如下:</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.itcast.web.MyFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>language<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>CN<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) filter-name 用于指定过滤器名称 在web.xml中，过滤器名称必须唯一</span><br><span class="line">2) filter-class 过滤器的全限定类名，该类必须实现Filter接口</span><br><span class="line">3) async-supported该过滤器是否支持异步</span><br><span class="line">4) init-param 用于配置Filter的初始化参数 可以配置多个 可以通过Fi lterConfig.getInitParameter获取</span><br><span class="line">5) ur1-pattern指定该过滤器需要拦截的URL</span><br></pre></td></tr></table></figure><h3 id="5-6欢迎页面配置"><a href="#5-6欢迎页面配置" class="headerlink" title="5.6欢迎页面配置"></a>5.6欢迎页面配置</h3><ul><li><p>welcome- file-list用于指定web应用的欢迎文件列表</p><ul><li>尝试请求的顺序,从上到下</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-7错误页面配置"><a href="#5-7错误页面配置" class="headerlink" title="5.7错误页面配置"></a>5.7错误页面配置</h3><ul><li>error-page用于配置web应用访问异常时定向到的页面,支持HTTP响应码和异常类两种形式。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;<span class="name">error-code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">location</span>&gt;</span>/500.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exception-type</span>&gt;</span>java.lang.Exception<span class="tag">&lt;/<span class="name">exception-type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-Tomcat-管理配置"><a href="#6-Tomcat-管理配置" class="headerlink" title="6.Tomcat 管理配置"></a>6.Tomcat 管理配置</h2><ul><li><p>从早期的Tomcat版本开始,就提供了web版的管理控制台,他们是两个独立的web应用,位于webapps目录下</p></li><li><p>Tomcat 提供的管理应用有用于<strong>管理Host的host-manager</strong>和用于<strong>管理web应用的manager</strong></p><p><img src="1576044964425.png" alt="1576044964425"></p></li></ul><h3 id="6-1-host-manager"><a href="#6-1-host-manager" class="headerlink" title="6.1 host-manager"></a>6.1 host-manager</h3><ul><li>Tomcat启动之后,可以通过<a href="http://localhost:8080/host-manager/html访问该Web应用。" target="_blank" rel="noopener">http://localhost:8080/host-manager/html访问该Web应用。</a></li></ul><p><img src="1576045815612.png" alt="1576045815612"></p><ul><li>host-manager 默认添加了访问权限控制，当打开网址时,需要输入用户名和密码( conf/tomcat-users.xml中配置)。所以要想访问该页面,需要在conf/tomcat-users.xml中配置,并分配对应的角色:<ul><li>admin-gui :用于控制页面访问权限</li><li>admin-script :用于控制以简单文本的形式进行访问</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># conf&#x2F;tomcat-users.xml</span><br><span class="line"></span><br><span class="line">&lt;role rolename&#x3D;&quot;admin-gui&quot;&#x2F;&gt;</span><br><span class="line">&lt;role rolename&#x3D;&quot;admin-script&quot;&#x2F;&gt;</span><br><span class="line">&lt;user username&#x3D;&quot;yyx&quot; passwd&#x3D;&quot;123456&quot; role&#x3D;&quot;admin-script,admin-gui&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p><img src="1576047327639.png" alt="1576047327639"></p><p><img src="1576046944691.png" alt="1576046944691"></p><h3 id="6-2-manager"><a href="#6-2-manager" class="headerlink" title="6.2. manager"></a>6.2. manager</h3><ul><li>manager的访问地址为<a href="http://localhost:8080/manager，同样，manager也添加了" target="_blank" rel="noopener">http://localhost:8080/manager，同样，manager也添加了</a> 页面访问控制,因此我们需要为登录用户分配角色</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># conf&#x2F;tomcat-users.xml</span><br><span class="line"></span><br><span class="line">&lt;role rolename&#x3D;&quot;manager-gui&quot;&#x2F;&gt;</span><br><span class="line">&lt;role rolename&#x3D;&quot;manager-script&quot;&#x2F;&gt;</span><br><span class="line">&lt;user username&#x3D;&quot;yyx&quot; password&#x3D;&quot;123456&quot; roles&#x3D;&quot;admin-script,admin-gui,manager-gui,manager-script&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><ul><li>登录查看web应用</li></ul><p><img src="1576047290767.png" alt="1576047290767"></p><p><img src="1576047723908.png" alt="1576047723908"></p><ul><li>查看Server状态</li></ul><p><img src="1576048474484.png" alt="1576048474484"></p><p><img src="1576048503640.png" alt="1576048503640"></p><h2 id="7-JVM配置"><a href="#7-JVM配置" class="headerlink" title="7.JVM配置"></a>7.JVM配置</h2><ul><li>最常见的JVM配置当属内存分配,因为在绝大多数情况下, JVM默认分配的内存可能不能够满足我们的需求,特别是在生产环境,此时需要手动修改Tomcat启动时的内存参数分配</li></ul><h3 id="7-1-JVM内存模型图"><a href="#7-1-JVM内存模型图" class="headerlink" title="7.1. JVM内存模型图"></a>7.1. JVM内存模型图</h3><p><img src="1576048846734.png" alt="1576048846734"></p><h3 id="7-2-JVM配置选项"><a href="#7-2-JVM配置选项" class="headerlink" title="7.2. JVM配置选项"></a>7.2. JVM配置选项</h3><ul><li>Windows平台（catalina.bat）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set JAVA_OPTS&#x3D;-server -Xms2048m -Xmx2048m -XX:MetaspaceSize&#x3D;256m -XX:MaxMetaspaceSize&#x3D;256m -XX:SurvivorRatio&#x3D;8</span><br></pre></td></tr></table></figure><ul><li>linux平台（catalina.sh）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS&#x3D;&quot;-server -Xms1024m -Xmx2048m -XX:MetaspaceSize&#x3D;256m -XX:MaxMetaspaceSize&#x3D;512m  -XX:SurvivorRatio&#x3D;8&quot;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">序号</th><th align="center">参数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">-Xms</td><td align="center">堆内存的初始大小</td></tr><tr><td align="center">2</td><td align="center">-Xmx</td><td align="center">堆内存的最大大小</td></tr><tr><td align="center">3</td><td align="center">-Xmn</td><td align="center">新生代的内存大小，官方建议是整个堆得3/8。</td></tr><tr><td align="center">4</td><td align="center">-XX:MetaspaceSize</td><td align="center">元空间内存初始大小，在JDK1. 8版本之前配置为-xx:Permsize (永久代)</td></tr><tr><td align="center">5</td><td align="center">-XX:MaxMetaspaceSize</td><td align="center">元空间内存最大大小，在JDK1 .8版本之前配置为-Xx:MaxPermsize (永久代}</td></tr><tr><td align="center">6</td><td align="center">-XX:NewRatio</td><td align="center">设置新生代和老年代的相对大小比例。这种方式的优点是新生代大小会随着整个堆大小动态扩展。如-XX:NewRatio=3 指定老年代/新生代为3/1。老年代占堆大小的3/4.新生代占1/4。</td></tr><tr><td align="center">7</td><td align="center">-XX:SurvivoRatio</td><td align="center">指定伊甸园区(Eden) 与幸存区大小比例。如-XX:survivorRatio=10 表示伊甸园区(Eden) 是幸存区To大小的10 倍(也是幸存区From 的10倍)。所以，伊甸园区(Eden) 占新生代大小的10/12， 幸存区From和幸存区To每个占新生代的1/12。注意， 两个幸存区永远是一样大的。</td></tr></tbody></table><p><img src="1576051053125.png" alt="1576051053125"></p><h2 id="8-Tomcat集群"><a href="#8-Tomcat集群" class="headerlink" title="8.Tomcat集群"></a>8.Tomcat集群</h2><h3 id="8-1-介绍"><a href="#8-1-介绍" class="headerlink" title="8.1. 介绍"></a>8.1. 介绍</h3><ul><li>由于单台Tomcat的承载能力是有限的，当我们的业务系统用户量比较大，请求压力比较大时，单台Tomcat是扛不住的,这个时候,就需要搭建Tomcat的集群,而目前比较流程的做法就是通过Nginx来实现tomcat集群的负载均衡。</li></ul><p><img src="1576052233452.png" alt="1576052233452"></p><h3 id="8-2-环境准备"><a href="#8-2-环境准备" class="headerlink" title="8.2.环境准备"></a>8.2.环境准备</h3><h4 id="8-2-1-准备多台Tomcat"><a href="#8-2-1-准备多台Tomcat" class="headerlink" title="8.2.1. 准备多台Tomcat"></a>8.2.1. 准备多台Tomcat</h4><ul><li><p>在服务器上，安装两台tomcat【复制两个Tomcat目录】，然后分别改Tomcat服务器的端口号</p><p><img src="1576054953362.png" alt="1576054953362"></p><ul><li>关闭命令监听端口</li></ul><p><img src="1576054717113.png" alt="1576054717113"></p><ul><li><p>HTTP监听端口</p><p><img src="1576054744011.png" alt="1576054744011"></p></li><li><p>AJP监听端口</p><p><img src="1576054764258.png" alt="1576054764258"></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原配置         Tomcat1      Tomcat2</span><br><span class="line">8005 ---------&gt; 8015 ---------&gt; 8025</span><br><span class="line">8080 ---------&gt; 8888 ---------&gt; 9999</span><br><span class="line">8009 ---------&gt; 8019 ---------&gt; 8029</span><br></pre></td></tr></table></figure><p><img src="1576055872117.png" alt="1576055872117"></p><p><img src="1576055904020.png" alt="1576055904020"></p></li></ul><h4 id="8-2-2-准备Nginx"><a href="#8-2-2-准备Nginx" class="headerlink" title="8.2.2. 准备Nginx"></a>8.2.2. 准备Nginx</h4><ul><li><p>在当前服务器上，安装Nginx，然后再配置Nginx,配置nginx.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">upstream serverpool&#123;</span><br><span class="line">server localhost:8888;</span><br><span class="line">server localhost:9999;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">listen 99;</span><br><span class="line">server_name localhost;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;serverpool&#x2F;;# 反向代理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1576056073323.png" alt="1576056073323"></p></li></ul><h3 id="8-3-负载均衡策略"><a href="#8-3-负载均衡策略" class="headerlink" title="8.3. 负载均衡策略"></a>8.3. 负载均衡策略</h3><ul><li><p>轮询</p><ul><li>最基本的配置方法,它是upstream模块默认的负载均衡默认策略。每个请求会按时间顺序逐一分配到不同的后端服务器。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream serverpool&#123;</span><br><span class="line">server localhost:8888;</span><br><span class="line">server localhost:9999;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center"></th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">fail_timeout</td><td align="center">与max_fails结合使用</td></tr><tr><td align="center">max_fails</td><td align="center">设置在fail_timeout参数设置的时间内最大失败次数,如果在这个时间内,所有针对该服务器的请求都失败了,那么认为该服务器会被认为是停机了</td></tr><tr><td align="center">fail_time</td><td align="center">服务器会被认为停机的时间长度,默认为10s</td></tr><tr><td align="center">backup</td><td align="center">标记该服务器为备用服务器。当主服务器停止时，请求会被发送到它这里</td></tr><tr><td align="center">down</td><td align="center"></td></tr></tbody></table></li><li><p>weight权重</p><ul><li>权重方式,在轮询策略的基础上指定轮询的几率</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream serverpool&#123;</span><br><span class="line">server localhost:8888 weight&#x3D;3;</span><br><span class="line">server localhost:9999 weight&#x3D;2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>weight参数用于指定轮训几率, weight的默认值为1 ;</li><li>weight的数值与访问比率成正比</li><li>此策略比较适合服务器的硬件配置差别比较大的情况</li></ul></li><li><p>ip_hash</p><ul><li>指定负载均衡器按照基于客户端IP的分配方式</li><li>这个方法确保了相同的客户端的请求一直发送到相同的服务器,以保证session会话。</li><li>这样每个访客都固定访问一个后端服务器,可以解决session不能跨服务器的问题。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream serverpool&#123;</span><br><span class="line">ip_hash;</span><br><span class="line">server 192.168.192.133:8080weight&#x3D;3;</span><br><span class="line">server 192.168.192.137:8080 weight&#x3D;2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-4-Session共享方案"><a href="#8-4-Session共享方案" class="headerlink" title="8.4.Session共享方案"></a>8.4.Session共享方案</h3><ul><li>在Tomcat集群中,如果应用需要用户进行登录,那么这个时候,用于tomcat做了负载均衡,则用户登录并访问应用系统时,就会出现问题</li></ul><p><img src="1576135360218.png" alt="1576135360218"></p><h4 id="8-4-1-ip-hash-策略"><a href="#8-4-1-ip-hash-策略" class="headerlink" title="8.4.1 ip_hash 策略"></a>8.4.1 ip_hash 策略</h4><ul><li>一个用户发起的请求,只会请求到tomcatA上进行操作，另一个用户发起的请求只在tomcatB上进行操作。那么这个时候,同一个用户发起的请求。都会通过nginx的ip_ hash策略,将请求转发到其中的一台Tomcat上。</li></ul><h4 id="8-4-2-Session复制"><a href="#8-4-2-Session复制" class="headerlink" title="8.4.2. Session复制"></a>8.4.2. Session复制</h4><ul><li>在sexvlet_demo01工程中，制作seession.jsp页面。分别将工程存放在两台tomcat的webapps/目录下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language&#x3D;&quot;java&quot; contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;</span><br><span class="line">         pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;login&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">TOMCAT---A&#x2F;B</span><br><span class="line">sessionID: &lt;%&#x3D; session.getId() %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    Object loginUser &#x3D; session.getAttribute(&quot;loginUser&quot;);</span><br><span class="line">    if(loginUser !&#x3D; null &amp;&amp; loginUser.toString().length()&gt;0) &#123;</span><br><span class="line">        out.println(&quot;session有值，loginUser &#x3D;&quot; + loginUser);&#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        session.setAttribute(&quot;loginUser&quot;,&quot;ITCAST&quot;);</span><br><span class="line">        out.println(&quot;session没有值&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><ul><li><p>配置小规模Session复制负载均衡</p><ul><li><p>配置前</p><ul><li>第一次访问8888Tomcat</li></ul><p><img src="1576137216858.png" alt="1576137216858"></p><ul><li>第一次访问9999Tomcat——之前访问8888记录未同步——session无值</li></ul><p><img src="1576137248739.png" alt="1576137248739"></p></li><li><p>配置</p><ul><li>在conf/server.xml文件中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Cluster className&#x3D;&quot;org.apache.catalina.ha.top.SimpleTopCluster&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><ul><li>在工程web.xml中，增加一行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;distributable&#x2F;&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置后</p><ul><li>第一次访问8888Tomcat</li></ul><p><img src="1576137111345.png" alt="1576137111345"></p><ul><li>第一次访问9999Tomcat——之前访问8888记录同步——session有值</li></ul><p><img src="1576137138658.png" alt="1576137138658"></p></li></ul></li><li><p>Session复制实现Session共享弊端</p><ul><li>适用于较小的集群环境(节点数不超过4个) </li><li>如果集群的节点数比较多的话,通过<strong>这种广播的形式</strong>来完成session的复制，会消耗大量的网络带宽,影响服务的性能</li></ul></li></ul><h4 id="8-4-3-SSO-单点登录【重点】"><a href="#8-4-3-SSO-单点登录【重点】" class="headerlink" title="8.4.3.SSO-单点登录【重点】"></a>8.4.3.SSO-单点登录【重点】</h4><ul><li>单点登录(Single Sign On) , 简称为SSO，是目前比较流行的企业业务整合的解决方案之一。</li><li>SSO的定义是在多个应用系统中,用户只需要登录一次就可以访问所有相互信任的应用系统,也是用来解决集群环境session共享的方案之一</li></ul><p><img src="1576137868773.png" alt="1576137868773"></p>]]></content>
    
    <summary type="html">
    
      Tomcat服务器配置 Web配置文件 Tomcat管理配置 JVM配置 Tomcat集群
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Tomcat" scheme="http://goldcarpenter.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat</title>
    <link href="http://goldcarpenter.github.io/2020/01/11/Tomcat_Part1/"/>
    <id>http://goldcarpenter.github.io/2020/01/11/Tomcat_Part1/</id>
    <published>2020-01-10T16:00:00.000Z</published>
    <updated>2020-06-19T14:04:49.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="1-Tomcat目录结构"><a href="#1-Tomcat目录结构" class="headerlink" title="1.Tomcat目录结构"></a>1.Tomcat目录结构</h2><table><thead><tr><th>目录</th><th>目录下文件</th><th>说明</th></tr></thead><tbody><tr><td>bin</td><td>/</td><td>存放Tomcat的启动、停止等批处理脚本文件</td></tr><tr><td></td><td>startup.bat/startup.sh</td><td>用于在windows和Iinux下的启动脚本</td></tr><tr><td></td><td>shutdown.bat/shutdown. sh</td><td>用于在windows和linus下的停止脚本</td></tr><tr><td>conf</td><td>/</td><td>用于存放Tomcat的相关配置文件</td></tr><tr><td></td><td>Catalina</td><td>用于存储针对每个虚拟机的context配置</td></tr><tr><td></td><td>logging.properties</td><td>Tomcat的日志配置文件，可以通过该文件修改tomcat的日志级别及日志路径等</td></tr><tr><td></td><td>server.xml</td><td>Tomcat服务器的核心配置文件</td></tr><tr><td></td><td>tomcat-users.xml</td><td>定义Tomcat默认的用户及角色映射信息配置</td></tr><tr><td></td><td>web.xml</td><td>Tomcat中所有应用默认的部署描述文件，主要定义了基础servlet和时</td></tr><tr><td></td><td>context.xml</td><td>用于定义所有web应用均需加载的context配置，如果web应用指定了自己的context. xml该文件将被覆盖</td></tr><tr><td></td><td>catalina.policy</td><td>Tomcat运行的安全策略配置</td></tr><tr><td></td><td>catalina.properties</td><td>Tomcat的环境变量配置l</td></tr><tr><td>lib</td><td>/</td><td>Tomcat服务器的依赖包</td></tr><tr><td>logs</td><td>/</td><td>Tomcat默认的日志存放目录</td></tr><tr><td>webapps</td><td>/</td><td>Tomcat默认的web应用部署目录</td></tr><tr><td>work</td><td>/</td><td>Web应用JSP代码生成和编译的临时目录</td></tr></tbody></table><h2 id="2-Tomcat整体架构"><a href="#2-Tomcat整体架构" class="headerlink" title="2.Tomcat整体架构"></a>2.Tomcat整体架构</h2><h3 id="2-1-Http服务器处理请求"><a href="#2-1-Http服务器处理请求" class="headerlink" title="2.1.Http服务器处理请求"></a>2.1.Http服务器处理请求</h3><ul><li><p>浏览器发给服务端的是一个Http格式的请求，Http服务器收到这个请求后，需要调用服务端程序来处理</p></li><li><p>所谓的服务端程序就是程序员写的Java类，一般来说不同的请求需要由不同的Java类来处理</p></li><li><p>如何确定所需要调用的业务Java代码？</p><p><img src="1575856821617.png" alt="1575856821617"></p><ul><li><p>左图方案✖</p><ul><li>Http服务器<strong>直接调用</strong>具体业务类，存在过多的if…else…判断，<strong>紧耦合</strong></li></ul></li><li><p>右图方案✔</p><ul><li>Http服务器不直接调用业务类，而把请求交给Servlet容器处理，Servlet容器通过Servlet接口调用业务类</li><li>因此Servlet接口和servlet容器的出现，达到了Http服务器与业务类解耦的目的</li><li>Servlet接口和Servlet容器这一整套规范叫作Servlet规范</li><li>Tomcat按照Servlet规范的要求实现了Servlet容器，同时它们也具有HTTP服务器的功能</li><li><strong>作为Java程序员</strong>。如果要实现新的业务功能，只需要<strong>实现一个Servlet</strong> ,并将Servlet<strong>注册到Tomcat (Servlet容器)</strong>中，剩下的事情就由Tomcat帮我们处理了</li></ul></li></ul></li></ul><h3 id="2-2-Servlet容器工作流程"><a href="#2-2-Servlet容器工作流程" class="headerlink" title="2.2.Servlet容器工作流程"></a>2.2.Servlet容器工作流程</h3><ul><li>为了解耦，Http服务器不直接调用Servlet，而是把请求交给servlet容器来处理，那<strong>Servlet容器又是怎么工作</strong>的呢?<ul><li>当客户请求某个资源时 HTTP服务器会用一个ServletRequest对象把客户的<strong>请求信息封装</strong>起来,然后<strong>调用Servlet容器的service方法</strong></li><li><strong>【定位Servlet】</strong>Servlet容器拿到请求后,根据<strong>请求的URL和Servlet的映射关系</strong>,找到相应的Servlet </li><li><strong>【加载Servlet】</strong>如果servlet还没有被加载,就用反射机制<strong>创建这个Servlet</strong>，并调用Servlet的init方法来完成<strong>初始化</strong></li><li><strong>【调用Servlet】</strong>接着<strong>调用Servlet的service方法来处理请求</strong>，把servletResponse对象返回给HTTP服务器, HTTP服务器会把响应发送给客户端。</li></ul></li></ul><p><img src="1575857441906.png" alt="1575857441906"></p><h3 id="2-3-Tomcat整体架构"><a href="#2-3-Tomcat整体架构" class="headerlink" title="2.3.Tomcat整体架构"></a>2.3.Tomcat整体架构</h3><ul><li><p>我们知道如果要设计一个系统，首先是要了解需求，我们已经了解了Tomcat要实现两个核心功能:</p><ul><li>处理socket连接 ,负责网络字节流与Request和Response对象的转化</li><li>加载和管理Servlet ,以及具体处理Request请求</li></ul></li><li><p>因此Tomcat设计了两个核心组件连接器( Connector )和容器( Container )来分别做这两件事情。</p><ul><li>连接器负责对外交流</li><li>容器负责内部处理</li></ul><p><img src="1575857998509.png" alt="1575857998509"></p></li></ul><h3 id="2-4-连接器–Coyote"><a href="#2-4-连接器–Coyote" class="headerlink" title="2.4.连接器–Coyote"></a>2.4.连接器–Coyote</h3><h4 id="2-4-1-架构介绍"><a href="#2-4-1-架构介绍" class="headerlink" title="2.4.1.架构介绍"></a>2.4.1.架构介绍</h4><ul><li>Coyote是Tomcat的连接器框架的名称，是Tomcat服务器提供的供客户端访问的外部按口。客户端通过coyote与服务器建立连接、发送请求并接受响应</li><li>Coyote封装了底层的网络通信(Socket请求及响应处理) , 为Catalina容器提供了统一的接口，使Catalina容器与<strong>具体的请求协议</strong>及<strong>IO操作方式完全解耦</strong></li><li>Coyote将Socket输入转换封装为Request对象，交由Catalina容号进行处理，处理请求完成后，Catalina通过Coyote提供的Response对象将结果写入输出流</li><li><strong>Coyote</strong>作为独立的模块，只负责具体协议和IO的相关操作，<strong>与Servlet规范实现没有直接关系</strong>，因此即便是<strong>Request和Response对象也并未实现servlet规范对应的接口</strong>，而是在<strong>Catalina中将他们进一步封装为ServletRequest 和ServletResponse</strong>。</li></ul><p><img src="1575858473531.png" alt="1575858473531"></p><h4 id="2-4-2-IO模型与协议"><a href="#2-4-2-IO模型与协议" class="headerlink" title="2.4.2.IO模型与协议"></a>2.4.2.IO模型与协议</h4><ul><li><p>在Coyote中，Tomcat支持的多种I/O模型和应用层协议</p><ul><li>在8.0之前，Tomcat默认采用的I/O方式为BIO</li></ul><p><img src="1575859048452.png" alt="1575859048452"></p></li><li><p>Tomcat支持的I/O模型（自8.5/9.0版本起，Tomcat移除了对BIO的支持）</p><table><thead><tr><th align="center">IO模型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">NIO</td><td align="center">非阻塞I/O，采用Java NIO类库实现【8.5默认】</td></tr><tr><td align="center">NIO2</td><td align="center">异步I/O，采用JDK 7最新的NIO2类实现</td></tr><tr><td align="center">APR</td><td align="center">采用Apache可移植运行库实现，是C/C++编写的本地库。如果选择该方案，需要单独安装</td></tr></tbody></table></li><li><p>Tomcat支持的应用层协议:</p><table><thead><tr><th align="center">应用层协议</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">HTTP/1.1</td><td align="center">这是大部分Web应用采用的访问协议</td></tr><tr><td align="center">AJP</td><td align="center">用于和Web服务器集成(如Apache )。以实现对静态资源的优化以及集群部著，当前支持AJP/1.3</td></tr><tr><td align="center">HTTP/2</td><td align="center">HTTP 2. 0大幅度的提升了Web性能。下一代HTTP协议 ，自8 .5以及9.0版本之后支持</td></tr></tbody></table></li><li><p><strong>Tomcat为了实现支持多种I/O模型和应用层协议，一个容器可能对接多个连接器</strong>, 类比一个房间有多个门</p></li><li><p>单独的连接器或者容器都不能对外提供服务,需要把它们组装起来才能工作，<strong>组装后这个整体叫作Service组件</strong>。这里请你注意, Service本身没有做什么重要的事情，只是在连接器和容器外面多包了一层,把它们组装在一起</p></li><li><p>Tomcat内可能有多个Service ,这样的设计也是出于灵活性的考虑。通过在Tomcat中配置多个Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用</p></li></ul><h4 id="2-4-3-连接器组件"><a href="#2-4-3-连接器组件" class="headerlink" title="2.4.3.连接器组件"></a>2.4.3.连接器组件</h4><p><img src="1575860153258.png" alt="1575860153258"></p><ul><li><p>连接器中的各个组件的作用如下</p><ul><li><p>Endpoint </p><ul><li>Coyote 通信端点，即<strong>通信监听的接口</strong>，是<strong>具体socket接收和发送处理器</strong>，是对<strong>传输层的抽象</strong>，因此Endpoint用来实现<strong>TCP/IP协议</strong>的</li><li>Tomcat并没有EndPoint接口，而是提供了一个抽象类AbstractEndpoint，里面定义了两个内部类: Acceptor和SocketProcessor。<ul><li>Acceptor用于监听Socket连接请求。</li><li>SocketProcessor用于<strong>处理接收到的Socket请求,它实现Runnable接口</strong>。在Run方法里调用协议处理组件Processor进行处理。为了提高处理能力, <strong>Socketprocessor被提交到线程池来执行</strong>，而这个线程池叫作执行器(Executor) </li></ul></li></ul></li><li><p>Processor</p><ul><li>Coyote<strong>协议处理接口</strong>，如果说EndPoint是用来实现Tcp/Ip协议的，那么Processor用来<strong>实现Http/AJP协议</strong></li><li><strong>Processor接收来自EndPoint的Socket ,读取字节流解析成Tomcat Request和Response对象 ，并通过Adapter将其提交到容器处理</strong>，Processor是对<strong>应用层协议的抽象</strong>。</li></ul></li><li><p>ProtocolHandler</p><ul><li>Coyote协议接口，通过Endpoint和Processor，实现针对具体协议的处理能力。 </li><li>Tomcat<strong>按照协议和I/O提供了6个实现类</strong>: AjpNioProtocol，AjpAprprotocol，AjpNio2Protocol ，Http11Nioprotocol ，Http11Nio2Protocol , Http11AprProtocol</li><li>我们在配置<code>tomcat/conf/server.xml</code>时，至少要指定具体的<code>ProtocolHandler</code>，当然也可以指定协议名称，如: <code>HTTP/1.1</code>, 如果安装了APR，那么将使用<code>Http11AprProtocol</code>，否则<br>使用<code>Http11NioProtocol</code>。</li></ul></li><li><p>Adapter</p><ul><li>由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat定义了自己的Request类来”存放”这些请求信息。</li><li><strong>ProtocolHandler接口负责解析请求并生成Tomcat Request类</strong>。但是这个Request对象不是标准的ServletRequest，也就意味着不能用Tomcat Request作为参数来调用容器。</li><li>Tomcat设计者的解决方案是引入CoyoteAdapter，这是<strong>适配器模式</strong>的经典运用，连接器调用CoyoteAdapter的Sevice方法，传入的是Tomcat Request对象，CoyoteAdapter负责将Tomcat Request转成ServletRequest，再调用容器的Service方法</li></ul></li></ul></li></ul><h3 id="2-5容器–Catalina"><a href="#2-5容器–Catalina" class="headerlink" title="2.5容器–Catalina"></a>2.5容器–Catalina</h3><ul><li>Tomcat是由一系列可配置的组件构成的Web容器，而catalina是Tomcat的Servlet容器。</li><li>Catalina是Servlet容器实现，包含了之前讲到的所有的容器组件。以及后续章节涉及到的安全、会话、集群、管理等servlet容器架构的各个方面。</li><li>它通过松耦合的方式<strong>集成Coyote</strong>。以完成按照请求协议进行数据读写。同时,它还包括我们的启动入口、shell程序等。</li></ul><h4 id="2-5-1Catalina地位"><a href="#2-5-1Catalina地位" class="headerlink" title="2.5.1Catalina地位"></a>2.5.1Catalina地位</h4><ul><li><p>Tomcat本质上就是一款Servlet容器，因此catalina才是Tomcat的核心，其他模块都是为Catalina提供支撑的。比如：通过Coyote模块提供链接通信，Jasper模块提供Jsp引擎，Naming提供JNDI服务，Juli提供日志服务。</p><p><img src="1575862360805.png" alt="1575862360805"></p></li></ul><h4 id="2-5-2Catalina结构"><a href="#2-5-2Catalina结构" class="headerlink" title="2.5.2Catalina结构"></a>2.5.2Catalina结构</h4><ul><li>Catalina负责管理Server ,而Server表示着整个服务器。</li><li>Server下面有多个服务Service。每个服务都包含着多个连接器组件Connector (coyote实现)和一个容器组件Container</li><li>在Tomcat启动的时候，会初始化一个Catalina的实例</li></ul><p><img src="1575862500322.png" alt="1575862500322"></p><ul><li><p>Catalina各个组件的职责</p><table><thead><tr><th align="center">组件</th><th align="center">职责</th></tr></thead><tbody><tr><td align="center">Catalina</td><td align="center">负责解析Tomcat的配置文件，以此来创建服务器Server组件,并根据命令来对其进行管理</td></tr><tr><td align="center">Server</td><td align="center"><strong>表示整个Catalina Servlet容器以及其它组件</strong>，负责组装并启动servlet引擎，Tomcat连接器。Server通过实现Lifecycle接口，提供了一种优雅的启动和关闭整个系统的方式</td></tr><tr><td align="center">Service</td><td align="center">是Server内部的组件，一个Server包含多个Service。它<strong>将若干个Connector组件绑定到一个Container (Engine)上</strong></td></tr><tr><td align="center">Connector</td><td align="center">处理与客户端的通信，它负责接收客户请求，然后转给相关的容器处理，最后向客户返回响应结果</td></tr><tr><td align="center">Container</td><td align="center">负责处理用户的servlet请求,并返回对象给Web用户的模块</td></tr></tbody></table></li></ul><h4 id="2-5-3-Container结构"><a href="#2-5-3-Container结构" class="headerlink" title="2.5.3.Container结构"></a>2.5.3.Container结构</h4><ul><li>Tomcat设计了4种容器，分别是Engine，Host，Context和Wrapper</li><li>这4种容器不是平行关系，而是父子关系</li><li>Tomcat通过一种分层的架构，使得servlet容器具有很好的灵活性</li></ul><p><img src="1575863290356.png" alt="1575863290356"></p><ul><li><p>各个组件含义</p><table><thead><tr><th align="center">容器</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Engine</td><td align="center">表示整个Catalina的servlet引擎，用来管理多个虚拟站点，一个<strong>Service最多只能有一个Engine</strong>，但是<strong>一个引擎可包含多个Host</strong></td></tr><tr><td align="center">Host</td><td align="center">代表一个虚拟主机/站点。可以给Tomcat配置多个虚拟主机地址，而一个<strong>虚拟主机下可包含多个Context</strong></td></tr><tr><td align="center">Context</td><td align="center">表示个Web应用程序，<strong>一个Web应用可包含多个wrapper</strong></td></tr><tr><td align="center">Wrapper</td><td align="center">表示一个Servlet，Wrapper作为容眼中的最底层，不能包含子容器</td></tr></tbody></table><ul><li>可以通过Tomcat的Server.xml配置文件来加深对Tomcat容器的理解</li><li>Tomcat采用了组件化的设计,它的构成组件都是可配置的，其中最外层的是Server ,其他组件按照一定的格式要求配置在这个顶层容器中</li></ul></li><li><p>Tomcat是怎么管理这些容器?</p><p><img src="1575864506324.png" alt="1575864506324"></p><p>Container接口部分方</p><p><img src="1575864576618.png" alt="1575864576618"></p><ul><li>这些容器具有父子关系，形成一个树形结构，Tomcat就是用<strong>组合模式</strong>来管理这些容器的</li><li>具体实现方法是,所有容器组件都实现了Container接口,因此组合模式可以使得用户对单容器对象和组合容器对象的使用具有一致性。</li><li>这里单容器对象指的是最底层的wrapper ,组合容器对象指的是上面的Context、Host或者Engine</li></ul></li></ul><h3 id="2-6-Tomcat启动流程"><a href="#2-6-Tomcat启动流程" class="headerlink" title="2.6.Tomcat启动流程"></a>2.6.Tomcat启动流程</h3><h4 id="2-6-1流程"><a href="#2-6-1流程" class="headerlink" title="2.6.1流程"></a>2.6.1流程</h4><ul><li>加载Tomcat的配置文件，初始化容器组件，监听对应的端口号，准备接受客户端请求</li></ul><p><img src="1575864794356.png" alt="1575864794356"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- 启动tomcat，需要调用bin&#x2F;startup.bat (在linux目录下，需要调用bin&#x2F;startup.sh)，在startup.bat 脚本中，调用了catalina.bat</span><br><span class="line">- 在catalina.bat脚本文件中,调用了org.apache.catalina.startup.Bootstrap中的main方法</span><br><span class="line">- 在Bootstrap的main方法中调用了init方法，来创建catalina及初始化类加载器</span><br><span class="line">- 在Bootstrap的main方法中调用了load方法，在其中又调用了catalina的load方法</span><br><span class="line">- 在catalina的load方法中，需要进行一些初始化的工作，并需要构造Digester对象，用于解析XMI</span><br><span class="line">- 然后在调用后续组件的初始化操作</span><br><span class="line">Server----------------------------&gt;</span><br><span class="line">Service---------------------------&gt;</span><br><span class="line">    Engine------------------------&gt;</span><br><span class="line">    Host--------------------------&gt;</span><br><span class="line">    Context-----------------------&gt;</span><br><span class="line">Executor--------------------------&gt;</span><br><span class="line">Connector-------------------------&gt;</span><br><span class="line">ProtocolHandler-------------------&gt;</span><br></pre></td></tr></table></figure><h4 id="2-6-2-源码解析"><a href="#2-6-2-源码解析" class="headerlink" title="2.6.2.源码解析"></a>2.6.2.源码解析</h4><h5 id="2-6-2-1-Lifecycle"><a href="#2-6-2-1-Lifecycle" class="headerlink" title="2.6.2.1.Lifecycle"></a>2.6.2.1.Lifecycle</h5><ul><li><p>由于所有的组件均存在初始化、启动、停止等生命周期方法，拥有生命周期管理的特性</p></li><li><p>所以Tomcat在设计的时候，基于生命周期管理抽象成了一个接口Lifecycle , 而组件Server、Service, Container，Executor，Connector组件，都实现了一个生命周期的按口</p></li><li><p>从而具有了以下生命周期中的核心方法:</p><ul><li>init( ) :初始化组件</li><li>start( ) :启动组件</li><li>stop( ) :停止组件</li><li>destroy( ) :销毁组件</li></ul><p><img src="1575876412558.png" alt="1575876412558"></p></li><li><p>各个组件的默认实现</p><ul><li><p>上面我们提到的server，service，Engine，Host，Context都是接口，下图中罗列了这些接口的默认实现类</p><p><img src="1575876680679.png" alt="1575876680679"></p></li><li><p>当前对于Endpoint组件来说，在Tomcat中没有对应的Endpoint接口，但是有一个抽象类AbstractEndpoint , 其下有三个实现类：NioEndpoint，Nio2Endpoint，AprEndpoint，这三个实现类分别对应于前面讲解链接器Coyote时，提到的链接器支持的三种IO模型 : NIO，NIO2 , APR，Tomcat8 .5版本中,默认采用的是NioEndpoint</p></li><li><p>ProtocolHandler : Coyote协议接口通过封装Endpoint和Processor，实现针对具体协议的处理功能。 Tomcat按照协议和IO提供 了6个实现类</p><p><img src="1575877029611.png" alt="1575877029611"></p><ul><li>AjpNioProtocol————Ajp协议 采用NIO的IO模型</li><li>AjpNio2Protocol————Ajp协议 采用NIO2的IO模型</li><li>AjpAprprotocol————Ajp协议 采用APR的IO模型 依赖于APR库</li><li>Http11Nioprotocol————Http协议 采用NIO的IO模型 默认使用的协议</li><li>Http11Nio2Protocol————Http协议 采用NIO2的IO模型</li><li>Http11AprProtocol————Http协议 采用APR的IO模型 依赖于APR库</li></ul></li></ul></li></ul><h5 id="2-6-2-2-码源跟踪"><a href="#2-6-2-2-码源跟踪" class="headerlink" title="2.6.2.2.码源跟踪"></a>2.6.2.2.码源跟踪</h5><ul><li>初试化过程</li></ul><p><img src="1575882726340.png" alt="1575882726340"></p><p>进入bootstrap.init()–发现其创建Catalina对象</p><p><img src="1575882406344.png" alt="1575882406344"></p><p>返回main()继续</p><p><img src="1575882756992.png" alt="1575882756992"></p><p>进入BootStrap的load()—–其调用了catalina对象load方法</p><p><img src="1575883061824.png" alt="1575883061824"></p><p>打开catalina类</p><p><img src="1575883116511.png" alt="1575883116511"></p><p><img src="1575883199087.png" alt="1575883199087"></p><p>在load()重载方法中</p><p><img src="1575883484958.png" alt="1575883484958"></p><p>catalina的load方法中初始化了Server</p><p><img src="1575883581006.png" alt="1575883581006"></p><p>进入init()方法—发现是个接口</p><p><img src="1575885115518.png" alt="1575885115518"></p><p>进入</p><p><img src="1575885142269.png" alt="1575885142269"></p><p>发现使用模板方法——将共有的逻辑抽象到父类中 在子类中实现自身逻辑</p><p><img src="1575885165831.png" alt="1575885165831"></p><p>进入initInternal()——寻找StandardServer实现类中的initInternal()</p><p><img src="1575885323999.png" alt="1575885323999"></p><p>在Server的init()中初始化services</p><p><img src="1575885761324.png" alt="1575885761324"></p><p>进入init()方法—发现又一次进入到顶级接口</p><p><img src="1575885850910.png" alt="1575885850910"></p><p>进入实现LifecycleBase</p><p><img src="1575885886103.png" alt="1575885886103"></p><p>再次进入initInternal</p><p><img src="1575885959480.png" alt="1575885959480"></p><p><img src="1575885991376.png" alt="1575885991376"></p><p>查找Service的标准实现StandarService</p><p><img src="1575886056384.png" alt="1575886056384"></p><p>Service中执行内容很多了</p><p><img src="1575886227664.png" alt="1575886227664"></p><p>进入engine.init() executor.init()同理，此处跟踪connector.init()</p><p><img src="1575886351176.png" alt="1575886351176"></p><p><img src="1575886358791.png" alt="1575886358791"></p><p><img src="1575886389139.png" alt="1575886389139"></p><p><img src="1575886534305.png" alt="1575886534305"></p><p>进入protocolHandler.init()</p><p><img src="1575886609990.png" alt="1575886609990"></p><p>进入实现类</p><p><img src="1575886630318.png" alt="1575886630318"></p><p><img src="1575886660319.png" alt="1575886660319"></p><p>再进入super.init()—-发现初始化endpoint</p><p><img src="1575886848776.png" alt="1575886848776"></p><p>bind()方法又是一个模板方法</p><p><img src="1575886977143.png" alt="1575886977143"></p><p>选择默认IO模型</p><p><img src="1575887040151.png" alt="1575887040151"></p><p><img src="1575887148448.png" alt="1575887148448"></p><p>至此所有初始化代码跟踪结束</p><ul><li>start过程</li></ul><p>返回main()方法 上一个部分是从daemon.load()开始的 此次进入start()方法</p><p><img src="1575890204736.png" alt="1575890204736"></p><p>通过反射调用了catalina.start()方法</p><p><img src="1575890371487.png" alt="1575890371487"></p><p>找到catalina.start()方法</p><p><img src="1575890432430.png" alt="1575890432430"></p><p><img src="1575890496608.png" alt="1575890496608"></p><p>进入了Lifecycle接口</p><p><img src="1575890527631.png" alt="1575890527631"></p><p><img src="1575890578376.png" alt="1575890578376"></p><p><img src="1575890667219.png" alt="1575890667219"></p><p>进入startInternal()</p><p><img src="1575890726199.png" alt="1575890726199"></p><p>进入它的实现类</p><p><img src="1575890757251.png" alt="1575890757251"></p><p>调用了services.start()</p><p><img src="1575890832824.png" alt="1575890832824"></p><p>进入start()方法—-又回到了</p><p><img src="1575890886680.png" alt="1575890886680"></p><p>又回到了</p><p><img src="1575890578376.png" alt="1575890578376"></p><p>又回到了</p><p><img src="1575890667219.png" alt="1575890667219"></p><p>又回到了</p><p><img src="1575890726199.png" alt="1575890726199"></p><p>这次进入StanderService</p><p><img src="1575891019790.png" alt="1575891019790"></p><p><img src="1575891131058.png" alt="1575891131058"></p><p>直接进入connector.start()</p><p><img src="1575891203698.png" alt="1575891203698"></p><p><img src="1575891218702.png" alt="1575891218702"></p><p>进入Connector</p><p><img src="1575891240984.png" alt="1575891240984"></p><p><img src="1575891296313.png" alt="1575891296313"></p><p>进入protocolHandler.start()</p><p><img src="1575891354421.png" alt="1575891354421"></p><p><img src="1575891395735.png" alt="1575891395735"></p><p>进入start()</p><p><img src="1575891453431.png" alt="1575891453431"></p><p><img src="1575891495519.png" alt="1575891495519"></p><p><img src="1575891515862.png" alt="1575891515862"></p><p><img src="1575891820081.png" alt="1575891820081"></p><p>进入startAcceptorThreads()</p><p><img src="1575892033743.png" alt="1575892033743"></p><p>进入第一个Acceptor</p><p><img src="1575892087240.png" alt="1575892087240"></p><p>进入第二个位置createAcceptor();</p><p><img src="1575892126763.png" alt="1575892126763"></p><p><img src="1575892139788.png" alt="1575892139788"></p><p><img src="1575892177878.png" alt="1575892177878"></p><p><img src="1575892209984.png" alt="1575892209984"></p><p>在run方法中</p><p><img src="1575892270751.png" alt="1575892270751"></p><h4 id="2-6-3-总结"><a href="#2-6-3-总结" class="headerlink" title="2.6.3.总结"></a>2.6.3.总结</h4><ul><li>从启动流程图中以及源码中，我们可以看出Tomcat的启动过程非常标准化，统一按照生命周期管理按口lifecycle的定义进行启动。</li><li>首先调用init()方法进行组件的逐级初始化操作，然后再调用start ()方法进行启动。</li><li>每一级的组件除了完成自身的处理外，还要负责调用子组件响应的生命周期管理方法，组件与组件之间是松耦合的,因为我们可以很容易的通过配置文件进行修改和替换。</li></ul><h3 id="2-7-Tomcat请求处理流程"><a href="#2-7-Tomcat请求处理流程" class="headerlink" title="2.7.Tomcat请求处理流程"></a>2.7.Tomcat请求处理流程</h3><h4 id="2-7-1-流程"><a href="#2-7-1-流程" class="headerlink" title="2.7.1.流程"></a>2.7.1.流程</h4><ul><li><p>设计了这么多层次的容器，Tomcat是怎么确定每一个请求应该由哪个wrapper容器里的servlet来处理的呢 ?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tomcat是用Mapper组件来完成这个任务的</span><br></pre></td></tr></table></figure></li><li><p>Mapper组件的功能就是将用户请求的Url定位到一个servlet ,它的工作原理</p><p><img src="1575948416448.png" alt="1575948416448"></p><ul><li>多层次的Map</li><li>Mapper组件里保存了web应用的配置信息 其实就是容器组件与访问路径的映射关系</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host容器里配置的域名</span><br><span class="line">Context容器里的web应用路径</span><br><span class="line">Wrapper容器里serv1et映射的路径</span><br></pre></td></tr></table></figure></li><li><p>当一个请求到来时，Mapper组件通过解析请求URL里的域名和路径，再到自己保存的Map里去查找,就能定位到一个Servlet。</p></li><li><p>一个请求URL最后只会定位到一个Wrapper容器，也就是一个Servlet</p></li><li><p>例子</p><p><img src="1575948580587.png" alt="1575948580587"></p></li></ul><p><img src="1575948697559.png" alt="1575948697559"></p><p><img src="1575948667654.png" alt="1575948667654"></p><p><img src="1575948754162.png" alt="1575948754162"></p><p><img src="1575948797543.png" alt="1575948797543"></p><p><img src="1575948840243.png" alt="1575948840243"></p><ul><li>总体分为两个部分</li></ul><p><img src="1575948939914.png" alt="1575948939914"></p><p><img src="1575949193321.png" alt="1575949193321"></p><h4 id="2-7-2-源码分析"><a href="#2-7-2-源码分析" class="headerlink" title="2.7.2.源码分析"></a>2.7.2.源码分析</h4><p><img src="1575964047495.png" alt="1575964047495"></p><ul><li><p>在前面所讲解的Tomca t的整体架构中,我们发现Tomcat中的各个组件各司其职,组件之间松耦合，确保了整体架构的可伸缩性和可拓展性,那么在组件内部,如何增强组件的灵活性和拓展性呢?</p></li><li><p>在Tomcat中 ,每个Container组件采用责任链模式来完成具体的请求处理。</p></li><li><p>在Tomcat中定义了Pipeline和valve两个接口，Pipeline用于构建责任链，后者代表责任链 上的每个处理器。Pipeline中维护了一个基础的valve ,它始终位于Pipeline的末端(最后执行) , 封装了具体的请求处理和输出响应的过程。当然,我们也可以调用addvalve()方法，为pipeline 添加其他的valve，后添加的valve 位于基础的valve之前,并按照添加顺序执行。Pipiline通过获得首个valxe来启动整合链条的执行</p></li><li><p>在源码的Tomcat中部署一个Servlet，访问</p></li></ul><p><img src="1575961071432.png" alt="1575961071432"></p><p><img src="1575961080666.png" alt="1575961080666"></p><p><img src="1575960908595.png" alt="1575960908595"></p><p><img src="1575961520950.png" alt="1575961520950"></p><p><img src="1575961610352.png" alt="1575961610352"></p><p><img src="1575961671025.png" alt="1575961671025"></p><p><img src="1575961696209.png" alt="1575961696209"></p><p><img src="1575961859207.png" alt="1575961859207"></p><p><img src="1575962230435.png" alt="1575962230435"></p><p>进入process()</p><p><img src="1575962263145.png" alt="1575962263145"></p><p>在进入实现<img src="1575962415354.png" alt="1575962415354"></p><p><img src="1575962947827.png" alt="1575962947827"></p><p>进入process()</p><p><img src="1575963001666.png" alt="1575963001666"></p><p><img src="1575963100940.png" alt="1575963100940"></p><p>进入service()</p><p><img src="1575963219994.png" alt="1575963219994"></p><p><img src="1575963501254.png" alt="1575963501254"></p><p><img src="1575963622276.png" alt="1575963622276"></p><p>适配器对象调用service方法</p><p><img src="1575963739698.png" alt="1575963739698"></p><p><img src="1575963937143.png" alt="1575963937143"></p><p>getContainer()返回的就是Engine</p><p><img src="1575963986585.png" alt="1575963986585"></p><p><img src="1575964251337.png" alt="1575964251337"></p><p><img src="1575964294241.png" alt="1575964294241"></p><p><img src="1575964490993.png" alt="1575964490993"></p><p><img src="1575964614946.png" alt="1575964614946"></p><p>进入</p><p><img src="1575964691741.png" alt="1575964691741"></p><p>再次进入invoke()</p><p><img src="1575964490993.png" alt="1575964490993"></p><p><img src="1575964727634.png" alt="1575964727634"></p><p><img src="1575964793930.png" alt="1575964793930"></p><p><img src="1575964860165.png" alt="1575964860165"></p><p><img src="1575964893851.png" alt="1575964893851"></p><p><img src="1575964968995.png" alt="1575964968995"></p><p><img src="1575965021915.png" alt="1575965021915"></p><p><img src="1575965154876.png" alt="1575965154876"></p><p><img src="1575965288699.png" alt="1575965288699"></p><p><img src="1575965340001.png" alt="1575965340001"></p><p><img src="1575965568050.png" alt="1575965568050"></p><p><img src="1575965665102.png" alt="1575965665102"></p><p><img src="1575965730442.png" alt="1575965730442"></p><p><img src="1575965744638.png" alt="1575965744638"></p><p><img src="1575965808902.png" alt="1575965808902"></p><p><img src="1575966344598.png" alt="1575966344598"></p><p><img src="1575966387484.png" alt="1575966387484"></p><p><img src="1575966435890.png" alt="1575966435890"></p><h2 id="3-Jasper"><a href="#3-Jasper" class="headerlink" title="3.Jasper"></a>3.Jasper</h2><ul><li>对于基于Jsp的Web应用来说,我们可以直接在Jsp页面中编写Java代码，添加第三方的标签库，以及使用r工表达式。但是无论经过何种形式的处理, 最终输出到客户端的都是标准的ITML页面(包含js , css… )，并不包含任何的java相关的语法。也就是说 ，我们可以把jsp看做是一种运行在服务端的脚本。那么服务器是如何将Jsp页面转换为HTMI页面的呢?</li><li>Jasper模块是Tomcat的Jsp核心引擎,我们知道Jsp本质上是一个servlet。Tomcat使用Jasper对Jsp语法进行解析 ,生成servlet并生成class字节码,用户在进行访问jsp时,会访问servlet ,最终将访问的结果直接响应在浏览器端。</li><li>另外,在运行的时候, Jasper还会检测Jsp文件是否修改，如果修改，则会重新编译Jsp文件。</li></ul><h3 id="3-1-Jsp编译方式"><a href="#3-1-Jsp编译方式" class="headerlink" title="3.1.Jsp编译方式"></a>3.1.Jsp编译方式</h3><h4 id="3-1-1-运行时编译"><a href="#3-1-1-运行时编译" class="headerlink" title="3.1.1.运行时编译"></a>3.1.1.运行时编译</h4><ul><li>Tomcat并不会在启动jsp应用的时候自动编译jsp文件，而是在客户端第一次请求时 ，才编译需要访问的的jsp文件。</li></ul><h5 id="3-1-1-1-编译过程"><a href="#3-1-1-1-编译过程" class="headerlink" title="3.1.1.1.编译过程"></a>3.1.1.1.编译过程</h5><ul><li>Tomcat在默认的web.xml中配置了一个org.apache.jasper.servlet.JspServlet ,用于处理所有的.jsp或.jspx结尾的请求，该Servlet实现即是运行时编译的入口。</li></ul><p><img src="1575969024776.png" alt="1575969024776"></p><p><img src="1575969060980.png" alt="1575969060980"></p><ul><li><p>Jspservlet处理流程图:</p><p><img src="1575969193345.png" alt="1575969193345"></p></li></ul><p><img src="1575969517522.png" alt="1575969517522"></p><p><img src="1575969510275.png" alt="1575969510275"></p><p><img src="1575969612450.png" alt="1575969612450"></p><p>获取jsp文件路径</p><p><img src="1575969633235.png" alt="1575969633235"></p><p>是否是预编译请求</p><p><img src="1575969700425.png" alt="1575969700425"></p><p>进入serviceJspFlie</p><p><img src="1575969755938.png" alt="1575969755938"></p><p><img src="1575969831700.png" alt="1575969831700"></p><p>进入service方法 进入ctxt.compile()</p><p><img src="1575970502163.png" alt="1575970502163"></p><p><img src="1575970653059.png" alt="1575970653059"></p><p><img src="1575970729306.png" alt="1575970729306"></p><p><img src="1575970753129.png" alt="1575970753129"></p><p><img src="1575971217230.png" alt="1575971217230"></p><p>退回到ctxt.compile的下一行</p><p><img src="1575971506700.png" alt="1575971506700"></p><p><img src="1575971689979.png" alt="1575971689979"></p><p>放行到476 进入</p><p><img src="1575971765482.png" alt="1575971765482"></p><p><img src="1575971955537.png" alt="1575971955537"></p><p>执行我们的jsp的servlet</p><h5 id="3-1-1-2-编译结果"><a href="#3-1-1-2-编译结果" class="headerlink" title="3.1.1.2.编译结果"></a>3.1.1.2.编译结果</h5><ul><li>如果在tomcat/conf/web.xml中配置了参数scratchdir，则jsp编译后的结果就会存储在该目录下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;init-param&gt;</span><br><span class="line">&lt;par. am-name&gt; sora tahdir&lt;&#x2F;par am- name&gt;</span><br><span class="line">&lt;param-value&gt;D: &#x2F; tmp&#x2F;jsp&#x2F;&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;init -param&gt;</span><br></pre></td></tr></table></figure><ul><li>如果没有配置该选项，则会将编译后的结果,存储在Tomcat安装目录下的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tomcat安装目录&#x2F;work&#x2F;Catalina (Engine名称) &#x2F;localhost (Host名称)&#x2F;（Context名称）</span><br><span class="line"></span><br><span class="line">假设项目名称为jsp_demo_01，默认的目录为: work&#x2F;catalina&#x2F;localhost&#x2F;jsp_demo_01</span><br></pre></td></tr></table></figure><ul><li>如果使用的是IDEA开发工具集成tomcat访问web工程中的jsp，编译后的结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator\.IntelliJIdea2019.1\system\tomcat\_project_ tomcat\work\Catalina\localhost\jsp_demo_01_war_exploded\org\apache\jsp</span><br></pre></td></tr></table></figure><h4 id="3-1-2-预编译"><a href="#3-1-2-预编译" class="headerlink" title="3.1.2.预编译"></a>3.1.2.预编译</h4><ul><li>除了运行时编译，我们还可以直接在web应用启动时，一次性将web应用中的所有的Jse页面一次性编译完成。</li><li>在这种情况下, web应用运行过程中，使可以不必再进行实时编译,而是直接调用Jsp页面对应的servlet完成请求处理，从而提升 系统性能。</li><li>Tomcat提供了一个shell程序JspC。用于支持JSP预编译,而且在Tomcat的安装目录下提供了一个catalina-tasks.xml文件，声明了Tomcat支持的Ant任务，因此，我们很容易使用Ant来执行JSP 预编译。( 要想使用这种方式,必须得确保在此之前已经下载并安装了Apache Ant )。</li></ul><h3 id="3-2-JSP编译原理"><a href="#3-2-JSP编译原理" class="headerlink" title="3.2. JSP编译原理"></a>3.2. JSP编译原理</h3><ul><li><p>类名为index_jsp.java继承自org.apache.jasper . runtime.HttpJspBase，该类是HttpServlet的子类，所以Jsp本质就是一个servlet</p><p><img src="1576029721866.png" alt="1576029721866"></p><p><img src="1576029753033.png" alt="1576029753033"></p></li><li><p>通过属性_jspx_dependants 保存了当前Jsp页面依赖的资源，包含引入的外部的Jsp页面、 导入的标签、标签所在的jar包等，便于后续处理过程中使用（如重新编译检测,因此它以Map形式保存了每个资源的上次修改时间）</p><p><img src="1576029819498.png" alt="1576029819498"></p><p><img src="1576029834180.png" alt="1576029834180"></p></li><li><p>通过属性_jspx_imports_ packages存放导入的java包，默认导入javax.servlet，javax.servlet.http，javax.servlet.jsp</p><p><img src="1576029963400.png" alt="1576029963400"></p></li><li><p>通过属性_jspx_imports_classes存放导入的类，通过import指令导入的DateFormat，SimpleDateFormat，Date都会包含在该集合中。_jspx_imports_ packages和jspx_imports_clases属性主要用于配置EL引擎上下文。</p><p><img src="1576029891212.png" alt="1576029891212"></p><p><img src="1576029981836.png" alt="1576029981836"></p></li><li><p>请求处理由方法_jspService完成，而在父类HttpJspBase中的service 方法通过模板方法模式，调用了子类的_jspService方法。</p></li></ul><p><img src="1576030178277.png" alt="1576030178277">)<img src="1576030218468.png" alt="1576030218468">)<img src="1576030288725.png" alt="1576030288725"></p><ul><li>_jspService方法中定义了几个重要的局部变量:pageContext 、Session、 application、 config、 out、page。 由于整个页面的输出由_jspService方法完成,因此这些变量和参数会对整个Jsp页面生效。这也是我们为什么可以在Jsp页面使用这些变 量的原因。</li><li>指定文档类型的指令( page)最终转换为response.setContentType()方法调用</li><li>对于每一行的静态内容( HTML) ，调用out.write 输出</li><li>对于&lt;%  …  %&gt;中的java代码，将直接转换为Servlet 类中的代码。如果在 Java代码中嵌入了静态文件，则同样调用out.write输出</li></ul>]]></content>
    
    <summary type="html">
    
      Tomcat整体架构细分研究 Tomcat源码分析 Jasper
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Tomcat" scheme="http://goldcarpenter.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal总结</title>
    <link href="http://goldcarpenter.github.io/2019/12/21/ThreadLocal/"/>
    <id>http://goldcarpenter.github.io/2019/12/21/ThreadLocal/</id>
    <published>2019-12-21T15:19:21.000Z</published>
    <updated>2020-06-17T03:25:33.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><ul><li><code>ThreadLocal</code>可以为当前线程关联一个数据【普通变量，对象，数组，集合】</li><li>可以像 Map一样存取数据，key 为当前线程，<strong>保证各个线程的变量相对独立于其他线程内的变量，解决多线程的数据安全问题</strong>。</li><li>每一个<code>ThreadLocal</code>对象，只能为当前线程关联一个数据，如果要为当前线程关联多个数据，就需要使用多个<code>ThreadLocal</code>对象</li><li>每个<code>ThreadLocal</code>对象实例定义的时候，<strong>一般都是static类型</strong></li><li><code>ThreadLocal</code>中保存数据，在线程销毁后。会由JVM虚拟自动释放</li></ul><h2 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2.常用方法"></a>2.常用方法</h2><table><thead><tr><th align="center">方法声明</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ThreadLocal()</td><td align="center">创建ThreadLocal对象</td></tr><tr><td align="center">public T get()</td><td align="center">设置当前线程绑定的局部变量</td></tr><tr><td align="center">public void set(T value)</td><td align="center">获取当前线程绑定的局部变量</td></tr><tr><td align="center">public void remove()</td><td align="center">移除当前线程绑定的局部变量</td></tr></tbody></table><h2 id="3-案例"><a href="#3-案例" class="headerlink" title="3.案例"></a>3.案例</h2><ul><li>线程隔离，在多线程并发的场景下，每个线程中的变量都是相互独立<br>线程1——设置(变量1)——获取(变量1)<br>线程2——设置(变量2)——获取(变量2)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;       </span><br><span class="line">    String content;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main main = <span class="keyword">new</span> Main();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                main.setContent(Thread.currentThread().getName() + <span class="string">"的数据"</span>);</span><br><span class="line">                System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"---&gt;"</span> + main.getContent());</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">"线程"</span>+i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--------------------</span><br><span class="line">线程2---&gt;线程2的数据</span><br><span class="line">--------------------</span><br><span class="line">线程3---&gt;线程3的数据</span><br><span class="line">--------------------</span><br><span class="line">线程0---&gt;线程4的数据</span><br><span class="line">--------------------</span><br><span class="line">线程4---&gt;线程1的数据</span><br><span class="line">--------------------</span><br><span class="line">线程1---&gt;线程1的数据</span><br></pre></td></tr></table></figure><ul><li><p>尝试使用Synchronized解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main main = <span class="keyword">new</span> Main();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Load10<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    main.setContent(Thread.currentThread().getName() + <span class="string">"的数据"</span>);</span><br><span class="line">                System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"---&gt;"</span> + main.getContent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">"线程"</span>+i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>从结果可以发现，加锁确实可以解决这个问题，但是在<strong>这里我们强调的是线程数据隔离的问题</strong>，并<strong>不是多线程共享数据的问题</strong>，在这个案例中使用synchronized关键字是不合适的。</li></ul></blockquote></li><li><p>ThreadLocal与synchronized的区别</p><ul><li><p>虽然ThreadLocal模式与synchronized关键字都用于处理多线程并发访问变量的问题,不过两者处理问题的角度和思路不同。</p><table><thead><tr><th></th><th align="center">synchronized</th><th align="center">ThreadLocal</th></tr></thead><tbody><tr><td>原理</td><td align="center">同步机制采用以时间换空间的方式，只提供了一份变量，让不同的线程排队访问</td><td align="center">ThreadLocal采用以空间换时间的方式，为<strong>每一个线程原都提供了一份变量的副本</strong>，从而实现同时访问而相不干扰</td></tr><tr><td>侧重点</td><td align="center">多个线程之间<strong>访问资源同步</strong></td><td align="center">多线程中让每个线程之间的<strong>数据相互隔离</strong></td></tr></tbody></table></li></ul></li><li><p>ThreadLocal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String content = threadLocal.get();</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.threadLocal.set(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-ThreadLocal方案的好处"><a href="#4-ThreadLocal方案的好处" class="headerlink" title="4.ThreadLocal方案的好处"></a>4.ThreadLocal方案的好处</h2><ul><li>线程隔离：各线程之间的数据相互隔离却又具备并发性，<strong>避免同步方式带来的性能损失</strong>【案例1】</li><li>传递数据：保存每个线程绑定的数据，在需要的地方可以直接获取，<strong>避免参数直接传递带来的代码耦合问题</strong>【Service层和Dao层传递Connection对象】</li></ul><h2 id="4-内部结构"><a href="#4-内部结构" class="headerlink" title="4.内部结构"></a>4.内部结构</h2><ul><li><p>早期</p><ul><li>每个ThreadLocal都创建一个Map，然后用线程作为Map的key，要存储的局部变量作为Map的value ，这样就能达到各个线程的局部变量隔离的效果。</li></ul><p><img src="ThreadLocal_img/1589278568621.png" alt="1589278568621"></p></li><li><p>JDK8</p><ul><li><p>每个Thread维护一个ThreadLocalMap，这个Map的key是ThreadLocal实例本身，value 才是真正要存储的值Object。</p></li><li><p>具体的过程是这样的:</p><ul><li>每个Thread线程内部都有一个Map【ThreadLocalMap】</li><li>Map【ThreadLocalMap】<code>key</code>存储<strong>ThreadLocal对象</strong>和 <code>value</code>存储<strong>线程的变量副本</strong></li><li>Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。</li><li>对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，<br>互不干扰。</li></ul><p><img src="ThreadLocal_img/1589278729316.png" alt="1589278729316"></p></li></ul></li><li><p>JDK8 VS 早期的优点</p><ul><li>每个Map存储的Entry数量变少</li><li>当Thread销毁的时候, ThreadLocalMap也会随之销毁,减少内存的使用</li></ul></li></ul><h2 id="5-ThreadLocal源码分析"><a href="#5-ThreadLocal源码分析" class="headerlink" title="5.ThreadLocal源码分析"></a>5.ThreadLocal源码分析</h2><h3 id="5-1-set方法"><a href="#5-1-set方法" class="headerlink" title="5.1.set方法"></a>5.1.set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 设置当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value 将要保存在当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">pub1ic <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程对象</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">//判断map是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (map != nu11)&#123;</span><br><span class="line">            <span class="comment">//存在则调用map.set设置此实体entry</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 1)当前线程Thread不存在ThreadLocalMap对象</span></span><br><span class="line">            <span class="comment">// 2)则调用createMap进行ThreaduocalMap对象的初始化</span></span><br><span class="line">            <span class="comment">// 3)并将t(当前线程)和value(t对应的值)作为第一 个entry存放至ThreadLocalMap中</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *获取当前线程Thr ead对应维护的ThreadLocalMap</span></span><br><span class="line"><span class="comment">  *<span class="doctag">@param</span> t the current thread 当前线程</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the map 对应维护的ThreadLocalMap</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadlocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建当前线程Thread对应维护的ThreadLocalMap</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> t 当前线程</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> firstValue存放到map中第一个entry的值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t,T firstValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里的this 是调用此方法的threadLocal</span></span><br><span class="line">        t.threadlocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>代码执行流程<ul><li>首先获取当前线程,并根据当前线程获取一个Map</li><li>如果获取的Map不为空,则将参数设置到Map中(当前ThreadLocal的引用作为key )</li><li>如果Map为空,则给该线程创建Map，并设置初始值</li></ul></li></ul><h3 id="5-2-get方法"><a href="#5-2-get方法" class="headerlink" title="5.2.get方法"></a>5.2.get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程中保存ThreadLocal的值</span></span><br><span class="line"><span class="comment"> * 如果当前线程没有此ThreadLocal变量</span></span><br><span class="line"><span class="comment"> * 则它会通过调用&#123;<span class="doctag">@link</span> #initialvalue&#125; 方法进行初始化值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回当前线程对应此ThreadLocal的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程对象</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t) ;</span><br><span class="line">        <span class="comment">//如果此map存在</span></span><br><span class="line">        <span class="keyword">if</span> (map != nu11) &#123;</span><br><span class="line">        <span class="comment">//以当前的ThreadLocal为key,调用getEntry获取对应的存储实体e</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//对e进行判空</span></span><br><span class="line">            <span class="keyword">if</span> (e != nu11) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                <span class="comment">//获取存储实体e对应的value值</span></span><br><span class="line">                <span class="comment">//即为我们想要的当前线程对应此ThreadLocal的值</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            初始化:有两种情况有执行当前代码</span></span><br><span class="line"><span class="comment">            第一种情况: map不存在，表示此线程没有维护的ThreadLocalMap对象</span></span><br><span class="line"><span class="comment">            第二种情况: map存在， 但是没有与当前ThreadLocal关联的entry</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> setInitialvalue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value初始化后的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用initialvalue获取初始化的值</span></span><br><span class="line">        <span class="comment">//此方法可以被子类重写，如果不重写默认返回null</span></span><br><span class="line">        T value = initialValue();</span><br><span class="line">        <span class="comment">//获取当前线程对象</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">//判断map是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (map != nu11)&#123;</span><br><span class="line">            <span class="comment">//存在则调用map.set设置此实体entry</span></span><br><span class="line">            map.set(<span class="keyword">this</span>,value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 1)当前线程Thread 不存在ThreadL oca 1Map对象</span></span><br><span class="line">        <span class="comment">// 2)则调用cr eat eMap进行ThreadLoca 1Map对象的初始化</span></span><br><span class="line">        <span class="comment">// 3)并将t(当前线程)和value(t对应的值)作为第一个entry存放至Thr eadL ocalMap中</span></span><br><span class="line">        createMap(t,value);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//返回设置的值value</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>代码执行流程<ol><li>首先获取当前线程，根据当前线程获取一个Map</li><li>如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的<code>Entry e</code>，否则转到4</li><li>如果e不为null，则返回<code>e.value</code>，否则转到4</li><li><code>Map</code>为空或者<code>e</code>为空,则通过<code>initialValue</code>函数获取初始值<code>value</code> ,然后用<code>Threadlocal</code>的引用和<code>value</code>作为<code>firstKey</code>和<code>firstValue</code>创建一个新的<code>Map</code></li></ol></li><li>总结：先获取当前线程的ThreadLocalMap变量，如果存在则返回值，不存在则创建并返回初始值。</li></ul><h3 id="5-3-remove方法"><a href="#5-3-remove方法" class="headerlink" title="5.3.remove方法"></a>5.3.remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除当前线程中保存的Thr eadLoca 1对应的实体entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">        <span class="comment">//如果此map存在</span></span><br><span class="line">        <span class="keyword">if</span> (m != nu11)&#123;</span><br><span class="line">            <span class="comment">//存在则调用map.remove</span></span><br><span class="line">            <span class="comment">//以当前ThreadLocal为key删除对应的实体entry</span></span><br><span class="line">            m.remove(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>代码执行流程<ul><li>首先获取当前线程，并根据当前线程获取一个Map</li><li>如果获取的Map不为空，则移除当前ThreadLocal对象对应的entry</li></ul></li></ul><h3 id="5-4-initialValue方法"><a href="#5-4-initialValue方法" class="headerlink" title="5.4.initialValue方法"></a>5.4.initialValue方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方返回当前线程对应的Threadlocal的初始值</span></span><br><span class="line"><span class="comment"> * 此方法的第一次调用发生在，当线程通过get方法访问此线程的ThreadLocal值时</span></span><br><span class="line"><span class="comment"> * 除非线程先调用了set方法，在这种情况下，initialvalue才不会被这个线程调用。</span></span><br><span class="line"><span class="comment"> * 通常情况下，每个线程最多调用一次这个方法。</span></span><br><span class="line"><span class="comment"> * 这个方法仅仅简单的返回null &#123;<span class="doctag">@code</span> nu11&#125;;</span></span><br><span class="line"><span class="comment"> * 如果程序员想ThreadLoca1线程局部变量有一个除null以外的初始值，</span></span><br><span class="line"><span class="comment"> * 必须通过子类继承&#123;<span class="doctag">@code</span> ThreadLocal&#125; 的方式去重写此方法</span></span><br><span class="line"><span class="comment"> * 通常，可以通过匿名内部类的方式实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前ThreadLocal的初始值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> nu11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>此方法的作用是返回该线程局部变量的初始值。<ul><li>这个方法是一个延迟调用方法，从上面的代码我们得知，在set方法还未调用而先调用了get方法时才执行，并且仅执行一次</li><li>这个方法缺省实现直接返回<code>null</code></li><li>如果想要一个除<code>null</code>之外的初始值,可以重写此方法。( 备注:该访法是一个protected的方法，显然是<br>为了让子类覆盖而设计的)</li></ul></li></ul><h2 id="6-ThreadLocalMap源码分析"><a href="#6-ThreadLocalMap源码分析" class="headerlink" title="6.ThreadLocalMap源码分析"></a>6.ThreadLocalMap源码分析</h2><ul><li>分析ThreadLocal方法了解到ThreadLocal的操作实际上是围绕ThreadLocalMap展开的。</li><li>ThreadLocalMap的源码相对比较复杂，以下三个方面进行讨论。</li></ul><h3 id="6-1基本结构"><a href="#6-1基本结构" class="headerlink" title="6.1基本结构"></a>6.1基本结构</h3><ul><li><p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的<strong>内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也是独立实现。</strong></p><p><img src="ThreadLocal_img/1589289298701.png" alt="1589289298701"></p></li><li><p>成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *初始容量--必须是2的整次幂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> InItIAl_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  存放数据的table，Entry类的定义在下面分析</span></span><br><span class="line"><span class="comment"> *  同样，数组长度必须是2的整次幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组里面entrys的个数，可以用于判断table当前使用量是否超过阈值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 进行扩容的阈值，表使用量大于它的时候进行扩容。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><ul><li>跟HashMap类似，<code>INITIAL_CAPACITY</code>代表这个Map的初始容量，table是一个<code>Entry</code>类型的数组，用于存储数据，size代表表中的存储数目， threshold代表需要扩容时对应size的阈值。</li></ul></li><li><p>存储结构Entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Entry继承WeakReference，并且用ThreadLocal作为key</span></span><br><span class="line"><span class="comment"> * 如果key为null(entry.get() == nu11) 意味着key不再被引用</span></span><br><span class="line"><span class="comment"> * 因此这时候entry也可以从tab1e中清除。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this Threadocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。不过Entry中的key只能是ThreadLocal对象 ,这点在构造方法中已经限定死了。</li><li>另外, Entry继承WeakReference，也就是key ( ThreadLocal )是弱引用，其目的是将ThreadLocal对象的生命周期和线程生命周期解绑。</li></ul></li></ul><h3 id="6-2弱引用和内存泄漏"><a href="#6-2弱引用和内存泄漏" class="headerlink" title="6.2弱引用和内存泄漏"></a>6.2弱引用和内存泄漏</h3><ul><li><p>内存泄漏相关概念</p><ul><li>Memory overflow：内存溢出,没有足够的内存提供申请者使用</li><li>Memory leak：内存泄漏是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。内存泄漏的堆积终将导致内存溢出。</li></ul></li><li><p>弱引用相关概念</p><ul><li>Java中的引用有4种类型：强、软、弱、虚。</li><li>强引用：最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾回收器就不会回收这种对象。</li><li>弱引用：垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</li></ul></li><li><p><strong>在使用ThreadLocal的过程中有内存泄漏的情况发生</strong></p></li></ul><h4 id="6-2-1与否与ThreadLocalMap中的key使用弱引用有关"><a href="#6-2-1与否与ThreadLocalMap中的key使用弱引用有关" class="headerlink" title="6.2.1与否与ThreadLocalMap中的key使用弱引用有关"></a>6.2.1与否与ThreadLocalMap中的key使用弱引用有关</h4><p><img src="ThreadLocal_img/1589292275492.png" alt="1589292275492"></p><ul><li>假设在业务代码中使用完<code>ThreadLocal</code> ，<code>threadLocalRef</code>被回收了</li><li>由于<code>ThreadLocalMap</code>只持有<code>ThreadLocal</code>的弱引用，没有任何强引用指向<code>threadlocal</code>实例,所以<code>threadlocal</code>就可以顺利被GC回收，此时<code>Entry</code>中的<code>key=null</code></li><li>【在没有手动删除这个<code>Entry</code>以及<code>CurrentThread</code>依然运行的前提下】，存在有强引用链<code>threadRef-&gt; currentThread-&gt; threadLocalMap-&gt;entry-&gt;value</code>，<code>value</code>不会被回收，而这块<code>value</code>永远不会被访问到了，导致<code>value</code>内存泄漏</li><li><strong>ThreadLocalMap中的key使用了弱引用，有可能内存泄漏。</strong></li></ul><h4 id="6-2-2假设ThreadLocalMap中的key使用强引用"><a href="#6-2-2假设ThreadLocalMap中的key使用强引用" class="headerlink" title="6.2.2假设ThreadLocalMap中的key使用强引用"></a>6.2.2假设ThreadLocalMap中的key使用强引用</h4><ul><li><p>假设<code>ThreadLocalMap</code>中的<code>key</code>使用了强引用，那么会出现内存泄漏吗?</p></li><li><p>此时<code>ThreadLocal</code>的内存图如下:</p><p><img src="ThreadLocal_img/1589291319111.png" alt="1589291319111"></p><ul><li>在业务代码中使用完<code>ThreadLocal</code>，<code>threadLocalRef</code>被回收了</li><li>因为<code>threadLocalMap</code>的<code>Entry</code>强引用了<code>threadLocal</code>，造成<code>threadLocal</code>无法被回收</li><li>【在没有手动删除这个<code>Entry</code>以及<code>CurrentThread</code>依然运行的前提下】，始终有强引用链<code>threadRef-&gt; currentThread-&gt; threadLocalMap-&gt; entry</code>，<code>Entry</code>就不会被回收（包括了<code>ThreadLocal</code>实例和<code>value</code>)，导致Entry内存泄漏</li><li><strong>ThreadLocalMap中的key使用了强引用，是无法完全避免内存泄漏的。</strong></li></ul></li></ul><h4 id="6-2-3为什么使用弱引用"><a href="#6-2-3为什么使用弱引用" class="headerlink" title="6.2.3为什么使用弱引用"></a>6.2.3为什么使用弱引用</h4><ul><li><strong>在<code>ThreadLocalMap</code>中的<code>set/getEntry</code>方法中，会对<code>key</code>为<code>null</code> (也即是<code>ThreadLocal</code>为<code>null</code> )进行判</strong><br><strong>断，如果为<code>null</code>的话，那么是会对<code>value</code>置为<code>null</code>的</strong></li><li>意味着使用完<code>ThreadLocal</code> ，<code>CurrentThread</code>依然运行的前提下，就算忘记调用<code>remove</code>方法，<strong>弱引比</strong><br><strong>强引用可以多一层保障</strong>，弱引用的ThreadLocal会被回收，<strong>对应的value在下一次<code>ThreadLocalMap</code>调用<code>set get remove</code>中的任一方法的时候会被清除，从而避免内存泄漏。</strong></li></ul><h4 id="6-2-4出现内存泄漏的真实原因"><a href="#6-2-4出现内存泄漏的真实原因" class="headerlink" title="6.2.4出现内存泄漏的真实原因"></a>6.2.4出现内存泄漏的真实原因</h4><ul><li><strong>内存泄漏的发生跟<code>ThreadLocalMap</code>中的<code>key</code>使用哪种类型引用是没有关系的</strong></li><li>在以上两种内存泄漏的情况中，都有两个前提:<ul><li>没有手动删除这个<code>Entry</code><ul><li><strong>只要在使用完<code>ThreadLocal</code>，调用其<code>remove</code>方法删除对应的<code>Entry</code>，就能避免内存泄漏</strong></li></ul></li><li><code>CurrentThread</code>依然运行<ul><li><code>ThreadLocalMap</code>是<code>Thread</code>的一个属性，被当前线程所引用，所以它的生命周期跟<code>Thread</code>样长。</li><li><strong>那么在使用完<code>ThreadLocal</code>的使用，如果当前<code>Thread</code>也随之执行结束，</strong><code>ThreadLocalMap</code>自然也会被GC回收，<strong>从根源上避免了内存泄漏。</strong>【不好控制，使用线程池的时候，线程结束是不会销毁的】</li></ul></li></ul></li><li>综上，<code>ThreadLocal</code>内存泄漏的根源是：ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏。</li></ul><h3 id="6-3-hash冲突的解决"><a href="#6-3-hash冲突的解决" class="headerlink" title="6.3 hash冲突的解决"></a>6.3 hash冲突的解决</h3><ul><li><p>hash冲突的解决是Map中的一个重要内容。我们以hash冲突的解决为线索,来研究一下ThreadLocalMap的<br>核心源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 设置当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value 将要保存在当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">pub1ic <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != nu11)&#123;</span><br><span class="line">            <span class="comment">//threadLocalMap的set方法</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            createMap(t, value);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadlocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t,T firstValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//threadLocalMap构造方法</span></span><br><span class="line">        t.threadlocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-3-1构造方法"><a href="#6-3-1构造方法" class="headerlink" title="6.3.1构造方法"></a>6.3.1构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * firstKey : 本ThreadLocal实例(this)</span></span><br><span class="line"><span class="comment"> * firstValue :要保存的线程本地变量</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        <span class="comment">//初始化table</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="comment">//计算索引(重点代码)</span></span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//设置值</span></span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//设置阈值</span></span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的索引，然后存储到table中，并设置size和threshold</p></li><li><p>重点分析: <code>int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</code></p><ul><li><p><code>firstKey.threadLocalHashCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//AtomicInteger是一个提供原子操作的Integer类，通过线程安全的方式操作加减, 适合高并发情况下的使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">   <span class="comment">//特殊的hash值    </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br></pre></td></tr></table></figure><p>这里定义了一个AtomicInteger类型，每次获取当前值并加上HASH_INCREMENT，这个值跟斐波那契数列(黄金分割数)有关，其主要目的就是为了让哈希码能均匀的分布在2的n次方的数组里,也就是Entry[] table中，这样做可以尽星避免hash冲突。</p></li><li><p><code>(INITIAL_CAPACITY - 1)</code></p><ul><li>计算hash的时候里面采用了<code>hashCode &amp; (size - 1)</code>的算法，这相当于取模运算<code>hashCode % size</code>的一个更高效的实现。正是因为这种算法，我们要求size必须是2的整次幂，这也能保证在索引不越界的前提下,使得hash发生冲突的次数减小。</li></ul></li></ul></li></ul><h4 id="6-3-2set方法"><a href="#6-3-2set方法" class="headerlink" title="6.3.2set方法"></a>6.3.2set方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">     Entry[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line">     <span class="comment">//计算索引(重点代码，刚才分析过了)</span></span><br><span class="line">     <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">     <span class="comment">//使用线性探测法查找元素(重点代码)</span></span><br><span class="line">     <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">          e != <span class="keyword">null</span>;</span><br><span class="line">          e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">         ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//Threadlocal对应的key存在，直接覆盖之前的值</span></span><br><span class="line">         <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">             e.value = value;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">// key为null 但是值不为null 说明之前的ThreadLocal对象已经被回收了，</span></span><br><span class="line">        <span class="comment">// 当前数组中的Entry是一个陈旧(stale)的元素</span></span><br><span class="line">         <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">             replaceStaleEntry(key, value, i);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line"> <span class="comment">//Threadlocal对应的key不存在并且没有找到陈旧的元素，则在空元素的位置创建一个新的Entry</span></span><br><span class="line">     tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">     <span class="keyword">int</span> sz = ++size;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * cleanSomeSlots用于清除那些e.get()==null的元素，</span></span><br><span class="line"><span class="comment">       * 这种数据key关联的对象已经被回收，所以这个Entry(table[index])可以被置null</span></span><br><span class="line"><span class="comment">       * 如果没有清除任何entry ,并且当前使用量达到了负载因子所定义(长度的2/3)。那么进行rehash(执行一次全表的扫描清理工作)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">     <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">         rehash();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *获取环形数组的下一个索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span>&lt; len)?i+<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>代码执行流程</p><ul><li>首先还是根据key计算出索引i，然后查找i位置上的Entry</li><li>若是Entry已经存在并且key等于传入的key，那么这时候直接给这个Entry赋新的value值</li><li>若是Entry存在，但是key为null，则调用<code>replaceStaleEntry</code>来更换这个key为空的Entry</li><li>不断循环检测，直到遇到为null的地方，这时候要是还没在循环过程中return，则在空元素的位置创建一个新的Entry，并且插入同时size增加1。</li><li>最后调用cleanSomeSlots，清理key为null的Entry，最后返回是否清理了Entry，接下来再判断sz是否&gt;=<br>threshold达到了rehash的条件，达到的话就会调用rehash函数执行一次全表的扫描清理。</li></ul></li><li><p>重点分析: <strong>ThreadLocalMap使用线性探测法来解决哈希冲突的</strong></p><ul><li>该方法一次探测下一个地址，直到有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。</li><li>举个例子<ul><li>假设当前table长度为16 ,也就是说如果计算出来key的hash值为14，如果table[14]上已经有值，并且其key与当前key不一致，那么就发生了hash冲突，这个时候将14加1得到15 ,取table[15]进行判断，这个时候如果还是冲突会回到0，取table[0]，以此类推,直到可以插入。</li><li>可以把Entry[] table看成一个环形数组</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      ThreadLocal方案 ThreadLocal源码分析 ThreadLocalMap源码分析
    
    </summary>
    
    
      <category term="Java基础" scheme="http://goldcarpenter.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ThreadLocal" scheme="http://goldcarpenter.github.io/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="http://goldcarpenter.github.io/2019/11/19/SpringMVC_Part3/"/>
    <id>http://goldcarpenter.github.io/2019/11/19/SpringMVC_Part3/</id>
    <published>2019-11-18T16:00:00.000Z</published>
    <updated>2020-06-17T08:03:16.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-Spring返回模型数据和结果视图"><a href="#4-Spring返回模型数据和结果视图" class="headerlink" title="4.Spring返回模型数据和结果视图"></a>4.Spring返回模型数据和结果视图</h1><ul><li><p>处理模型数据方式一：<strong>将方法的返回值设置为<code>ModelAndView</code></strong></p></li><li><p>处理模型数据方式二：<strong>方法的返回值仍是<code>String</code>类型，在方法的入参中传入<code>Map</code> <code>Model</code>或者<code>ModelMap</code></strong></p></li><li><p>不管将处理器方法的返回值设置为<code>ModelAndView</code>还是在方法的入参中传入<code>Map</code> <code>Model</code>或者<code>ModelMap</code>，<code>SpringMVC</code>都会转换为一个<code>ModelAndView</code>对象</p><p><img src="1584758167073.png" alt="1584758167073"></p></li></ul><h2 id="4-1-返回字符串类型"><a href="#4-1-返回字符串类型" class="headerlink" title="4.1.返回字符串类型"></a>4.1.返回字符串类型</h2><h3 id="4-1-1-直接返回目标jsp文件名"><a href="#4-1-1-直接返回目标jsp文件名" class="headerlink" title="4.1.1.直接返回目标jsp文件名"></a>4.1.1.直接返回目标jsp文件名</h3><ul><li><p><code>controller</code>方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址</p><ul><li><p><code>index.jsp</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="yyx/hello"&gt;返回字符串&lt;/a&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>Controlller.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"returnfunction"</span>,<span class="string">"string"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>success.jsp</code></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;入门成功&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">sessionScope.<span class="keyword">return</span>:  $&#123;sessionScope.returnfunction&#125;&lt;br&gt;</span><br><span class="line">requestScope.<span class="keyword">return</span>:  $&#123;requestScope.returnfunction&#125;&lt;br&gt;</span><br></pre></td></tr></table></figure><p><img src="1578536963748.png" alt="1578536963748"></p></li></ul></li></ul><p><img src="1578537238298.png" alt="1578537238298"></p><h3 id="4-1-2-返回使用forward转发"><a href="#4-1-2-返回使用forward转发" class="headerlink" title="4.1.2.返回使用forward转发"></a>4.1.2.返回使用<code>forward</code>转发</h3><ul><li>相当于<code>Request.getRequestDispatcher (&quot;url&quot;).forward (request, response)</code></li><li>使用请求转发，既可以转发到<code>jsp</code>,也可以转发到其他的控制器方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"returnfunction"</span>,<span class="string">"string"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"forward:/WEB-INF/pages/success.jsp"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1578538119827.png" alt="1578538119827"></p><p><img src="1578540927192.png" alt="1578540927192"></p><h3 id="4-1-3-返回使用Redirect重定向"><a href="#4-1-3-返回使用Redirect重定向" class="headerlink" title="4.1.3.返回使用Redirect重定向"></a>4.1.3.返回使用<code>Redirect</code>重定向</h3><ul><li><code>contrller</code>方法提供了一个<code>String</code>类型返回值之后，需要在返回值里使用:<code>redirect:</code></li><li>相当于<code>Response.sendRedirect(url)</code></li><li>重定向到<code>jsp</code>页面，则<code>jsp</code>页面不能写在<code>WEB-INF</code>目录中，否则无法找到</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"returnfunction"</span>,<span class="string">"string"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/index.jsp"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-返回void类型"><a href="#4-2-返回void类型" class="headerlink" title="4.2.返回void类型"></a>4.2.返回void类型</h2><ul><li>将上例中方法返回值修改为<code>void</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">model.addAttribute(<span class="string">"returnfunction"</span>,<span class="string">"string"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行程序报<code>404</code>的异常，默认查找页面没有找到。</li></ul><p><img src="1578537385549.png" alt="1578537385549"></p><ul><li><strong>会有默认请求路径：<code>方法路径.jsp</code></strong>——<strong>请求转发或者重定向跳转到指定的页面</strong></li><li>如果<strong>就想返回void</strong>，见下</li></ul><h3 id="4-2-1-方法一：Request使用请求转发"><a href="#4-2-1-方法一：Request使用请求转发" class="headerlink" title="4.2.1.方法一：Request使用请求转发"></a>4.2.1.方法一：<code>Request</code>使用请求转发</h3><ul><li>请求转发是一次请求 不用编写项目名称 但不会调用视图解析器 必须带<code>.jsp</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Model model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    request.getRequestDispatcher(<span class="string">"/WEB-INF/pages/success.jsp"</span>).forward(request,response);</span><br><span class="line">    model.addAttribute(<span class="string">"returnfunction"</span>,<span class="string">"string"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1578538119827.png" alt="1578538119827"></p><p><img src="1578538042126.png" alt="1578538042126"></p><h3 id="4-2-2-方法二：Response页面重定向"><a href="#4-2-2-方法二：Response页面重定向" class="headerlink" title="4.2.2.方法二：Response页面重定向"></a>4.2.2.方法二：<code>Response</code>页面重定向</h3><ul><li>重定向是两次请求 要编写项目名称 WEB-INF目录下文件无法访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Model model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">   Response.sendRedirect(request.getContextPath()+<span class="string">"/index.jsp"</span>);</span><br><span class="line">   model.addAttribute(<span class="string">"returnfunction"</span>,<span class="string">"string"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-3-方法三：输出流直接响应"><a href="#4-2-3-方法三：输出流直接响应" class="headerlink" title="4.2.3.方法三：输出流直接响应"></a>4.2.3.方法三：输出流直接响应</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">    response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">    response.getWriter().println(<span class="string">"早上好"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1578538633002.png" alt="1578538633002"></p><h2 id="4-3-返回ModelAndView类型【常用】"><a href="#4-3-返回ModelAndView类型【常用】" class="headerlink" title="4.3.返回ModelAndView类型【常用】"></a>4.3.返回ModelAndView类型【常用】</h2><ul><li><code>ModelAndView</code>是SpringMVC为我们提供的一个对象，其既包含视图信息，也包含模型数据信息<ul><li><code>SpringMVC</code>会把<code>ModelAndView</code>的<code>model</code>中数据放入到<code>request</code>域对象中</li><li>添加模型数据：<code>MoelAndView addObject(String attributeName, Object attributeValue)</code></li><li>设置视图：<code>void setViewName(String viewName)</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    modelAndView.addObject(<span class="string">"returnfunction"</span>,<span class="string">"ModelAndView"</span>);</span><br><span class="line">    modelAndView.setViewName(<span class="string">"success"</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1578539195616.png" alt="1578539195616"></p><h2 id="4-4-返回-ResponseBody的json数据"><a href="#4-4-返回-ResponseBody的json数据" class="headerlink" title="4.4.返回@ResponseBody的json数据"></a>4.4.返回<code>@ResponseBody</code>的<code>json</code>数据</h2><h3 id="4-4-1-防止静态资源被拦截"><a href="#4-4-1-防止静态资源被拦截" class="headerlink" title="4.4.1.防止静态资源被拦截"></a>4.4.1.防止静态资源被拦截</h3><ul><li><p><code>DispatcherServlet</code>会拦截到所有的资源，导致静态资源（<code>images</code>、 <code>css</code>，<code>js</code>） 会被拦截到，当成一个普通请求处理，因找不到对应处理器将导致错误，从而不能被使用。</p></li><li><p>解决问题就是需要配置静态资源不进行拦截，在<code>springmvc.xml</code>配置文件添加如下配置</p><ul><li><code>springmvc.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/js/**"</span> <span class="attr">location</span>=<span class="string">"/js/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/css/**"</span> <span class="attr">location</span>=<span class="string">"/css/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/images/**"</span> <span class="attr">location</span>=<span class="string">"/images/"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>在SpringMVC上下文中定义一个<code>DefaultServletHttpRequestHandler</code>,它会对进入<code>DispatcherServlet</code>的请求进行筛查，如果发现是没有经过映射的请求，就将该请求交由<code>WEB</code>应用服务器默认的<code>Servlet</code>处理，如果不是静态资源的请求，才由<code>DispatcherServlet</code>继续处理</p></li><li><p>一般WEB应用服务器默认的Servlet的名称都是default。若所使用的<code>WEB</code>服务器的默认<code>Servlet</code>名称不是<code>default</code>，则需要通过<code>default-servlet-name</code>属性显式指定</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>index.jsp</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> isELIgnored=<span class="string">"false"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">        &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            $(function () &#123;</span><br><span class="line">                $(<span class="string">"#btn"</span>).click(<span class="function">function <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  # 此时此处的按键将会有响应</span><br><span class="line">                  alert(<span class="string">"hello btn"</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;入门程序&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    &lt;button id="btn"&gt;发送ajax请求&lt;/button&gt;</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-4-2-使用json请求"><a href="#4-4-2-使用json请求" class="headerlink" title="4.4.2.使用json请求"></a>4.4.2.使用json请求</h3><ul><li><p>使用<code>@RequestBody</code>注解把json的字符串转换成<code>JavaBean</code>的对象</p></li><li><p>导包</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>index.jsp</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> isELIgnored=<span class="string">"false"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        $(function () &#123;</span><br><span class="line">            $(<span class="string">"#btn"</span>).click(function() &#123;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    <span class="comment">// 编写json格式 设置属性和值</span></span><br><span class="line">                    url:<span class="string">"yyx/hello"</span>,</span><br><span class="line">                    contentType: <span class="string">"application/json; charset=UTF-8"</span> ,</span><br><span class="line">                    data: <span class="string">'&#123;"uname": "yyx", "age" :"123"&#125;'</span>,</span><br><span class="line">                    dataType:<span class="string">"json"</span>,</span><br><span class="line">                    type: <span class="string">"post"</span>,</span><br><span class="line">                    success: function(data)&#123;</span><br><span class="line">                        <span class="comment">// data : 服务器端响应的json数据 进行解析</span></span><br><span class="line">                        alert(data);</span><br><span class="line">                        alert(data.age);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;入门程序&lt;/h3&gt;</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">        &lt;button id="btn"&gt;发送ajax请求&lt;/button&gt;</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(@RequestBody String body)</span></span>&#123;</span><br><span class="line">    <span class="comment">// &#123;"uname": "yyx", "age" :123&#125;</span></span><br><span class="line">    System.out.println(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1578556292682.png" alt="1578556292682"></p><h3 id="4-4-3-使用-ResponseBody响应json"><a href="#4-4-3-使用-ResponseBody响应json" class="headerlink" title="4.4.3.使用@ResponseBody响应json"></a>4.4.3.使用<code>@ResponseBody</code>响应<code>json</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">User <span class="title">sayHello</span><span class="params">(@RequestBody User user)</span></span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1578556235223.png" alt="1578556235223"></p><p><img src="1578556135298.png" alt="1578556135298"></p><h3 id="4-4-4-原理"><a href="#4-4-4-原理" class="headerlink" title="4.4.4.原理"></a>4.4.4.原理</h3><ul><li><p><code>HttpMessageConverter&lt;T&gt;</code>是 Spring3.0 新添加的一个<strong>接口</strong>，负责将<strong>请求信息转换为一个对象</strong>（类型为 T）或将<strong>对象（ 类型为 T）输出为响应信息</strong></p><ul><li>使用<code>@RequestBody / @ResponseBody</code>对处理方法进行标注</li><li>使用<code>HttpEntity&lt;T&gt; / ResponseEntity&lt;T&gt;</code>作为处理方法的入参或返回值</li></ul><p><img src="1584847753988.png" alt="1584847753988"></p></li><li><p><code>HttpMessageConverter&lt;T&gt;</code>接口实现类</p><p><img src="1584847800708.png" alt="1584847800708"></p></li><li><p><code>DispatcherServlet</code>默认装配<code>RequestMappingHandlerAdapter</code>，而<code>RequestMappingHandlerAdapter</code> 默认装配如下<code>HttpMessageConverter</code></p><p><img src="1584847886253.png" alt="1584847886253"></p><blockquote><p>加入 jackson jar 包后 新增[6]</p></blockquote></li><li><p>原理</p><ul><li>Spring 首先根据请求头或响应头的 Accept 属性选择匹配的<code>HttpMessageConverter</code>,</li><li>进而根据参数类型或泛型类型的过滤得到匹配的<code>HttpMessageConverter</code>, 若找不到可用的<code>HttpMessageConverter</code>将报错</li></ul><p><img src="1584847993959.png" alt="1584847993959"></p></li></ul><h2 id="自定义视图"><a href="#自定义视图" class="headerlink" title="自定义视图"></a>自定义视图</h2><ul><li><p>常用的视图解析器实现类</p><p><img src="1584777827863.png" alt="1584777827863"></p></li><li><p>自定义过程</p><ul><li><p>编写自定时视图类并实现View接口</p></li><li><p>将<code>@Component</code>标致在只定义类上</p></li><li><p>使用<code>BeanNameViewResolver</code>作为视图解析器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置视图BeanNameViewResolver 解析器:使用视图的名字来解析视图--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过order属性来定义视图解析器的优先级，order值越小优先级越高--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>= <span class="string">"org. springframework.web.servlet.view.BeanNameViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>= <span class="string">"order"</span> <span class="attr">value</span>= <span class="string">"100"</span>&gt;</span><span class="tag">&lt;/ <span class="attr">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      返回模型数据和结果视图 拦截器 异常处理
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="SpringMVC" scheme="http://goldcarpenter.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="http://goldcarpenter.github.io/2019/11/16/SpringMVC_Part4/"/>
    <id>http://goldcarpenter.github.io/2019/11/16/SpringMVC_Part4/</id>
    <published>2019-11-15T16:00:00.000Z</published>
    <updated>2020-06-17T08:02:53.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-SpringMVC上传文件"><a href="#5-SpringMVC上传文件" class="headerlink" title="5.SpringMVC上传文件"></a>5.SpringMVC上传文件</h1><h2 id="5-1-SpringMVC上传文件概念"><a href="#5-1-SpringMVC上传文件概念" class="headerlink" title="5.1.SpringMVC上传文件概念"></a>5.1.SpringMVC上传文件概念</h2><ul><li><p>文件上传要求</p><ul><li><p><code>form</code>表单的<code>enctype</code>取值必须是：<code>multipart/form-data</code></p><ul><li><code>multipart/form-data</code>：表单请求正文的类型</li></ul></li><li><p><code>method</code>属性的取值必须是<code>Post</code></p></li><li><p>提供一个文件选择域<code>&lt;input type=&quot;file&quot;/&gt;</code></p></li></ul></li><li><p>文件上传原理分析</p><ul><li>当<code>form</code>表单的<code>enctype</code>取值不是默认值后，<code>request.getParameter()</code>将失效</li><li><code>enctype=&quot;application/x-ww-form-urlencoded&quot;</code>时，form 表单的正文内容是:<code>key=value &amp;key=value &amp;key=value</code></li><li>当<code>form</code>表单的<code>enctype</code>取值为<code>Mutilpart/form-data</code>时，请求正文内容就变成:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">------WebKitFormBoundaryYMJEn4NC2H3fo8Ls</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;picname&quot;</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryYMJEn4NC2H3fo8Ls</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;uploadFile&quot;; filename&#x3D;&quot;exam.sql&quot;</span><br><span class="line">Content-Type: application&#x2F;octet-stream</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">select * from emp;</span><br><span class="line">select * from dept;</span><br><span class="line">select * from salgrade;</span><br><span class="line">*&#x2F;</span><br><span class="line">------WebKitFormBoundaryYMJEn4NC2H3fo8Ls--</span><br></pre></td></tr></table></figure></li><li><p>依赖的<code>jar</code>包</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Spring MVC 为文件上传提供了直接的支持，这种支持是通过即插即用的 MultipartResolver 实现的。</li><li>Spring 用 Jakarta Commons FileUpload 技术实现了一个 MultipartResolver 实现类<code>CommonsMultipartResovler</code></li></ul><h2 id="5-2-SpringMVC上传文件案例"><a href="#5-2-SpringMVC上传文件案例" class="headerlink" title="5.2.SpringMVC上传文件案例"></a>5.2.SpringMVC上传文件案例</h2><p><img src="upfile.bmp" alt=""></p><ul><li>编写按键</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"yyx/upfile"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"picname"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"uploadFile"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"upload"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写控制器方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"upfile"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upFile</span><span class="params">(String picname, MultipartFile uploadFile, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//      1.设置文件名</span></span><br><span class="line">        String fileName = <span class="string">""</span>;</span><br><span class="line">        String uploadFilename = uploadFile.getOriginalFilename();</span><br><span class="line">        fileName = uploadFilename;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      2. 获取文件路径</span></span><br><span class="line">        String context = request.getSession().getServletContext().getRealPath(<span class="string">"/uploads"</span>);</span><br><span class="line">        File file = <span class="keyword">new</span> File(context);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())</span><br><span class="line">        &#123;</span><br><span class="line">            file.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 上传</span></span><br><span class="line">        uploadFile.transferTo(<span class="keyword">new</span> File(file, fileName));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>配置文件解析器</p><ul><li><p><code>Spring MVC</code>上下文中默认没有装配<code>MultipartResovler</code>，因此默认情况下不能处理文件的上传工作，如果想使用 Spring 的文件上传功能，需现在上下文中配置<code>MultipartResolver</code></p></li><li><p><strong>文件上传的解析器id是固定的，不能起别的名称，否则无法实现请求参数的绑定。(不光是文件， 其他字段也将无法绑定)</strong></p></li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxInMemorySize"</span> <span class="attr">value</span>=<span class="string">"5000000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="6-SpringMVC异常处理"><a href="#6-SpringMVC异常处理" class="headerlink" title="6.SpringMVC异常处理"></a>6.SpringMVC异常处理</h1><h2 id="6-1-SpringMVC-异常处理概念"><a href="#6-1-SpringMVC-异常处理概念" class="headerlink" title="6.1.SpringMVC 异常处理概念"></a>6.1.SpringMVC 异常处理概念</h2><ul><li>系统的<code>dao</code>，<code>service</code>，<code>controller</code>出现都通过<code>throws Exception</code>向上抛出，最后由<code>SpringMVC</code>前端控制器交由<strong>异常处理器</strong>进行异常处理</li></ul><p><img src="%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.bmp" alt=""></p><ul><li><p><code>Spring MVC</code>通过<code>HandlerExceptionResolver</code>接口处理程序的异常，包括<code>Handler</code>映射、数据绑定以及目标方法执行时发生的异常</p></li><li><p><code>SpringMVC</code>提供的<code>HandlerExceptionResolver</code>的实现类</p><ul><li><p><code>ExceptionHandlerExceptionResolver</code></p></li><li><p><code>ResponseStatusExceptionResolver</code></p></li><li><p><code>DefaultHandlerExceptionResolver</code></p></li><li><p><code>SimpleMappingExceptionResolver</code></p></li></ul></li><li><p>使用了<code>&lt;mvc:annotation-driven/&gt;</code>配置<code>DispatcherServlet</code>默认装配的<code>HandlerExceptionResolver</code></p><p><img src="1584868554434.png" alt="1584868554434"></p></li></ul><h3 id="6-1-1-ExceptionHandlerExceptionResolver"><a href="#6-1-1-ExceptionHandlerExceptionResolver" class="headerlink" title="6.1.1 ExceptionHandlerExceptionResolver"></a>6.1.1 ExceptionHandlerExceptionResolver</h3><ul><li><p>主要处理<code>Handler</code>中用<code>@ExceptionHandler</code>注解定义的 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1.在<span class="doctag">@ExceptionHandler</span>方法的入参中可以加入Exception类型的参数，该参数即对应发生的异常对象</span></span><br><span class="line"><span class="comment">    * 2.<span class="doctag">@ExceptionHandler</span>方法的入参中不能传入Map. 若希望把异常信息传导页面上,需要使用ModelAndView 作为返回值</span></span><br><span class="line"><span class="comment">    * 3.<span class="doctag">@ExceptionHandler</span>方法标记的异常有优先级的问题</span></span><br><span class="line"><span class="comment">    * 4.<span class="doctag">@ControllerAdvice</span>: 如果在当前Handler中找不到<span class="doctag">@ExceptionHandler</span>方法来出来当前方法出现的异常，则将去<span class="doctag">@ControllerAdvice</span>标记的类中查找<span class="doctag">@ExceptionHandler</span>标记的方法来处理异常。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(&#123;ArithmeticException<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ModelAndView</span> <span class="title">handleArithmeticException</span>(<span class="title">Exception</span> <span class="title">ex</span>)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"出异常了:"</span>+ ex);</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>);</span><br><span class="line">    mv.addobject(<span class="string">"exception"</span>, ex);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ExceptionHandlerMethodResolver</code>内部若找不到<code>@ExceptionHandler</code>注解的话，会找<code>@ControllerAdvice</code>中的<code>@ExceptionHandler</code>注解方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleException</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>( &#123;ArithmeticException. <span class="class"><span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ModelAndView</span> <span class="title">handleArithmeticException</span>( <span class="title">Exception</span> <span class="title">ex</span>)</span>&#123;</span><br><span class="line">        System.out. println(<span class="string">"----&gt;出异常了:"</span> + ex);</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>);</span><br><span class="line">        mv.add0bject(<span class="string">"exception"</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-1-2-ResponseStatusExceptionResolver"><a href="#6-1-2-ResponseStatusExceptionResolver" class="headerlink" title="6.1.2 ResponseStatusExceptionResolver"></a>6.1.2 ResponseStatusExceptionResolver</h3><ul><li><p>在异常及异常父类中找到<code>@ResponseStatus</code>注解，然后使用这个注解的属性进行处理。</p></li><li><p>定义一个<code>@ResponseStatus</code>注解修饰的异常类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseStatus</span>(value=HttpStatus.FORBIDDEN, reason= <span class="string">"用户名和密码不匹配! "</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserNameNotMatchPasswordException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="number">1</span>ong serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于触发的异常<code>UnauthorizedException</code>带有<code>@ResponseStatus</code>注解。因此会被<code>ResponseStatusExceptionResolver</code>解析到。</p></li><li><p>最后响应给客户端</p><p><img src="1584869462518.png" alt="1584869462518"></p></li></ul><h3 id="6-1-3DefaultHandlerExceptionResolver"><a href="#6-1-3DefaultHandlerExceptionResolver" class="headerlink" title="6.1.3DefaultHandlerExceptionResolver"></a>6.1.3DefaultHandlerExceptionResolver</h3><ul><li>对一些特殊的异常进行处理<ul><li><code>NoSuchRequestHandlingMethodException</code></li><li><code>HttpReques tMethodNotSupportedException</code></li><li><code>HttpMediaTypeNotSupportedException</code> </li><li><code>HttpMediaTypeNotAcceptableException</code>等</li></ul></li></ul><h3 id="6-1-4-SimpleMappingExceptionResolver"><a href="#6-1-4-SimpleMappingExceptionResolver" class="headerlink" title="6.1.4.SimpleMappingExceptionResolver"></a>6.1.4.SimpleMappingExceptionResolver</h3><ul><li><p>如果希望对所有异常进行统一处理，可以使用 SimpleMappingExceptionResolver，它将异常类名映射为视图名，即发生异常时使用对应的视图报告异常</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleMappingExceptionResolver"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>= <span class="string">"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>= <span class="string">"exceptionMappings"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"java.lang.ArithmeticException"</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="6-2-SpringMVC-异常处理配置"><a href="#6-2-SpringMVC-异常处理配置" class="headerlink" title="6.2.SpringMVC 异常处理配置"></a>6.2.SpringMVC 异常处理配置</h2><ol><li>编写自定义异常类(做提示信息的)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyError</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyError</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//set get function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>编写异常处理器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerExceptionResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> </span>&#123;</span><br><span class="line">        Exception exception = <span class="keyword">null</span>;</span><br><span class="line">        MyError myError = <span class="keyword">null</span>;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">//如果抛出的是系统自定义异常则直接转换</span></span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> MyError)</span><br><span class="line">        &#123;</span><br><span class="line">            myError = (MyError)e;</span><br><span class="line">            modelAndView.addObject(<span class="string">"message"</span>,myError.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果抛出的不是系统自定义异常则重新构造一个系统错误异常。</span></span><br><span class="line">            exception = <span class="keyword">new</span> Exception (<span class="string">"系统错误，请与系统管理员联系! "</span>);</span><br><span class="line">            modelAndView.addObject(<span class="string">"message"</span>,exception.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        modelAndView.setViewName(<span class="string">"fail"</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置异常处理器(跳转到提示页面)</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exceptionResolver"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.exception.ExceptionResolver"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><img src="1578578156330.png" alt="1578578156330"></p><p><img src="1578578182783.png" alt="1578578182783"></p><h1 id="7-SpringMVC-拦截器"><a href="#7-SpringMVC-拦截器" class="headerlink" title="7.SpringMVC 拦截器"></a>7.SpringMVC 拦截器</h1><h2 id="7-1-SpringMVC-拦截器概念"><a href="#7-1-SpringMVC-拦截器概念" class="headerlink" title="7.1.SpringMVC 拦截器概念"></a>7.1.SpringMVC 拦截器概念</h2><ul><li><code>SpringMVC</code>的处理器拦截器类似于<code>Servlet</code>开发中的过滤器<code>Filter</code>,用于对处理器进行预处理和后处理</li><li>用户可以自己定义一些拦截器来实现特定的功能。</li><li>拦截器链：将拦截器按一定的顺字联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。</li><li>过滤器/拦截器区别<ul><li>过滤器<ul><li>过滤器是<code>servlet</code>规范中的一部分，任何<code>java web</code>工程都可以使用</li><li>过滤器在<code>url-pattern</code>中配置了<code>/*</code>之后，可以对所有要访问的资源拦截</li></ul></li><li>拦截器<ul><li>拦截器它是只会拦截访问的控制器方法，如果访问的是<code>jsp</code>，<code>html</code>，<code>css</code>,<code>image</code>或者<code>js</code>是不会进行拦载的</li><li>拦截器是<code>SpringMVC</code>框架自己的，只有使用了<code>SpringMVC</code>框架的工程才能用。</li></ul></li></ul></li><li>它也是AOP思想的具体应用。</li><li>想自定义拦截器，要求必须实现<code>HandlerInterceptor</code>接口</li></ul><h2 id="7-2-SpringMVC-拦截器配置"><a href="#7-2-SpringMVC-拦截器配置" class="headerlink" title="7.2.SpringMVC 拦截器配置"></a>7.2.SpringMVC 拦截器配置</h2><ol><li>自定义拦截器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 预处理，controller方法执行前</span></span><br><span class="line">    <span class="comment">// return true 放行，执行下一个拦截器，如果没有，执行controller中的方法</span></span><br><span class="line">    <span class="comment">// return false 不放行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"preHandle~~"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后处理方法，controller方法执行后，***.jsp执行之前</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postHandle~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ***.jsp页面执行后，该方法会执行 用于释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"afterCompletion~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>Springmvc.xml</code>配置拦截器</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        包含某些路径方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/yyx/**"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mvc:exclude-mapping path=""/&gt;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myHandlerInterceptor"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.handler.MyHandlerInterceptor"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="1578582999074.png" alt="1578582999074"></p><h2 id="7-3-SpringMVC-拦截器相关细节"><a href="#7-3-SpringMVC-拦截器相关细节" class="headerlink" title="7.3.SpringMVC 拦截器相关细节"></a>7.3.SpringMVC 拦截器相关细节</h2><ul><li><p>拦截器的放行</p><ul><li>如果有下一个拦截器就执行下一个，如果该拦截器处于拦截器链的最后一个， 则执行控制器中的方法。</li></ul></li><li><p>前置处理：</p><ul><li>如何调用<ul><li>按拦截器定义顺序调用</li></ul></li><li>何时调用<ul><li>只要配置了都会调用</li></ul></li><li>有什么用:<ul><li>如果程序员决定该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去进行处理，则返回true</li><li>如果程序员决定不需要再调用其他的组件去处理请求，则返回false。</li></ul></li></ul></li><li><p>后置处理</p><ul><li>如何调用：按拦截器定义<strong>逆序调用</strong></li><li>何时调用：在拦截器链内所有拦截器返成功调用</li><li>有什么用<ul><li>在业务处理器处理完请求后，但是<code>DispatcherServlet</code>向客户端返回响应前被调用，在该方法中对用户请求request进行处理</li></ul></li></ul></li><li><p>AfterCompletion</p><ul><li>如何调用：按拦截器定义<strong>逆序调用</strong></li><li>何时调用：<strong>只有preHandle返回true才调用</strong></li><li>有什么用<ul><li>在DispatcherServlet完全处理完请求后被调用，<strong>进行一些资源清理的操作</strong></li></ul></li></ul></li><li><p>多个拦截器的执行顺序</p></li></ul><p><img src="1578583878348.png" alt="1578583878348"></p><h1 id="Spring-MVC-与-Spring"><a href="#Spring-MVC-与-Spring" class="headerlink" title="Spring MVC 与    Spring"></a>Spring MVC 与    Spring</h1><ul><li><p>问题：需要进行<code>Spring</code>整合<code>SpringMVC</code>吗/是否还需要再加入<code>Spring</code>的<code>IoC</code>容器/是否需要再<code>web. xml</code>文件中配置启动<code>Spring IoC</code>容器的<code>ContextLoaderListener</code>?</p><ul><li>需要：通常情况下，类似于数据源，事务，整合其他框架都是放在<code>Spring</code>的配置文件中(而不是放在<code>SpringMVC</code>的配置文件中)。实际上放入Spring配置文件对应的<code>IoC</code>容器中的还有<code>Service</code>和<code>Dao</code></li></ul></li><li><p>问题：若<code>Spring</code>的<code>IOC</code>容器和<code>SpringMVC</code>的<code>IoC</code>容器扫描的包有重合的部分，就会导致有的<code>bean</code>会被创建2次。</p><ul><li><p>Spring 的 IOC 容器不应该扫描 SpringMVC 中的 bean, 对应的 SpringMVC 的 IOC 容器不应该扫描 Spring 中的 bean</p></li><li><p>【方案一】使Spring的IOC容器扫描的包和SpringMVC的IOC容器扫描的包没有重合的部分.</p></li><li><p>【方案二】使用exclude- filter和include-filter子节点来规定只能扫描的注解</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.atguigu.springmvc"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>= <span class="string">"org.springframework. stereotype.Controller"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.web.bind.annotation.controllerAdvice"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>多个 Spring IOC 容器之间可以设置为父子关系， 以实现良好的解耦。</p><ul><li><strong>Spring MVC WEB 层容器可作为 “业务层” Spring 容器的子容器：即 WEB 层容器可以引用业务层 容器的 Bean，而业务层容器却访问不到 WEB 层 容器的 Bean</strong></li></ul></li></ul><p>100.说一下 spring mvc 运行流程？</p><p>101.spring mvc 有哪些组件？</p><p>102.@RequestMapping 的作用是什么？</p><p>103.@Autowired 的作用是什么？</p>]]></content>
    
    <summary type="html">
    
      上传文件 拦截器 异常处理
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="SpringMVC" scheme="http://goldcarpenter.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="http://goldcarpenter.github.io/2019/11/13/SpringMVC_Part2/"/>
    <id>http://goldcarpenter.github.io/2019/11/13/SpringMVC_Part2/</id>
    <published>2019-11-12T16:00:00.000Z</published>
    <updated>2020-06-17T08:01:28.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-常用注解"><a href="#3-常用注解" class="headerlink" title="3. 常用注解"></a>3. 常用注解</h1><h2 id="3-1-RequestParam-重要"><a href="#3-1-RequestParam-重要" class="headerlink" title="3.1.@RequestParam[重要]"></a>3.1.<code>@RequestParam</code>[重要]</h2><ul><li>原因：在绑定机制中，要求<strong>参数名称</strong>必须和控制器中<strong>方法的形参名称</strong>保持一致。</li><li>作用：把<strong>请求的名称参数给</strong>控制器中的<strong>形参赋值</strong>。</li><li>属性<ul><li><code>value/name</code>：请求参数的名称</li><li><code>required</code>：请求参数中是否必须提供此参数。默认值: true。 表示必须提供，如果不提供将报错</li><li><code>defaultValue</code>：请求参数的默认值</li></ul></li><li><strong>请求类型</strong><ul><li><strong>Get请求</strong></li><li><strong>POST DELETE请求</strong>：<strong>请求头中的Content-Type 为 application/x-www-form-urlencoded[默认属性]</strong></li><li><strong>如果改用 <code>json</code> 字符串来传值的话，类型设置为 <code>application/json</code>，点击发送的话，会报错，后台接收不到值，为 <code>null</code>。——&gt;引入注解@RequestBody</strong></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"yyx/hello?username=yyx"</span>&gt;</span>入门程序<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@RequestParam(value = <span class="string">"username"</span>, required= <span class="keyword">false</span>)</span> String name)</span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>前端使用$.ajax的话，一定要指定 <code>contentType: &quot;application/json;charset=utf-8;&quot;</code>，默认为 <code>application/x-www-form-urlencoded</code>。</li></ul><h2 id="3-2-RequestBody-重要"><a href="#3-2-RequestBody-重要" class="headerlink" title="3.2.@RequestBody[重要]"></a>3.2.<code>@RequestBody</code>[重要]</h2><ul><li><p>作用：用于获取<strong>请求体</strong>内容</p><ul><li>直接使用得到是<code>key=values&amp;key=value&amp;..</code>结构的数据</li><li>get请求方式不适用</li><li><strong>用于处理非 <code>Content-Type: application/x-www-form-urlencoded</code>编码格式的数据</strong></li><li><strong>用于处理<code>application/json</code>、<code>application/xml</code>等类型的数据。</strong></li></ul></li><li><p>属性</p></li><li><p><code>required</code>：是否必须有请求体。默认值<code>true</code>。当取值为<code>true</code>时,<code>get</code>请求方式会报错。如果取值<code>false</code>或 <code>get</code>，请求得到是<code>null</code>。</p></li><li><p>例1</p><p><img src="1578384645597.png" alt="1578384645597"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"yyx/saveUser"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    账户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"uname"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    年  龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/saveUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(@RequestBody String str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(str);<span class="comment">//uname=%E6%9D%A8%E9%9B%A8%E9%91%AB&amp;age=23</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>例2</p><p><img src="1543609-20190711195647145-1083582365.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/test"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"id = &#123;&#125;, name = &#123;&#125;, age = &#123;&#125;"</span>, user.getId(), user.getName(), user.getAge());<span class="comment">//id = 1, name = yc, age = 23</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="小对比"><a href="#小对比" class="headerlink" title="小对比"></a>小对比</h3><ul><li><p><strong>使用@RequestParam：Content-Type为application/x-www-form-urlencoded，参数在FormData中</strong><br><img src="20181010140426784.png" alt="img"></p></li><li><p><strong>使用@RequestBody：Content-Type为application/json，参数在Request PayLoad中</strong><br><img src="20181010141048192.png" alt="img"></p></li></ul><h1 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h1><h2 id="从content-type方面总结："><a href="#从content-type方面总结：" class="headerlink" title="从content-type方面总结："></a>从content-type方面总结：</h2><p>① form-data、x-www-form-urlencoded：不可以用@RequestBody；可以用@RequestParam。见postman的格局，这两种方式的时候没有json字符串部分。</p><p>② application/json：json字符串部分可以用@RequestBody；url中的?后面参数可以用@RequestParam。见postman的格局</p><ul><li><p>application/json格局图<br><img src="aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDYxMzc5LTYzYWJjNmNjODZhMDYzYWYucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMDAwL2Zvcm1hdC93ZWJw.jpg" alt="img"></p></li><li><p>form-data、x-www-form-urlencoded格局图</p><p><img src="aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDYxMzc5LTQ5MTAxNDllZGEzZTRiZDQucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMDAwL2Zvcm1hdC93ZWJw.jpg" alt="img"></p></li></ul><h2 id="从两种注解方式总结："><a href="#从两种注解方式总结：" class="headerlink" title="从两种注解方式总结：**"></a>从两种注解方式总结：**</h2><p><strong>@RequestBody</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="meta">@RequestBody</span> Map map)</span><br><span class="line">(<span class="meta">@RequestBody</span> Object object)</span><br><span class="line">application/json时候可用</span><br><span class="line">form-data、x-www-form-urlencoded时候不可用</span><br></pre></td></tr></table></figure><p><strong>@RequestParam</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="meta">@RequestParam</span> Map map)</span><br><span class="line">application/json时候，json字符串部分不可用，url中的?后面添加参数即可用，form-data、x-www-form-urlencoded时候可用，但是要将Headers里的Content-Type删掉</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="meta">@RequestParam</span> String waterEleId,</span><br><span class="line"> <span class="meta">@RequestParam</span> String enterpriseName)</span><br><span class="line">application/json时候，json字符串部分不可用，url中的?后面添加参数即可用</span><br><span class="line">form-data、x-www-form-urlencoded时候可用，且参数可以没有顺序（即前端传过来的参数或者url中的参数顺序不必和后台接口中的参数顺序一致，只要字段名相同就可以），但是要将Headers里的Content-Type删掉</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="meta">@RequestParam</span> Object object)</span><br><span class="line">不管application/json、form-data、x-www-form-urlencoded都不可用</span><br></pre></td></tr></table></figure><h1 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h1><p>@RequestBody</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RequestBody Map / Object</span><br><span class="line">GET请求中不可以使用<span class="meta">@RequestBody</span></span><br></pre></td></tr></table></figure><p>@RequestParam</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="meta">@RequestParam</span> Map map)</span><br><span class="line">在url中的?后面添加参数即可使用</span><br><span class="line">(<span class="meta">@RequestParam</span> String waterEleId,<span class="meta">@RequestParam</span> String enterpriseName)</span><br><span class="line">在url中的?后面添加参数即可使用</span><br><span class="line">(<span class="meta">@RequestParam</span> Object object)</span><br><span class="line">GET请求中不可以使用</span><br></pre></td></tr></table></figure><h2 id="3-3-PathVariable-重要"><a href="#3-3-PathVariable-重要" class="headerlink" title="3.3.@PathVariable[重要]"></a>3.3.<code>@PathVariable</code>[重要]</h2><h3 id="3-3-1-Rest风格"><a href="#3-3-1-Rest风格" class="headerlink" title="3.3.1.Rest风格"></a>3.3.1.Rest风格</h3><ul><li>请求路径一样，可以根据不同的请求方式去执行后台的不同方法</li><li>Restful风格的URL优点<ul><li>结构清晰</li><li>符合标准</li><li>易于理解</li><li>扩展方便</li></ul></li></ul><p><img src="1578385736979.png" alt="1578385736979"></p><p><img src="1578385750781.png" alt="1578385750781"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.理解本真的REST架构风格: http:&#x2F;&#x2F;kb.cnblogs.com&#x2F;page&#x2F;186516&#x2F;</span><br><span class="line">2.深入浅出REST: http:&#x2F;&#x2F;www.infog.com&#x2F;cn&#x2F;articles&#x2F;rest-introduction</span><br></pre></td></tr></table></figure><h3 id="3-3-2-PathVariable"><a href="#3-3-2-PathVariable" class="headerlink" title="3.3.2.@PathVariable"></a>3.3.2.<code>@PathVariable</code></h3><ul><li>作用：用于绑定<code>url</code>中的占位符。<ul><li>请求<code>url</code>中<code>/delete/{id}</code>，这个<code>{id}</code>就是<code>url</code>占位符</li><li><strong><code>url</code>支持占位符是<code>spring3.0</code>之后加入的，是<code>springmvc</code>支持<code>rest</code>风格<code>URL</code>的一个重要标志。</strong></li></ul></li><li>属性<ul><li><code>value</code>：用于指定url中占位符名称</li><li><code>required</code>：是否必须提供占位符</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"yyx/hello/yyx"</span>&gt;</span>入门程序<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello/&#123;abcd&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@PathVariable(value = <span class="string">"abcd"</span>)</span> String name)</span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1578386196782.png" alt="1578386196782"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yyx</span><br></pre></td></tr></table></figure><h2 id="3-4-RequestHeader"><a href="#3-4-RequestHeader" class="headerlink" title="3.4.@RequestHeader"></a>3.4.<code>@RequestHeader</code></h2><ul><li>作用：用于获取请求消息头</li><li>属性：【同3.1<code>@RequestParam</code>】</li><li><strong>在实际开发中一般不怎么用</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"yyx/hello"</span>&gt;</span>入门程序<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@RequestHeader(value = <span class="string">"Content-Type"</span>,required = <span class="keyword">false</span>)</span> String contype,</span></span><br><span class="line"><span class="function">@<span class="title">RequestHeader</span><span class="params">(value = <span class="string">"Date"</span>)</span> String date)</span>&#123;</span><br><span class="line">    System.out.println(contype);</span><br><span class="line">    System.out.println(date);</span><br><span class="line">    <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用API Test插件</li></ul><p><img src="1578389359852.png" alt="1578389359852"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multipart&#x2F;form-dataBROKEN REFERENCE</span><br><span class="line">23</span><br></pre></td></tr></table></figure><h2 id="3-5-CookieValue"><a href="#3-5-CookieValue" class="headerlink" title="3.5.@CookieValue"></a>3.5.<code>@CookieValue</code></h2><ul><li><p>作用：用于把指定cookie名称的值传入控制器方法参数</p></li><li><p>属性：【同3.1<code>@RequestParam</code>】</p></li><li><p><strong>在实际开发中一般不怎么用</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;yyx&#x2F;hello&quot;&gt;入门程序&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@CookieValue(value = <span class="string">"JSESSIONID"</span>,required = <span class="keyword">false</span>)</span> String id)</span>&#123;</span><br><span class="line">    System.out.println(id);</span><br><span class="line">    <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1578386196782.png" alt="1578386196782"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8115EE2160ABBA27808A76664D050473</span><br></pre></td></tr></table></figure><h3 id="总结1："><a href="#总结1：" class="headerlink" title="总结1："></a>总结1：</h3><ul><li><p>Http协议常用的四种请求方式：Post、Get、Put、Delete等；其中Put、Delete请求方式很少见，都可用Post方式代替</p><ul><li>对数据库而言： get 请求不修改数据库，只是查询。Post是增加记录，put是更新，Delete数据库删除</li><li>Put，Post，Delete 方式的请求参数会直接放在requestBody里</li><li>处理 request uri 部分的注解，路径参数变量：@PathVariable</li><li>处理request header部分的注解：   @RequestHeader, @CookieValue，@RequestParam</li><li>处理request body部分的注解：@RequestParam， @RequestBody；　　</li></ul></li><li><p>综上所述：@RequestParam注解既可以接收Get方式的请求头中的参数，也可以接收Post方式的请求体中的参数；</p></li></ul><h3 id="总结2："><a href="#总结2：" class="headerlink" title="总结2："></a>总结2：</h3><ul><li>get请求的 headers 中没有 content-type 这个字段，post 的 content-type 有 ：<ul><li><code>application/x-www-form-urlencoded</code>，这种就是一般的文本表单用 post 传地数据，只要将得到的 data 用 @RequestParam 或 request.getParamter() 获取即可；</li><li><code>multipart/form-data</code> ，用于文件上传，此时 form 的 enctype 属性必须指定为 multipart/form-data；</li><li><code>application/json</code>，将数据以json对象的格式传递</li><li><code>text/xml</code></li></ul></li><li>put 和 delete 请求的headers 是有 content-type 这个字段的，只不过这两个方法类型目前不常用；</li></ul><h2 id="3-6-ModelAttribute"><a href="#3-6-ModelAttribute" class="headerlink" title="3.6.@ModelAttribute"></a>3.6.<code>@ModelAttribute</code></h2><ul><li>作用：该注解是<code>SpringMVC4.3</code>版本以后新加入的，它可以用于修饰方法和参数。<ul><li>在方法上：当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。</li><li>在参数上，获取指定的数据给参数赋值。</li></ul></li><li>属性:<ul><li><code>value/name</code>：用于获取数据的<code>key</code>。<code>key</code>可以是<code>POJO</code>的属性名称，也可以是<code>map</code>结构的<code>key</code>。</li></ul></li><li>应用场景：当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。<ul><li>例如：我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据是肯定没有此字段的内容，一旦更新会把该字段内容置为null,此时就可以使用此注解解决问题</li></ul></li></ul><h3 id="3-6-1-ModelAttribute方法会在控制器的方法执行之前执行"><a href="#3-6-1-ModelAttribute方法会在控制器的方法执行之前执行" class="headerlink" title="3.6.1.@ModelAttribute方法会在控制器的方法执行之前执行"></a>3.6.1.<code>@ModelAttribute</code>方法会在控制器的方法执行之前执行</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/saveUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testController</span><span class="params">(String uname, String age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testController"</span>+ uname + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testModelAttribute</span><span class="params">(String uname, String age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testModelAttribute"</span>+uname + age);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//============================================================</span></span><br><span class="line">    &lt;form action=<span class="string">"yyx/saveUser"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">        账户名：&lt;input type=<span class="string">"text"</span> name=<span class="string">"uname"</span>&gt;&lt;br/&gt;</span><br><span class="line">        年  龄：&lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span>&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"ok"</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br></pre></td></tr></table></figure><p><img src="1578399505850.png" alt="1578399505850"></p><p><img src="1578399494050.png" alt="1578399494050"></p><h3 id="3-6-2-ModelAttribute方法带返回值——保证没有提交数据的字段使用数据库对象原来的数据"><a href="#3-6-2-ModelAttribute方法带返回值——保证没有提交数据的字段使用数据库对象原来的数据" class="headerlink" title="3.6.2.@ModelAttribute方法带返回值——保证没有提交数据的字段使用数据库对象原来的数据"></a>3.6.2.<code>@ModelAttribute</code>方法带返回值——保证没有提交数据的字段使用数据库对象原来的数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/saveUser"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">testController</span><span class="params">(User user)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"testController"</span>+ user);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@ModelAttribute</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">testModelAttribute</span><span class="params">(String uname, String age)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       User user = serviceFindByName(uname);</span><br><span class="line">       System.out.println(<span class="string">"testModelAttribute run..."</span>+ user);</span><br><span class="line">       <span class="keyword">return</span> user;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 模拟数据库查询</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">serviceFindByName</span><span class="params">(String username)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       User user = <span class="keyword">new</span> User();</span><br><span class="line">       user.setUname(username);</span><br><span class="line">       user.setAge(<span class="number">19</span>);</span><br><span class="line">       user.setDate(<span class="keyword">new</span> Date());</span><br><span class="line">       <span class="keyword">return</span>  user;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"yyx/saveUser"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    账户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"uname"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    年  龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="1578400070341.png" alt="1578400070341"></p><p>表单中数据会<strong>覆盖</strong>从数据库读取的数据</p><p><img src="1578400139350.png" alt="1578400139350"></p><h3 id="3-6-3-ModelAttribute方法不带返回值——保证没有提交数据的字段使用数据库对象原来的数据"><a href="#3-6-3-ModelAttribute方法不带返回值——保证没有提交数据的字段使用数据库对象原来的数据" class="headerlink" title="3.6.3.@ModelAttribute方法不带返回值——保证没有提交数据的字段使用数据库对象原来的数据"></a>3.6.3.<code>@ModelAttribute</code>方法不带返回值——保证没有提交数据的字段使用数据库对象原来的数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@RequestMapping</span>(path=<span class="string">"/saveUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testController</span><span class="params">(@ModelAttribute(<span class="string">"abcd"</span>)</span>User user)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testController"</span>+ user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testModelAttribute</span><span class="params">(String uname, String age, Map&lt;String,User&gt; map)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        User user = serviceFindByName(uname);</span><br><span class="line">        System.out.println(<span class="string">"testModelAttribute run..."</span>+ user);</span><br><span class="line">        map.put(<span class="string">"abcd"</span>,user);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟数据库查询 同上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//============================================================</span></span><br><span class="line">     <span class="comment">//表单提交 同上</span></span><br></pre></td></tr></table></figure><p><img src="1578400070341.png" alt="1578400070341"></p><p>表单中数据会<strong>覆盖</strong>从数据库读取的数据</p><p><img src="1578400447580.png" alt="1578400447580"></p><h2 id="3-7-SessionAttributes-重要"><a href="#3-7-SessionAttributes-重要" class="headerlink" title="3.7.@SessionAttributes[重要]"></a>3.7.<code>@SessionAttributes</code>[重要]</h2><ul><li>默认情况下<code>Spring MVC</code>将模型中的数据存储到<code>request</code>域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到<code>session</code></li><li>作用：<strong>可以使得模型中的数据存储一份到<code>session</code>域中</strong></li><li>范围：<strong>仅仅作用在类上</strong></li><li>属性：<ul><li><code>value/names</code>：存储到session域数据的属性名称</li><li><code>types</code>：用于指定存入的数据类型</li></ul></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开始EL表达式注解</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> isELIgnored=<span class="string">"false"</span> %&gt;</span><br></pre></td></tr></table></figure><ul><li><code>success.jsp</code></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sessionScope.username:  $&#123;sessionScope.username&#125;&lt;br&gt;</span><br><span class="line">sessionScope.password:  $&#123;sessionScope.password&#125;&lt;br&gt;</span><br><span class="line">sessionScope.age:  $&#123;sessionScope.age&#125;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">requestScope.username:  $&#123;requestScope.username&#125;&lt;br&gt;</span><br><span class="line">requestScope.password:  $&#123;requestScope.password&#125;&lt;br&gt;</span><br><span class="line">requestScope.age:  $&#123;requestScope.age&#125;&lt;br&gt;</span><br></pre></td></tr></table></figure><ul><li><code>SessionAttributesTest</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.ModelMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.SessionAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.support.SessionStatus;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes</span>(value = &#123;<span class="string">"username"</span>,<span class="string">"password"</span>&#125;)</span><br><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/springmvc"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionAttributesTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/sessionPut"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPut</span><span class="params">(Model model)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"username"</span>,<span class="string">"gold"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"password"</span>,<span class="string">"123"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"age"</span>,<span class="string">"23"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/sessionGet"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testGet</span><span class="params">(ModelMap model)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(model.get(<span class="string">"username"</span>));</span><br><span class="line">        System.out.println(model.get(<span class="string">"password"</span>));</span><br><span class="line">        System.out.println(model.get(<span class="string">"age"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/sessionClean"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testClean</span><span class="params">(SessionStatus sessionStatus)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sessionStatus.setComplete();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>index.jsp</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="springmvc/sessionPut"&gt;存入SessionAttribute&lt;/a&gt;</span><br><span class="line">&lt;a href="springmvc/sessionGet"&gt;取出SessionAttribute&lt;/a&gt;</span><br><span class="line">&lt;a href="springmvc/sessionClean"&gt;清除SessionAttribute&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><img src="1578404462290.png" alt="1578404462290"></p><p><img src="1578404472995.png" alt="1578404472995"></p><p><img src="1578404504684.png" alt="1578404504684"></p><p><img src="1578404496939.png" alt="1578404496939"></p><p><img src="1578404513763.png" alt="1578404513763"></p><p><img src="1578404520248.png" alt="1578404520248"></p><p><img src="1578404530895.png" alt="1578404530895"></p><p><img src="1578404612544.png" alt="1578404612544"></p><p><img src="1578404623243.png" alt="1578404623243"></p>]]></content>
    
    <summary type="html">
    
      常用注解
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="SpringMVC" scheme="http://goldcarpenter.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="http://goldcarpenter.github.io/2019/11/05/SpringMVC_Part1/"/>
    <id>http://goldcarpenter.github.io/2019/11/05/SpringMVC_Part1/</id>
    <published>2019-11-04T16:00:00.000Z</published>
    <updated>2020-06-17T08:00:57.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-SpringMVC入门"><a href="#1-SpringMVC入门" class="headerlink" title="1.SpringMVC入门"></a>1.SpringMVC入门</h1><h2 id="1-1-MVC模式"><a href="#1-1-MVC模式" class="headerlink" title="1.1.MVC模式"></a>1.1.MVC模式</h2><ul><li><code>MVC</code>全名是<code>Model View Controller</code>是模型(<code>model</code>)  视图(<code>view</code>) 控制器(<code>controller</code>)的缩写，是一种用于设计创建Web应用程序<strong>表现层</strong>的模式。</li><li>MVC中每个部分各司其职:<ul><li>Model (模型) ：通常指的就是数据模型，<code>JavaBean</code>类。一般情况下用于封装数据</li><li>View (视图) ：通常指的就是我们的<code>jsp</code>/<code>html</code>。一般用于展示数据的</li><li>Controller (控制器) ：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。</li></ul></li></ul><h2 id="1-2-SpringMVC模式"><a href="#1-2-SpringMVC模式" class="headerlink" title="1.2.SpringMVC模式"></a>1.2.SpringMVC模式</h2><ul><li>SpringMVC是一种基于Java的实现<strong>MVC设计模型</strong>的请求驱动类型的<strong>轻量级Web框架</strong></li><li>属于Spring FrameWork的后续产品，已经融合在Spring Web Flow 里面</li><li><code>Spring</code>框架提供了构建Web应用程序的<strong>全功能MVC模块</strong>。</li><li>使用Spring可插入的MVC架构，从而在进行WEB开发时，可以选择<code>Spring</code>的<code>Spring MVC</code>框架或其他MVC开发框架，如<code>Struts2</code>等</li></ul><h2 id="1-3-入门程序"><a href="#1-3-入门程序" class="headerlink" title="1.3.入门程序"></a>1.3.入门程序</h2><p><img src="1578324261588.png" alt="1578324261588"></p><ul><li>当启动<code>Tomcat</code>服务器的时候，因为配置了<code>load-on-startup</code>标签，所以会创建<code>DispatcherServlet</code>对象，就会加载<code>springmvc.xml</code>配置文件</li><li><code>springmvc.xml</code>开启了注解扫描，<code>Spring</code>容器就会创建<code>HelloController</code>对象</li><li>打开浏览器，从<code>index.jsp</code>发送请求，请求会先到达<code>DispatcherServlet</code>核心控制器，根据配置<code>@RequestMapping</code>注解找到执行的具体方法</li><li>根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的<code>JSP</code>文件</li><li><code>Tomcat</code>服务器渲染页面，做出响应</li></ul><p><img src="1578365574745.png" alt="1578365574745"></p><ul><li><code>pom.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.carpenter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringMVC_Study<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>web.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置中央调度器 拦截所有请求--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--配置DispatcherServlet 的一个初始化参数:配置SpringMVC 配置文件的位置和名称--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>index.jsp</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;入门程序&lt;&#x2F;h3&gt;</span><br><span class="line">######注意！此处URL没有&#x2F; 如果有&#x2F;则访问时没有项目路径</span><br><span class="line">&lt;a href&#x3D;&quot;hello&quot;&gt;入门程序&lt;&#x2F;a&gt;  </span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><ul><li><code>success.jsp</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;入门成功&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li><code>springmvc.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注解扫描位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top.carpenter"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    视图解析器对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--SpringMVC 框架支持注解--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>HelloController</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello MVC"</span>);</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-组件方式执行流程"><a href="#1-4-组件方式执行流程" class="headerlink" title="1.4.组件方式执行流程"></a>1.4.组件方式执行流程</h2><p><img src="%E7%BB%84%E4%BB%B6.png" alt=""></p><ul><li><p><code>DispatcherServlet</code>前端控制器</p><ul><li>用户请求到达前端控制器，它就相当于<code>mvc</code>模式中的<code>c</code>，<code>dispatcherservlet</code>是整个流程控制的中心，由它调用其它组件处理用户的请求，<code>dispatcherServlet</code>的存在降低了组件之间的耦合性</li></ul></li><li><p><code>HandlerMapping</code>处理器映射器</p><ul><li><p><code>HandlerMapping</code>负责根据用户请求找到<code>Handler</code>即处理器，<code>SpringMVC</code>提供了不同的映射器实现不同的映射方式，例如:配置文件方式，实现接口方式，注解方式等。</p><p><img src="1584879264052.png" alt="1584879264052"></p><p><code>&lt;mvc:default-servlet-handler/&gt;</code></p><p><img src="1584879305167.png" alt="1584879305167"></p></li></ul></li><li><p><code>Handler</code>处理器</p><ul><li>它就是我们开发中要编写的具体业务控制器。由<code>DispatcherServlet</code>把用户请求转发到<code>Handler</code>，由<br><code>Handler</code>对具体的用户请求进行处理。</li></ul></li><li><p><code>HandlAdapter</code>处理器适配器</p><ul><li>通过<code>HandlerAdapter</code>对处理器进行执行，这是<strong>适配器模式的应用</strong>，通过扩展适配器可以对更多类型的处理器进行执行<ul><li>表单数据类型校验/转换….</li></ul></li></ul></li><li><p><code>View Resolver</code>视图解析器</p><ul><li><code>View Resolver</code>负责将处理结果生成View视图，<code>View Resolver</code>首先根据<strong>逻辑视图名</strong>解析成<strong>物理视图名</strong><br>即具体的页面地址，再生成<code>View</code>视图对象，最后对<code>View</code>进行渲染将处理结果通过页面展示给用户</li><li>所有的视图解析器都必须实现 ViewResolver 接口</li><li>可以选择一种视图解析器或混用多种视图解析器</li><li>每个视图解析器都实现了<code>Ordered</code>接口并开放出一个<code>order</code>属性，可以通过<code>order</code>属性指定解析器的优先顺序，<code>order</code>越小优先级越高。 </li><li><code>SpringMVC</code>会按视图解析器顺序的优先顺序对逻辑视图名进行解析，直到解析成功并返回视图对象，否则将抛出 ServletException 异常</li></ul></li><li><p><code>View</code>视图</p><ul><li><code>SpringMVC</code>框架提供了很多的View视图类型的支持，包括:<code>jstlView</code>、<code>freemarkerView</code>、<code>pdfView</code><br>等，最常用的视图就是<code>jsp</code></li><li>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面</li><li><strong>视图对象由视图解析器负责实例化。由于视图是无状态的，所以不会有线程安全的问题</strong></li></ul></li></ul><h2 id="1-5-xml-注解配置说明"><a href="#1-5-xml-注解配置说明" class="headerlink" title="1.5.xml/注解配置说明"></a>1.5.xml/注解配置说明</h2><ul><li><p><code>&lt;mvc:annotation-driven&gt;</code></p><ul><li>在<code>SpringMVC</code>的各个组件中，<strong>处理器映射器</strong>、<strong>处理器适配器</strong>、<strong>视图解析器</strong>称为SpringMVC的三大组件</li><li>使用<code>&lt;mvc: annotation-driven&gt;</code>自动加载<code>RequestMappingHandlerMapping</code> (处理映射器)和<code>RequestMappingHandlerAdapter</code>(处理适配器) <code>ExceptionHandlerExceptionResolver</code>，可用在<code>springMVC.xml</code>配置文件中使用<code>&lt;mvc:annotation-driven&gt;</code>替代注解处理器和适配器的配置。</li></ul></li><li><p>支持使用<code>ConversionService</code>实例对表单参数进行类型转换</p><ul><li>支持使用<code>@NumberFormat</code>、<code>@DateTimeFormat</code>注解完成数据类型的格式化</li><li>支持使用<code>@Valid</code>注解对<code>JavaBean</code>实例进行<code>JSR 303</code>验证</li><li>支持使用<code>@RequestBody</code>和<code>@ResponseBody</code>注解</li></ul></li><li><p><code>@RequestMaping</code></p><ul><li><p>用于建立请求URL和处理请求方法之间的对应关系</p></li><li><p>属性</p><ul><li><code>value/path</code>:用于指定请求的URL</li><li><code>method</code>:用于指定请求的方式</li><li><code>params</code>:用于限制请求的参数，即必须包含的参数。它支持简单的表达式，要求<code>url</code>请求参数的<code>key</code>和<code>value</code>必须和此参数配置的一模一样【不常用】</li><li><code>headers</code>:用于限制请求消息头，即必须包含的消息头【不常用】</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>,params = &#123;<span class="string">"name=yyx"</span>&#125;,  method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello MVC"</span>+ name);</span><br><span class="line">    <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>位置</p><ul><li>类名——<strong>需要以<code>/</code>开头</strong>：第一级的访问目录</li><li>方法名：第二级的访问目录</li></ul></li></ul></li></ul><h1 id="2-SpringMVC请求参数的绑定"><a href="#2-SpringMVC请求参数的绑定" class="headerlink" title="2.SpringMVC请求参数的绑定"></a>2.SpringMVC请求参数的绑定</h1><ul><li>不使用@RequestParam注解直接进行对象属性赋值（不推荐使用，容易和@ReuqestBody混淆）</li></ul><h2 id="2-1绑定的机制"><a href="#2-1绑定的机制" class="headerlink" title="2.1绑定的机制"></a>2.1绑定的机制</h2><ul><li><p>表单中请求参数都是基于<code>key=value</code>的</p></li><li><p>SpringMVC绑定请求参数的过程是通过<strong>表单提交请求参数</strong>，作为<strong>控制器中方法参数</strong>进行<strong>绑定</strong>的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"yyx/hello?name=yyx"</span>&gt;</span>入门程序<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Hello MVC"</span>+ name);</span><br><span class="line">      <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-支持的数据类型"><a href="#2-2-支持的数据类型" class="headerlink" title="2.2.支持的数据类型"></a>2.2.支持的数据类型</h2><ul><li><code>SpringMVC</code>绑定请求参数是<strong>自动实现</strong>的，但是要想使用，<strong>必须遵循使用要求</strong></li></ul><h3 id="2-2-1-基本类型参数和String类型"><a href="#2-2-1-基本类型参数和String类型" class="headerlink" title="2.2.1.基本类型参数和String类型"></a>2.2.1.<strong>基本类型参数</strong>和<strong><code>String</code>类型</strong></h3><ul><li><strong>参数名称</strong>必须和控制器中<strong>方法的形参名称</strong>保持一致【严格区分大小写】</li></ul><h3 id="2-2-2-pojo类型参数：包括实体类，以及关联的实体类"><a href="#2-2-2-pojo类型参数：包括实体类，以及关联的实体类" class="headerlink" title="2.2.2.pojo类型参数：包括实体类，以及关联的实体类"></a>2.2.2.<strong><code>pojo</code>类型参数</strong>：包括实体类，以及关联的实体类</h3><ul><li><strong>表单中参数名</strong>称和<strong><code>pojo</code>类的属性名称</strong>保持一致。并且控制器<strong>方法的参数类型是pojo</strong>类型</li><li>如果一个<code>JavaBean</code>类中包含其他的引用类型， 那么表单的<code>name</code>属性需要编写成:对象.属性例如：<code>address.name</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"yyx/accountSave"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    账户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密  码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    金  额：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"money"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user.uname"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    年  龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user.age"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String uname;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    # set get toString方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    # set get toString方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@RequestMapping</span>(path=<span class="string">"/accountSave"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(Account account)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(account);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//========================================================</span></span><br><span class="line">Account&#123;username=<span class="string">'杨雨鑫'</span>, password=<span class="string">'123'</span>, money=<span class="number">4.0</span>, user=User&#123;uname=<span class="string">'杨雨鑫'</span>, age=<span class="number">23</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-数组，List结构和Map结构的集合"><a href="#2-2-3-数组，List结构和Map结构的集合" class="headerlink" title="2.2.3.数组，List结构和Map结构的集合"></a>2.2.3.<strong>数组</strong>，<strong>List结构</strong>和<strong>Map结构</strong>的集合</h3><ul><li>在表单中<strong>请求参数名称</strong>要和<strong><code>pojo</code>中集合属性名称</strong>相同<ul><li>给List集合中的元素赋值，使用下标</li><li>给Map集合中的元素赋值，使用键值对    </li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"yyx/accountSave"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    账户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密  码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    金  额：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"money"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"list_users[0].uname"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"map_users['yyx'].uname"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    年  龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"list_users[0].age"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    年  龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"map_users['yyx'].age"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; list_users;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,User&gt; map_users;</span><br><span class="line">    <span class="comment">//set get toString方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String uname;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//set get toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/accountSave"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(Account account)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.println(account);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">========================================================</span><br><span class="line">Account&#123;username=<span class="string">'杨雨鑫'</span>, password=<span class="string">'123'</span>, money=<span class="number">4.0</span>, list_users=[User&#123;uname=<span class="string">'杨雨鑫'</span>, age=<span class="number">23</span>&#125;], map_users=&#123;yyx=User&#123;uname=<span class="string">'杨雨鑫'</span>, age=<span class="number">23</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-4-数据绑定流程"><a href="#2-2-4-数据绑定流程" class="headerlink" title="2.2.4 数据绑定流程"></a>2.2.4 数据绑定流程</h3><ul><li><code>Spring MVC</code>主框架<strong>将<code>ServletRequest</code>对象及目标方法的入参实例传递给<code>WebDataBinderFactory</code>实例</strong>，以创建<code>DataBinder</code>实例对象</li><li><code>DataBinder</code>调用装配在<code>Spring MVC</code>下文中的<code>ConversionService</code>组件进行数据类型转换、数据格式化工作。将 Servlet 中的请求信息填充到入参对象中 </li><li>调用<code>Validator</code>组件对已经绑定了请求消息的入参对象进行数据合法性校验，并最终生成数据绑定结果<code>BindingData</code>对象</li><li><code>Spring MVC</code>抽取<code>BindingResult</code>中的入参对象和校验错误对象，将它们赋给处理方法的响应入参</li></ul><p><img src="1584782101133.png" alt="1584782101133"></p><blockquote><p>数据绑定的核心部件是 DataBinder</p></blockquote><h3 id="2-2-5-自定义类型转换器"><a href="#2-2-5-自定义类型转换器" class="headerlink" title="2.2.5.自定义类型转换器"></a>2.2.5.自定义类型转换器</h3><ul><li><p><strong><code>ConversionService</code>是 Spring 类型转换体系的核心接口</strong></p></li><li><p>可以利用<code>ConversionServiceFactoryBean</code>在<code>Spring</code>的<code>IOC</code>容器中定义一个<code>ConversionService</code> ，<code>Spring</code>将自动识别出 IOC 容器中的<code>ConversionService</code>，并在 Bean 属性配置及 Spring MVC 处理方法入参绑定等场合使用它进行数据的转换</p></li><li><p>可通过<code>ConversionServiceFactoryBean</code>的<code>converters</code>属性注册自定义的类型转换器</p></li><li><p><code>&lt;mvc:annotation-driven conversion-service= &quot;conversionService&quot;/&gt;</code>会将自定义的<code>ConversionService</code>注册到<code>Spring MVC</code>的上下文中</p><p><img src="1584788751251.png" alt="1584788751251"></p></li><li><p>Spring 定义了 3 种类型的转换器接口，实现任意一个转换 器接口都可以作为自定义转换器注册到 ConversionServiceFactroyBean 中</p><ul><li>Converter&lt;S,T&gt;：将 S 类型对象转为 T 类型对象</li><li>ConverterFactory：将相同系列多个 “同质” Converter 封装在一 起。如果希望将一种类型的对象转换为另一种类型及其子类的对 象（例如将 String 转换为 Number 及 Number 子类 （Integer、Long、Double 等）对象）可使用该转换器工厂类 </li><li>GenericConverter：会根据源类对象及目标类对象所在的宿主类 中的上下文信息进行类型转换</li></ul></li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul><li><p>表单提交的任何数据类型全部都是字符串类型，但是后台定义Integer类型，数据也可以封装上，说明Spring框架内部会默认进行数据类型转换</p></li><li><p>如果想自定义数据类型转换，可以实现Converter的接口</p></li><li><p>问题引入</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"yyx/saveUser"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    账户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"uname"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密  码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    日  期：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"date"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String uname;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">    <span class="comment">//set get toString方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/saveUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(User user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1578380463888.png" alt="1578380463888"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入 xxxx/xx/xx成功封装</span></span><br><span class="line">User&#123;uname=<span class="string">'杨雨鑫'</span>, age=<span class="number">123</span>, date=Wed Mar <span class="number">03</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">2010</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="1578380541526.png" alt="1578380541526"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入 xxxx-xx-xx封装失败</span></span><br></pre></td></tr></table></figure><p><img src="1578380553445.png" alt="1578380553445"></p><ul><li><p>定义一个类实现<code>Converter</code>接口，<strong>实现自定义的转换器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.utils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.convert.converter.Converter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//    实现其唯一抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        DateFormat formate = <span class="keyword">null</span>;</span><br><span class="line">        Date date = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(str))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"请输入日期"</span>);</span><br><span class="line">            formate = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">            date = formate.parse(str);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>Spring</code>配置文件中配置类型转换器</p><ul><li><code>Spring</code>配置类型转换器的机制是，将<strong>自定义的转换器注册到类型转换服务</strong>中去。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    在Spring配置文件中配置类型转换器工厂--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> =<span class="string">"converterService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--       使用工厂类的set注入一个新的类型转换器（自定义的）--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"top.carpenter.utils.StringToDateConverter"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>annotation-driven</code>标签中引用配置的类型转换服务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"converterService"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="1578381876422.png" alt="1578381876422"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User&#123;uname&#x3D;&#39;杨雨鑫&#39;, age&#x3D;123, date&#x3D;Sat Mar 02 00:00:00 CST 2019&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-6数据格式化"><a href="#2-2-6数据格式化" class="headerlink" title="2.2.6数据格式化"></a>2.2.6数据格式化</h3><ul><li><p><code>Spring</code>在格式化模块中定义了一个实现<code>ConversionService</code>接口的<code>FormattingConversionService</code>实现类，该实现类扩展了<code>GenericConversionService</code>，因此它<strong>既具有类型转换的功能，又具有格式化</strong>的功能 </p></li><li><p><code>FormattingConversionService</code>拥有一个<code>FormattingConversionServiceFactroyBean</code>工厂类， 后者用于在 Spring 上下文中构造前者</p></li><li><p>FormattingConversionServiceFactroyBean 内部已经注册了</p><ul><li>NumberFormatAnnotationFormatterFactroy：支持对数字类型的属性 使用 @NumberFormat 注解</li><li>JodaDateTimeFormatAnnotationFormatterFactroy：支持对日期类型 的属性使用 @DateTimeFormat 注解</li></ul></li><li><p>装配了<code>FormattingConversionServiceFactroyBean</code>后，就可以在<code>Spring MVC</code>入参绑定及模型数据输出时使用注解驱动了。</p></li><li><p><code>&lt;mvc:annotation-driven/&gt;</code>默认创建的<code>ConversionService</code>实例即为<code>FormattingConversionServiceFactroyBean</code></p></li><li><p>日期格式化</p><ul><li><code>@DateTimeFormat</code>注解可对<code>java.util.Date</code> <code>java.util.Calendar</code> <code>java.long.Long</code>时间</li><li>类型进行标注： <code>pattern</code>属性：类型为字符串。指定解析/格式化字段数据的模式， 如：<code>yyyy-MM-dd hh:mm:ss</code></li></ul></li><li><p>数值格式化</p><ul><li><code>@NumberFormat</code>可对类似数字类型的属性进行标注</li></ul></li></ul><h3 id="2-2-7-JSR-303"><a href="#2-2-7-JSR-303" class="headerlink" title="2.2.7 JSR 303"></a>2.2.7 JSR 303</h3><ul><li><p>JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对 Bean 进行验证</p><p><img src="1584790438648.png" alt="1584790438648"></p></li><li><p><strong>Hibernate Validator 是 JSR 303 的一个参考实现</strong>，除支持 所有标准的校验注解外，它还支持以下的扩展注解</p><p><img src="1584790471272.png" alt="1584790471272"></p></li><li><p><strong>Spring 4.0 拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。</strong></p></li><li><p>Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在 Spring MVC 中，可直接通过注解驱动的方式进行数据校验</p></li><li><p>Spring 的 LocalValidatorFactroyBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在 Spring 容器中定义了一个 LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean 中。</p></li><li><p><code>&lt;mvc:annotation-driven/&gt;</code>会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标 注 @valid 注解即可让 Spring MVC 在完成数据绑定后执行 数据校验的工作</p></li><li><p>校验结果保存到随后的入参中，这个保存校验结果的入参必须是 BindingResult 或 Errors 类型，这两个类都位于 org.springframework.validation 包中</p></li><li><p>Spring 本身并没有提供 JSR303 的实现，所以必须将 JSR303 的实现者的 jar 包放到类路径下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/emp"</span>, method=RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(@Valid Employee employee, BindingResult result, Map&lt;String, Object&gt; mapl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(result.getErrorCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"出错了!"</span>);</span><br><span class="line">        <span class="keyword">for</span>(FieldError error : result. getFieldErrors())&#123;</span><br><span class="line">            System.out.println(error.getField() + <span class="string">":"</span> + error.getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//若验证出错，则转向定制的页面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">" input"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    employeeDao.save( employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/emps"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>需校验的 Bean 对象和其绑定结果对象或错误对象时成对出现的，之间不允许声明其他的入参 </p></li><li><p>Errors 接口提供了获取错误信息的方法</p><pre><code>* getErrorCount()* getFieldErrors(String field) </code></pre></li><li><p>BindingResult 扩展了 Errors 接口</p></li></ul></blockquote></li></ul><h2 id="2-3-解决中文乱码问题"><a href="#2-3-解决中文乱码问题" class="headerlink" title="2.3.解决中文乱码问题"></a>2.3.解决中文乱码问题</h2><ul><li><code>SpringMVC</code>可以配置中文乱码</li><li><code>web.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  配置中文乱码过滤器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="1578379929857.png" alt="1578379929857"></p><h2 id="2-4-使用ServletAPI对象作为方法参数-重要"><a href="#2-4-使用ServletAPI对象作为方法参数-重要" class="headerlink" title="2.4.使用ServletAPI对象作为方法参数[重要]"></a>2.4.使用ServletAPI对象作为方法参数[重要]</h2><ul><li><p><code>SpringMVC</code>支持使用原始<code>ServletAPI</code>对象作为控制器方法的参数。</p></li><li><p>支持原始ServletAPI对象有:</p><ul><li><code>HttpServletRequest</code></li><li><code>HttpServletResponse</code></li><li><code>HttpSession</code></li><li><code>java.security.Principal</code></li><li><code>Locale</code></li><li><code>InputStream</code></li><li><code>OutputStream</code></li><li><code>Reader</code></li><li><code>Writer</code></li></ul></li><li><p>我们可以把上述对象，<strong>直接写在控制的方法参数</strong>中使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/saveUser"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(User user, HttpServletRequest request)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      System.out.println(user);</span><br><span class="line">      System.out.println(request.getSession());</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      SpringMVC入门
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="SpringMVC" scheme="http://goldcarpenter.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>String底层总结</title>
    <link href="http://goldcarpenter.github.io/2019/11/01/String%E6%80%BB%E7%BB%93/"/>
    <id>http://goldcarpenter.github.io/2019/11/01/String%E6%80%BB%E7%BB%93/</id>
    <published>2019-11-01T14:54:45.000Z</published>
    <updated>2020-06-17T03:17:31.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String底层总结"><a href="#String底层总结" class="headerlink" title="String底层总结"></a>String底层总结</h1><h2 id="1-字符串创建方式"><a href="#1-字符串创建方式" class="headerlink" title="1.字符串创建方式"></a>1.字符串创建方式</h2><ul><li>字符串有六种基本的创建方式<ul><li>使用<code>char[]</code>数组配合<code>new</code>来创建</li><li>使用<code>byte[]</code>数组配合<code>new</code>来创建</li><li>使用<code>int[]</code>数组配合<code>new</code>来创建</li><li>使用 已有字符串 配合<code>new</code>来创建</li><li>使用字面量创建（不使用<code>new</code>）</li><li>合二为一，使用<code>+</code>运算符来拼接创建</li></ul></li></ul><p>可以看到，至少从表面上讲，后两种都没有用到 new 关键字</p><h3 id="1-1-char-数组创建"><a href="#1-1-char-数组创建" class="headerlink" title="1.1 char[] 数组创建"></a>1.1 char[] 数组创建</h3><ul><li>这种是最基本的，因为字符串本身就是将字符串起来</li><li>String底层结构就是多个字符的 char[] 数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;);</span><br></pre></td></tr></table></figure><p>它的内部结构如下（1.8）</p><p><img src="st01-1589963576703.png" alt=""></p><p>其中 97 其实就是 ‘a’ ，98 其实就是 ‘b’ ，99 其实就是 ‘c’ </p><h3 id="1-2-byte-数组创建"><a href="#1-2-byte-数组创建" class="headerlink" title="1.2 byte[] 数组创建"></a>1.2 byte[] 数组创建</h3><ul><li><p>什么时候会根据 byte[] 数组来创建字符串呢【从 byte[] 转为字符串的需求】</p><ul><li>从网络（例如一个浏览器的 http 请求）传递过来的字节数据</li><li>从 I/O（例如从一个文本文件）读取到的数据</li></ul></li><li><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;); <span class="comment">// abc</span></span><br></pre></td></tr></table></figure><p>其中 <code>new byte[]{97, 98, 99}</code> 就可以是</p><ul><li>从网络（例如一个浏览器的 http 请求）传递过来的字节数据</li><li>从 I/O（例如从一个文本文件）读取到的数据</li></ul></li><li><p>它的内部结构其实也是</p></li></ul><p><img src="st01.png" alt=""></p><p>这时 byte[] 会在构造时被转换为 char[]，其中 byte[] 和 char [] 的结构如下</p><p><img src="st02.png" alt=""></p><p>看到上幅图有同学会说，对于 byte[] 转换为 char[]，97 还是对应 97，98 还是对应 98，99 还是对应 99 啊，看不出 byte[] 和 char[] 的任何区别啊？你要知道，首先他们的大小不一样，其次上面的 char[] 中的 97（a），98（b），99（c） 都属于拉丁字符集，如果用到其它字符集，那么结果就不一样了，看下面的例子</p><ul><li><p>按 gbk 字符集转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = &#123;(<span class="keyword">byte</span>) <span class="number">0xD5</span>, (<span class="keyword">byte</span>) <span class="number">0xC5</span>&#125;;</span><br><span class="line">String str = <span class="keyword">new</span> String(bytes, Charset.forName(<span class="string">"gbk"</span>));</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><p>这时</p></li></ul><p><img src="st04.png" alt=""></p><ul><li><p>其中两个<code>byte 0xD5</code>和 <code>0xC5</code>被转换成了一个 char 0x5F20（汉字【张】）</p></li><li><p>按<code>utf-8</code>字符集转换</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = &#123;(<span class="keyword">byte</span>) <span class="number">0xE5</span>, (<span class="keyword">byte</span>) <span class="number">0xBC</span>, (<span class="keyword">byte</span>) <span class="number">0xA0</span>&#125;;</span><br><span class="line">      String str = <span class="keyword">new</span> String(bytes, Charset.forName(<span class="string">"utf-8"</span>));</span><br><span class="line"><span class="comment">//String str = new String(bytes);等价</span></span><br><span class="line">      System.out.println(str);</span><br></pre></td></tr></table></figure><p><img src="st03.png" alt=""></p><p>其中三个<code>byte 0xE5</code>，<code>0xBC</code> 和<code>0xA0</code> 被转换成了一个<code>char 0x5F20</code>（汉字【张】）</p><p><strong>其实 java 中的 char 字符都是以 unicode 编码的，从外界不同的编码（如 gbk，utf-8）传过来的 byte[] 最终到 java 中的 char 都统一了</strong></p><h3 id="1-3-int-数组创建"><a href="#1-3-int-数组创建" class="headerlink" title="1.3 int[] 数组创建"></a>1.3 int[] 数组创建</h3><p>有时候我们还需要用两个 char 表示一个字符，比如 😂 这个笑哭的字符，它用 unicode 编码表示为 0x1F602，存储范围已经超过了 char 能表示的最大值 0xFFFF，因此需要使用 int[] 来构造这样的字符串，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0x1F602</span>&#125;, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>转换过程如图所示</p><p><img src="st05.png" alt=""></p><blockquote><p>参考</p><p><a href="http://unicode.org/versions/Unicode9.0.0/" target="_blank" rel="noopener">unicode 9.0 说明</a></p><p><a href="http://www.unicode.org/emoji/charts/emoji-versions.html#v9.0_2016" target="_blank" rel="noopener">unicode 中的 emoji 表情</a></p></blockquote><h3 id="1-4-从已有字符串创建"><a href="#1-4-从已有字符串创建" class="headerlink" title="1.4 从已有字符串创建"></a>1.4 从已有字符串创建</h3><p>直接看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种最为简单，但要注意是两个字符串对象<strong>引用同一个 char[] 对象</strong>，但是引用值不相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(s1);</span><br></pre></td></tr></table></figure><p>内存结构如下</p><p><img src="st09.png" alt=""></p><h3 id="1-5-字面量创建"><a href="#1-5-字面量创建" class="headerlink" title="1.5 字面量创建"></a>1.5 字面量创建</h3><p>以上四种创建方式，大家用的实际上相对少一点，最熟悉的是这种字面量的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"abc"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>&quot;abc&quot;</code>  被叫做字符串字面量</strong>（英文 Literal），但恰恰是这种方式其实奥妙最多<ul><li><strong>非对象</strong></li><li><strong>懒加载</strong></li><li><strong>不重复</strong></li></ul></li></ul><h4 id="1-5-1非对象"><a href="#1-5-1非对象" class="headerlink" title="1.5.1非对象"></a>1.5.1非对象</h4><p>严格地说，<strong>字面量在代码运行到它所在语句之前，它还不是字符串对象</strong></p><p>要理解从字面量变成字符串对象的过程，需要从字节码的角度来分析</p><p>在上面的 java 代码被编译为 class 文件后，<code>&quot;abc&quot;</code>  存储于【类文件常量池】中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constant pool: &#x2F;&#x2F; 常量池</span><br><span class="line">   #1 &#x3D; Methodref          #19.#41        &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; String             #42            &#x2F;&#x2F; abc</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>当 class 完成类加载之后，<code>&quot;abc&quot;</code>  这个字面量被存储于【运行时常量池】（归属于方法区）中，其中 #1 #2 都会被翻译为运行时真正的内存地址</p><p>再看一下 class 中 main 方法的字节码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]); &#x2F;&#x2F; 字节码指令</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;2, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String abc</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: return</span><br><span class="line">         ...</span><br></pre></td></tr></table></figure><p>将来 main 方法被调用时，就会执行里面的字节码指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: ldc           #2                  &#x2F;&#x2F; String abc</span><br><span class="line">2: astore_1</span><br><span class="line">3: return</span><br></pre></td></tr></table></figure><p><strong><code>ldc #2</code> 就是到运行时常量池中找到 #2 的内存地址，找到 <code>&quot;abc&quot;</code>  这个字面量，再根据它创建一个 String 对象。</strong></p><p><img src="st11.png" alt=""></p><h4 id="1-5-2懒加载"><a href="#1-5-2懒加载" class="headerlink" title="1.5.2懒加载"></a>1.5.2懒加载</h4><ul><li><p><strong>当第一次用到 <code>&quot;abc&quot;</code>  字面量时（就是执行到 <code>ldc #2</code> 时） ，才会创建对应的字符串对象</strong></p></li><li><p>如何验证呢？</p></li></ul><p>例如有如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"1"</span>); <span class="comment">// 断点1 2411</span></span><br><span class="line">System.out.println(<span class="string">"2"</span>); <span class="comment">// 断点2 2412</span></span><br><span class="line">System.out.println(<span class="string">"3"</span>); <span class="comment">// 断点3</span></span><br></pre></td></tr></table></figure><p>可以给每行语句加上断点，然后用 idea 的 debug 界面中的 memory 工具来查看字符串对象的数量</p><p>刚开始在断点1 处，其它类中创建的字符串对象有 2411 个</p><p><img src="st06.png" alt=""></p><p>执行到断点2 处，这时新创建了 <code>&quot;1&quot;</code> 对应的字符串对象，个数为 2412</p><p><img src="st07.png" alt=""></p><p>执行到断点3 处，这时新创建了 <code>&quot;2&quot;</code> 对应的字符串对象，个数为 2413</p><p><img src="st08.png" alt=""></p><h4 id="1-5-3不重复"><a href="#1-5-3不重复" class="headerlink" title="1.5.3不重复"></a>1.5.3不重复</h4><p><strong>同一个类中的值相同字面量，其实只有一份</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量池为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #25.#48        &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; String             #49            &#x2F;&#x2F; abc</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>对应的字节码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String abc</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: ldc           #2                  &#x2F;&#x2F; String abc</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: return</span><br><span class="line">         ...</span><br></pre></td></tr></table></figure><p>可以看到 <code>&quot;abc&quot;</code> 这个字面量虽然出现了 2 次，但实际上都是对应着常量池中 #2 这个地址</p><p>如果是不同类中的 <code>&quot;abc&quot;</code> 呢？【类文件常量池】包括【运行时常量池】都是以类为单位的</p><p>例如，另一个类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"a"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的常量池</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #5.#22         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = String             #23            // a</span><br><span class="line">   #3 = String             #24            // abc</span><br></pre></td></tr></table></figure><p>可以看到在这个类中，<code>&quot;abc&quot;</code> 对应的常量池的编号是 #3，与 TestString1 中的已经不同</p><p>这时候【字面量】是两份，而【字符串对象】会有几个呢？</p><p>我们来做个实验，把刚才的代码做个改写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>; <span class="comment">// 字符串对象 "abc"</span></span><br><span class="line">        String s2 = <span class="string">"abc"</span>; <span class="comment">// 字符串对象 "abc"</span></span><br><span class="line">        TestString2.main(<span class="keyword">new</span> String[]&#123;s1, s2&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// args[0] "abc", args[1] "abc"</span></span><br><span class="line">        String s1 = <span class="string">"a"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(args[<span class="number">0</span>] == s2);</span><br><span class="line">        System.out.println(args[<span class="number">1</span>] == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>具体原理我们下一个章节再讲</p><h3 id="1-5-拼接创建"><a href="#1-5-拼接创建" class="headerlink" title="1.5 拼接创建"></a>1.5 拼接创建</h3><p>最后还可以通过 <code>+</code> 运算符将两个字符串（其中一个也可以是其它类型）拼接为一个新字符串，例如</p><p>例1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span> + <span class="string">"b"</span>;</span><br></pre></td></tr></table></figure><p>例2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="string">"a"</span> + x;</span><br></pre></td></tr></table></figure><p>例3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="string">"a"</span> + x;</span><br></pre></td></tr></table></figure><p>例4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>有同学会问，例1与例2与例3 不同吗？还别说，真就不同，其中例1 与例2 原理是一样的，例3 与例4 原理是一样的，反编译一下</p><p>例1 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span> + <span class="string">"b"</span>;</span><br></pre></td></tr></table></figure><p>常量池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #4.#20         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; String             #21            &#x2F;&#x2F; ab</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>主方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;2, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String ab</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: return</span><br><span class="line">         ...</span><br></pre></td></tr></table></figure><p>可以看到，其实并没有真正的【拼接】操作发生，从源码编译为字节码时，javac 就已经把 “a” 和 “b” 串在一起了，这是一种编译期的优化处理</p><p>例2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="string">"a"</span> + x;</span><br></pre></td></tr></table></figure><p>常量池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #5.#22         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; String             #23            &#x2F;&#x2F; b</span><br><span class="line">   #3 &#x3D; String             #24            &#x2F;&#x2F; ab</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>主方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String b   final b</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: ldc           #3                  &#x2F;&#x2F; String ab</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: return</span><br><span class="line">         ...</span><br></pre></td></tr></table></figure><p>可以看到，还是没有真正的【拼接】操作发生，final 意味着 x 的值不可改变，因此其它引用 x 的地方都可以安全地被替换为 “b”，而不用担心 x 被改变，从源码编译为字节码时，javac 就也进行了优化，把所有出现 x 的地方都替换成为了 “b”</p><p>那么，什么是真正的【拼接】操作呢？看一下例3 反编译后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="string">"a"</span> + x;</span><br></pre></td></tr></table></figure><p>常量池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #9.#26         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; String             #27            &#x2F;&#x2F; b</span><br><span class="line">   #3 &#x3D; Class              #28            &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">   #4 &#x3D; Methodref          #3.#26         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #5 &#x3D; String             #29            &#x2F;&#x2F; a</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>可以看到常量池中并没有 ab 字面量</p><p>主方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String b</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: new           #3                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">         6: dup</span><br><span class="line">         7: invokespecial #4                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        10: ldc           #5                  &#x2F;&#x2F; String a</span><br><span class="line">        12: invokevirtual #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        15: aload_1</span><br><span class="line">        16: invokevirtual #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        19: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">        22: astore_2</span><br><span class="line">        23: return</span><br></pre></td></tr></table></figure><p>翻译成人能读懂的就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="string">"a"</span> + x;</span><br><span class="line"></span><br><span class="line">String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="keyword">new</span> StringBuilder().append(<span class="string">"a"</span>).append(x).toString();</span><br></pre></td></tr></table></figure><p>StringBuilder 的 toString() 方法又是怎么实现的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从 AbstractStringBuilder 继承的属性，方便阅读加在此处</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create a copy, don't share the array</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，本质上就是根据 StringBuilder 维护的 char[] 创建了新的 String 对象</p><h3 id="1-6-JDK-9-之后的改变"><a href="#1-6-JDK-9-之后的改变" class="headerlink" title="1.6 JDK 9 之后的改变"></a>1.6 JDK 9 之后的改变</h3><p>前面我们讲的是 JDK 8 中的字符串，但从 JDK 9 开始，String 的内部存储方式、以及拼接方式又发生了较大的改变</p><ul><li>不再用 char[] 存储字符，改为了 byte[]，目的是更节约内存</li><li>使用 invokedynamic 指令扩展了字符串的拼接的实现方式</li></ul><h4 id="1-6-1内存结构改变"><a href="#1-6-1内存结构改变" class="headerlink" title="1.6.1内存结构改变"></a>1.6.1内存结构改变</h4><p>例如，字符串中仅有拉丁字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;);</span><br></pre></td></tr></table></figure><p><img src="st12.png" alt=""></p><p>例如，字符串中有中文字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(</span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;(<span class="keyword">byte</span>) <span class="number">0xd5</span>, (<span class="keyword">byte</span>) <span class="number">0xc5</span>&#125;, </span><br><span class="line">    Charset.forName(<span class="string">"gbk"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="st13.png" alt=""></p><p>例如，既有中文字符也有拉丁字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(</span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;(<span class="keyword">byte</span>) <span class="number">0xd5</span>, (<span class="keyword">byte</span>) <span class="number">0xc5</span>, <span class="number">97</span>&#125;, </span><br><span class="line">    Charset.forName(<span class="string">"gbk"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="st14.png" alt=""></p><h4 id="1-6-2拼接方式改变"><a href="#1-6-2拼接方式改变" class="headerlink" title="1.6.2拼接方式改变"></a>1.6.2拼接方式改变</h4><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String x = <span class="string">"b"</span>;</span><br><span class="line">    String s = <span class="string">"a"</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #5.#22         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; String             #23            &#x2F;&#x2F; b</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>主方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String b</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: aload_1</span><br><span class="line">         4: invokedynamic #3,  0              &#x2F;&#x2F; InvokeDynamic #0:makeConcatWithConstants:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">         9: astore_2</span><br><span class="line">        10: return</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>直接跟 <code>invokedynamic</code> 对应的字节码比较难，我直接翻译成人能看懂的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    String x = <span class="string">"b"</span>;</span><br><span class="line">    <span class="comment">// String s = "a" + x; </span></span><br><span class="line">    <span class="comment">// 会生成如下等价的字节码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器会提供 lookup，用来查找 MethodHandle</span></span><br><span class="line">    MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">    CallSite callSite = StringConcatFactory.makeConcatWithConstants(</span><br><span class="line">        lookup,</span><br><span class="line">        <span class="comment">// 方法名，不重要，编译器会自动生成</span></span><br><span class="line">        <span class="string">"arbitrary"</span>,</span><br><span class="line">        <span class="comment">// 方法的签名，第一个 String 为返回值类型，之后是入参类型</span></span><br><span class="line">        MethodType.methodType(String<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class">        // 具体处方格式，其中 \1 意思是变量的占位符，将来被 <span class="title">x</span> 代替</span></span><br><span class="line">        "a\1"</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// callSite.getTarget() 返回的是 MethodHandle 对象，用来反射执行拼接方法</span></span><br><span class="line">    String s = (String) callSite.getTarget().invoke(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么搞这么麻烦！！！</strong>主要是为了对字符串的拼接做各种扩展优化，多了扩展途径。其中最为重要的是 <code>MethodHandle</code> ，它使用了<strong>策略模式</strong>生成，JDK 提供的所有的策略可以在 <code>StringConcatFactory.Strategy</code> 中找到：</p><table><thead><tr><th>策略名</th><th>内部调用</th><th>解释</th></tr></thead><tbody><tr><td>BC_SB</td><td>字节码拼接生成 StringBuilder 代码</td><td>等价于 new StringBuilder()</td></tr><tr><td>BC_SB_SIZED</td><td>字节码拼接生成 StringBuilder 代码</td><td>等价于 new StringBuilder(n) n为预估大小</td></tr><tr><td>BC_SB_SIZED_EXACT</td><td>字节码拼接生成 StringBuilder 代码</td><td>等价于 new StringBuilder(n) n为准确大小</td></tr><tr><td>MH_SB_SIZED</td><td>MethodHandle 生成 StringBuilder 代码</td><td>等价于 new StringBuilder(n) n为预估大小</td></tr><tr><td>MH_SB_SIZED_EXACT</td><td>MethodHandle 生成 StringBuilder 代码</td><td>等价于 new StringBuilder(n) n为准确大小</td></tr><tr><td>MH_INLINE_SIZED_EXACT</td><td>MethodHandle 内部使用字节数组直接构造出 String</td><td>默认策略</td></tr></tbody></table><p>如果想改变策略，可以在运行时添加 JVM 参数，例如将策略改为 BC_SB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Djava.lang.invoke.stringConcat&#x3D;BC_SB</span><br><span class="line">-Djava.lang.invoke.stringConcat.debug&#x3D;true</span><br><span class="line">-Djava.lang.invoke.stringConcat.dumpClasses&#x3D;匿名类导出路径</span><br></pre></td></tr></table></figure><p>还有一种选择，是在 <code>javac</code> 编译时仍使用JDK1.5<code>StringBuilder</code>的办法拼接字符串，而不是采用 <code>invokedynamic</code>，就是在 <code>javac</code> 时加上参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XDstringConcat&#x3D;inline</span><br></pre></td></tr></table></figure><h4 id="1-6-3默认拼接策略"><a href="#1-6-3默认拼接策略" class="headerlink" title="1.6.3默认拼接策略"></a>1.6.3默认拼接策略</h4><p>默认策略为 MH_INLINE_SIZED_EXACT，使用字节数组直接构造出 String</p><p>例如有下面的字符串拼接代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"b"</span>;</span><br><span class="line">String s = <span class="string">"a"</span> + x + <span class="string">"c"</span> + <span class="string">"d"</span>;</span><br></pre></td></tr></table></figure><p>使用了 MH_INLINE_SIZED_EXACT 策略后，内部会执行如下等价调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"b"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预先分配字符串需要的字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新字符串，这时内部字节数组值为 [0,0,0,0]</span></span><br><span class="line">String s = StringConcatHelper.newString(buf, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行【拼接】，字符串内部字节数组值为 [97,0,0,0]</span></span><br><span class="line">StringConcatHelper.prepend(<span class="number">1</span>, buf, <span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行【拼接】，字符串内部字节数组值为 [97,98,0,0]</span></span><br><span class="line">StringConcatHelper.prepend(<span class="number">2</span>, buf, x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行【拼接】，字符串内部字节数组值为 [97,98,99,100]</span></span><br><span class="line">StringConcatHelper.prepend(<span class="number">4</span>, buf, <span class="string">"cd"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到此【拼接完毕】</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> </p><ul><li>StringConcatHelper 对外是不可见的，因此无法直接测试，只能反射测试</li><li>prepend 可以直接修改字符串中的 bytes 属性值，他们都是 java.lang 包下的</li></ul></blockquote><h4 id="1-6-4模仿-BC-SB-策略"><a href="#1-6-4模仿-BC-SB-策略" class="headerlink" title="1.6.4模仿 BC_SB 策略"></a>1.6.4模仿 BC_SB 策略</h4><p>接下来我模拟其中一种策略的实现过程：以字节码指令生成拼接方法为例</p><p>先说明一下我的目的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"hello,"</span>;</span><br><span class="line">String y = <span class="string">"world"</span>;</span><br><span class="line">String s = x + y;</span><br></pre></td></tr></table></figure><p>其中 + 可以被 invokedynamic 优化为多种实现策略，如果让我自己来实现，我仅会用 StringBuilder 来拼接，因此我希望 x+y 能够被翻译为对下面方法的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concat</span><span class="params">(String x, String y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder().append(x).append(y).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-方法手动生成"><a href="#1-方法手动生成" class="headerlink" title="1. 方法手动生成"></a>1. 方法手动生成</h5><p>提供一个拼接方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concat</span><span class="params">(String x, String y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder().append(x).append(y).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 MethodHandle 反射调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"hello,"</span>;</span><br><span class="line">String y = <span class="string">"world"</span>;</span><br><span class="line">MethodHandle mh = MethodHandles.lookup().findStatic(</span><br><span class="line">    TestString4<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">    "concat", </span><br><span class="line">    MethodType.methodType(String<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">)</span>;</span><br><span class="line">String s = (String) mh.invoke(x,y);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello,world</span><br></pre></td></tr></table></figure><p>但这样需要自己提供 concat 方法，而且其参数个数都固定死了，能否动态生成这么一个方法呢，答案是肯定的，为了简化生成逻辑，这里我仍然以固定参数为例</p><h5 id="2-字节码生成方法"><a href="#2-字节码生成方法" class="headerlink" title="2. 字节码生成方法"></a>2. 字节码生成方法</h5><p>Unsafe 对象访问类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeAccessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 asm 生成匿名类字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] dump() &#123;</span><br><span class="line"></span><br><span class="line">    ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">    FieldVisitor fv;</span><br><span class="line">    MethodVisitor mv;</span><br><span class="line">    AnnotationVisitor av0;</span><br><span class="line"></span><br><span class="line">    cw.visit(<span class="number">52</span>, ACC_PUBLIC + ACC_SUPER, <span class="string">"cn/itcast/string/TestString4"</span>, <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    cw.visitSource(<span class="string">"TestString4.java"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        mv = cw.visitMethod(ACC_PUBLIC, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        mv.visitCode();</span><br><span class="line">        Label l0 = <span class="keyword">new</span> Label();</span><br><span class="line">        mv.visitLabel(l0);</span><br><span class="line">        mv.visitLineNumber(<span class="number">3</span>, l0);</span><br><span class="line">        mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">        mv.visitMethodInsn(INVOKESPECIAL, <span class="string">"java/lang/Object"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">false</span>);</span><br><span class="line">        mv.visitInsn(RETURN);</span><br><span class="line">        Label l1 = <span class="keyword">new</span> Label();</span><br><span class="line">        mv.visitLabel(l1);</span><br><span class="line">        mv.visitLocalVariable(<span class="string">"this"</span>, <span class="string">"Lcn/itcast/string/TestString4;"</span>, <span class="keyword">null</span>, l0, l1, <span class="number">0</span>);</span><br><span class="line">        mv.visitMaxs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        mv.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, <span class="string">"concat"</span>, <span class="string">"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        mv.visitCode();</span><br><span class="line">        Label l0 = <span class="keyword">new</span> Label();</span><br><span class="line">        mv.visitLabel(l0);</span><br><span class="line">        mv.visitLineNumber(<span class="number">9</span>, l0);</span><br><span class="line">        mv.visitTypeInsn(NEW, <span class="string">"java/lang/StringBuilder"</span>);</span><br><span class="line">        mv.visitInsn(DUP);</span><br><span class="line">        mv.visitMethodInsn(INVOKESPECIAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">false</span>);</span><br><span class="line">        mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">        mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line">        mv.visitVarInsn(ALOAD, <span class="number">1</span>);</span><br><span class="line">        mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line">        mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"toString"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">false</span>);</span><br><span class="line">        mv.visitInsn(ARETURN);</span><br><span class="line">        Label l1 = <span class="keyword">new</span> Label();</span><br><span class="line">        mv.visitLabel(l1);</span><br><span class="line">        mv.visitLocalVariable(<span class="string">"x"</span>, <span class="string">"Ljava/lang/String;"</span>, <span class="keyword">null</span>, l0, l1, <span class="number">0</span>);</span><br><span class="line">        mv.visitLocalVariable(<span class="string">"y"</span>, <span class="string">"Ljava/lang/String;"</span>, <span class="keyword">null</span>, l0, l1, <span class="number">1</span>);</span><br><span class="line">        mv.visitMaxs(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        mv.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    cw.visitEnd();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cw.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么多字节码主要目的仅仅是生成一个匿名类的字节码，其中包括了拼接方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concat</span><span class="params">(String x, String y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder().append(x).append(y).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就可以生成匿名类，供 MethodHandler 反射调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成匿名类所需字节码</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = dump();</span><br><span class="line"><span class="comment">// 根据字节码生成匿名类.class</span></span><br><span class="line">Class&lt;?&gt; innerClass = UnsafeAccessor.UNSAFE</span><br><span class="line">    .defineAnonymousClass(TestString4<span class="class">.<span class="keyword">class</span>, <span class="title">bytes</span>, <span class="title">null</span>)</span>;</span><br><span class="line"><span class="comment">// 确保匿名类初始化</span></span><br><span class="line">UnsafeAccessor.UNSAFE.ensureClassInitialized(innerClass);</span><br><span class="line"><span class="comment">// 找到匿名类中 String concat(String x, String y)</span></span><br><span class="line">MethodHandle mh = MethodHandles.lookup().findStatic(</span><br><span class="line">    innerClass,</span><br><span class="line">    <span class="string">"concat"</span>, </span><br><span class="line">    MethodType.methodType(String<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">)</span>;</span><br></pre></td></tr></table></figure><p>最终就可以使用该 MethodHandle 反射完成字符串拼接了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"hello,"</span>;</span><br><span class="line">String y = <span class="string">"world"</span>;</span><br><span class="line">String s = (String) mh.invoke(x, y);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello,world</span><br></pre></td></tr></table></figure><p>JDK 9 当然做的更为专业，可以适配生成不同的参数个数、类型的 MethodHandle，但原理就是这样。</p><h2 id="2-字符串之家-StringTable"><a href="#2-字符串之家-StringTable" class="headerlink" title="2.字符串之家 - StringTable"></a>2.字符串之家 - StringTable</h2><h3 id="2-1-家养与野生"><a href="#2-1-家养与野生" class="headerlink" title="2.1 家养与野生"></a>2.1 家养与野生</h3><p>其实字符串分为家养的和野生的。</p><p>前面我们讲解了 String 的六种创建方式，<strong>除了字面量方式创建的字符串是家养的以外，其它方法创建的字符串都是野生的。</strong>什么意思呢？</p><ul><li><p>字面量方式创建的字符串，会放入 StringTable 中，StringTable 管理的字符串，才具有不重复的特性，这种就像是家养的</p></li><li><p>而 char[]，byte[]，int[]，String，以及 + 方式本质上都是使用 new 来创建，它们都是在堆中创建新的字符串对象，<strong>不会考虑字符串重不重复</strong>，这种就像是野生的，野生字符串的缺点就是如果存在大量值相同的字符串，对内存占用非常严重</p></li></ul><p>如何保证家养的字符串对象不重复呢？JDK 使用了 <strong>StringTable 来解决，StringTable 是采用 c++ 代码编写的，数据结构上就是一个 hash 表</strong>，字符串对象就充当 hash 表中的 key，key 的不重复性，是 hash 表的基本特性</p><p><img src="st10.png" alt=""></p><p>当代码运行到一个字面量 “abc” 时，会首先检查 StringTable 中有没有相同的 key，如果没有，创建新字符串对象加入；否则直接返回已有的字符串对象</p><h3 id="2-2-收留野生字符串"><a href="#2-2-收留野生字符串" class="headerlink" title="2.2 收留野生字符串"></a>2.2 收留野生字符串</h3><p>野生的字符串也有机会得到教育</p><p>字符串提供了 intern 方法来实现去重，让字符串对象有机会受到 StringTable 的管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>它会尝试将调用者放入 StringTable</p><h4 id="2-2-1如果-StringTable-中已有"><a href="#2-2-1如果-StringTable-中已有" class="headerlink" title="2.2.1如果 StringTable 中已有"></a>2.2.1如果 StringTable 中已有</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = ...;</span><br><span class="line">String s = x.intern();</span><br></pre></td></tr></table></figure><p>总会返回家养的 String 对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant x as x</span><br><span class="line">participant s as s</span><br><span class="line">participant st as StringTable</span><br><span class="line"></span><br><span class="line">x -&gt;&gt; st : intern()</span><br><span class="line">st -&gt;&gt; st : 如果已有</span><br><span class="line">st --&gt;&gt; s : 返回 StringTable 对象</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;); <span class="comment">// 野生的</span></span><br><span class="line">String y = <span class="string">"abc"</span>; <span class="comment">// 将 "abc"字符串对象 加入 StringTable</span></span><br><span class="line">String z = x.intern(); <span class="comment">// 已有，返回 StringTable 中 "abc"，即 y</span></span><br><span class="line">System.out.println(z == y);</span><br><span class="line">System.out.println(z == x);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h4 id="2-2-2如果-StringTable-中没有（1-7-以上-JDK-的做法）"><a href="#2-2-2如果-StringTable-中没有（1-7-以上-JDK-的做法）" class="headerlink" title="2.2.2如果 StringTable 中没有（1.7 以上 JDK 的做法）"></a>2.2.2如果 StringTable 中没有（1.7 以上 JDK 的做法）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = ...;</span><br><span class="line">String s = x.intern();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant x as x</span><br><span class="line">participant s as s</span><br><span class="line">participant st as StringTable</span><br><span class="line"></span><br><span class="line">x -&gt;&gt; st : intern()</span><br><span class="line">st -&gt;&gt; st : 如果没有</span><br><span class="line">st -&gt;&gt; st : 将x引用的对象加入</span><br><span class="line">st --&gt;&gt; s : 返回 StringTable 对象</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;); <span class="comment">// 野生的</span></span><br><span class="line">String z = x.intern(); <span class="comment">// 野生的 x 加入 StringTable，StringTable 中有了 "abc"</span></span><br><span class="line">String y = <span class="string">"abc"</span>; <span class="comment">// 已有，不会产生新的对象，用的是 StringTable 中 "abc"</span></span><br><span class="line">System.out.println(z == x);</span><br><span class="line">System.out.println(z == y);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><h4 id="2-2-3如果-StringTable-中没有（1-6-JDK-的做法）"><a href="#2-2-3如果-StringTable-中没有（1-6-JDK-的做法）" class="headerlink" title="2.2.3如果 StringTable 中没有（1.6 JDK 的做法）"></a>2.2.3如果 StringTable 中没有（1.6 JDK 的做法）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = ...;</span><br><span class="line">String s = x.intern();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant x as x</span><br><span class="line">participant s as s</span><br><span class="line">participant st as StringTable</span><br><span class="line"></span><br><span class="line">x -&gt;&gt; st : intern()</span><br><span class="line">st -&gt;&gt; st : 如果没有</span><br><span class="line">st -&gt;&gt; st : 将x引用的对象复制</span><br><span class="line">st -&gt;&gt; st : 将复制后的对象加入</span><br><span class="line">st --&gt;&gt; s : 返回 StringTable 对象</span><br></pre></td></tr></table></figure><p>例子，代码同上面 1.7 相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;); <span class="comment">// 野生的</span></span><br><span class="line">String z = x.intern(); <span class="comment">// 野生的 x 被复制后加入 StringTable，StringTable 中有了 "abc"</span></span><br><span class="line">String y = <span class="string">"abc"</span>; <span class="comment">// 已有，不会产生新的对象，用的是 StringTable 中 "abc"</span></span><br><span class="line">System.out.println(z == x);</span><br><span class="line">System.out.println(z == y);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><h3 id="2-3-去重的好处"><a href="#2-3-去重的好处" class="headerlink" title="2.3 去重的好处"></a>2.3 去重的好处</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 intern 减少内存占用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        List&lt;String&gt; address = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"linux.words"</span>), <span class="string">"utf-8"</span>))) &#123;</span><br><span class="line">                String line = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    line = reader.readLine();</span><br><span class="line">                    <span class="keyword">if</span>(line == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    address.add(line.intern());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"cost:"</span> +(System.nanoTime()-start)/<span class="number">1000000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-家的位置"><a href="#2-4-家的位置" class="headerlink" title="2.4 家的位置"></a>2.4 家的位置</h3><p><strong>StringTable 的位置（1.6）</strong></p><p><img src="8.png" alt=""></p><p><strong>StringTable 的位置（1.8）</strong></p><p>![](</p><p>9.png)</p><p>如何证明</p><ul><li>1.6 不断将字符串用 intern 加入 StringTable，最后撑爆的是永久代内存，为了让错误快速出现，将永久代内存设置的小一些：<code>-XX:MaxPermSize=10m</code>，最终会出现 <code>java.lang.OutOfMemoryError: PermGen space</code></li><li>1.8 不断将字符串用 intern 加入 StringTable，最后撑爆的是堆内存，为了让错误快速出现，将堆内存设置的小一些：<code>-Xmx10m -XX:-UseGCOverheadLimit</code> 后一个虚拟机参数是避免 GC 频繁引起其他错误而不是我们期望的 <code>java.lang.OutOfMemoryError: Java heap space</code></li></ul><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 StringTable 位置</span></span><br><span class="line"><span class="comment"> * 在jdk8下设置 -Xmx10m -XX:-UseGCOverheadLimit</span></span><br><span class="line"><span class="comment"> * 在jdk6下设置 -XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">260000</span>; j++) &#123;</span><br><span class="line">                list.add(String.valueOf(j).intern());</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-intern-去重原理"><a href="#2-5-intern-去重原理" class="headerlink" title="2.5 intern 去重原理"></a>2.5 intern 去重原理</h3><p>查阅一下 jdk 的源码</p><p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/5bd0e0bcb152/src/share/vm/classfile/symbolTable.cpp" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/5bd0e0bcb152/src/share/vm/classfile/symbolTable.cpp</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string_or_null 字符串对象</span></span><br><span class="line"><span class="comment">// name 字符串原始指针</span></span><br><span class="line"><span class="comment">// len 字符串长度</span></span><br><span class="line">oop StringTable::intern(Handle string_or_null, jchar* name,</span><br><span class="line">                        <span class="keyword">int</span> len, TRAPS) &#123;</span><br><span class="line">  <span class="comment">// 获取字符串的 hash 值</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hashValue = hash_string(name, len);</span><br><span class="line">  <span class="comment">// 算出 hash table 桶下标  </span></span><br><span class="line">  <span class="keyword">int</span> index = the_table()-&gt;hash_to_index(hashValue);</span><br><span class="line">  <span class="comment">// 看字符串在 hash table 中有没有 </span></span><br><span class="line">  oop found_string = the_table()-&gt;lookup(index, name, len, hashValue);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有，直接返回（避免重复加入）</span></span><br><span class="line">  <span class="keyword">if</span> (found_string != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保该字符串对象没有被垃圾回收  </span></span><br><span class="line">    ensure_string_alive(found_string);</span><br><span class="line">    <span class="keyword">return</span> found_string;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  debug_only(StableMemoryChecker smc(name, len * <span class="keyword">sizeof</span>(name[<span class="number">0</span>])));</span><br><span class="line">  assert(!Universe::heap()-&gt;is_in_reserved(name),</span><br><span class="line">         <span class="string">"proposed name of symbol must be stable"</span>);</span><br><span class="line"></span><br><span class="line">  Handle <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// try to reuse the string if possible</span></span><br><span class="line">  <span class="keyword">if</span> (!string_or_null.is_null()) &#123;</span><br><span class="line">    <span class="built_in">string</span> = string_or_null;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 根据 unicode 创建【字符串对象 string】 </span></span><br><span class="line">    <span class="built_in">string</span> = java_lang_String::create_from_unicode(name, len, CHECK_NULL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> INCLUDE_ALL_GCS</span></span><br><span class="line">  <span class="keyword">if</span> (G1StringDedup::is_enabled()) &#123;</span><br><span class="line">    <span class="comment">// Deduplicate the string before it is interned. Note that we should never</span></span><br><span class="line">    <span class="comment">// deduplicate a string after it has been interned. Doing so will counteract</span></span><br><span class="line">    <span class="comment">// compiler optimizations done on e.g. interned string literals.</span></span><br><span class="line">    G1StringDedup::deduplicate(<span class="built_in">string</span>());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Grab the StringTable_lock before getting the_table() because it could</span></span><br><span class="line">  <span class="comment">// change at safepoint.</span></span><br><span class="line">  oop added_or_found;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLocker <span class="title">ml</span><span class="params">(StringTable_lock, THREAD)</span></span>;</span><br><span class="line">    <span class="comment">// 将【字符串对象 string】加入 hash table</span></span><br><span class="line">    added_or_found = the_table()-&gt;basic_add(index, <span class="built_in">string</span>, name, len,</span><br><span class="line">                                  hashValue, CHECK_NULL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ensure_string_alive(added_or_found);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> added_or_found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 lookup 的定义为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index 桶下标</span></span><br><span class="line"><span class="comment">// name 字符串原始指针</span></span><br><span class="line"><span class="comment">// len 字符串长度</span></span><br><span class="line"><span class="comment">// hash 哈希码</span></span><br><span class="line">oop StringTable::lookup(<span class="keyword">int</span> index, jchar* name,</span><br><span class="line">                        <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash) &#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (HashtableEntry&lt;oop, mtSymbol&gt;* l = bucket(index); l != <span class="literal">NULL</span>; l = l-&gt;next()) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (l-&gt;hash() == hash) &#123;</span><br><span class="line">      <span class="keyword">if</span> (java_lang_String::equals(l-&gt;literal(), name, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> l-&gt;literal();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果链表过长，需要 rehash</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt;= rehash_count &amp;&amp; !needs_rehashing()) &#123;</span><br><span class="line">    _needs_rehashing = check_rehash_table(count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 basic_add 的定义为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index_arg 桶下标</span></span><br><span class="line"><span class="comment">// string 字符串对象</span></span><br><span class="line"><span class="comment">// name 字符串原始指针</span></span><br><span class="line"><span class="comment">// len 字符串长度</span></span><br><span class="line">oop StringTable::basic_add(<span class="keyword">int</span> index_arg, Handle <span class="built_in">string</span>, jchar* name,</span><br><span class="line">                           <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> hashValue_arg, TRAPS) &#123;</span><br><span class="line"></span><br><span class="line">  assert(java_lang_String::equals(<span class="built_in">string</span>(), name, len),</span><br><span class="line">         <span class="string">"string must be properly initialized"</span>);</span><br><span class="line">  <span class="comment">// Cannot hit a safepoint in this function because the "this" pointer can move.</span></span><br><span class="line">  No_Safepoint_Verifier nsv;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if the symbol table has been rehashed, if so, need to recalculate</span></span><br><span class="line">  <span class="comment">// the hash value and index before second lookup.</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hashValue;</span><br><span class="line">  <span class="keyword">int</span> index;</span><br><span class="line">  <span class="keyword">if</span> (use_alternate_hashcode()) &#123;</span><br><span class="line">    hashValue = hash_string(name, len);</span><br><span class="line">    index = hash_to_index(hashValue);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    hashValue = hashValue_arg;</span><br><span class="line">    index = index_arg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Since look-up was done lock-free, we need to check if another</span></span><br><span class="line">  <span class="comment">// thread beat us in the race to insert the symbol.</span></span><br><span class="line"></span><br><span class="line">  oop test = lookup(index, name, len, hashValue); <span class="comment">// calls lookup(u1*, int)</span></span><br><span class="line">  <span class="keyword">if</span> (test != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// Entry already added</span></span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 构造新的 HashtableEntry 节点</span></span><br><span class="line">  HashtableEntry&lt;oop, mtSymbol&gt;* entry = new_entry(hashValue, <span class="built_in">string</span>());</span><br><span class="line">  <span class="comment">// 加入链表  </span></span><br><span class="line">  add_entry(index, entry);</span><br><span class="line">  <span class="comment">// 返回字符串对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-G1-去重"><a href="#2-6-G1-去重" class="headerlink" title="2.6 G1 去重"></a>2.6 G1 去重</h3><p>懒惰是程序员的一大美德，不追求懒惰的程序员不是好程序员</p><p>如果你使用的 JDK 8u20，那么可以使用下面的 JVM 参数开启 G1 垃圾回收器，并开启字符串去重功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC -XX:+UseStringDeduplication</span><br></pre></td></tr></table></figure><p>原理是让多个字符串对象引用同一个 char[] 来达到节省内存的目的</p><p><img src="st09.png" alt=""></p><p>特点</p><ul><li>由 G1 垃圾回收器在 minor gc 阶段自动分析优化，不需要程序员自己干预</li><li>只有针对那些多次回收还不死的字符串对象，才会进行去重优化，可以通过 <code>-XX:StringDeduplicationAgeThreshold=n</code> 来调整</li><li>可以通过 <code>-XX:+PrintStringDeduplicationStatistics</code> 查看 G1 去重的统计信息</li><li>与调用 intern 去重相比，G1 去重好处在于自动，但缺点是即使 char[] 不重复，但字符串对象本身还要占用一定内存（对象头、value引用、hash），intern 去重是字符串对象只存一份，更省内存</li></ul><h3 id="2-7-家的大小"><a href="#2-7-家的大小" class="headerlink" title="2.7 家的大小"></a>2.7 家的大小</h3><p>StringTable 足够大，才能发挥性能优势，大意味着 String 在 hash 表中冲突减少，链表短，性能高。</p><p>可以通过 <code>-XX:+PrintStringTableStatistics</code> 来查看 StringTable 的大小，<strong>JDK 8 中它的默认大小为 60013</strong></p><p><strong>要注意 StringTable 底层的 hash 表在 JVM 启动后大小就固定不变了</strong></p><p>这个 hash 表可以在链表长度太长时进行 rehash，但不是利用扩容实现的 rehash，而是通过重新计算字符串的 hash 值来让它们分布均匀</p><p>如果想在启动前调整 StringTable 的大小，可以通过 <code>-XX:StringTableSize=n</code> 来指定</p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示串池大小对性能的影响</span></span><br><span class="line"><span class="comment"> * -XX:+PrintStringTableStatistics -XX:StringTableSize=1009</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"linux.words"</span>), <span class="string">"utf-8"</span>))) &#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                line = reader.readLine();</span><br><span class="line">                <span class="keyword">if</span> (line == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                line.intern();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"cost:"</span> + (System.nanoTime() - start) / <span class="number">1000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8-字符串之死"><a href="#2-8-字符串之死" class="headerlink" title="2.8 字符串之死"></a>2.8 字符串之死</h3><p>字符串也是一个对象，只要是对象，终究逃不过死亡的命运。字符串对象与其它 Java 对象一样，只要失去了利用价值，就会被垃圾回收，无论是野生字符串，还是家养字符串</p><p>怎么证明家养的字符串也能被垃圾回收呢，可以用以下 JVM 参数来查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 StringTable 垃圾回收</span></span><br><span class="line"><span class="comment"> * -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123; <span class="comment">// j=100, j=10000</span></span><br><span class="line">                String.valueOf(j).intern();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、面试题讲解"><a href="#三、面试题讲解" class="headerlink" title="三、面试题讲解"></a>三、面试题讲解</h2><p><strong>1. 判断输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"string"</span>; <span class="comment">// 家</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"string"</span>); <span class="comment">// 野生</span></span><br><span class="line">String str3 = str2.intern(); <span class="comment">// 家</span></span><br><span class="line"></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//#1  false</span></span><br><span class="line">System.out.println(str1==str3);<span class="comment">//#2  true</span></span><br></pre></td></tr></table></figure><p><strong>2. 判断输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String baseStr = <span class="string">"baseStr"</span>;</span><br><span class="line"><span class="keyword">final</span> String baseFinalStr = <span class="string">"baseStr"</span>;</span><br><span class="line"></span><br><span class="line">String str1 = <span class="string">"baseStr01"</span>; <span class="comment">// 家</span></span><br><span class="line">String str2 = <span class="string">"baseStr"</span>+<span class="string">"01"</span>; <span class="comment">// 家</span></span><br><span class="line">String str3 = baseStr + <span class="string">"01"</span>; <span class="comment">// 野生</span></span><br><span class="line">String str4 = baseFinalStr+<span class="string">"01"</span>;<span class="comment">// 家</span></span><br><span class="line">String str5 = <span class="keyword">new</span> String(<span class="string">"baseStr01"</span>).intern(); <span class="comment">// 家</span></span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//#3 true</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//#4 false </span></span><br><span class="line">System.out.println(str1 == str4);<span class="comment">//#5 true</span></span><br><span class="line">System.out.println(str1 == str5);<span class="comment">//#6 true</span></span><br></pre></td></tr></table></figure><p><strong>3. 判断输出（注意版本）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"str"</span>)+<span class="keyword">new</span> String(<span class="string">"01"</span>);</span><br><span class="line">str2.intern(); <span class="comment">//1.6</span></span><br><span class="line">String str1 = <span class="string">"str01"</span>;</span><br><span class="line">System.out.println(str2==str1);<span class="comment">//#7 1.7 true, 1.6 false</span></span><br></pre></td></tr></table></figure><p><strong>4. 判断输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"str01"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"str"</span>)+<span class="keyword">new</span> String(<span class="string">"01"</span>);</span><br><span class="line">str2.intern();</span><br><span class="line">System.out.println(str2 == str1);<span class="comment">//#8 false</span></span><br></pre></td></tr></table></figure><p><strong>5. String s = new String(“xyz”)，创建了几个String Object?</strong></p><p><strong>6. 判断输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>7. 判断输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><strong>8. 判断输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"a"</span>;</span><br><span class="line">String s3 = <span class="string">"bc"</span>;</span><br><span class="line">String s4 = s2 + s3;</span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><strong>9. 判断输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">final</span> String s2 = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">final</span> String s3 = <span class="string">"bc"</span>;</span><br><span class="line">String s4 = s2 + s3;</span><br><span class="line">System.out.println(s1 == s4);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>10. 判断输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">// 野生</span></span><br><span class="line">String s1 = <span class="string">"abc"</span>; <span class="comment">// 家</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">// 野生</span></span><br><span class="line">System.out.println(s == s1.intern()); <span class="comment">// false</span></span><br><span class="line">System.out.println(s == s2.intern()); <span class="comment">// false</span></span><br><span class="line">System.out.println(s1 == s2.intern()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      字符串创建方式 StringTable
    
    </summary>
    
    
      <category term="Java高级" scheme="http://goldcarpenter.github.io/categories/Java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="JVM" scheme="http://goldcarpenter.github.io/tags/JVM/"/>
    
      <category term="String" scheme="http://goldcarpenter.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Spring FrameWork</title>
    <link href="http://goldcarpenter.github.io/2019/09/22/Spring_AOP/"/>
    <id>http://goldcarpenter.github.io/2019/09/22/Spring_AOP/</id>
    <published>2019-09-22T15:19:21.000Z</published>
    <updated>2020-06-17T03:24:07.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-AOP引入"><a href="#6-AOP引入" class="headerlink" title="6.AOP引入"></a>6.AOP引入</h1><h2 id="6-1-环境准备——引出问题"><a href="#6-1-环境准备——引出问题" class="headerlink" title="6.1.环境准备——引出问题"></a>6.1.环境准备——引出问题</h2><ul><li><code>sql</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table1 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">40</span>),</span><br><span class="line">money <span class="built_in">float</span></span><br><span class="line">)<span class="built_in">character</span> <span class="keyword">set</span> utf8 <span class="keyword">collate</span> utf8_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table1(<span class="keyword">name</span>,money) <span class="keyword">values</span>(<span class="string">"aaa"</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><img src="1578021143043.png" alt="1578021143043"></p><ul><li><code>pojo.Account.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.pojo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Float money;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Account&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", money="</span> + money +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get set function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>dao.impl.AccountDaoImpl.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.pojo.Account;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.utils.ConnectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QueryRunner runner;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> runner.query(connectionUtils.getThreadConnection(), <span class="string">"select * from table1"</span>,<span class="keyword">new</span> BeanListHandler&lt;Account&gt;(Account<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> runner.query(connectionUtils.getThreadConnection(), <span class="string">"select * from table1 where id = ?"</span>,<span class="keyword">new</span> BeanHandler&lt;Account&gt;(Account<span class="class">.<span class="keyword">class</span>),<span class="title">accountId</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        runner.update(connectionUtils.getThreadConnection(), <span class="string">"insert into table1(name,money) values(?,?) "</span>,account.getName(),account.getMoney());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        runner.update(connectionUtils.getThreadConnection(), <span class="string">"update table1 set name=?, money=? where id = ?"</span>,account.getName(),account.getMoney(),account.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAccount</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        runner.update(connectionUtils.getThreadConnection(), <span class="string">"delete from table1 where id=?"</span>,accountId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountByName</span><span class="params">(String accountName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Account&gt; accounts = runner.query(connectionUtils.getThreadConnection(), <span class="string">"select * from table1 where name=?"</span>, <span class="keyword">new</span> BeanListHandler&lt;Account&gt;(Account<span class="class">.<span class="keyword">class</span>), <span class="title">accountName</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (accounts == <span class="keyword">null</span> || accounts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (accounts.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"&gt;0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> accounts.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>dao.IAccountDao</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.carpenter.pojo.Account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function">Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function">Account <span class="title">findAccountByName</span><span class="params">(String accountName)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAccount</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>service.IAccountService</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.carpenter.pojo.Account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function">Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAccount</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>service.impl.AccountServiceImpl</code></strong><ul><li><strong>存在问题</strong>：<strong>大量【事务控制】的重复代码，引出问题</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.pojo.Account;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.utils.TransactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransactionManager tx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        List&lt;Account&gt; allAccount = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx.beginTransaction();</span><br><span class="line">            allAccount = accountDao.findAllAccount();</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            tx.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allAccount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx.beginTransaction();</span><br><span class="line">            account = accountDao.findAccountById(accountId);</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            tx.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx.beginTransaction();</span><br><span class="line">            accountDao.saveAccount(account);</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            tx.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx.beginTransaction();</span><br><span class="line">            accountDao.updateAccount(account);</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            tx.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAccount</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx.beginTransaction();</span><br><span class="line">            accountDao.deleteAccount(accountId);</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            tx.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx.beginTransaction();</span><br><span class="line">            Account sourceAccount = accountDao.findAccountByName(sourceName);</span><br><span class="line">            Account targetAccount = accountDao.findAccountByName(targetName);</span><br><span class="line">            sourceAccount.setMoney(sourceAccount.getMoney() - money);</span><br><span class="line">            targetAccount.setMoney(targetAccount.getMoney() + money);</span><br><span class="line">            accountDao.updateAccount(sourceAccount);</span><br><span class="line">            accountDao.updateAccount(targetAccount);</span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            tx.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Client.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.ui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.pojo.Account;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        IAccountService accountService = (IAccountService) ac.getBean(<span class="string">"accountServiceImpl"</span>);</span><br><span class="line">        List&lt;Account&gt; allAccount = accountService.findAllAccount();</span><br><span class="line">        <span class="keyword">for</span>(Account item : allAccount)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(item.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        accountService.transfer(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="number">100f</span>);</span><br><span class="line">        allAccount =  accountService.findAllAccount();</span><br><span class="line">        <span class="keyword">for</span>(Account item : allAccount)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(item.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>bean.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top.carpenter"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">以下注释已用注解方式完成其功能 此处仅作参看</span><br><span class="line"><span class="comment">&lt;!--    &lt;bean id="accountService" class="top.carpenter.service.impl.AccountServiceImpl"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name="tx" ref="transactionManager"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name="accountDao" ref="accountDaoImpl"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean id="tx" class="top.carpenter.utils.TransactionManager"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name="connectionUtils" ref="connectionUtils"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean id="accountDao" class="top.carpenter.dao.impl.AccountDaoImpl"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name="connectionUtils" ref="connectionUtils"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name="runner" ref="runner"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean id="connectionUtils" class="top.carpenter.utils.ConnectionUtils"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name="dataSource" ref="dataSource"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runner"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbutils.QueryRunner"</span>  <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/spring_study"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>pom.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.carpenter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring_restudy_day01<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-2-代理前置知识"><a href="#6-2-代理前置知识" class="headerlink" title="6.2.代理前置知识"></a>6.2.代理前置知识</h2><h3 id="6-2-1静态代理"><a href="#6-2-1静态代理" class="headerlink" title="6.2.1静态代理"></a>6.2.1静态代理</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li>代理对象继承目标对象，重写需要增强的方法</li><li>缺点：会代理类过多,非常复杂<ul><li>日志子类 <strong>权限验证子类</strong> 运行时间计算子类</li><li>日志子类的权限验证继承类 <strong>权限验证子类的日志继承类</strong> 日志子类的运行时间计算继承类…</li><li>…</li></ul></li></ul><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><ul><li>【代理模式】</li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul><li><p>本质：生成<code>.class</code>字节数组，使用本地方法<code>defineClass0</code>生成<code>class</code>对象</p><p><img src="1590926927757.png" alt="1590926927757"></p></li><li><p>特点：字节码随用随创建，随用随加载</p></li><li><p>作用：不修改源码的基础上对方法增强</p></li></ul><h4 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h4><ul><li>涉及类：<code>Proxy</code></li><li>提供者：JDK官方</li><li>创建代理对象要求：被代理对象<strong>至少实现一个接口</strong>，如果没有则不能使用【已经继承了Proxy 不能多继承】</li><li>如何创建代理对象：<code>Proxy</code>类的<code>newProxyInstance()</code><ul><li><code>ClassLoader</code><ul><li>用于<strong>加载代理对象字节码的，和被代理对象使用相同的类加载器</strong>。</li><li>固定写法：<code>被代理对象.getClass().getClassLoader()</code></li></ul></li><li><code>Class[] interfaces</code><ul><li>是用于让<strong>反射得到的代理对象和被代理对象有相同方法</strong></li><li>固定写法：<code>被代理对象.getClass().getInterfaces()</code></li></ul></li><li><code>InvocationHandler</code>：<ul><li>写具体<strong>如何代理</strong>，一般都是接口的实现类。通常情况下都是<strong>匿名内部类</strong>，但不是必须的</li><li>此接口的实现类都是谁用谁写</li></ul></li></ul></li><li><code>IProducer.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Producer.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span>  <span class="title">IProducer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sale bonus is "</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Main.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> IProducer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        IProducer producerProxy = (IProducer)Proxy.newProxyInstance(producer.getClass().getClassLoader(),</span><br><span class="line">                producer.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Object returnValue = <span class="keyword">null</span>;</span><br><span class="line">                        Float money = (Float)args[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">if</span>(<span class="string">"saleProduct"</span>.equals(method.getName()))</span><br><span class="line">                            returnValue = method.invoke(producer,money*<span class="number">0.8f</span>);</span><br><span class="line">                        <span class="keyword">return</span> returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        producerProxy.saleProduct(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以将生成的Class对象保存下来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">IProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"><span class="comment">// 唯一的一个构造方法 就是传入InvocationHandler</span></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// protected InvocationHandler h; 解释了三个参数的由来</span></span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">"top.carpenter.IProducer"</span>).getMethod(<span class="string">"saleProduct"</span>, Float.TYPE);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h4><ul><li><code>pom.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>涉及类：<code>Enhancer</code></p></li><li><p>提供者：第三方<code>cglib</code>库</p></li><li><p>创建代理对象要求：被代理类不能是最终类</p></li><li><p>如何创建代理对象：<code>Enhancer</code>类的<code>create()</code></p><ul><li><code>Class</code><ul><li>固定写法：<code>被代理对象.getClass()</code></li></ul></li></ul><ul><li><code>Callback</code>：<ul><li>提供增强代码</li><li>写如何代理，一般都是接口的实现类。通常情况下都是匿名内部类，但不是必须的</li><li>此接口的实现类都是谁用谁写</li><li>一般写的都是该接口的子接口实现类：<code>MethodInterceptor</code></li></ul></li></ul></li><li><p><code>Producer.java</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span>  <span class="title">IProducer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sale bonus is "</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Main.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        System.out.println(producer);</span><br><span class="line">        Producer producerProxy = (Producer) Enhancer.create(producer.getClass(),</span><br><span class="line">                <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Object returnValue = <span class="keyword">null</span>;</span><br><span class="line">                        Float money = (Float)args[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">if</span>(<span class="string">"saleProduct"</span>.equals(method.getName()))</span><br><span class="line">                            returnValue =method.invoke(producer,money*<span class="number">0.8f</span>);</span><br><span class="line">                        <span class="keyword">return</span> returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        producerProxy.saleProduct(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-基于动态代理的问题解决"><a href="#6-3-基于动态代理的问题解决" class="headerlink" title="6.3.基于动态代理的问题解决"></a>6.3.基于动态代理的问题解决</h2><ul><li><code>factory.BeanFactory.java</code>——用于创建Service的代理类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.utils.TransactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IAccountService accountService;</span><br><span class="line">    <span class="keyword">private</span> TransactionManager tx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTx</span><span class="params">(TransactionManager tx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tx = tx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAccountService</span><span class="params">(IAccountService accountService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountService = accountService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IAccountService <span class="title">getAccountService</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        IAccountService proxyInstance = (IAccountService)Proxy.newProxyInstance(accountService.getClass().getClassLoader(),</span><br><span class="line">                accountService.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Object reValue = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            tx.beginTransaction();</span><br><span class="line">                            reValue = method.invoke(accountService, args);</span><br><span class="line">                            tx.commit();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">                        &#123;</span><br><span class="line">                            tx.rollback();</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                            tx.release();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> reValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> proxyInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>AccountServiceImpl</code>——文件变得清爽，问题解决</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.pojo.Account;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(IAccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  accountDao.findAllAccount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAccountById(accountId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        accountDao.saveAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        accountDao.updateAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAccount</span><span class="params">(Integer accountId)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        accountDao.deleteAccount(accountId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Account sourceAccount = accountDao.findAccountByName(sourceName);</span><br><span class="line">        Account targetAccount = accountDao.findAccountByName(targetName);</span><br><span class="line">        sourceAccount.setMoney(sourceAccount.getMoney() - money);</span><br><span class="line">        targetAccount.setMoney(targetAccount.getMoney() + money);</span><br><span class="line">        accountDao.updateAccount(sourceAccount);</span><br><span class="line">        accountDao.updateAccount(targetAccount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>bean.xml</code>——修改一下部分内容</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyAccountService"</span> <span class="attr">factory-bean</span>=<span class="string">"beanFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getAccountService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanFactory"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.factory.BeanFactory"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountService"</span> <span class="attr">ref</span>=<span class="string">"accountService"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tx"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-4-基于Spring框架中AOP的问题解决"><a href="#6-4-基于Spring框架中AOP的问题解决" class="headerlink" title="6.4.基于Spring框架中AOP的问题解决"></a>6.4.基于Spring框架中AOP的问题解决</h2><ul><li><code>@EnableAspectJAutoProxy (proxyTargetClass=true)</code>——使用CGLib</li><li><code>@EnableAspectJAutoProxy (proxyTargetClass=false)</code><ul><li>实现接口——JDK官方动态代理</li><li>不实现接口——使用CGLib</li></ul></li><li>见7.2 &amp; 7.3</li></ul><h1 id="7-AOP"><a href="#7-AOP" class="headerlink" title="7.AOP"></a>7.AOP</h1><h2 id="AOP-amp-SpringAOP"><a href="#AOP-amp-SpringAOP" class="headerlink" title="AOP &amp; SpringAOP"></a>AOP &amp; SpringAOP</h2><ul><li><p><strong>AOP是一种思想</strong></p></li><li><p><strong>SpringAOP是AOP的一种实现</strong></p></li><li><p><strong>同样，AspectJ是AOP的一种实现</strong></p></li><li><p>Spring旧版有自己的AOP语法，但是非常复杂。</p></li><li><p><strong>故：Spring借助AspectJ的语法(AspectJ的注解，故要导入AspectJ的Jar包)，但底层使用自己Spring实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="7-1-AOP基础知识"><a href="#7-1-AOP基础知识" class="headerlink" title="7.1.AOP基础知识"></a>7.1.AOP基础知识</h2><ul><li><p><code>AOP</code>：全称是<code>Aspect oriented Programming</code>面向切面编程，通过预编译方式和<strong>运行期动态代理</strong>实现程序功能的统一维护的一种技术</p></li><li><p>作用：<strong>解决与主业务逻辑无关的横切性问题，把程序重复的代码抽取出来</strong>，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对已有方法进行增强</p></li><li><p>优势</p><ul><li>减少重复代码</li><li>提高开发效率</li><li>维护方便</li></ul></li><li><p><strong>与OOP对比</strong>，面向切面，传统的OOP开发中的代码逻辑是至上而下的，在这些至上而下的过程中会产生一些横切性的问题，这些横切性的问题和我们的主业务逻辑关系不大，会散落在代码的各个地方，造成难以维护，AOP的编程思想就是把业务逻辑和横切的问题进行分离，从而达到解耦的目的，使代码的重用性和开发效率高</p></li><li><p>应用场景</p><ul><li>日志记录</li><li>权限验证</li><li>效率检查</li><li>事务管理</li></ul></li><li><p>专业词汇</p><ul><li><p><code>Joinpoint</code>（连接点）</p><ul><li>被拦截到的点【如Service层的所有需要增强（目标对象）的方法】。在spring中，这些点指的是方法，因为spring只支持方法类型的连接点。</li></ul></li><li><p><code>Pointcut</code> （切入点）</p><ul><li>要对哪些Joinpoint进行拦截并增强【如Service层的需要增强的方法】，连接点的集合</li></ul></li><li><p><code>Advice</code>（通知/增强）</p><ul><li><p>所谓通知是指拦截到Joinpoint之后所要做的事情就是通知</p><ul><li>增强的位置</li><li>增强的内容</li></ul></li><li><p>通知的类型：</p><ul><li>前置通知，后置通知，异常通知，最终通知</li><li>环绕通知</li></ul><p><img src="1578117576531.png" alt="1578117576531"></p></li></ul></li><li><p><code>Introduction</code>（引介）:</p><ul><li><p>一种特殊的通知。在不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法或Field</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsageTracking</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DeclareParents</span>(value=<span class="string">"com.xzy.myapp.service.*"</span>, defaultImpl=DefaultUsageTracked<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">static</span> <span class="title">sageTracked</span> <span class="title">mixin</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Target</code>（目标对象）</p><ul><li>被代理的对象</li></ul></li><li><p><code>Weaving</code>（织入）</p><ul><li>织入：目标对象的需要增强的<strong>方法变</strong>成代理对象的<strong>方法的过程</strong></li><li>代理：目标对象变成代理对象的过程</li><li>spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入</li></ul></li><li><p><code>Proxy</code>（代理）</p><ul><li>一个类被AOP织入增强后，就产生一个结果代理类</li></ul></li><li><p><code>Aspect</code> （切面）</p><ul><li>切入点和通知(引介)的结合</li></ul></li></ul></li><li><p><code>pom.xml</code></p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="7-2-Spring中基于XML的AOP配置步骤"><a href="#7-2-Spring中基于XML的AOP配置步骤" class="headerlink" title="7.2.Spring中基于XML的AOP配置步骤"></a>7.2.Spring中基于XML的AOP配置步骤</h2><ul><li><p><code>通知Bean</code>也交给spring来管理</p></li><li><p><strong>使用<code>&lt;aop:config&gt;</code>标签表明开始AOP的配置</strong></p></li><li><p><strong>使用<code>&lt;aop:aspect&gt;</code>标签表明配置切面</strong></p><ul><li><strong><code>id</code>属性：切面唯一标识</strong></li><li><strong><code>ref</code>属性：通知类<code>bean</code>的<code>Id</code></strong></li></ul></li><li><p>在<code>&lt;aop:aspect&gt;</code>标签的<strong>内部使用对应标签</strong>来配置通知的类型</p><ul><li><code>&lt;aop:before&gt;</code>：表示配置前置通知<ul><li><code>method</code>属性：通知类中哪个方法是前置通知</li><li><code>pointcut</code>属性：切入点表达式，对业务层中哪些方法增强</li></ul></li><li>切入点表达式写法：<ul><li>关键字<code>execution(表达式)</code><ul><li>标准表达式：<code>访问修饰符 返回值 包名.包名.包名...类名.方法名(参数列表)</code></li><li><strong>访问修饰符可以省略</strong>：<code>返回值 包名.包名.包名...类名.方法名(参数列表)</code></li><li><strong>返回值可以使用通配符</strong>，表示任意返回值：<code>* 包名.包名.包名...类名.方法名(参数列表)</code></li><li>包名可以使用通配符，表示任意包。但是有几级包，需要写几个*：<code>*  *.*.*.类名.方法名(参数列表)</code></li><li>包名可以使用..表示当前包及其子包：<code>*  *..类名.方法名(参数列表)</code></li><li>类名和方法名都可以使用*来实现通配：<code>* *..*.*(参数列表)</code></li><li>参数列表可以直接写数据类型<ul><li>基本类型直接写名称——<code>int</code></li><li>引用类型写包名.类名的方式——<code>java.lang.String</code></li><li>可以使用通配符表示任意类型，但是必须有参数</li><li><strong>可以使用..表示有无参数均可，有参数可以是任意类型</strong></li></ul></li><li>全通配写法：<code>* *..*.*(..)</code></li><li>实际开发中切入点表达式的通常写法: </li><li>切到业务层实现类下的所有方法：<code>top.carpenter.service.impl.*.*(..)</code></li></ul></li><li>关键字<code>withIn</code>以类作为控制粒度</li><li>关键字<code>args</code>以参数作为控制粒度</li><li>关键字<code>@annotation</code>以注解作为控制粒度</li><li>关键字<code>@withIn(X)</code>以类是否加了X注解作为控制粒度</li><li>关键字<code>@args(X)</code>以参数是否加了X注解作为控制粒度</li><li>关键字<code>this(X)</code>是否是<code>X</code>的代理对象</li><li>关键字<code>target(X)</code>是否是<code>X</code>的目标对象</li><li>上述所有的表达式<strong>在通知中可以混合使用<code>||</code> <code>&amp;&amp;</code></strong> </li></ul></li></ul></li><li><p><code>bean.xml</code>约束</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="7-2-基于Spring框架中AOP的问题解决"><a href="#7-2-基于Spring框架中AOP的问题解决" class="headerlink" title="7.2.基于Spring框架中AOP的问题解决"></a>7.2.基于Spring框架中AOP的问题解决</h3><h4 id="7-2-1-基于前置-后置-异常以及最终通知的问题解决"><a href="#7-2-1-基于前置-后置-异常以及最终通知的问题解决" class="headerlink" title="7.2.1.基于前置 后置 异常以及最终通知的问题解决"></a>7.2.1.基于前置 后置 异常以及最终通知的问题解决</h4><ul><li><code>Bean.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">...约束头...</span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top.carpenter"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"servicePointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* top.carpenter.service.impl.AccountServiceImpl.*(..))"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"txManagerAdvice"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置前置通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"beginTransaction"</span> <span class="attr">pointcut-ref</span>=<span class="string">"servicePointcut"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置后置通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"commit"</span> <span class="attr">pointcut-ref</span>=<span class="string">"servicePointcut"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置异常通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"rollback"</span> <span class="attr">pointcut-ref</span>=<span class="string">"servicePointcut"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置最终通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"release"</span> <span class="attr">pointcut-ref</span>=<span class="string">"servicePointcut"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"account"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.pojo.Account"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.dao.impl.AccountDaoImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionUtils"</span> <span class="attr">ref</span>=<span class="string">"connectionUtils"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"runner"</span> <span class="attr">ref</span>=<span class="string">"runner"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.utils.TransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionUtils"</span> <span class="attr">ref</span>=<span class="string">"connectionUtils"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionUtils"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.utils.ConnectionUtils"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runner"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbutils.QueryRunner"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/spring_study"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>AccountServiceImpl</code>——同6.3无需更改 </li></ul><h4 id="7-2-2-基于环绕通知的问题解决"><a href="#7-2-2-基于环绕通知的问题解决" class="headerlink" title="7.2.2.基于环绕通知的问题解决"></a>7.2.2.基于环绕通知的问题解决</h4><ul><li><p>Spring框架为我们提供了一个接口：<code>ProceedingJoinPoint</code> </p></li><li><p>该接口有一个方法<code>proceed()</code>，此方法就相当于明确调用切入点方法</p></li><li><p>该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。</p></li><li><p><strong>环绕通知：spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。</strong></p></li><li><p><code>bean.xml</code></p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 修改7.3.1中配置</span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"servicePointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* top.carpenter.service.impl.AccountServiceImpl.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"txManagerAdvice"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"aroundTransaction"</span> <span class="attr">pointcut-ref</span>=<span class="string">"servicePointcut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>TransactionManager</code>——新增<code>aroundTransaction()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectionUtils</span><span class="params">(ConnectionUtils connectionUtils)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionUtils = connectionUtils;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"beginTransaction"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"commit"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().commit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"rollback"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().rollback();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"release"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().close();</span><br><span class="line">        connectionUtils.removeThreadConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundTransaction</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            beginTransaction();</span><br><span class="line">            rtValue = pjp.proceed(args);</span><br><span class="line">            commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            release();</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rtValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3-Spring中基于注解的AOP"><a href="#7-3-Spring中基于注解的AOP" class="headerlink" title="7.3.Spring中基于注解的AOP"></a>7.3.Spring中基于注解的AOP</h2><ul><li><code>bean.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>@Aspect</code> ——表示当前类是个切面类</p></li><li><p><code>@Before</code>——前置通知方法</p></li><li><p><code>@AfterReturning()</code>——后置通知方法</p></li><li><p><code>@AfterThrowing()</code>——异常通知方法</p></li><li><p><code>@After()</code>——最终通知方法</p></li><li><p><code>@Around()</code>——环绕通知方法</p></li><li><p><code>@Pointcut</code>——切入点表达式</p></li></ul><h3 id="7-3-基于Spring框架中AOP的问题解决"><a href="#7-3-基于Spring框架中AOP的问题解决" class="headerlink" title="7.3.基于Spring框架中AOP的问题解决"></a>7.3.基于Spring框架中AOP的问题解决</h3><h4 id="7-3-1-基于前置-后置-异常以及最终通知的问题解决-不建议使用-Spring框架存在一定bug"><a href="#7-3-1-基于前置-后置-异常以及最终通知的问题解决-不建议使用-Spring框架存在一定bug" class="headerlink" title="7.3.1.基于前置 后置 异常以及最终通知的问题解决[不建议使用 Spring框架存在一定bug]"></a>7.3.1.基于前置 后置 异常以及最终通知的问题解决[不建议使用 Spring框架存在一定bug]</h4><ul><li><code>bean.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="comment">配置Spring开启注解AOP支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>TransactionManager</code>切面类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span><span class="comment">//将切面类放入Spring容器管理</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//表明切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个切点 包含了众多连接点/方法</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* top.carpenter.service.impl.AccountServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectionUtils</span><span class="params">(ConnectionUtils connectionUtils)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionUtils = connectionUtils;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通知：位置+逻辑</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"beginTransaction"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"commit"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"rollback"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().rollback();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"release"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().close();</span><br><span class="line">        connectionUtils.removeThreadConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>JoinPoint</code>可以作为方法参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pt1()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    Object target = joinPoint.getTarget();  <span class="comment">//top.carpenter.UserService1@79da1ec0</span></span><br><span class="line">    Object aThis = joinPoint.getThis();  <span class="comment">//UserService1$$EnhancerBySpringCGLlB$$8fa9ac4d@2552</span></span><br><span class="line">    Object signature = joinPoint.getSignature();    <span class="comment">//void top.carpenter.UserService1.print()</span></span><br><span class="line">    System.out.println(<span class="string">"beginTransaction"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-3-2-基于环绕通知的问题解决"><a href="#7-3-2-基于环绕通知的问题解决" class="headerlink" title="7.3.2.基于环绕通知的问题解决"></a>7.3.2.基于环绕通知的问题解决</h4><ul><li><code>bean.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="comment">配置Spring开启注解AOP支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>TransactionManager</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* top.carpenter.service.impl.AccountServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectionUtils</span><span class="params">(ConnectionUtils connectionUtils)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionUtils = connectionUtils;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"beginTransaction"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"commit"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"rollback"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().rollback();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"release"</span>);</span><br><span class="line">        connectionUtils.getThreadConnection().close();</span><br><span class="line">        connectionUtils.removeThreadConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundTransaction</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Object[] args = pjp.getArgs();<span class="comment">//⭐</span></span><br><span class="line">        Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            beginTransaction();</span><br><span class="line">            rtValue = pjp.proceed(args);<span class="comment">//⭐</span></span><br><span class="line">            commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            release();</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rtValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ProceedIngjoinpoint</code>继承了<code>JoinPoint</code>，<code>proceed()</code>这个是aop代理链执行的方法。</li><li>proceed()有重载，有个带参数的方法,可以修改目标方法的的参数</li></ul><h1 id="8-Sping事务控制API"><a href="#8-Sping事务控制API" class="headerlink" title="8.Sping事务控制API"></a>8.Sping事务控制API</h1><h2 id="8-1-明确前提"><a href="#8-1-明确前提" class="headerlink" title="8.1.明确前提"></a>8.1.明确前提</h2><ul><li>JavaEE体系进行分层开发，事务处理位于<strong>业务层</strong>，Spring提供了分层设计业务层的事务处理解决方案。</li><li><strong>Spring框架为我们提供了一组事务控制的接口。</strong>这组接口是在<code>spring-tx-5.0.2.RELEASE.jar</code>中</li><li><strong>Spring的事务控制都是基于AOP的</strong><ul><li><strong>可以使用编程式事务实现【太麻烦】</strong></li><li>可以使用<strong>声明式事务实现</strong>。<strong>重点是使用声明式事务实现</strong></li></ul></li></ul><h2 id="8-2-事务控制API"><a href="#8-2-事务控制API" class="headerlink" title="8.2.事务控制API"></a>8.2.事务控制API</h2><ul><li><code>pom.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配合AOP使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>PlatformTransactionManager</code></p><ul><li><p>此接口是<code>Spring</code>的事务管理器，提供了常用的操作事务方法</p><ul><li><code>void commit(TransactionStatus status)</code></li><li><code>void rollback(TransactionStatus status)</code></li><li><code>TransactionStatus getTransaction(TransactionDefinition definition)</code></li></ul></li><li><p>开发中<strong>使用其实现类</strong>管理事务的对象</p><ul><li><strong><code>org.springframework.jdbc.datasource.DataSourceTransactionManager</code></strong>使用 SpringJDBC或iBatis进行持久化数据时使用</li><li><code>org.springframework.orm. hibernate5.HibernateTransactionManager</code><br>使用Hibernate版本进行持久化数据时使用</li></ul></li></ul></li><li><p><code>TransactionDefinition</code></p><ul><li>事务的定义信息对象<ul><li><code>String getName()</code>——获取事务对象名称</li><li><code>int getlsolationLevel()</code>——获取事务隔离级【默认同数据库】</li><li><code>int getPropagationBehavior()</code>——获取事务传播行为</li><li><code>int getTimeout()</code>——获取事务超时时间</li><li><code>boolean isReadOnly()</code>——获取事务是否只读</li></ul></li></ul></li><li><p>事务的隔离级别</p><ul><li>事务隔离级反映事务提交并发访问时的处理态度<ul><li><code>ISOLATION_DEFAULT</code>——默认级别，归属下列某一种</li><li><code>ISOLATION _READ_UNCOMMITTED</code>——可以读取未提交数据</li><li><code>ISOLATION READ_COMMITTED</code>——只能读取已提交数据，解决脏读问题(Oracle默认级别)</li><li><code>ISOLATION_REPEATABLE_READ</code>——是否读取其他事务提交修改后的数据，解决不可重复读问题(MySQL默认级别)</li><li><code>ISOLATION_SERIALIZABLE</code>——是否读取其他事务提交添加后的数据，解决幻影读问题</li></ul></li></ul></li><li><p>事务的传播行为</p><ul><li><code>REQUIRED</code>：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择【默认值】</li><li><code>SUPPORTS</code>：支持当前事务，如果当前没有事务，就以非事务方式执行(没有事务)</li></ul></li><li><p>超时时间</p><ul><li>默认值是-1，没有超时限制</li><li>如果有，以秒为单位进行设置</li></ul></li><li><p>是否是只读事务</p><ul><li>建议查询设置为只读</li></ul></li><li><p><code>TransactionStatus</code></p><ul><li>此接口提供的事务具体的运行状态包含有6个具体的操作<ul><li><code>void flush()</code>——刷新事务</li><li><code>boolean hasSavepoint()</code>——获取是否是否存在存储点</li><li><code>boolean isCompleted()</code>——获取事务是否完成</li><li><code>boolean isNewTransaction()</code>——获取事务是否为新的事务</li><li><code>boolean isRollbackOnly()</code>——获取事务是否回滚</li><li><code>void setRollbackOnly()</code>——设置事务回滚</li></ul></li></ul></li></ul><p>​    </p><h2 id="8-3-基于XML的实现"><a href="#8-3-基于XML的实现" class="headerlink" title="8.3.基于XML的实现"></a>8.3.基于XML的实现</h2><ul><li>需要导入事务的的约束 </li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>配置事务管理器</p><p><img src="1578313947538.png" alt="1578313947538"></p></li><li><p><strong>使用<code>&lt;tx:advice&gt;</code>标签配置事务的通知，以及配置的事务属性</strong></p><ul><li>在<code>&lt;tx:advice&gt;</code>标签内部<ul><li>属性<ul><li><code>id</code>：事务通知唯一标识</li><li><code>transaction-manager</code>：给事务通知提供一个事务管理器引用</li></ul></li></ul></li></ul><p><img src="1578313804043.png" alt="1578313804043"></p></li><li><p>配置AOP中的通用切入点表达式，并建立事务通知和切入点表达式的对应关系</p><p><img src="1578313839120.png" alt="1578313839120"></p></li></ul><h2 id="8-4-基于注解的实现"><a href="#8-4-基于注解的实现" class="headerlink" title="8.4.基于注解的实现"></a>8.4.基于注解的实现</h2><ul><li>需要导入事务的的约束</li><li>配置事务管理器</li><li>开启Spring对注解事物的支持</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- @EnableTransactionManagement等价于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transacannotation-drivention-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在需要事务支持的地方使用<code>@Transactional</code>注解</li></ul><h2 id="8-5-事务的传播特性"><a href="#8-5-事务的传播特性" class="headerlink" title="8.5.事务的传播特性"></a>8.5.事务的传播特性</h2><p>[1]死活不要事务的 PROPAGATION_NEVER：没有就非事务执行，有就抛出异常 PROPAGATION_NOT_SUPPORTED：没有就非事务执行，有就直接挂起，然后非事务执行 [2]可有可无的 PROPAGATION_SUPPORTS: 有就用，没有就算了 [3]必须有事务的 PROPAGATION_REQUIRES_NEW：有没有都新建事务，如果原来有，就将原来的挂起。 PROPAGATION_NESTED: 如果没有，就新建一个事务；如果有，就在当前事务中嵌套其他事务。 PROPAGATION_REQUIRED: 如果没有，就新建一个事务；如果有，就加入当前事务 PROPAGATION_MANDATORY: 如果没有，就抛出异常；如果有，就使用当前事务。</p><h1 id="9-面试"><a href="#9-面试" class="headerlink" title="9.面试"></a>9.面试</h1><ul><li><p>Spring 动态代理是如何实现的</p></li><li><p>为什么要使用 spring？</p></li><li><p>解释一下什么是 aop？</p></li><li><p>解释一下什么是 ioc？</p></li><li><p>spring 有哪些主要模块？</p></li><li><p>spring 常用的注入方式有哪些？</p></li><li><p>spring 中的 bean 是线程安全的吗？</p></li><li><p>spring 支持几种 bean 的作用域？</p></li><li><p>spring 自动装配 bean 有哪些方式？</p></li><li><p>spring 事务实现方式有哪些？</p></li><li><p>spring 的事务隔离？</p></li></ul>]]></content>
    
    <summary type="html">
    
      SpringAOP
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Spring" scheme="http://goldcarpenter.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring FrameWork</title>
    <link href="http://goldcarpenter.github.io/2019/09/12/Spring_IOC/"/>
    <id>http://goldcarpenter.github.io/2019/09/12/Spring_IOC/</id>
    <published>2019-09-12T14:43:11.000Z</published>
    <updated>2020-06-17T03:23:20.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Spring-FrameWork"><a href="#1-Spring-FrameWork" class="headerlink" title="1.Spring FrameWork"></a>1.Spring FrameWork</h1><ul><li><p>Spring是一个开源框架，Spring是于2003年兴起的一个轻量级的Java开发框架，它是为了解决企业应用开发的复杂性而创建的。</p></li><li><p>Spring使用基本的<code>JavaBean</code>来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，<strong>任何Java应用都可以从Spring中受益</strong>。</p></li><li><p>简单来说，Spring是一个轻量级的<strong>控制反转（IoC）</strong>和<strong>面向切面（AOP）</strong>的容器框架。</p></li></ul><h2 id="1-1-Sping-优点"><a href="#1-1-Sping-优点" class="headerlink" title="1.1.Sping 优点"></a>1.1.Sping 优点</h2><ul><li><p>方便解耦，简化开发</p><ul><li>Spring就是一个大工厂，专门负责生成<code>Bean</code>，可以将所有对象创建和依赖关系维护由<code>Spring</code>管理</li></ul></li><li><p>提供面向切面编程</p><ul><li>方便的实现对程序进行<strong>权限拦截</strong>、运行监控等功能</li></ul></li><li><p>声明式事务的支持</p><ul><li>只需要通过配置就可以完成对事务的管理，而无需手动编程</li></ul></li><li><p>方便程序的测试</p><ul><li>Spring对Junit4支持，可以通过注解方便的测试Spring程序</li></ul></li><li><p>方便集成各种优秀框架</p><ul><li>内部提供了对各种优秀框架（如：<code>Struts Hibernate MyBatis Quartz</code>等）的支持</li></ul></li><li><p>降低<code>JavaEE API</code>的使用难度</p><ul><li>对JavaEE开发中一些难用的API（JDBC、JavaMail、远程调webservice用等）都提供了封装，使这些API应用难度大大降低</li></ul></li></ul><h2 id="1-2-体系结构"><a href="#1-2-体系结构" class="headerlink" title="1.2.体系结构"></a>1.2.体系结构</h2><p><img src="1568184874034.png" alt="1568184874034"></p><ul><li><code>Core Container</code>——<strong>其他所有内容</strong>都需要<strong>核心容器（IOC）</strong>支持<ul><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html" target="_blank" rel="noopener">Core technologies</a>: dependency injection, events, resources, i18n, validation, data binding, type conversion, SpEL, AOP.</li></ul></li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/testing.html" target="_blank" rel="noopener">Testing</a>: mock objects, TestContext framework, Spring MVC Test, <code>WebTestClient</code>.</li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html" target="_blank" rel="noopener">Data Access</a>: transactions, DAO support, JDBC, ORM, Marshalling XML.</li><li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html" target="_blank" rel="noopener">Spring MVC</a> and <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html" target="_blank" rel="noopener">Spring WebFlux</a> web frameworks.</li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/integration.html" target="_blank" rel="noopener">Integration</a>: remoting, JMS, JCA, JMX, email, tasks, scheduling, cache.</li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/languages.html" target="_blank" rel="noopener">Languages</a>: Kotlin, Groovy, dynamic languages.</li></ul><h2 id="1-3Spring编程的风格"><a href="#1-3Spring编程的风格" class="headerlink" title="1.3Spring编程的风格"></a>1.3Spring编程的风格</h2><ul><li>可以配合使用<ul><li><code>schemal-based------xml</code></li><li><code>annotation-based----- annotation</code></li><li><code>java-based----java Configuration</code></li></ul></li></ul><h1 id="2-Spring-IOC原理入门"><a href="#2-Spring-IOC原理入门" class="headerlink" title="2.Spring IOC原理入门"></a>2.Spring IOC原理入门</h1><h2 id="2-1-问题：程序间耦合"><a href="#2-1-问题：程序间耦合" class="headerlink" title="2.1.问题：程序间耦合"></a>2.1.问题：程序间耦合</h2><ul><li><p>耦合——程序间的依赖关系</p><ul><li>类（jar包）之间的依赖</li><li>方法之间的依赖</li></ul></li><li><p>实际开发中——<strong>目标：编译期不依赖，运行时依赖（方便动态代理，让Spring返回我们需要的对象【是否添加AOP/事务控制内容】）</strong></p></li><li><p>解耦思路</p><ul><li>步骤一：使用反射创建对象，而避免使用new关键字–&gt;导致字符串写‘死’</li><li>步骤二：通过读取配置文件来获取要创建的对象全限定类名</li></ul></li><li><p>以<code>JDBC</code>为例</p><p><img src="1577606658701.png" alt="1577606658701"></p></li><li><p>以视图层-业务层-表现层为例</p><ul><li>以下两张图耦合性非常强</li></ul><p><img src="1577606531887.png" alt="1577606531887"></p><p><img src="1577606552486.png" alt="1577606552486"></p></li></ul><h2 id="2-2-解决方案"><a href="#2-2-解决方案" class="headerlink" title="2.2.解决方案"></a>2.2.解决方案</h2><ul><li>创建<code>Bean</code>对象工厂<ul><li><code>Bean</code>：可重用组件</li><li>第一步：一个配置文件中<code>唯一标识id=全限定类名(key=value)</code>（配置service和dao对象信息）<ul><li>配置文件种类：<code>xml</code>/<code>properties</code></li></ul></li><li>第二步：通过读取配文件中配的内容，反射创建对象</li></ul></li></ul><p><img src="1577629887742.png" alt="1577629887742"></p><ul><li><code>bean.properties</code></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">accountService</span>=<span class="string">top.carpenter.service.impl.AccountServiceImpl</span></span><br></pre></td></tr></table></figure><ul><li><code>IAccountService.java</code> &amp; <code>AccountServiceImpl.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> top.carpenter.service.impl;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"save ok"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>BeanFactory.java</code>多例版本</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义个Properties对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties props;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用静态代码块为Properties对象赋值</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化对象</span></span><br><span class="line">            props = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="comment">// 获取properties文件的流对象，获取编译后classes下资源文件</span></span><br><span class="line">            InputStream in = BeanFactory.class.getPropertiesClassLoader().getResourceAsStream("bean.properties");</span><br><span class="line">            props.load(in);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(<span class="string">"系统初始化失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Bean名称获取Bean对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Object bean;</span><br><span class="line">        String beanPath = props.getProperty(beanName);</span><br><span class="line">        bean = Class.forName(beanPath).newInstance();</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>BeanFactory.java</code>单例版本</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个Properties对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties props;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个Map 用于存放我们要创建的对象 即容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; beans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用静态代码块为Properties对象赋值</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化对象</span></span><br><span class="line">            props = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="comment">// 获取properties文件的流对象，获取编译后classes下资源文件</span></span><br><span class="line">            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream("bean.properties");</span><br><span class="line">            props.load(in);</span><br><span class="line">            <span class="comment">// 实例化容器</span></span><br><span class="line">            beans = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">            <span class="comment">// 取出配置文件中所有key</span></span><br><span class="line">            Enumeration keys = props.keys();</span><br><span class="line">            <span class="comment">// 遍历枚举</span></span><br><span class="line">            <span class="keyword">while</span> (keys.hasMoreElements())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 取出每一个key</span></span><br><span class="line">                String key = keys.nextElement().toString();</span><br><span class="line">                <span class="comment">// 根据key值获取value</span></span><br><span class="line">                String beanPath = props.getProperty(key);</span><br><span class="line">                <span class="comment">// 反射创建对象</span></span><br><span class="line">                Object value = Class.forName(beanPath).newInstance();</span><br><span class="line">                <span class="comment">// 把key值放入容器</span></span><br><span class="line">                beans.put(key,value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(<span class="string">"系统初始化失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Bean名称获取Bean对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beans.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Client.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.ui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.carpenter.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        IAccountService accountService =(IAccountService)BeanFactory.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">        accountService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1577630112947.png" alt="1577630112947"></p><h1 id="3-控制反转-IOC"><a href="#3-控制反转-IOC" class="headerlink" title="3.控制反转(IOC)"></a>3.控制反转(IOC)</h1><ul><li>控制反转：把创建对象的权利交给框架，由框架控制对象的生命周期，是框架的重要特征</li><li>IOC作用：<strong>削减计算机程序的耦合，降低程序间的依赖关系</strong></li></ul><p><img src="1577632805455.png" alt="1577632805455"></p><h2 id="3-1-Spring-IOC容器构建"><a href="#3-1-Spring-IOC容器构建" class="headerlink" title="3.1.Spring IOC容器构建"></a>3.1.Spring IOC容器构建</h2><ul><li><code>pom.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--这个依赖可以解决Spring IOC 90%功能--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="1577671311771.png" alt="1577671311771"></p><blockquote><p><strong>核心容器本质是个Map</strong></p></blockquote><ul><li><code>applicationContext.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置文件中`唯一标识==全限定类名(key=value)`--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.service.impl.AccountServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Client.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.ui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Spring容器</span></span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);<span class="comment">//显现类选择见下图</span></span><br><span class="line">        <span class="comment">// 从容器中提取Bean</span></span><br><span class="line">        IAccountService accountService = (IAccountService) ac.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">        <span class="comment">// 或：IAccountService accountService1 = ac.getBean("accountService", IAccountService.class);</span></span><br><span class="line">        accountService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Spring工厂类结构图</p><p><img src="1577673600316.png" alt="1577673600316"></p><ul><li><p><code>BeanFactory</code>是<strong>核心容器</strong>的顶层接口</p></li><li><p>三个常用实现类</p><ul><li><code>ClassPathXmlApplicationContext</code>——可以<strong>加载类路径</strong>下的<strong>配置文件</strong>，要求配置文件必须在类路径下，否则加载不了。</li><li><code>FileSystemXmlApplicationContext</code>——可以加载磁盘任意路径下的配置文件(必须有访问权限)</li><li><code>AnnotationConfigApplicationContext</code>——用于读取注解创建容器的</li></ul></li><li><p>两个常用接口</p><ul><li><code>BeanFactory</code>——构建核心容器时，创建对象采取的策略是采用延迟加载的方式。即根据id获取对象时才创建对象</li><li><code>ApplicationContext</code>——构建核心容器时，创建对象采取的策略是采用立即加载的方式。即只要读取完配置文件马上就创建配置文件中配置的对象</li></ul></li></ul></li></ul><h2 id="3-2-Bean的三种创建方式"><a href="#3-2-Bean的三种创建方式" class="headerlink" title="3.2.Bean的三种创建方式"></a>3.2.Bean的三种创建方式</h2><h3 id="3-2-1-使用默认构造函数创建，并存入spring容器"><a href="#3-2-1-使用默认构造函数创建，并存入spring容器" class="headerlink" title="3.2.1.使用默认构造函数创建，并存入spring容器"></a>3.2.1.使用默认构造函数创建，并存入spring容器</h3><ul><li><p>在spring的配置文件中使用<code>bean</code>标签，配以<code>id</code>和<code>class</code>属性之后，且没有其他属性和标签</p></li><li><p>构造函数创建<code>bean</code>对象，<strong>此时如果类中没有默认构造函数，则对象无法创建</strong></p></li><li><p><code>applicationContext.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.service.impl.AccountServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-2-使用普通工厂中的方法创建对象-使用某个类中的方法创建对象，并存入spring容器"><a href="#3-2-2-使用普通工厂中的方法创建对象-使用某个类中的方法创建对象，并存入spring容器" class="headerlink" title="3.2.2.使用普通工厂中的方法创建对象/使用某个类中的方法创建对象，并存入spring容器"></a>3.2.2.使用普通工厂中的方法创建对象/使用某个类中的方法创建对象，并存入spring容器</h3><ul><li><p><code>InstanceFactory.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟存在于jar包中的 我们无法修改</span></span><br><span class="line"><span class="keyword">package</span> top.carpenter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.impl.AccountServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IAccountService <span class="title">getIAccountService</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>applicationContext.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instanceFactory"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.InstanceFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">factory-bean</span>=<span class="string">"instanceFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getIAccountService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-3-使用工厂中的静态方法创建对象-使用某个类中的静态方法创建对象，并存入spring容器"><a href="#3-2-3-使用工厂中的静态方法创建对象-使用某个类中的静态方法创建对象，并存入spring容器" class="headerlink" title="3.2.3.使用工厂中的静态方法创建对象/使用某个类中的静态方法创建对象，并存入spring容器"></a>3.2.3.使用工厂中的静态方法创建对象<strong>/</strong>使用某个类中的静态方法创建对象，并存入spring容器</h3><ul><li><p><code>InstanceFactory.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟存在于jar包中的 我们无法修改</span></span><br><span class="line">  <span class="keyword">package</span> top.carpenter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line">  <span class="keyword">import</span> top.carpenter.service.impl.AccountServiceImpl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceStaticFactory</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IAccountService <span class="title">getIAccountService</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>applicationContext.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.InstanceStaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getIAccountService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-3-Bean对象的作用范围"><a href="#3-3-Bean对象的作用范围" class="headerlink" title="3.3.Bean对象的作用范围"></a>3.3.Bean对象的作用范围</h2><ul><li><p>用于指定<code>bean</code>的作用范围</p><ul><li><code>singleton</code>——单例（默认）</li><li><code>prototype</code>——多例</li><li><code>request</code>——作用于web应用的请求范围</li><li><code>session</code>——作用于web应用的会话范围</li><li><code>global-session</code>——作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session</li></ul></li><li><p>在<code>Singleton</code>当中引用了一个<code>Prototype</code>的bean的时候，会使得<code>Prototype</code>失效</p><ul><li><p>容器只创建单例Singleton一次，只有一次机会设置属性值</p></li><li><p>解决问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例的</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService1</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;<span class="comment">//原型的</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-4-Bean对象的生命周期"><a href="#3-4-Bean对象的生命周期" class="headerlink" title="3.4.Bean对象的生命周期"></a>3.4.Bean对象的生命周期</h2><ul><li>单例对象<ul><li>创建：当容器创建时，对象创建</li><li>存活：容器存在，对象一直存在</li><li>销毁：与容器同时销毁</li></ul></li><li>多例对象<ul><li>创建：当使用对象时，容器创建对象</li><li>存活：对象只要使用过程中就一直活着</li><li>销毁：长时间不用，且没有其他对象引用时，由JVM自动回收</li></ul></li></ul><h1 id="4-依赖注入-Dependency-Injection"><a href="#4-依赖注入-Dependency-Injection" class="headerlink" title="4.依赖注入(Dependency Injection)"></a>4.依赖注入(Dependency Injection)</h1><ul><li><code>IoC</code>的作用：降低程序间的耦合<strong>(依赖关系</strong>)</li><li>依赖关系的管理：<ul><li>在当前类需要用到其他类的对象，由<code>spring</code>为我们提供，我们只需要在配置文件中说明</li><li>以后都<strong>交给<code>spring</code>来维护依赖关系，就称之为依赖注入</strong></li></ul></li><li><strong>依赖注入的数据</strong><ul><li><strong>基本类型和<code>String</code></strong></li><li><strong>其他<code>bean</code>类型(在配置文件中或者注解配置过的bean)</strong></li><li><strong>复杂类型/集合类型</strong></li></ul></li></ul><h2 id="4-1-依赖注入的方式"><a href="#4-1-依赖注入的方式" class="headerlink" title="4.1.依赖注入的方式"></a>4.1.依赖注入的方式</h2><h3 id="4-1-1-使用构造函数提供"><a href="#4-1-1-使用构造函数提供" class="headerlink" title="4.1.1.使用构造函数提供"></a>4.1.1.使用构造函数提供</h3><ul><li><p><code>AccountServiceImpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountServiceImpl</span><span class="params">(String name, <span class="keyword">int</span> age, Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.age);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.birthday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>bean.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置文件中`唯一标识==全限定类名(key=value)`--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"yyx"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"date"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用的标签：<code>constructor-arg</code></p></li><li><p>标签出现的位置：<code>bean</code>标签的内部</p></li><li><p>标签中的属性</p><ul><li><code>type</code>：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型（容易混）</li><li><code>index</code>：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始</li><li><code>name</code>：用于指定给构造函数中指定名称的参数赋值【常用】<br>=================以上三个用于指定给构造函数中哪个参数赋值============</li><li><code>value</code>：用于提供基本数据类型和String类型的数据</li><li><code>ref</code>：用于指定其他的bean类型数据。它指的就是在spring的IoC核心容器中出现过的bean对象</li></ul></li><li><p>优势</p><ul><li>在获取<code>bean</code>对象时，注入数据是必须的操作，否则对象无法创建成功</li></ul></li><li><p>劣势</p><ul><li><code>bean</code>对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供</li></ul></li></ul><h3 id="4-1-2-使用set方法提供"><a href="#4-1-2-使用set方法提供" class="headerlink" title="4.1.2.使用set方法提供"></a>4.1.2.使用set方法提供</h3><ul><li><code>AccountServiceImpl.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.age);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.birthday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>bean.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置文件中`唯一标识==全限定类名(key=value)`--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"yyx"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"date"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用的标签：<code>property</code></li><li>标签出现的位置：<code>bean</code>标签的内部</li><li>标签的属性<ul><li><code>name</code>:用于指定注入时所调用的set方法名称</li><li><code>value</code>: 用于提供基本类型和String类型的数据</li><li><code>ref</code>:用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象</li></ul></li><li>优势:<ul><li>创建对象时没有明确的限制，可以直接使用默认构造函数</li></ul></li><li>弊端:<ul><li>如果有某个成员必须有值，则获取对象是有可能set方法没有执行</li></ul></li></ul><h3 id="补充：复杂类型-集合类型注入（set方法-amp-构造函数）"><a href="#补充：复杂类型-集合类型注入（set方法-amp-构造函数）" class="headerlink" title="补充：复杂类型/集合类型注入（set方法 &amp; 构造函数）"></a>补充：复杂类型/集合类型注入（set方法 &amp; 构造函数）</h3><ul><li><p><code>AccountServiceImpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] myStrs;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; myList;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; mySet;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String ,String&gt; myMap;</span><br><span class="line">    <span class="keyword">private</span> Properties myProps;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountServiceImpl</span><span class="params">(String[] myStrs, List&lt;String&gt; myList, Set&lt;String&gt; mySet, Map&lt;String, String&gt; myMap, Properties myProps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myStrs = myStrs;</span><br><span class="line">        <span class="keyword">this</span>.myList = myList;</span><br><span class="line">        <span class="keyword">this</span>.mySet = mySet;</span><br><span class="line">        <span class="keyword">this</span>.myMap = myMap;</span><br><span class="line">        <span class="keyword">this</span>.myProps = myProps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyStrs</span><span class="params">(String[] myStrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myStrs = myStrs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyList</span><span class="params">(List&lt;String&gt; myList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myList = myList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMySet</span><span class="params">(Set&lt;String&gt; mySet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mySet = mySet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyMap</span><span class="params">(Map&lt;String, String&gt; myMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myMap = myMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyProps</span><span class="params">(Properties myProps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myProps = myProps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(myList);</span><br><span class="line">        System.out.println(myMap);</span><br><span class="line">        System.out.println(myProps);</span><br><span class="line">        System.out.println(mySet);</span><br><span class="line">        System.out.println(Arrays.toString(myStrs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>bean.xml</code>（set方法）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置文件中`唯一标识==全限定类名(key=value)`--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myStrs"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>A<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>B<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mySet"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>AA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>BB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myMap"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"AAAA"</span> <span class="attr">value</span>=<span class="string">"BBBB"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"CCCC"</span> <span class="attr">value</span>=<span class="string">"DDDD"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myProps"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"2"</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>        <span class="comment">&lt;!--  没有value属性了  --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>bean.xml</code>（构造函数）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置文件中`唯一标识==全限定类名(key=value)`--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>a<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>b<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"myStrs"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>a<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>b<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"myMap"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"a"</span> <span class="attr">value</span>=<span class="string">"b"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"a"</span> <span class="attr">value</span>=<span class="string">"b"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"myProps"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"a"</span>&gt;</span>b<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"a"</span>&gt;</span>b<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"mySet"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>a<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>b<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用标签：List结构集合</p><ul><li><code>list</code></li><li><code>array</code></li><li><code>set</code></li></ul></li><li><p>使用标签：Map结构集合</p><ul><li><code>map</code>&amp;<code>entry</code></li><li><code>props</code>&amp;<code>prop</code></li></ul></li><li><p><code>set</code>方法标签出现的位置：<code>property</code>标签的内部</p></li><li><p>构造函数标签出现的位置：<code>bean</code>标签的内部</p></li></ul><h3 id="4-1-3-使用注解提供"><a href="#4-1-3-使用注解提供" class="headerlink" title="4.1.3.使用注解提供"></a>4.1.3.使用注解提供</h3><h4 id="1-注解知识引入"><a href="#1-注解知识引入" class="headerlink" title="1. 注解知识引入"></a>1. 注解知识引入</h4><ul><li>曾经的XML配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"top.carpenter.service.impl.AccountServiceImpl"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">scope</span>=<span class="string">"..."</span> <span class="attr">init-method</span>=<span class="string">"..."</span> <span class="attr">destroy-method</span>=<span class="string">".."</span> <span class="attr">depends-on</span>=<span class="string">".."</span> <span class="attr">lazy-</span>        <span class="attr">init</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>创建对象的注解</strong></p><ul><li>作用：同在XML配置文件中编写一个<code>&lt;bean&gt;</code>标签</li><li><code>@Component</code><ul><li>把当前类存入Spring容器</li><li>属性<ul><li>value：用于指定<code>bean</code>的<code>id</code>，当不写时，它的<strong>默认是当前类名，且首字母改小写</strong></li></ul></li></ul></li><li><code>@Controller</code>——spring框架明确提供的三层中<strong>表现层</strong>使用的</li><li><code>@Service</code>——spring框架明确提供的三层中<strong>业务层</strong>使用的</li><li><code>@Repository</code>——spring框架明确提供的三层中<strong>持久层</strong>使用的</li></ul></li><li><p><strong>注入数据的注解</strong></p><ul><li><p>作用：同在XML配置文件中的<code>bean</code>标签中写一个<code>&lt;property&gt;</code>标签</p></li><li><p><code>@Autowired</code>——自动按照类型注入</p><ul><li><p>出现位置：</p><ul><li>变量</li><li>方法(<code>比如配合@Bean使用 需要添加属性</code>)</li></ul></li><li><p>只要容器中有唯一一个<strong>bean对象类型</strong>和<strong>要注入的变量类型匹配</strong>，就可以注入成功</p></li><li><p>如果ioc容器中没有任何bean的类型和要注入的变至类型匹配，则报错</p></li><li><p>如果Ioc容器中<strong>有多个类型匹配</strong>时</p><ul><li><strong>如果在多个类型匹配中存在<code>id</code>与变量名称相同，就可以注入成功</strong></li><li><strong>如果在多个类型匹配中不存在<code>id</code>与变量名称相同，则报错</strong></li><li><strong><code>id</code>与变量名称必须相同，存在不方便，引出<code>@Qualifier</code></strong></li></ul></li></ul></li></ul></li></ul><pre><code>![1577891921173](1577891921173.png)* 细节：  * **在使用注解注入时，set方法就不是必须的**  ![1577891716576](1577891716576.png)</code></pre><ul><li><p><code>@Qualifier</code></p><ul><li>按照<strong>数据类型</strong>注入的基础之上再按照名称注入</li><li><strong>它在给类成员注入时配合<code>@Autowired</code>使用，不能单独使用。</strong></li><li><strong>在给方法参数往入时可以单独使用</strong></li><li>属性<ul><li><code>value</code>：用于指定注入<code>bean</code>的<code>id</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"accountServiceImpl1"</span>)</span><br><span class="line"><span class="keyword">private</span> IAccountService accountServiceImpl2;  <span class="comment">// 以注解的名称为准</span></span><br></pre></td></tr></table></figure></li><li><p><code>@Resource</code></p><ul><li>作用：<strong>直接按照<code>bean</code>的<code>id</code>注入，独立使用</strong></li><li>属性：<ul><li><code>name</code>：用于指定<code>bean</code>的<code>id</code></li></ul></li></ul></li><li><p><strong>===============以上三个注入都只能注入其他bean类型的数据==========================</strong></p></li><li><p><strong>===============基本类型和String类型无法使用上述注解实现，使用<code>@Value</code>===============</strong></p></li><li><p><code>@Value</code></p><ul><li>作用：用于注入基本类型和String类型的数据</li><li>属性<ul><li><code>value</code>：用于指定数据的值。它可以使用<code>spring</code>中<code>SpEL</code>（spring的el表达式）</li><li><strong>SpEL的写法: <code>${表达式}</code></strong></li></ul></li></ul></li><li><p><strong>===============集合类型的注入只能通过XML来实现==============================</strong></p></li></ul><ul><li><p>改变作用范围的注解</p><ul><li>作用：同在XML配置文件中的<code>bean</code>标签中使用<code>scope</code></li><li><code>@Scope</code>：<ul><li><code>value</code>属性：<ul><li>单例：<code>singleton</code></li><li>多例：<code>prototype</code></li></ul></li></ul></li></ul></li><li><p>生命周期相关的注解</p><ul><li>作用：同在XML配置文件中的标签中使用<code>init-method</code>和<code>destroy-method</code></li><li><code>@PreDestroy</code>：指定生命周期结束销毁的回调方法</li><li><code>@PostConstruct</code>：指定生命周期初始化的回调方法（在构造方法之后执行）</li></ul></li><li><p>【官网不推荐】还可以使得类实现接口<code>InitializingBean</code>，<code>DisposableBean</code></p><ul><li>Destroy methods are called in the same order<ol><li>Methods annotated with @PreDestroy</li><li>destroy() as defined by the DisposableBean callback interface</li><li>A custom configured destroy() method</li></ol></li></ul></li></ul><h4 id="2-为什么要添加注解扫描"><a href="#2-为什么要添加注解扫描" class="headerlink" title="2.为什么要添加注解扫描"></a>2.为什么要添加注解扫描</h4><ul><li>程序在创建容器的解析配置文件过程中，只读了<code>bean.xml</code>，<strong>并不知道你在哪里使用了注解</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br></pre></td></tr></table></figure><ul><li>故需告知Spring在创建容器时，要扫描的包</li><li>配置所需要的标签不是在beans的约束中，而是在一个名称为<code>context</code>名称空间和约束中</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top.carpenter"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>即开启Spring注解支持，又开启注解扫描</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 已经二合一了 下边这个不用了--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>&gt;</span><span class="tag">&lt;/<span class="name">context:annotation-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-使用注解提供"><a href="#3-使用注解提供" class="headerlink" title="3. 使用注解提供"></a>3. 使用注解提供</h4><ul><li><code>AccountServiceImpl.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> top.carpenter.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"yyx"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"18"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.age);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.birthday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>bean.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top.carpenter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>/&gt;</span><span class="comment">&lt;!--jar包中的类需要在`bean.xml`配置--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-优化-去除配置文件"><a href="#4-优化-去除配置文件" class="headerlink" title="4.优化 去除配置文件"></a>4.优化 去除配置文件</h4><ul><li><p><strong>之前所使用的注解只能使用在自己写的类上，jar包中的类需要在<code>bean.xml</code>配置，导致无法彻底删除<code>bean.xml</code></strong></p></li><li><p>使用<code>top.carpenter.config.SpringConfiguration.java</code>代替<code>bean.xml</code></p><ul><li><code>@Configuration</code>——指定当前类是个配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用注解new AnnotationConfigApplicationContext 但是XML内容还可以用</span></span><br><span class="line"><span class="meta">@ImportResource</span>(<span class="string">"Classpath:spring.xml"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value = &#123;<span class="string">"top.carpenter"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">createDate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@ComponentScan</code>——指定Spring在创建容器时要扫描的包</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- @ComponentScan(value = &#123;"top.carpenter"&#125;)等价于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top.carpenter"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>@EnableAspectJAutoProxy</code>——使用注解开启AOP支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- @EnableAspectJAutoProxy等价于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>@EnableTransactionManagement</code>——开启对事务的支持</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- @EnableTransactionManagement等价于--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>@Bean</code>——用于把当前方法的返回值作为bean对象存入<code>Spring</code>的<code>IOC</code>容器中<ul><li>属性<ul><li><code>name</code>：用于指定<code>bean</code>的<code>id</code>。当不写时，默认值是当前方法的名称</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  @Bean</span></span><br><span class="line"><span class="comment">  public Date createDate()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  return  new Date();</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  等价于--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>@Import</code>——当存在多个配置类时，用于导入其他的配置类</p><ul><li>属性:<ul><li><code>value</code>：用于指定其他配置类的字节码<ul><li>当我们使用<code>@Import</code>的注解之后，有<code>@Import</code>注解的类就父配置类，而导入的都是子配置类<ul><li><code>SpringConfiguration.java</code></li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value = &#123;<span class="string">"top.carpenter"</span>&#125;)</span><br><span class="line"><span class="meta">@Import</span>(DateConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>DateConfiguration.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.carpenter.config;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">import</span> java.util.Date;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PropertySource</span>(<span class="string">"classpath:dateConfig.properties"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConfiguration</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用EL表达式注入</span></span><br><span class="line">        <span class="meta">@Value</span>(<span class="string">"$&#123;date&#125;"</span>)</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> date;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Date <span class="title">createDate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Date(date);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@PropertySource</code></p><ul><li>作用：用于指定properties文件的位置</li></ul></li><li><p>属性：</p><pre><code>* `value`：指定文件的名称和路径。关键词：classpath 表示类路径下</code></pre><ul><li><code>dateConfig.properties</code></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">date</span>=<span class="string">10000</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Client.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line"><span class="comment">//等价于 </span></span><br><span class="line">ApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure></li></ul><h1 id="5-Spring整合JUnit"><a href="#5-Spring整合JUnit" class="headerlink" title="5.Spring整合JUnit"></a>5.Spring整合JUnit</h1><ul><li><code>junit</code>单元测试内部继承了<code>main</code>方法，该方法就会判断当前测试类中哪些方法有<code>@Test</code>注解，然后让方法执行</li><li><strong><code>junit</code>在执行测试方法时，junit根本不知道是否使用了spring框架，所以也就不会读取配置文件/配置类创建spring核心容器，报空指针异常</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClient</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        accountService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报空指针异常</span></span><br></pre></td></tr></table></figure><ul><li><p>Spring整合JUnit</p><ol><li>导入Spring整合JUnit的jar包</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用JUnit提供的<code>@RunWith(SpringJUnit4ClassRunner.class)</code>注解把原有的main方法替换 换成spring提供的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="3"><li><strong><code>@ContextConfiguration</code>告知Spring运行器，<code>Spring</code>和<code>Ioc</code>创建是基于<code>XML</code>还是注解的</strong><ul><li><strong><code>locations</code>：指定<code>xml</code>文件的位置，加上classpath关键字，表示在类路径下</strong></li><li><strong><code>classes</code>：指定注解类所在位置</strong></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span> </span>= SpringConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">//@<span class="title">ContextConfiguration</span>(<span class="title">locations</span> </span>= <span class="string">"classpath:bean.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="4"><li>注意：<code>Spring5.0.+</code>要求<code>JUnit4.12+</code></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      SpringIOC
    
    </summary>
    
    
      <category term="Web开发" scheme="http://goldcarpenter.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Spring" scheme="http://goldcarpenter.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
